
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.AvaliacaoLayout = {}));
})(this, (function (exports) { 'use strict';

    class Assessment {
        constructor({ id, title, questions = [], attachments = [], layout = {} }) {
            this.id = id;
            this.title = title;
            this.questions = questions;
            this.attachments = attachments;
            this.layout = layout;
        }
    }

    class Question {
        constructor({ id, order, customOrder, value, type, content, reference, alternatives = [], afirmacoes = [], associacoes = null, assercoes = null, title, visualizaQuestaoRaw = null, orderAlternative = 0 }) {
            this.referenceInfo = null;
            this.showReference = false;
            this.visualizaQuestaoParsed = null;
            this.id = id;
            this.order = order;
            this.customOrder = customOrder;
            this.value = value;
            this.type = type;
            this.title = title;
            this.content = content;
            this.reference = reference || null;
            this.alternatives = alternatives || [];
            this.afirmacoes = afirmacoes || [];
            this.associacoes = associacoes;
            this.assercoes = assercoes;
            this.visualizaQuestaoRaw = visualizaQuestaoRaw || '';
            this.orderAlternative = orderAlternative || 0;
        }
        get displayOrder() {
            var _a;
            return (_a = this.customOrder) !== null && _a !== void 0 ? _a : this.order;
        }
    }

    class ReferenceService {
        /**
         * Group questions by reference and set metadata
         * @param {Question[]} questions
         */
        static processReferences(questions) {
            const formatLista = (indices) => indices.map((i) => i + 1).join(", ").replace(/,([^,]*)$/, " e$1");
            const questaoReferencia = questions.reduce((map, question, index) => {
                var _a, _b;
                const ref = (_a = question.reference) === null || _a === void 0 ? void 0 : _a.codigo;
                if (ref) {
                    const existentes = (_b = map.get(ref)) !== null && _b !== void 0 ? _b : [];
                    map.set(ref, [...existentes, index]);
                }
                return map;
            }, new Map());
            for (const [codigo, indices] of questaoReferencia) {
                const primeira = questions[indices[0]];
                primeira.referenceInfo = formatLista(indices);
                primeira.showReference = true;
            }
            return questions;
        }
    }

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var handlebars_runtime = {exports: {}};

    var base = {};

    var utils$2 = {};

    var hasRequiredUtils$1;

    function requireUtils$1 () {
    	if (hasRequiredUtils$1) return utils$2;
    	hasRequiredUtils$1 = 1;

    	utils$2.__esModule = true;
    	utils$2.extend = extend;
    	utils$2.indexOf = indexOf;
    	utils$2.escapeExpression = escapeExpression;
    	utils$2.isEmpty = isEmpty;
    	utils$2.createFrame = createFrame;
    	utils$2.blockParams = blockParams;
    	utils$2.appendContextPath = appendContextPath;
    	var escape = {
    	  '&': '&amp;',
    	  '<': '&lt;',
    	  '>': '&gt;',
    	  '"': '&quot;',
    	  "'": '&#x27;',
    	  '`': '&#x60;',
    	  '=': '&#x3D;'
    	};

    	var badChars = /[&<>"'`=]/g,
    	    possible = /[&<>"'`=]/;

    	function escapeChar(chr) {
    	  return escape[chr];
    	}

    	function extend(obj /* , ...source */) {
    	  for (var i = 1; i < arguments.length; i++) {
    	    for (var key in arguments[i]) {
    	      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
    	        obj[key] = arguments[i][key];
    	      }
    	    }
    	  }

    	  return obj;
    	}

    	var toString = Object.prototype.toString;

    	utils$2.toString = toString;
    	// Sourced from lodash
    	// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
    	/* eslint-disable func-style */
    	var isFunction = function isFunction(value) {
    	  return typeof value === 'function';
    	};
    	// fallback for older versions of Chrome and Safari
    	/* istanbul ignore next */
    	if (isFunction(/x/)) {
    	  utils$2.isFunction = isFunction = function (value) {
    	    return typeof value === 'function' && toString.call(value) === '[object Function]';
    	  };
    	}
    	utils$2.isFunction = isFunction;

    	/* eslint-enable func-style */

    	/* istanbul ignore next */
    	var isArray = Array.isArray || function (value) {
    	  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
    	};

    	utils$2.isArray = isArray;
    	// Older IE versions do not directly support indexOf so we must implement our own, sadly.

    	function indexOf(array, value) {
    	  for (var i = 0, len = array.length; i < len; i++) {
    	    if (array[i] === value) {
    	      return i;
    	    }
    	  }
    	  return -1;
    	}

    	function escapeExpression(string) {
    	  if (typeof string !== 'string') {
    	    // don't escape SafeStrings, since they're already safe
    	    if (string && string.toHTML) {
    	      return string.toHTML();
    	    } else if (string == null) {
    	      return '';
    	    } else if (!string) {
    	      return string + '';
    	    }

    	    // Force a string conversion as this will be done by the append regardless and
    	    // the regex test will do this transparently behind the scenes, causing issues if
    	    // an object's to string has escaped characters in it.
    	    string = '' + string;
    	  }

    	  if (!possible.test(string)) {
    	    return string;
    	  }
    	  return string.replace(badChars, escapeChar);
    	}

    	function isEmpty(value) {
    	  if (!value && value !== 0) {
    	    return true;
    	  } else if (isArray(value) && value.length === 0) {
    	    return true;
    	  } else {
    	    return false;
    	  }
    	}

    	function createFrame(object) {
    	  var frame = extend({}, object);
    	  frame._parent = object;
    	  return frame;
    	}

    	function blockParams(params, ids) {
    	  params.path = ids;
    	  return params;
    	}

    	function appendContextPath(contextPath, id) {
    	  return (contextPath ? contextPath + '.' : '') + id;
    	}
    	
    	return utils$2;
    }

    var exception = {exports: {}};

    var hasRequiredException;

    function requireException () {
    	if (hasRequiredException) return exception.exports;
    	hasRequiredException = 1;
    	(function (module, exports) {

    		exports.__esModule = true;
    		var errorProps = ['description', 'fileName', 'lineNumber', 'endLineNumber', 'message', 'name', 'number', 'stack'];

    		function Exception(message, node) {
    		  var loc = node && node.loc,
    		      line = undefined,
    		      endLineNumber = undefined,
    		      column = undefined,
    		      endColumn = undefined;

    		  if (loc) {
    		    line = loc.start.line;
    		    endLineNumber = loc.end.line;
    		    column = loc.start.column;
    		    endColumn = loc.end.column;

    		    message += ' - ' + line + ':' + column;
    		  }

    		  var tmp = Error.prototype.constructor.call(this, message);

    		  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
    		  for (var idx = 0; idx < errorProps.length; idx++) {
    		    this[errorProps[idx]] = tmp[errorProps[idx]];
    		  }

    		  /* istanbul ignore else */
    		  if (Error.captureStackTrace) {
    		    Error.captureStackTrace(this, Exception);
    		  }

    		  try {
    		    if (loc) {
    		      this.lineNumber = line;
    		      this.endLineNumber = endLineNumber;

    		      // Work around issue under safari where we can't directly set the column value
    		      /* istanbul ignore next */
    		      if (Object.defineProperty) {
    		        Object.defineProperty(this, 'column', {
    		          value: column,
    		          enumerable: true
    		        });
    		        Object.defineProperty(this, 'endColumn', {
    		          value: endColumn,
    		          enumerable: true
    		        });
    		      } else {
    		        this.column = column;
    		        this.endColumn = endColumn;
    		      }
    		    }
    		  } catch (nop) {
    		    /* Ignore if the browser is very particular */
    		  }
    		}

    		Exception.prototype = new Error();

    		exports['default'] = Exception;
    		module.exports = exports['default'];
    		
    	} (exception, exception.exports));
    	return exception.exports;
    }

    var helpers = {};

    var blockHelperMissing = {exports: {}};

    var hasRequiredBlockHelperMissing;

    function requireBlockHelperMissing () {
    	if (hasRequiredBlockHelperMissing) return blockHelperMissing.exports;
    	hasRequiredBlockHelperMissing = 1;
    	(function (module, exports) {

    		exports.__esModule = true;

    		var _utils = requireUtils$1();

    		exports['default'] = function (instance) {
    		  instance.registerHelper('blockHelperMissing', function (context, options) {
    		    var inverse = options.inverse,
    		        fn = options.fn;

    		    if (context === true) {
    		      return fn(this);
    		    } else if (context === false || context == null) {
    		      return inverse(this);
    		    } else if (_utils.isArray(context)) {
    		      if (context.length > 0) {
    		        if (options.ids) {
    		          options.ids = [options.name];
    		        }

    		        return instance.helpers.each(context, options);
    		      } else {
    		        return inverse(this);
    		      }
    		    } else {
    		      if (options.data && options.ids) {
    		        var data = _utils.createFrame(options.data);
    		        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
    		        options = { data: data };
    		      }

    		      return fn(context, options);
    		    }
    		  });
    		};

    		module.exports = exports['default'];
    		
    	} (blockHelperMissing, blockHelperMissing.exports));
    	return blockHelperMissing.exports;
    }

    var each = {exports: {}};

    var hasRequiredEach;

    function requireEach () {
    	if (hasRequiredEach) return each.exports;
    	hasRequiredEach = 1;
    	(function (module, exports) {

    		exports.__esModule = true;
    		// istanbul ignore next

    		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    		var _utils = requireUtils$1();

    		var _exception = requireException();

    		var _exception2 = _interopRequireDefault(_exception);

    		exports['default'] = function (instance) {
    		  instance.registerHelper('each', function (context, options) {
    		    if (!options) {
    		      throw new _exception2['default']('Must pass iterator to #each');
    		    }

    		    var fn = options.fn,
    		        inverse = options.inverse,
    		        i = 0,
    		        ret = '',
    		        data = undefined,
    		        contextPath = undefined;

    		    if (options.data && options.ids) {
    		      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    		    }

    		    if (_utils.isFunction(context)) {
    		      context = context.call(this);
    		    }

    		    if (options.data) {
    		      data = _utils.createFrame(options.data);
    		    }

    		    function execIteration(field, index, last) {
    		      if (data) {
    		        data.key = field;
    		        data.index = index;
    		        data.first = index === 0;
    		        data.last = !!last;

    		        if (contextPath) {
    		          data.contextPath = contextPath + field;
    		        }
    		      }

    		      ret = ret + fn(context[field], {
    		        data: data,
    		        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
    		      });
    		    }

    		    if (context && typeof context === 'object') {
    		      if (_utils.isArray(context)) {
    		        for (var j = context.length; i < j; i++) {
    		          if (i in context) {
    		            execIteration(i, i, i === context.length - 1);
    		          }
    		        }
    		      } else if (typeof Symbol === 'function' && context[Symbol.iterator]) {
    		        var newContext = [];
    		        var iterator = context[Symbol.iterator]();
    		        for (var it = iterator.next(); !it.done; it = iterator.next()) {
    		          newContext.push(it.value);
    		        }
    		        context = newContext;
    		        for (var j = context.length; i < j; i++) {
    		          execIteration(i, i, i === context.length - 1);
    		        }
    		      } else {
    		        (function () {
    		          var priorKey = undefined;

    		          Object.keys(context).forEach(function (key) {
    		            // We're running the iterations one step out of sync so we can detect
    		            // the last iteration without have to scan the object twice and create
    		            // an itermediate keys array.
    		            if (priorKey !== undefined) {
    		              execIteration(priorKey, i - 1);
    		            }
    		            priorKey = key;
    		            i++;
    		          });
    		          if (priorKey !== undefined) {
    		            execIteration(priorKey, i - 1, true);
    		          }
    		        })();
    		      }
    		    }

    		    if (i === 0) {
    		      ret = inverse(this);
    		    }

    		    return ret;
    		  });
    		};

    		module.exports = exports['default'];
    		
    	} (each, each.exports));
    	return each.exports;
    }

    var helperMissing = {exports: {}};

    var hasRequiredHelperMissing;

    function requireHelperMissing () {
    	if (hasRequiredHelperMissing) return helperMissing.exports;
    	hasRequiredHelperMissing = 1;
    	(function (module, exports) {

    		exports.__esModule = true;
    		// istanbul ignore next

    		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    		var _exception = requireException();

    		var _exception2 = _interopRequireDefault(_exception);

    		exports['default'] = function (instance) {
    		  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    		    if (arguments.length === 1) {
    		      // A missing field in a {{foo}} construct.
    		      return undefined;
    		    } else {
    		      // Someone is actually trying to call something, blow up.
    		      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    		    }
    		  });
    		};

    		module.exports = exports['default'];
    		
    	} (helperMissing, helperMissing.exports));
    	return helperMissing.exports;
    }

    var _if = {exports: {}};

    var hasRequired_if;

    function require_if () {
    	if (hasRequired_if) return _if.exports;
    	hasRequired_if = 1;
    	(function (module, exports) {

    		exports.__esModule = true;
    		// istanbul ignore next

    		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    		var _utils = requireUtils$1();

    		var _exception = requireException();

    		var _exception2 = _interopRequireDefault(_exception);

    		exports['default'] = function (instance) {
    		  instance.registerHelper('if', function (conditional, options) {
    		    if (arguments.length != 2) {
    		      throw new _exception2['default']('#if requires exactly one argument');
    		    }
    		    if (_utils.isFunction(conditional)) {
    		      conditional = conditional.call(this);
    		    }

    		    // Default behavior is to render the positive path if the value is truthy and not empty.
    		    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    		    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    		    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
    		      return options.inverse(this);
    		    } else {
    		      return options.fn(this);
    		    }
    		  });

    		  instance.registerHelper('unless', function (conditional, options) {
    		    if (arguments.length != 2) {
    		      throw new _exception2['default']('#unless requires exactly one argument');
    		    }
    		    return instance.helpers['if'].call(this, conditional, {
    		      fn: options.inverse,
    		      inverse: options.fn,
    		      hash: options.hash
    		    });
    		  });
    		};

    		module.exports = exports['default'];
    		
    	} (_if, _if.exports));
    	return _if.exports;
    }

    var log = {exports: {}};

    var hasRequiredLog;

    function requireLog () {
    	if (hasRequiredLog) return log.exports;
    	hasRequiredLog = 1;
    	(function (module, exports) {

    		exports.__esModule = true;

    		exports['default'] = function (instance) {
    		  instance.registerHelper('log', function () /* message, options */{
    		    var args = [undefined],
    		        options = arguments[arguments.length - 1];
    		    for (var i = 0; i < arguments.length - 1; i++) {
    		      args.push(arguments[i]);
    		    }

    		    var level = 1;
    		    if (options.hash.level != null) {
    		      level = options.hash.level;
    		    } else if (options.data && options.data.level != null) {
    		      level = options.data.level;
    		    }
    		    args[0] = level;

    		    instance.log.apply(instance, args);
    		  });
    		};

    		module.exports = exports['default'];
    		
    	} (log, log.exports));
    	return log.exports;
    }

    var lookup = {exports: {}};

    var hasRequiredLookup;

    function requireLookup () {
    	if (hasRequiredLookup) return lookup.exports;
    	hasRequiredLookup = 1;
    	(function (module, exports) {

    		exports.__esModule = true;

    		exports['default'] = function (instance) {
    		  instance.registerHelper('lookup', function (obj, field, options) {
    		    if (!obj) {
    		      // Note for 5.0: Change to "obj == null" in 5.0
    		      return obj;
    		    }
    		    return options.lookupProperty(obj, field);
    		  });
    		};

    		module.exports = exports['default'];
    		
    	} (lookup, lookup.exports));
    	return lookup.exports;
    }

    var _with = {exports: {}};

    var hasRequired_with;

    function require_with () {
    	if (hasRequired_with) return _with.exports;
    	hasRequired_with = 1;
    	(function (module, exports) {

    		exports.__esModule = true;
    		// istanbul ignore next

    		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    		var _utils = requireUtils$1();

    		var _exception = requireException();

    		var _exception2 = _interopRequireDefault(_exception);

    		exports['default'] = function (instance) {
    		  instance.registerHelper('with', function (context, options) {
    		    if (arguments.length != 2) {
    		      throw new _exception2['default']('#with requires exactly one argument');
    		    }
    		    if (_utils.isFunction(context)) {
    		      context = context.call(this);
    		    }

    		    var fn = options.fn;

    		    if (!_utils.isEmpty(context)) {
    		      var data = options.data;
    		      if (options.data && options.ids) {
    		        data = _utils.createFrame(options.data);
    		        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
    		      }

    		      return fn(context, {
    		        data: data,
    		        blockParams: _utils.blockParams([context], [data && data.contextPath])
    		      });
    		    } else {
    		      return options.inverse(this);
    		    }
    		  });
    		};

    		module.exports = exports['default'];
    		
    	} (_with, _with.exports));
    	return _with.exports;
    }

    var hasRequiredHelpers;

    function requireHelpers () {
    	if (hasRequiredHelpers) return helpers;
    	hasRequiredHelpers = 1;

    	helpers.__esModule = true;
    	helpers.registerDefaultHelpers = registerDefaultHelpers;
    	helpers.moveHelperToHooks = moveHelperToHooks;
    	// istanbul ignore next

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	var _helpersBlockHelperMissing = requireBlockHelperMissing();

    	var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

    	var _helpersEach = requireEach();

    	var _helpersEach2 = _interopRequireDefault(_helpersEach);

    	var _helpersHelperMissing = requireHelperMissing();

    	var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

    	var _helpersIf = require_if();

    	var _helpersIf2 = _interopRequireDefault(_helpersIf);

    	var _helpersLog = requireLog();

    	var _helpersLog2 = _interopRequireDefault(_helpersLog);

    	var _helpersLookup = requireLookup();

    	var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

    	var _helpersWith = require_with();

    	var _helpersWith2 = _interopRequireDefault(_helpersWith);

    	function registerDefaultHelpers(instance) {
    	  _helpersBlockHelperMissing2['default'](instance);
    	  _helpersEach2['default'](instance);
    	  _helpersHelperMissing2['default'](instance);
    	  _helpersIf2['default'](instance);
    	  _helpersLog2['default'](instance);
    	  _helpersLookup2['default'](instance);
    	  _helpersWith2['default'](instance);
    	}

    	function moveHelperToHooks(instance, helperName, keepHelper) {
    	  if (instance.helpers[helperName]) {
    	    instance.hooks[helperName] = instance.helpers[helperName];
    	    if (!keepHelper) {
    	      delete instance.helpers[helperName];
    	    }
    	  }
    	}
    	
    	return helpers;
    }

    var decorators = {};

    var inline = {exports: {}};

    var hasRequiredInline;

    function requireInline () {
    	if (hasRequiredInline) return inline.exports;
    	hasRequiredInline = 1;
    	(function (module, exports) {

    		exports.__esModule = true;

    		var _utils = requireUtils$1();

    		exports['default'] = function (instance) {
    		  instance.registerDecorator('inline', function (fn, props, container, options) {
    		    var ret = fn;
    		    if (!props.partials) {
    		      props.partials = {};
    		      ret = function (context, options) {
    		        // Create a new partials stack frame prior to exec.
    		        var original = container.partials;
    		        container.partials = _utils.extend({}, original, props.partials);
    		        var ret = fn(context, options);
    		        container.partials = original;
    		        return ret;
    		      };
    		    }

    		    props.partials[options.args[0]] = options.fn;

    		    return ret;
    		  });
    		};

    		module.exports = exports['default'];
    		
    	} (inline, inline.exports));
    	return inline.exports;
    }

    var hasRequiredDecorators;

    function requireDecorators () {
    	if (hasRequiredDecorators) return decorators;
    	hasRequiredDecorators = 1;

    	decorators.__esModule = true;
    	decorators.registerDefaultDecorators = registerDefaultDecorators;
    	// istanbul ignore next

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	var _decoratorsInline = requireInline();

    	var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

    	function registerDefaultDecorators(instance) {
    	  _decoratorsInline2['default'](instance);
    	}
    	
    	return decorators;
    }

    var logger = {exports: {}};

    var hasRequiredLogger;

    function requireLogger () {
    	if (hasRequiredLogger) return logger.exports;
    	hasRequiredLogger = 1;
    	(function (module, exports) {

    		exports.__esModule = true;

    		var _utils = requireUtils$1();

    		var logger = {
    		  methodMap: ['debug', 'info', 'warn', 'error'],
    		  level: 'info',

    		  // Maps a given level value to the `methodMap` indexes above.
    		  lookupLevel: function lookupLevel(level) {
    		    if (typeof level === 'string') {
    		      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
    		      if (levelMap >= 0) {
    		        level = levelMap;
    		      } else {
    		        level = parseInt(level, 10);
    		      }
    		    }

    		    return level;
    		  },

    		  // Can be overridden in the host environment
    		  log: function log(level) {
    		    level = logger.lookupLevel(level);

    		    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
    		      var method = logger.methodMap[level];
    		      // eslint-disable-next-line no-console
    		      if (!console[method]) {
    		        method = 'log';
    		      }

    		      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    		        message[_key - 1] = arguments[_key];
    		      }

    		      console[method].apply(console, message); // eslint-disable-line no-console
    		    }
    		  }
    		};

    		exports['default'] = logger;
    		module.exports = exports['default'];
    		
    	} (logger, logger.exports));
    	return logger.exports;
    }

    var protoAccess = {};

    var createNewLookupObject = {};

    var hasRequiredCreateNewLookupObject;

    function requireCreateNewLookupObject () {
    	if (hasRequiredCreateNewLookupObject) return createNewLookupObject;
    	hasRequiredCreateNewLookupObject = 1;

    	createNewLookupObject.__esModule = true;
    	createNewLookupObject.createNewLookupObject = createNewLookupObject$1;

    	var _utils = requireUtils$1();

    	/**
    	 * Create a new object with "null"-prototype to avoid truthy results on prototype properties.
    	 * The resulting object can be used with "object[property]" to check if a property exists
    	 * @param {...object} sources a varargs parameter of source objects that will be merged
    	 * @returns {object}
    	 */

    	function createNewLookupObject$1() {
    	  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
    	    sources[_key] = arguments[_key];
    	  }

    	  return _utils.extend.apply(undefined, [Object.create(null)].concat(sources));
    	}
    	
    	return createNewLookupObject;
    }

    var hasRequiredProtoAccess;

    function requireProtoAccess () {
    	if (hasRequiredProtoAccess) return protoAccess;
    	hasRequiredProtoAccess = 1;

    	protoAccess.__esModule = true;
    	protoAccess.createProtoAccessControl = createProtoAccessControl;
    	protoAccess.resultIsAllowed = resultIsAllowed;
    	protoAccess.resetLoggedProperties = resetLoggedProperties;
    	// istanbul ignore next

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	var _createNewLookupObject = requireCreateNewLookupObject();

    	var _logger = requireLogger();

    	var _logger2 = _interopRequireDefault(_logger);

    	var loggedProperties = Object.create(null);

    	function createProtoAccessControl(runtimeOptions) {
    	  var defaultMethodWhiteList = Object.create(null);
    	  defaultMethodWhiteList['constructor'] = false;
    	  defaultMethodWhiteList['__defineGetter__'] = false;
    	  defaultMethodWhiteList['__defineSetter__'] = false;
    	  defaultMethodWhiteList['__lookupGetter__'] = false;

    	  var defaultPropertyWhiteList = Object.create(null);
    	  // eslint-disable-next-line no-proto
    	  defaultPropertyWhiteList['__proto__'] = false;

    	  return {
    	    properties: {
    	      whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
    	      defaultValue: runtimeOptions.allowProtoPropertiesByDefault
    	    },
    	    methods: {
    	      whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
    	      defaultValue: runtimeOptions.allowProtoMethodsByDefault
    	    }
    	  };
    	}

    	function resultIsAllowed(result, protoAccessControl, propertyName) {
    	  if (typeof result === 'function') {
    	    return checkWhiteList(protoAccessControl.methods, propertyName);
    	  } else {
    	    return checkWhiteList(protoAccessControl.properties, propertyName);
    	  }
    	}

    	function checkWhiteList(protoAccessControlForType, propertyName) {
    	  if (protoAccessControlForType.whitelist[propertyName] !== undefined) {
    	    return protoAccessControlForType.whitelist[propertyName] === true;
    	  }
    	  if (protoAccessControlForType.defaultValue !== undefined) {
    	    return protoAccessControlForType.defaultValue;
    	  }
    	  logUnexpecedPropertyAccessOnce(propertyName);
    	  return false;
    	}

    	function logUnexpecedPropertyAccessOnce(propertyName) {
    	  if (loggedProperties[propertyName] !== true) {
    	    loggedProperties[propertyName] = true;
    	    _logger2['default'].log('error', 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\n' + 'You can add a runtime option to disable the check or this warning:\n' + 'See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
    	  }
    	}

    	function resetLoggedProperties() {
    	  Object.keys(loggedProperties).forEach(function (propertyName) {
    	    delete loggedProperties[propertyName];
    	  });
    	}
    	
    	return protoAccess;
    }

    var hasRequiredBase;

    function requireBase () {
    	if (hasRequiredBase) return base;
    	hasRequiredBase = 1;

    	base.__esModule = true;
    	base.HandlebarsEnvironment = HandlebarsEnvironment;
    	// istanbul ignore next

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	var _utils = requireUtils$1();

    	var _exception = requireException();

    	var _exception2 = _interopRequireDefault(_exception);

    	var _helpers = requireHelpers();

    	var _decorators = requireDecorators();

    	var _logger = requireLogger();

    	var _logger2 = _interopRequireDefault(_logger);

    	var _internalProtoAccess = requireProtoAccess();

    	var VERSION = '4.7.8';
    	base.VERSION = VERSION;
    	var COMPILER_REVISION = 8;
    	base.COMPILER_REVISION = COMPILER_REVISION;
    	var LAST_COMPATIBLE_COMPILER_REVISION = 7;

    	base.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
    	var REVISION_CHANGES = {
    	  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
    	  2: '== 1.0.0-rc.3',
    	  3: '== 1.0.0-rc.4',
    	  4: '== 1.x.x',
    	  5: '== 2.0.0-alpha.x',
    	  6: '>= 2.0.0-beta.1',
    	  7: '>= 4.0.0 <4.3.0',
    	  8: '>= 4.3.0'
    	};

    	base.REVISION_CHANGES = REVISION_CHANGES;
    	var objectType = '[object Object]';

    	function HandlebarsEnvironment(helpers, partials, decorators) {
    	  this.helpers = helpers || {};
    	  this.partials = partials || {};
    	  this.decorators = decorators || {};

    	  _helpers.registerDefaultHelpers(this);
    	  _decorators.registerDefaultDecorators(this);
    	}

    	HandlebarsEnvironment.prototype = {
    	  constructor: HandlebarsEnvironment,

    	  logger: _logger2['default'],
    	  log: _logger2['default'].log,

    	  registerHelper: function registerHelper(name, fn) {
    	    if (_utils.toString.call(name) === objectType) {
    	      if (fn) {
    	        throw new _exception2['default']('Arg not supported with multiple helpers');
    	      }
    	      _utils.extend(this.helpers, name);
    	    } else {
    	      this.helpers[name] = fn;
    	    }
    	  },
    	  unregisterHelper: function unregisterHelper(name) {
    	    delete this.helpers[name];
    	  },

    	  registerPartial: function registerPartial(name, partial) {
    	    if (_utils.toString.call(name) === objectType) {
    	      _utils.extend(this.partials, name);
    	    } else {
    	      if (typeof partial === 'undefined') {
    	        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
    	      }
    	      this.partials[name] = partial;
    	    }
    	  },
    	  unregisterPartial: function unregisterPartial(name) {
    	    delete this.partials[name];
    	  },

    	  registerDecorator: function registerDecorator(name, fn) {
    	    if (_utils.toString.call(name) === objectType) {
    	      if (fn) {
    	        throw new _exception2['default']('Arg not supported with multiple decorators');
    	      }
    	      _utils.extend(this.decorators, name);
    	    } else {
    	      this.decorators[name] = fn;
    	    }
    	  },
    	  unregisterDecorator: function unregisterDecorator(name) {
    	    delete this.decorators[name];
    	  },
    	  /**
    	   * Reset the memory of illegal property accesses that have already been logged.
    	   * @deprecated should only be used in handlebars test-cases
    	   */
    	  resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
    	    _internalProtoAccess.resetLoggedProperties();
    	  }
    	};

    	var log = _logger2['default'].log;

    	base.log = log;
    	base.createFrame = _utils.createFrame;
    	base.logger = _logger2['default'];
    	
    	return base;
    }

    var safeString = {exports: {}};

    var hasRequiredSafeString;

    function requireSafeString () {
    	if (hasRequiredSafeString) return safeString.exports;
    	hasRequiredSafeString = 1;
    	(function (module, exports) {

    		exports.__esModule = true;
    		function SafeString(string) {
    		  this.string = string;
    		}

    		SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
    		  return '' + this.string;
    		};

    		exports['default'] = SafeString;
    		module.exports = exports['default'];
    		
    	} (safeString, safeString.exports));
    	return safeString.exports;
    }

    var runtime$1 = {};

    var wrapHelper = {};

    var hasRequiredWrapHelper;

    function requireWrapHelper () {
    	if (hasRequiredWrapHelper) return wrapHelper;
    	hasRequiredWrapHelper = 1;

    	wrapHelper.__esModule = true;
    	wrapHelper.wrapHelper = wrapHelper$1;

    	function wrapHelper$1(helper, transformOptionsFn) {
    	  if (typeof helper !== 'function') {
    	    // This should not happen, but apparently it does in https://github.com/wycats/handlebars.js/issues/1639
    	    // We try to make the wrapper least-invasive by not wrapping it, if the helper is not a function.
    	    return helper;
    	  }
    	  var wrapper = function wrapper() /* dynamic arguments */{
    	    var options = arguments[arguments.length - 1];
    	    arguments[arguments.length - 1] = transformOptionsFn(options);
    	    return helper.apply(this, arguments);
    	  };
    	  return wrapper;
    	}
    	
    	return wrapHelper;
    }

    var hasRequiredRuntime$1;

    function requireRuntime$1 () {
    	if (hasRequiredRuntime$1) return runtime$1;
    	hasRequiredRuntime$1 = 1;

    	runtime$1.__esModule = true;
    	runtime$1.checkRevision = checkRevision;
    	runtime$1.template = template;
    	runtime$1.wrapProgram = wrapProgram;
    	runtime$1.resolvePartial = resolvePartial;
    	runtime$1.invokePartial = invokePartial;
    	runtime$1.noop = noop;
    	// istanbul ignore next

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	// istanbul ignore next

    	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

    	var _utils = requireUtils$1();

    	var Utils = _interopRequireWildcard(_utils);

    	var _exception = requireException();

    	var _exception2 = _interopRequireDefault(_exception);

    	var _base = requireBase();

    	var _helpers = requireHelpers();

    	var _internalWrapHelper = requireWrapHelper();

    	var _internalProtoAccess = requireProtoAccess();

    	function checkRevision(compilerInfo) {
    	  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
    	      currentRevision = _base.COMPILER_REVISION;

    	  if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
    	    return;
    	  }

    	  if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
    	    var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
    	        compilerVersions = _base.REVISION_CHANGES[compilerRevision];
    	    throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    	  } else {
    	    // Use the embedded version info since the runtime doesn't know about this revision yet
    	    throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    	  }
    	}

    	function template(templateSpec, env) {
    	  /* istanbul ignore next */
    	  if (!env) {
    	    throw new _exception2['default']('No environment passed to template');
    	  }
    	  if (!templateSpec || !templateSpec.main) {
    	    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
    	  }

    	  templateSpec.main.decorator = templateSpec.main_d;

    	  // Note: Using env.VM references rather than local var references throughout this section to allow
    	  // for external users to override these as pseudo-supported APIs.
    	  env.VM.checkRevision(templateSpec.compiler);

    	  // backwards compatibility for precompiled templates with compiler-version 7 (<4.3.0)
    	  var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;

    	  function invokePartialWrapper(partial, context, options) {
    	    if (options.hash) {
    	      context = Utils.extend({}, context, options.hash);
    	      if (options.ids) {
    	        options.ids[0] = true;
    	      }
    	    }
    	    partial = env.VM.resolvePartial.call(this, partial, context, options);

    	    var extendedOptions = Utils.extend({}, options, {
    	      hooks: this.hooks,
    	      protoAccessControl: this.protoAccessControl
    	    });

    	    var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);

    	    if (result == null && env.compile) {
    	      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
    	      result = options.partials[options.name](context, extendedOptions);
    	    }
    	    if (result != null) {
    	      if (options.indent) {
    	        var lines = result.split('\n');
    	        for (var i = 0, l = lines.length; i < l; i++) {
    	          if (!lines[i] && i + 1 === l) {
    	            break;
    	          }

    	          lines[i] = options.indent + lines[i];
    	        }
    	        result = lines.join('\n');
    	      }
    	      return result;
    	    } else {
    	      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    	    }
    	  }

    	  // Just add water
    	  var container = {
    	    strict: function strict(obj, name, loc) {
    	      if (!obj || !(name in obj)) {
    	        throw new _exception2['default']('"' + name + '" not defined in ' + obj, {
    	          loc: loc
    	        });
    	      }
    	      return container.lookupProperty(obj, name);
    	    },
    	    lookupProperty: function lookupProperty(parent, propertyName) {
    	      var result = parent[propertyName];
    	      if (result == null) {
    	        return result;
    	      }
    	      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
    	        return result;
    	      }

    	      if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
    	        return result;
    	      }
    	      return undefined;
    	    },
    	    lookup: function lookup(depths, name) {
    	      var len = depths.length;
    	      for (var i = 0; i < len; i++) {
    	        var result = depths[i] && container.lookupProperty(depths[i], name);
    	        if (result != null) {
    	          return depths[i][name];
    	        }
    	      }
    	    },
    	    lambda: function lambda(current, context) {
    	      return typeof current === 'function' ? current.call(context) : current;
    	    },

    	    escapeExpression: Utils.escapeExpression,
    	    invokePartial: invokePartialWrapper,

    	    fn: function fn(i) {
    	      var ret = templateSpec[i];
    	      ret.decorator = templateSpec[i + '_d'];
    	      return ret;
    	    },

    	    programs: [],
    	    program: function program(i, data, declaredBlockParams, blockParams, depths) {
    	      var programWrapper = this.programs[i],
    	          fn = this.fn(i);
    	      if (data || depths || blockParams || declaredBlockParams) {
    	        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
    	      } else if (!programWrapper) {
    	        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
    	      }
    	      return programWrapper;
    	    },

    	    data: function data(value, depth) {
    	      while (value && depth--) {
    	        value = value._parent;
    	      }
    	      return value;
    	    },
    	    mergeIfNeeded: function mergeIfNeeded(param, common) {
    	      var obj = param || common;

    	      if (param && common && param !== common) {
    	        obj = Utils.extend({}, common, param);
    	      }

    	      return obj;
    	    },
    	    // An empty object to use as replacement for null-contexts
    	    nullContext: Object.seal({}),

    	    noop: env.VM.noop,
    	    compilerInfo: templateSpec.compiler
    	  };

    	  function ret(context) {
    	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    	    var data = options.data;

    	    ret._setup(options);
    	    if (!options.partial && templateSpec.useData) {
    	      data = initData(context, data);
    	    }
    	    var depths = undefined,
    	        blockParams = templateSpec.useBlockParams ? [] : undefined;
    	    if (templateSpec.useDepths) {
    	      if (options.depths) {
    	        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
    	      } else {
    	        depths = [context];
    	      }
    	    }

    	    function main(context /*, options*/) {
    	      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    	    }

    	    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    	    return main(context, options);
    	  }

    	  ret.isTop = true;

    	  ret._setup = function (options) {
    	    if (!options.partial) {
    	      var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
    	      wrapHelpersToPassLookupProperty(mergedHelpers, container);
    	      container.helpers = mergedHelpers;

    	      if (templateSpec.usePartial) {
    	        // Use mergeIfNeeded here to prevent compiling global partials multiple times
    	        container.partials = container.mergeIfNeeded(options.partials, env.partials);
    	      }
    	      if (templateSpec.usePartial || templateSpec.useDecorators) {
    	        container.decorators = Utils.extend({}, env.decorators, options.decorators);
    	      }

    	      container.hooks = {};
    	      container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);

    	      var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
    	      _helpers.moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);
    	      _helpers.moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);
    	    } else {
    	      container.protoAccessControl = options.protoAccessControl; // internal option
    	      container.helpers = options.helpers;
    	      container.partials = options.partials;
    	      container.decorators = options.decorators;
    	      container.hooks = options.hooks;
    	    }
    	  };

    	  ret._child = function (i, data, blockParams, depths) {
    	    if (templateSpec.useBlockParams && !blockParams) {
    	      throw new _exception2['default']('must pass block params');
    	    }
    	    if (templateSpec.useDepths && !depths) {
    	      throw new _exception2['default']('must pass parent depths');
    	    }

    	    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
    	  };
    	  return ret;
    	}

    	function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
    	  function prog(context) {
    	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    	    var currentDepths = depths;
    	    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
    	      currentDepths = [context].concat(depths);
    	    }

    	    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
    	  }

    	  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

    	  prog.program = i;
    	  prog.depth = depths ? depths.length : 0;
    	  prog.blockParams = declaredBlockParams || 0;
    	  return prog;
    	}

    	/**
    	 * This is currently part of the official API, therefore implementation details should not be changed.
    	 */

    	function resolvePartial(partial, context, options) {
    	  if (!partial) {
    	    if (options.name === '@partial-block') {
    	      partial = options.data['partial-block'];
    	    } else {
    	      partial = options.partials[options.name];
    	    }
    	  } else if (!partial.call && !options.name) {
    	    // This is a dynamic partial that returned a string
    	    options.name = partial;
    	    partial = options.partials[partial];
    	  }
    	  return partial;
    	}

    	function invokePartial(partial, context, options) {
    	  // Use the current closure context to save the partial-block if this partial
    	  var currentPartialBlock = options.data && options.data['partial-block'];
    	  options.partial = true;
    	  if (options.ids) {
    	    options.data.contextPath = options.ids[0] || options.data.contextPath;
    	  }

    	  var partialBlock = undefined;
    	  if (options.fn && options.fn !== noop) {
    	    (function () {
    	      options.data = _base.createFrame(options.data);
    	      // Wrapper function to get access to currentPartialBlock from the closure
    	      var fn = options.fn;
    	      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
    	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    	        // Restore the partial-block from the closure for the execution of the block
    	        // i.e. the part inside the block of the partial call.
    	        options.data = _base.createFrame(options.data);
    	        options.data['partial-block'] = currentPartialBlock;
    	        return fn(context, options);
    	      };
    	      if (fn.partials) {
    	        options.partials = Utils.extend({}, options.partials, fn.partials);
    	      }
    	    })();
    	  }

    	  if (partial === undefined && partialBlock) {
    	    partial = partialBlock;
    	  }

    	  if (partial === undefined) {
    	    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
    	  } else if (partial instanceof Function) {
    	    return partial(context, options);
    	  }
    	}

    	function noop() {
    	  return '';
    	}

    	function initData(context, data) {
    	  if (!data || !('root' in data)) {
    	    data = data ? _base.createFrame(data) : {};
    	    data.root = context;
    	  }
    	  return data;
    	}

    	function executeDecorators(fn, prog, container, depths, data, blockParams) {
    	  if (fn.decorator) {
    	    var props = {};
    	    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    	    Utils.extend(prog, props);
    	  }
    	  return prog;
    	}

    	function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
    	  Object.keys(mergedHelpers).forEach(function (helperName) {
    	    var helper = mergedHelpers[helperName];
    	    mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
    	  });
    	}

    	function passLookupPropertyOption(helper, container) {
    	  var lookupProperty = container.lookupProperty;
    	  return _internalWrapHelper.wrapHelper(helper, function (options) {
    	    return Utils.extend({ lookupProperty: lookupProperty }, options);
    	  });
    	}
    	
    	return runtime$1;
    }

    var noConflict = {exports: {}};

    /* global globalThis */

    var hasRequiredNoConflict;

    function requireNoConflict () {
    	if (hasRequiredNoConflict) return noConflict.exports;
    	hasRequiredNoConflict = 1;
    	(function (module, exports) {

    		exports.__esModule = true;

    		exports['default'] = function (Handlebars) {
    		  /* istanbul ignore next */
    		  // https://mathiasbynens.be/notes/globalthis
    		  (function () {
    		    if (typeof globalThis === 'object') return;
    		    Object.prototype.__defineGetter__('__magic__', function () {
    		      return this;
    		    });
    		    __magic__.globalThis = __magic__; // eslint-disable-line no-undef
    		    delete Object.prototype.__magic__;
    		  })();

    		  var $Handlebars = globalThis.Handlebars;

    		  /* istanbul ignore next */
    		  Handlebars.noConflict = function () {
    		    if (globalThis.Handlebars === Handlebars) {
    		      globalThis.Handlebars = $Handlebars;
    		    }
    		    return Handlebars;
    		  };
    		};

    		module.exports = exports['default'];
    		
    	} (noConflict, noConflict.exports));
    	return noConflict.exports;
    }

    var hasRequiredHandlebars_runtime;

    function requireHandlebars_runtime () {
    	if (hasRequiredHandlebars_runtime) return handlebars_runtime.exports;
    	hasRequiredHandlebars_runtime = 1;
    	(function (module, exports) {

    		exports.__esModule = true;
    		// istanbul ignore next

    		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    		// istanbul ignore next

    		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

    		var _handlebarsBase = requireBase();

    		var base = _interopRequireWildcard(_handlebarsBase);

    		// Each of these augment the Handlebars object. No need to setup here.
    		// (This is done to easily share code between commonjs and browse envs)

    		var _handlebarsSafeString = requireSafeString();

    		var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

    		var _handlebarsException = requireException();

    		var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

    		var _handlebarsUtils = requireUtils$1();

    		var Utils = _interopRequireWildcard(_handlebarsUtils);

    		var _handlebarsRuntime = requireRuntime$1();

    		var runtime = _interopRequireWildcard(_handlebarsRuntime);

    		var _handlebarsNoConflict = requireNoConflict();

    		var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

    		// For compatibility and usage outside of module systems, make the Handlebars object a namespace
    		function create() {
    		  var hb = new base.HandlebarsEnvironment();

    		  Utils.extend(hb, base);
    		  hb.SafeString = _handlebarsSafeString2['default'];
    		  hb.Exception = _handlebarsException2['default'];
    		  hb.Utils = Utils;
    		  hb.escapeExpression = Utils.escapeExpression;

    		  hb.VM = runtime;
    		  hb.template = function (spec) {
    		    return runtime.template(spec, hb);
    		  };

    		  return hb;
    		}

    		var inst = create();
    		inst.create = create;

    		_handlebarsNoConflict2['default'](inst);

    		inst['default'] = inst;

    		exports['default'] = inst;
    		module.exports = exports['default'];
    		
    	} (handlebars_runtime, handlebars_runtime.exports));
    	return handlebars_runtime.exports;
    }

    var runtime;
    var hasRequiredRuntime;

    function requireRuntime () {
    	if (hasRequiredRuntime) return runtime;
    	hasRequiredRuntime = 1;
    	// Create a simple path alias to allow browserify to resolve
    	// the runtime on a supported path.
    	runtime = requireHandlebars_runtime()['default'];
    	return runtime;
    }

    var runtimeExports = requireRuntime();
    var HandlebarsRuntime = /*@__PURE__*/getDefaultExportFromCjs(runtimeExports);

    function toRoman(num) {
        if (num < 1 || num > 3999)
            return "Number out of range";
        const romanNumerals = [
            { value: 1000, numeral: "M" },
            { value: 900, numeral: "CM" },
            { value: 500, numeral: "D" },
            { value: 400, numeral: "CD" },
            { value: 100, numeral: "C" },
            { value: 90, numeral: "XC" },
            { value: 50, numeral: "L" },
            { value: 40, numeral: "XL" },
            { value: 10, numeral: "X" },
            { value: 9, numeral: "IX" },
            { value: 5, numeral: "V" },
            { value: 4, numeral: "IV" },
            { value: 1, numeral: "I" },
        ];
        let result = "";
        for (const { value, numeral } of romanNumerals) {
            while (num >= value) {
                result += numeral;
                num -= value;
            }
        }
        return result;
    }
    const numberToLetter = (number, lowerCase = false) => {
        const letter = String.fromCharCode(65 + number);
        return lowerCase ? letter.toLowerCase() : letter;
    };
    function conversorDeIndicesParaAlternativas(indice, tipoColuna) {
        switch (tipoColuna) {
            case 1:
                return String(indice + 1);
            case 2:
                return toRoman(indice + 1) + ".";
            case 3:
                return numberToLetter(indice, true) + ".";
            case 4:
                return numberToLetter(indice) + ".";
            case 5:
                return numberToLetter(indice, true) + ")";
            case 6:
                return numberToLetter(indice) + ")";
            case 7:
                return `(${numberToLetter(indice)})`;
            case 8:
                return `${numberToLetter(indice)} (&nbsp;&nbsp;&nbsp;)`;
            case 9:
                return `<div class="item_enem" style="vertical-align:middle;border-radius:50%;width:18px;height:18px;background:black;color:white;display:table-cell;text-align:center;" >${numberToLetter(indice)}</div>`;
            case 10:
                return "";
            default:
                return indice;
        }
    }
    function diaDaSemana(dateStr) {
        const [day, month, year] = dateStr.split('/').map(Number);
        const date = new Date(year, month - 1, day); // month is 0-indexed in JS
        const mapaSemana = {
            0: 'domingo',
            1: 'segunda-feira',
            2: 'tera-feira',
            3: 'quarta-feira',
            4: 'quinta-feira',
            5: 'sexta-feira',
            6: 'sbado'
        };
        return mapaSemana[date.getDay()];
    }
    function anoLetivo(dateStr) {
        const [day, month, year] = dateStr.split('/').map(Number);
        const date = new Date(year, month - 1, day); // month is 0-indexed in JS
        return date.getFullYear();
    }
    function replacer(string, placeholders) {
        var _a;
        if (!string)
            return "";
        let replacedString = string;
        for (const placeholder in placeholders) {
            replacedString = replacedString.replace(new RegExp(placeholder, "g"), (_a = placeholders[placeholder]) !== null && _a !== void 0 ? _a : "&nbsp;");
        }
        return replacedString;
    }
    function replacePlaceholders(provaModelo) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2;
        const folhaDeRostoPlaceholder = {
            "#DATA#": provaModelo.prova.dataRealizacao,
            "#DIASEMANA#": diaDaSemana(provaModelo.prova.dataRealizacao),
            "#CURSO#": (_a = provaModelo.prova.turma) === null || _a === void 0 ? void 0 : _a.cursoUnidade.curso.nome,
            "#DISCIPLINA#": (_b = provaModelo.prova.turma) === null || _b === void 0 ? void 0 : _b.disciplina,
            "#TURMA#": (_c = provaModelo.prova.turma) === null || _c === void 0 ? void 0 : _c.codigoTurma,
            "#CODIGO_TURMA#": (_d = provaModelo.prova.turma) === null || _d === void 0 ? void 0 : _d.codigoTurma,
            "#TIPOPROVA#": provaModelo.prova.tipoProva.notaParcial,
            "#PERIODO#": (_f = (_e = provaModelo.prova.turma) === null || _e === void 0 ? void 0 : _e.periodoLetivo.nome) !== null && _f !== void 0 ? _f : "&nbsp;",
            "#MODELO#": " - Modelo " + provaModelo.nome,
            "#PROFESSOR#": ((_j = (_h = (_g = provaModelo.prova.turma) === null || _g === void 0 ? void 0 : _g.listaTurmaDisciplina) === null || _h === void 0 ? void 0 : _h[0]) === null || _j === void 0 ? void 0 : _j.nomeProfessor) == null &&
                provaModelo.prova.usuario != null
                ? provaModelo.prova.usuario.nome
                : (_m = (_l = (_k = provaModelo.prova.turma) === null || _k === void 0 ? void 0 : _k.listaTurmaDisciplina) === null || _l === void 0 ? void 0 : _l[0]) === null || _m === void 0 ? void 0 : _m.nomeProfessor,
            "#TURNO#": (_o = provaModelo.prova.turma) === null || _o === void 0 ? void 0 : _o.cursoUnidade.turno.nome,
            "#DURACAO#": provaModelo.prova.duracao,
            "#TOTALQUEST#": provaModelo.listaProvaQuestao.length,
            "#NUM_QUESTOES#": provaModelo.listaProvaQuestao.length,
            "#PONTOS#": provaModelo.prova.totalPontos,
            "#INSTRUCAO#": (_p = provaModelo.prova.instrucaoEspecifica) === null || _p === void 0 ? void 0 : _p.texto,
            "#ANO#": anoLetivo(provaModelo.prova.dataRealizacao),
            "#OBSERVACAO#": provaModelo.prova.observacao,
        };
        const cabecalhoPlaceholders = {
            "#LOGO#": provaModelo.prova.instituicao.linkFile,
            "#TIPOPROVA#": provaModelo.prova.tipoProva.notaParcial,
            "#TIPOPROVANOME#": provaModelo.prova.tipoProva.nome,
            "#DISCIPLINA#": (_q = provaModelo.prova.turma) === null || _q === void 0 ? void 0 : _q.disciplina,
            "#CURSO#": (_r = provaModelo.prova.turma) === null || _r === void 0 ? void 0 : _r.cursoUnidade.curso.nome,
            "#TURMA#": (_s = provaModelo.prova.turma) === null || _s === void 0 ? void 0 : _s.codigoTurma,
            "#TURMANOME#": (_t = provaModelo.prova.turma) === null || _t === void 0 ? void 0 : _t.nome,
            "#NOME_TURMA#": (_u = provaModelo.prova.turma) === null || _u === void 0 ? void 0 : _u.nome,
            "#TURNO#": (_v = provaModelo.prova.turma) === null || _v === void 0 ? void 0 : _v.cursoUnidade.turno.nome,
            "#PERIODO#": (_w = provaModelo.prova.turma) === null || _w === void 0 ? void 0 : _w.periodoLetivo.nome,
            "#TOTALQUEST#": provaModelo.listaProvaQuestao.length,
            "#LAYOUTNOME#": provaModelo.prova.layout.nome,
            "#NOMELAYOUT#": provaModelo.prova.layout.nome,
            "#INSTRUCAO#": (_x = provaModelo.prova.instrucaoEspecifica) === null || _x === void 0 ? void 0 : _x.texto,
            "#PONTOS#": provaModelo.prova.totalPontos,
            "#DATA#": provaModelo.prova.dataRealizacao,
            "#ANO#": anoLetivo(provaModelo.prova.dataRealizacao),
        };
        const cabecalhoPaginaPlaceholders = {
            "#LOGO#": provaModelo.prova.instituicao.linkFile,
            "#DISCIPLINA#": (_y = provaModelo.prova.turma) === null || _y === void 0 ? void 0 : _y.disciplina,
            "#CURSO#": (_z = provaModelo.prova.turma) === null || _z === void 0 ? void 0 : _z.cursoUnidade.curso.nome,
            "#CURSONOME#": (_0 = provaModelo.prova.turma) === null || _0 === void 0 ? void 0 : _0.cursoUnidade.curso.nome,
            "#PERIODO#": (_1 = provaModelo.prova.turma) === null || _1 === void 0 ? void 0 : _1.periodoLetivo.nome,
            "#PERIODOLET#": (_2 = provaModelo.prova.turma) === null || _2 === void 0 ? void 0 : _2.periodoLetivo.nome,
            "#TIPOPROVA#": provaModelo.prova.tipoProva.notaParcial,
            "#TIPOPROVANOME#": provaModelo.prova.tipoProva.nome,
            "#ANO#": anoLetivo(provaModelo.prova.dataRealizacao),
        };
        const footerPlaceholders = {
            "#site#": provaModelo.prova.instituicao.site,
        };
        provaModelo.prova.layout.cabecalho = replacer(provaModelo.prova.layout.cabecalho, cabecalhoPlaceholders);
        provaModelo.prova.layout.folhaRosto = replacer(provaModelo.prova.layout.folhaRosto, folhaDeRostoPlaceholder);
        provaModelo.prova.layout.cabecalhoPagina = replacer(provaModelo.prova.layout.cabecalhoPagina, cabecalhoPaginaPlaceholders);
        provaModelo.prova.layout.rodape = replacer(provaModelo.prova.layout.rodape, footerPlaceholders);
        return provaModelo;
    }
    function shuffleAndMultiply(arr, multiplier) {
        // Shuffle group order
        const chunks = Array(multiplier).fill(arr).map(a => [...a]);
        for (let i = chunks.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [chunks[i], chunks[j]] = [chunks[j], chunks[i]];
        }
        // Flatten
        const multipliedArray = chunks.flat();
        // Shuffle all elements
        for (let i = multipliedArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [multipliedArray[i], multipliedArray[j]] = [multipliedArray[j], multipliedArray[i]];
        }
        return multipliedArray;
    }

    class QuadroRespostaRenderer {
        linhasTabelaNumeradas(numberOfLines, withHeader = true) {
            const header = `<tr class='dontsplit'>
                      <td class="side-number-header" colspan="2">Resposta</td>
                    </tr>`;
            let rows = Array.from({ length: numberOfLines }, (_, index) => `
          <tr class='dontsplit'>
            <td class="side-number">${index + 1}</td>
            <td class="side-number-content"></td>
          </tr>
        `).join("");
            return `
      <table class="side-number-table">
        ${withHeader ? header : ""}
        ${rows}
      </table>
  `;
        }
        linhasTabela(numberOfLines, withHeader = true) {
            const header = `
        <tr class='dontsplit'>
        <td class="side-number-header">Resposta</td>
        </tr>
        `;
            return `
            <table class="answer-table">
            ${withHeader ? header : ""}
            ${"<tr class='dontsplit'><td></td></tr>".repeat(numberOfLines)}
            </table>
        `;
        }
        linhasTabelaComCabecalho(numberOfLines, withHeader = true) {
            return this.linhasTabela(numberOfLines, withHeader);
        }
        linhasSemRespostaSemBorda(numberOfLines) {
            if (!numberOfLines)
                return "";
            const lines = Array.from({ length: numberOfLines }, () => `
    <div class="linha linha-text linha-underline dontsplit">
      &nbsp;
    </div>
  `).join("");
            return `
    <div class="linhas-sem-borda">
      ${lines}
    </div>
  `;
        }
        // Linhas Sem Borda e Com Linha Para Ttulo
        linhasSemBordaComLinha(numberOfLines) {
            if (!numberOfLines)
                return "";
            const lines = Array.from({ length: numberOfLines }, () => `
    <div class="linha linha-text linha-underline dontsplit">
      &nbsp;
    </div>
  `).join("");
            return `
    <div class="linhas-sem-borda">
      <div class="linha linha-text linha-titulo-underline dontsplit">
        &nbsp;
      </div>
      ${lines}
    </div>
  `;
        }
        linhaComCalculo(numberOfLines) {
            if (!numberOfLines)
                return "";
            const lines = Array.from({ length: numberOfLines }, () => `
                <div class="quadro-resposta-linha-custom dontsplit">
                <td>&nbsp;</td>
                </div>
            `).join("");
            return `
                <div class="quadro-resposta-tabela quadro-resposta-container" >
                <header style="border-top: 1px solid black; border-bottom:1px solid black;" class="dontsplit"><strong class="quadro-resposta-coluna w100">Clculo</strong></header>
                ${lines}
                </div>
            `;
        }
        quadroDeLinhasEmBranco(numberOfLines) {
            if (!numberOfLines)
                return "";
            const height = Math.max(30 * numberOfLines, 30);
            return `
                <div class="box">
                <div class="box-header">Resposta</div>
                <div class="box-content" style='height: ${height}px'></div>
                </div>
            `;
        }
        quadroDeLinhasComCorrecao(numberOfLines) {
            if (!numberOfLines)
                return "";
            const header = `
                <header class="dontsplit">
                <strong class="quadro-resposta-coluna" style="width:85%;border-right: 1px solid black;">Resposta</strong>
                <strong class="quadro-resposta-coluna" style="width:5%;border-right: 1px solid black;">E</strong>
                <strong class="quadro-resposta-coluna" style="width:5%;border-right: 1px solid black;">G</strong>
                <strong class="quadro-resposta-coluna" style="width:5%">T</strong>
                </header>
            `;
            const rows = Array.from({ length: numberOfLines }, (_, index) => `<div>
            <span class="quadro-resposta-coluna" style="width: 5%; border-right: 1px solid black;">${index + 1}</span>
            <span class="quadro-resposta-coluna" style="width: 80%;border-right: 1px solid black;">&nbsp;</span>
            <span class="quadro-resposta-coluna" style="width: 5%;border-right: 1px solid black;">&nbsp;</span>
            <span class="quadro-resposta-coluna" style="width: 5%;border-right: 1px solid black;">&nbsp;</span>
            <span class="quadro-resposta-coluna" style="width: 5%;">&nbsp;</span>
            </div>`).join("");
            return `
                <div class="quadro-resposta-tabela w100 dontsplit tablelike">
                ${header}
                ${rows}
                </div>
            `;
        }
        static tipoQuadroRespostaHtml(tipoLinha, numeroLinhas) {
            const quadroResposta = new QuadroRespostaRenderer();
            switch (tipoLinha) {
                case 1:
                    return quadroResposta.linhasTabelaNumeradas(numeroLinhas);
                case 2:
                    return quadroResposta.linhasTabela(numeroLinhas);
                case 3:
                    return quadroResposta.quadroDeLinhasComCorrecao(numeroLinhas);
                case 4:
                    return quadroResposta.quadroDeLinhasEmBranco(numeroLinhas);
                case 5:
                    return quadroResposta.linhasTabelaComCabecalho(numeroLinhas, false);
                case 6:
                    return quadroResposta.linhasSemRespostaSemBorda(numeroLinhas);
                case 7:
                    return quadroResposta.linhasSemBordaComLinha(numeroLinhas);
                case 8:
                    return quadroResposta.linhaComCalculo(numeroLinhas);
                default:
                    return "";
            }
        }
    }

    const Handlebars$9 = HandlebarsRuntime.default || HandlebarsRuntime;
            var questionTpl = Handlebars$9.template({"1":function(container,depth0,helpers,partials,data) {
        return "dontsplit";
    },"3":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "        <div\n            style=\"font-size: 16px; font-weight: bold; text-transform: uppercase; margin-bottom: 10px; text-align: center;\">\n            "
        + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"title") : stack1), depth0))
        + "</div>\n";
    },"5":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "    "
        + ((stack1 = container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaResposta") : stack1), depth0)) != null ? stack1 : "")
        + "\n";
    },"7":function(container,depth0,helpers,partials,data) {
        return "    <div class='quebra-pagina'></div>\n";
    },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
        var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "<div class='tiptap' data-questao-id=\""
        + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"id") : stack1), depth0))
        + "\">\n    <div class='questao-completa "
        + ((stack1 = lookupProperty(helpers,"unless").call(alias1,((stack1 = (depth0 != null ? lookupProperty(depth0,"options") : depth0)) != null ? lookupProperty(stack1,"quebraQuestao") : stack1),{"name":"unless","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":33},"end":{"line":2,"column":86}}})) != null ? stack1 : "")
        + "'>\n"
        + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"title") : stack1),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":3,"column":8},"end":{"line":7,"column":15}}})) != null ? stack1 : "")
        + ((stack1 = container.invokePartial(lookupProperty(partials,"reference"),depth0,{"name":"reference","data":data,"indent":"        ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
        + "        <div class='cabecalho-questao dontend'>\n"
        + ((stack1 = container.invokePartial(lookupProperty(partials,"header"),depth0,{"name":"header","data":data,"indent":"            ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
        + "        </div>\n"
        + ((stack1 = container.invokePartial(lookupProperty(partials,"body"),depth0,{"name":"body","data":data,"indent":"        ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
        + "    </div>\n"
        + ((stack1 = container.invokePartial(lookupProperty(partials,"responseBox"),depth0,{"name":"responseBox","data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
        + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = (depth0 != null ? lookupProperty(depth0,"options") : depth0)) != null ? lookupProperty(stack1,"gabarito") : stack1),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":15,"column":4},"end":{"line":17,"column":11}}})) != null ? stack1 : "")
        + "    <div>"
        + ((stack1 = (lookupProperty(helpers,"repeat")||(depth0 && lookupProperty(depth0,"repeat"))||container.hooks.helperMissing).call(alias1,"<br>",((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"linhasBranco") : stack1),{"name":"repeat","hash":{},"data":data,"loc":{"start":{"line":18,"column":9},"end":{"line":18,"column":50}}})) != null ? stack1 : "")
        + "</div>\n"
        + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"quebraPagina") : stack1),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":19,"column":4},"end":{"line":21,"column":11}}})) != null ? stack1 : "")
        + "</div>";
    },"usePartial":true,"useData":true});

    const Handlebars$8 = HandlebarsRuntime.default || HandlebarsRuntime;
            var headerTpl = Handlebars$8.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return ((stack1 = (lookupProperty(helpers,"formatHeader")||(depth0 && lookupProperty(depth0,"formatHeader"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? lookupProperty(depth0,"assessmentLayout") : depth0)) != null ? lookupProperty(stack1,"cabecalhoPrimeiraQuestao") : stack1),((stack1 = (depth0 != null ? lookupProperty(depth0,"assessmentLayout") : depth0)) != null ? lookupProperty(stack1,"cabecalhoQuestao") : stack1),((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"order") : stack1),((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"displayOrder") : stack1),((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"value") : stack1),{"name":"formatHeader","hash":{},"data":data,"loc":{"start":{"line":1,"column":0},"end":{"line":2,"column":39}}})) != null ? stack1 : "");
    },"useData":true});

    const Handlebars$7 = HandlebarsRuntime.default || HandlebarsRuntime;
            var referenceTpl = Handlebars$7.template({"1":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"showReference") : stack1),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":0},"end":{"line":17,"column":7}}})) != null ? stack1 : "");
    },"2":function(container,depth0,helpers,partials,data) {
        var stack1, alias1=container.lambda, alias2=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "<div\n    style=\"margin-top: 10px; margin-bottom:15px; font-size:"
        + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"options") : depth0)) != null ? lookupProperty(stack1,"fontSize") : stack1), depth0))
        + "px; font-family: "
        + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"assessmentLayout") : depth0)) != null ? lookupProperty(stack1,"fonte") : stack1), depth0))
        + ";\">\n    <div class=\"referencia-style\" style=\"margin-top: 0px;\">\n        Para as questes "
        + ((stack1 = alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"referenceInfo") : stack1), depth0)) != null ? stack1 : "")
        + "\n    </div>\n    <div>\n"
        + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? lookupProperty(depth0,"assessmentLayout") : depth0)) != null ? lookupProperty(stack1,"origemQuestao") : stack1),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":9,"column":8},"end":{"line":13,"column":15}}})) != null ? stack1 : "")
        + "        <span>"
        + ((stack1 = alias1(((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"reference") : stack1)) != null ? lookupProperty(stack1,"texto") : stack1), depth0)) != null ? stack1 : "")
        + "</span>\n    </div>\n</div>\n";
    },"3":function(container,depth0,helpers,partials,data) {
        var stack1, alias1=container.lambda, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "        <span class=\"fonte-questao-width italic\">\n            ("
        + ((stack1 = alias1(((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"reference") : stack1)) != null ? lookupProperty(stack1,"fonte") : stack1)) != null ? lookupProperty(stack1,"descricao") : stack1), depth0)) != null ? stack1 : "")
        + " - "
        + ((stack1 = alias1(((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"reference") : stack1)) != null ? lookupProperty(stack1,"fonte") : stack1)) != null ? lookupProperty(stack1,"anoFonte") : stack1), depth0)) != null ? stack1 : "")
        + ")\n        </span>\n";
    },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"reference") : stack1)) != null ? lookupProperty(stack1,"texto") : stack1),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":1,"column":0},"end":{"line":18,"column":7}}})) != null ? stack1 : "");
    },"useData":true});

    const Handlebars$6 = HandlebarsRuntime.default || HandlebarsRuntime;
            var bodyTpl = Handlebars$6.template({"1":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return ((stack1 = container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoRaw") : stack1), depth0)) != null ? stack1 : "")
        + "\n";
    },"3":function(container,depth0,helpers,partials,data) {
        var stack1, alias1=container.lambda, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "<div class=\"adaptive-block-avalicao-visualize\">\n    "
        + ((stack1 = alias1(((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"fonte") : stack1), depth0)) != null ? stack1 : "")
        + "\n    "
        + ((stack1 = alias1(((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"instrucao") : stack1), depth0)) != null ? stack1 : "")
        + "\n    "
        + ((stack1 = alias1(((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"textoBase") : stack1), depth0)) != null ? stack1 : "")
        + "\n    <div style=\"padding-bottom: 12px;\"></div>\n\n"
        + ((stack1 = (lookupProperty(helpers,"switch")||(depth0 && lookupProperty(depth0,"switch"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"type") : stack1),{"name":"switch","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":10,"column":4},"end":{"line":44,"column":15}}})) != null ? stack1 : "")
        + "</div>\n";
    },"4":function(container,depth0,helpers,partials,data) {
        var stack1, helper, options, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        }, buffer = 
      ((stack1 = (lookupProperty(helpers,"case")||(depth0 && lookupProperty(depth0,"case"))||alias2).call(alias1,"Aberta - Associao",{"name":"case","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":11,"column":4},"end":{"line":14,"column":13}}})) != null ? stack1 : "")
        + ((stack1 = (lookupProperty(helpers,"case")||(depth0 && lookupProperty(depth0,"case"))||alias2).call(alias1,"Mltipla Escolha - Associao",{"name":"case","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":15,"column":4},"end":{"line":20,"column":13}}})) != null ? stack1 : "")
        + ((stack1 = (lookupProperty(helpers,"case")||(depth0 && lookupProperty(depth0,"case"))||alias2).call(alias1,"Mltipla Escolha - Alternativas Constantes",{"name":"case","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":21,"column":4},"end":{"line":29,"column":13}}})) != null ? stack1 : "");
      stack1 = ((helper = (helper = lookupProperty(helpers,"default") || (depth0 != null ? lookupProperty(depth0,"default") : depth0)) != null ? helper : alias2),(options={"name":"default","hash":{},"fn":container.program(12, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":30,"column":4},"end":{"line":43,"column":16}}}),(typeof helper === "function" ? helper.call(alias1,options) : helper));
      if (!lookupProperty(helpers,"default")) { stack1 = container.hooks.blockHelperMissing.call(depth0,stack1,options);}
      if (stack1 != null) { buffer += stack1; }
      return buffer;
    },"5":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "    "
        + ((stack1 = container.lambda(((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"comando") : stack1), depth0)) != null ? stack1 : "")
        + "\n"
        + ((stack1 = container.invokePartial(lookupProperty(partials,"associations"),depth0,{"name":"associations","hash":{"object":((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"associacoes") : stack1)},"data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
    },"7":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return ((stack1 = container.invokePartial(lookupProperty(partials,"associations"),depth0,{"name":"associations","hash":{"object":((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"associacoes") : stack1)},"data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
        + "    <div style=\"padding-bottom: 12px;\"></div>\n    "
        + ((stack1 = container.lambda(((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"comando") : stack1), depth0)) != null ? stack1 : "")
        + "\n"
        + ((stack1 = container.invokePartial(lookupProperty(partials,"alternatives"),depth0,{"name":"alternatives","hash":{"object":((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"alternativas") : stack1)},"data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
    },"9":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"isMultiplaEscolha") : depth0),{"name":"if","hash":{},"fn":container.program(10, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":22,"column":4},"end":{"line":25,"column":11}}})) != null ? stack1 : "")
        + "    <div style=\"padding-bottom: 12px;\"></div>\n    "
        + ((stack1 = container.lambda(((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"comando") : stack1), depth0)) != null ? stack1 : "")
        + "\n"
        + ((stack1 = container.invokePartial(lookupProperty(partials,"alternatives"),depth0,{"name":"alternatives","hash":{"object":((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"alternativas") : stack1)},"data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
    },"10":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return ((stack1 = container.invokePartial(lookupProperty(partials,"statements"),depth0,{"name":"statements","hash":{"justificarFalsas":((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"justificarFalsas") : stack1),"object":((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"afirmacoes") : stack1)},"data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
    },"12":function(container,depth0,helpers,partials,data) {
        var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "    "
        + ((stack1 = container.lambda(((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"comando") : stack1), depth0)) != null ? stack1 : "")
        + "\n"
        + ((stack1 = lookupProperty(helpers,"unless").call(alias1,(depth0 != null ? lookupProperty(depth0,"isMultiplaEscolha") : depth0),{"name":"unless","hash":{},"fn":container.program(10, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":32,"column":4},"end":{"line":35,"column":15}}})) != null ? stack1 : "")
        + ((stack1 = container.invokePartial(lookupProperty(partials,"associations"),depth0,{"name":"associations","hash":{"object":((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"associacoes") : stack1)},"data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
        + ((stack1 = container.invokePartial(lookupProperty(partials,"assertions"),depth0,{"name":"assertions","hash":{"object":((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"assercoes") : stack1)},"data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
        + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isMultiplaEscolha") : depth0),{"name":"if","hash":{},"fn":container.program(10, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":38,"column":4},"end":{"line":41,"column":11}}})) != null ? stack1 : "")
        + ((stack1 = container.invokePartial(lookupProperty(partials,"alternatives"),depth0,{"name":"alternatives","hash":{"object":((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"visualizaQuestaoParsed") : stack1)) != null ? lookupProperty(stack1,"alternativas") : stack1)},"data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
    },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"useRaw") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"data":data,"loc":{"start":{"line":1,"column":0},"end":{"line":46,"column":7}}})) != null ? stack1 : "");
    },"usePartial":true,"useData":true});

    const Handlebars$5 = HandlebarsRuntime.default || HandlebarsRuntime;
            var alternativesTpl = Handlebars$5.template({"1":function(container,depth0,helpers,partials,data,blockParams,depths) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "<ol class=\"coluna-sm-12 adaptive-margin-bottom avaliacao-alternativas\"\n    data-ordem-alternativa=\""
        + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"orderAlternative") : stack1), depth0))
        + "\">\n"
        + ((stack1 = lookupProperty(helpers,"each").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"object") : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":4,"column":4},"end":{"line":13,"column":13}}})) != null ? stack1 : "")
        + "</ol>\n";
    },"2":function(container,depth0,helpers,partials,data,blockParams,depths) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "    <li class=\"linha-alternativa\">\n        <span class=\"media-esq\">\n            "
        + ((stack1 = (lookupProperty(helpers,"formatAlternativeIndex")||(depth0 && lookupProperty(depth0,"formatAlternativeIndex"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(data && lookupProperty(data,"index")),((stack1 = (depths[1] != null ? lookupProperty(depths[1],"assessmentLayout") : depths[1])) != null ? lookupProperty(stack1,"tipoAlternativa") : stack1),{"name":"formatAlternativeIndex","hash":{},"data":data,"loc":{"start":{"line":7,"column":12},"end":{"line":7,"column":83}}})) != null ? stack1 : "")
        + "\n        </span>\n        <span class=\"media-corpo\">\n            "
        + ((stack1 = container.lambda(depth0, depth0)) != null ? stack1 : "")
        + "\n        </span>\n    </li>\n";
    },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data,blockParams,depths) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"object") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":1,"column":0},"end":{"line":15,"column":7}}})) != null ? stack1 : "");
    },"useData":true,"useDepths":true});

    const Handlebars$4 = HandlebarsRuntime.default || HandlebarsRuntime;
            var statementsTpl = Handlebars$4.template({"1":function(container,depth0,helpers,partials,data,blockParams,depths) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "<ul class=\"lista-sem-estilo\">\n"
        + ((stack1 = lookupProperty(helpers,"each").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"object") : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":3,"column":4},"end":{"line":23,"column":13}}})) != null ? stack1 : "")
        + "</ul>\n";
    },"2":function(container,depth0,helpers,partials,data,blockParams,depths) {
        var stack1, alias1=container.lambda, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "    <li class=\"coluna-sm-12\">\n        <div class=\"linha-alternativa\">\n            <span class=\"media-esq\">"
        + ((stack1 = alias1((depth0 != null ? lookupProperty(depth0,"item") : depth0), depth0)) != null ? stack1 : "")
        + "</span>\n            <span class=\"media-corpo\">"
        + ((stack1 = alias1((depth0 != null ? lookupProperty(depth0,"descricao") : depth0), depth0)) != null ? stack1 : "")
        + "</span>\n        </div>\n"
        + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depths[1] != null ? lookupProperty(depths[1],"justificarFalsas") : depths[1]),{"name":"if","hash":{},"fn":container.program(3, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":9,"column":8},"end":{"line":21,"column":15}}})) != null ? stack1 : "")
        + "    </li>\n";
    },"3":function(container,depth0,helpers,partials,data) {
        return "        <table class=\"class-table\">\n            <tr>\n                <td>&nbsp;</td>\n            </tr>\n            <tr>\n                <td>&nbsp;</td>\n            </tr>\n            <tr>\n                <td>&nbsp;</td>\n            </tr>\n        </table>\n";
    },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data,blockParams,depths) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"object") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":1,"column":0},"end":{"line":25,"column":7}}})) != null ? stack1 : "");
    },"useData":true,"useDepths":true});

    const Handlebars$3 = HandlebarsRuntime.default || HandlebarsRuntime;
            var associationsTpl = Handlebars$3.template({"1":function(container,depth0,helpers,partials,data) {
        var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "<div class=\"grid-cols-2\">\n    <ul class=\"lista-sem-estilo\">\n"
        + ((stack1 = lookupProperty(helpers,"each").call(alias1,((stack1 = (depth0 != null ? lookupProperty(depth0,"object") : depth0)) != null ? lookupProperty(stack1,"coluna1") : stack1),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":4,"column":8},"end":{"line":9,"column":17}}})) != null ? stack1 : "")
        + "    </ul>\n    <ul class=\"lista-sem-estilo\">\n"
        + ((stack1 = lookupProperty(helpers,"each").call(alias1,((stack1 = (depth0 != null ? lookupProperty(depth0,"object") : depth0)) != null ? lookupProperty(stack1,"coluna2") : stack1),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":12,"column":8},"end":{"line":17,"column":17}}})) != null ? stack1 : "")
        + "    </ul>\n</div>\n<div style=\"padding-bottom: 12px;\"></div>\n";
    },"2":function(container,depth0,helpers,partials,data) {
        var stack1, alias1=container.lambda, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "        <li class=\"linha-alternativa\">\n            <span class=\"media-esq\">"
        + ((stack1 = alias1((depth0 != null ? lookupProperty(depth0,"item") : depth0), depth0)) != null ? stack1 : "")
        + "</span>\n            <span class=\"media-corpo\">"
        + ((stack1 = alias1((depth0 != null ? lookupProperty(depth0,"descricao") : depth0), depth0)) != null ? stack1 : "")
        + "</span>\n        </li>\n";
    },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"object") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":1,"column":0},"end":{"line":21,"column":7}}})) != null ? stack1 : "");
    },"useData":true});

    const Handlebars$2 = HandlebarsRuntime.default || HandlebarsRuntime;
            var assertionsTpl = Handlebars$2.template({"1":function(container,depth0,helpers,partials,data) {
        var stack1, alias1=container.lambda, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return "<div>"
        + ((stack1 = alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"object") : depth0)) != null ? lookupProperty(stack1,"assercao1") : stack1), depth0)) != null ? stack1 : "")
        + "</div>\n<br>\n<p class=\"centro\">PORQUE</p><br>\n<div>"
        + ((stack1 = alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"object") : depth0)) != null ? lookupProperty(stack1,"assercao2") : stack1), depth0)) != null ? stack1 : "")
        + "</div>\n<br>\n";
    },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"object") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":1,"column":0},"end":{"line":7,"column":7}}})) != null ? stack1 : "");
    },"useData":true});

    const Handlebars$1 = HandlebarsRuntime.default || HandlebarsRuntime;
            var responseBoxTpl = Handlebars$1.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
        var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return parent[propertyName];
            }
            return undefined
        };

      return ((stack1 = (lookupProperty(helpers,"renderResponseBox")||(depth0 && lookupProperty(depth0,"renderResponseBox"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"tipoLinha") : stack1)) != null ? lookupProperty(stack1,"codigo") : stack1),((stack1 = (depth0 != null ? lookupProperty(depth0,"question") : depth0)) != null ? lookupProperty(stack1,"numeroLinhas") : stack1),{"name":"renderResponseBox","hash":{},"data":data,"loc":{"start":{"line":1,"column":0},"end":{"line":1,"column":71}}})) != null ? stack1 : "");
    },"useData":true});

    const Handlebars = HandlebarsRuntime.default || HandlebarsRuntime;
    // Register Partials
    Handlebars.registerPartial("reference", referenceTpl);
    Handlebars.registerPartial("header", headerTpl);
    Handlebars.registerPartial("body", bodyTpl);
    Handlebars.registerPartial("alternatives", alternativesTpl);
    Handlebars.registerPartial("statements", statementsTpl);
    Handlebars.registerPartial("associations", associationsTpl);
    Handlebars.registerPartial("assertions", assertionsTpl);
    Handlebars.registerPartial("responseBox", responseBoxTpl);
    // Register Helpers
    Handlebars.registerHelper("repeat", (str, count) => {
        return (str || "").repeat(count || 0);
    });
    Handlebars.registerHelper("formatHeader", (primeiraQuestaoTpl, questaoTpl, order, displayOrder, value) => {
        const template = order === 1 ? primeiraQuestaoTpl : questaoTpl;
        return (template || "")
            .replace("#ORDEM#", displayOrder)
            .replace("#VALOR#", String(value || 0).replace(".", ","));
    });
    Handlebars.registerHelper("renderResponseBox", (tipoLinhaCodigo, numeroLinhas) => {
        return new Handlebars.SafeString(QuadroRespostaRenderer.tipoQuadroRespostaHtml(tipoLinhaCodigo, numeroLinhas));
    });
    Handlebars.registerHelper("formatAlternativeIndex", (index, tipoAlternativa) => {
        return conversorDeIndicesParaAlternativas(index, tipoAlternativa);
    });
    Handlebars.registerHelper("switch", function (value, options) {
        if (!options.data) {
            options.data = {};
        }
        options.data._switch_value_ = value;
        options.data._switch_break_ = false;
        return options.fn(this);
    });
    Handlebars.registerHelper("case", function (value, options) {
        if (options.data && options.data._switch_value_ == value && !options.data._switch_break_) {
            options.data._switch_break_ = true;
            return options.fn(this);
        }
    });
    Handlebars.registerHelper("default", function (options) {
        if (options.data && !options.data._switch_break_) {
            return options.fn(this);
        }
    });
    const renderQuestion = (context) => {
        return questionTpl(context, {
            allowProtoPropertiesByDefault: true,
            allowProtoMethodsByDefault: true
        });
    };

    class QuestionRenderer {
        constructor(question, assessmentLayout, options) {
            this.question = question;
            this.assessmentLayout = assessmentLayout;
            this.options = options;
        }
        render() {
            const context = {
                question: this.question,
                displayOrder: this.question.order,
                assessmentLayout: this.assessmentLayout,
                options: this.options,
                isMultiplaEscolha: false,
                useRaw: false
            };
            try {
                const questaoObj = this.question.visualizaQuestaoParsed;
                if (!questaoObj) {
                    // If parsing failed or data is missing, use raw content
                    context.useRaw = true;
                }
                else {
                    if (questaoObj.alternativas && questaoObj.alternativas.length > 0) {
                        context.isMultiplaEscolha = true;
                    }
                }
            }
            catch (error) {
                context.useRaw = true;
            }
            return renderQuestion(context);
        }
    }

    class AssessmentHtmlRenderer {
        constructor(assessment, options) {
            this.assessment = assessment;
            this.options = options;
        }
        render() {
            const folhaDeRostoHtml = this.options.folhaDeRosto ? `<div id="folha-rosto">${this.options.folhaDeRosto}</div>` : "";
            const questionsHtml = this.renderQuestions();
            const attachmentsHtml = this.renderAttachments();
            const draftsHtml = `<div class="rascunho"></div>`.repeat(this.options.quantidadeFolhasRascunho || 0);
            return folhaDeRostoHtml + questionsHtml + attachmentsHtml + draftsHtml;
        }
        renderQuestions() {
            const questionsHtml = this.assessment.questions
                .map(question => {
                const presenter = new QuestionRenderer(question, this.assessment.layout, this.options);
                return presenter.render();
            })
                .join("");
            return this.options.quantidadeColunas == 2
                ? `<div id='duas-colunas'>${questionsHtml}</div>`
                : questionsHtml;
        }
        renderAttachments() {
            const listaAnexos = this.assessment.attachments;
            if (!listaAnexos || listaAnexos.length === 0)
                return "";
            return listaAnexos
                .map(anexo => `
                <div class="anexo">
                    <div class="columnbreak"></div>
                    <p style="text-align:center"><strong>ANEXO ${anexo.ordem}</strong></p>
                    <p>&nbsp;</p>
                    <div>${anexo.anexo.texto}</div>
                </div>
            `)
                .join("");
        }
    }

    class LayoutAvaliacao {
        constructor(provaModelo, layoutOptions) {
            this.provaModelo = provaModelo;
            this.layoutOptions = layoutOptions;
        }
        avalicaoHtml() {
            // 1. Map Raw Data to Entities
            const assessment = this._mapToEntity(this.provaModelo);
            // 2. Domain Logic: Process References
            ReferenceService.processReferences(assessment.questions);
            // 3. Prepare for Presentation
            const renderer = new AssessmentHtmlRenderer(assessment, this.layoutOptions);
            // 4. Return formatted data
            // The previous implementation returned only the HTML string from this method
            return renderer.render();
        }
        _mapToEntity(rawData) {
            const { prova, listaProvaQuestao, listaProvaAnexo } = rawData;
            const questions = (listaProvaQuestao || []).map(q => {
                let parsedContent = {};
                try {
                    parsedContent = JSON.parse(q.questao.visualizaQuestao);
                }
                catch (e) {
                    console.error("Error parsing question content", e);
                }
                const question = new Question({
                    id: q.questao.codigo,
                    order: q.ordem,
                    title: q.titulo,
                    customOrder: q.ordemPersonalizada,
                    value: q.valor,
                    type: q.questao.tipoQuestao,
                    reference: q.questao.referencia,
                    orderAlternative: q.ordemAlternativa,
                    visualizaQuestaoRaw: q.questao.visualizaQuestao
                });
                // Flatten parsed content into the entity for easier access in presenters
                question.visualizaQuestaoParsed = parsedContent;
                // Map other fields used in rendering
                question.linhasBranco = q.linhasBranco;
                question.quebraPagina = q.quebraPagina;
                question.visualizaResposta = q.questao.visualizaResposta;
                // Map fields used by QuadroResposta
                question.tipoLinha = q.tipoLinha;
                question.numeroLinhas = q.numeroLinhas;
                return question;
            });
            return new Assessment({
                id: prova === null || prova === void 0 ? void 0 : prova.id,
                title: prova === null || prova === void 0 ? void 0 : prova.descricao,
                questions: questions,
                attachments: listaProvaAnexo || [],
                layout: (prova === null || prova === void 0 ? void 0 : prova.layout) || {}
            });
        }
    }

    const TIPO_ORDENACAO$1 = {
        NAO_EMBARALHAR: 0,
        ALEATORIO: 1,
        ASCENDENTE: 2,
        DESCENDENTE: 3,
    };
    class LayoutAvaliacaoBuilder {
        constructor() {
            this.header = "";
            this.footer = "";
            this.fontSize = 12;
            this._folhaDeRosto = {
                header: "",
                content: "",
                footer: "",
            };
            this.pagina = {
                header: "",
                footer: "",
            };
            this.numeroFolhasRascunho = null;
            this._marcaDaquaRascunho = null;
            this._marcaDaguaInstituicao = null;
            this.quantidadeColunas = 1;
            this.paginacaoAtiva = false;
            this._identificacao = "";
            this._gabarito = false;
            this.tipoOrdenacaoAlternativa = TIPO_ORDENACAO$1.NAO_EMBARALHAR;
            this._tipoAlternativa = null;
        }
        marcaDaguaRascunho(comMarcaDagua) {
            this.comMarcaDaguaRascunho = comMarcaDagua;
            return this;
        }
        pageHeader(header) {
            this.header = header;
            return this;
        }
        pageFooter(footer) {
            this.footer = footer;
            return this;
        }
        marcaDaguaInstituicao(marcaDaguaUrl) {
            this._marcaDaguaInstituicao = marcaDaguaUrl;
            return this;
        }
        marcaDaquaRascunho(marcaDaguaUrl) {
            this._marcaDaquaRascunho = marcaDaguaUrl;
            return this;
        }
        fonteTamanho(tamanho) {
            if (isNaN(tamanho)) {
                throw new Error("O valor da fonte deve ser um valor numerico.");
            }
            this.fontSize = tamanho;
            return this;
        }
        gabarito() {
            this._gabarito = true;
            return this;
        }
        rascunho(quantidadeFolhasRascunho) {
            if (isNaN(quantidadeFolhasRascunho)) {
                throw new Error("O valor da rascunho deve ser um valor numerico.");
            }
            this.quantidadeFolhasRascunho = quantidadeFolhasRascunho;
            return this;
        }
        folhaDeRosto({ header, content, footer }) {
            const valid = header != null && content != null && footer != null;
            if (!valid) {
                throw new Error("Todas as propriedades de folha de rosto so obrigatorias. header, content e footer");
            }
            this._folhaDeRosto = { ...this._folhaDeRosto, header, content, footer };
            return this;
        }
        colunas(quantidade) {
            if (isNaN(quantidade)) {
                throw new Error("O valor da quantidade de colunas deve ser um valor numerico.");
            }
            if (quantidade > 2 || quantidade < 1) {
                throw new Error("A quantidade de colunas deve ser 1 ou 2.");
            }
            this.quantidadeColunas = quantidade;
            return this;
        }
        identificacao(identificacao = "") {
            this._identificacao = identificacao;
            return this;
        }
        paginacao() {
            this.paginacaoAtiva = true;
            return this;
        }
        ordemAlternativa(tipoOrdenacao) {
            if (!Object.values(TIPO_ORDENACAO$1).includes(tipoOrdenacao)) {
                throw new Error("Tipo de ordenao de alternativas invlido.");
            }
            this.tipoOrdenacaoAlternativa = tipoOrdenacao;
            return this;
        }
        tipoAlternativa(tipoAlternativa) {
            this._tipoAlternativa = tipoAlternativa;
            return this;
        }
        build(provaModelo) {
            const layoutAvaliacao = new LayoutAvaliacao(provaModelo, {
                fontSize: this.fontSize,
                folhaDeRosto: this._folhaDeRosto.content,
                quantidadeFolhasRascunho: this.quantidadeFolhasRascunho,
                quantidadeColunas: this.quantidadeColunas,
                quebraQuestao: provaModelo.prova.quebraQuestao,
                gabarito: this._gabarito,
                paginacaoAtiva: this.paginacaoAtiva,
            });
            return Object.freeze({
                layoutHtml: layoutAvaliacao.avalicaoHtml(),
                cssVars: {
                    "--layout-font-size": this.fontSize + "px",
                    "--layout-watermark-rascunho": this._marcaDaquaRascunho
                        ? `url("${this._marcaDaquaRascunho}")`
                        : "none",
                    "--layout-watermark-instituicao": this._marcaDaguaInstituicao
                        ? `url("${this._marcaDaguaInstituicao}")`
                        : "none",
                    "--layout-identificacao": this._identificacao
                        ? `"${this._identificacao}"`
                        : "none",
                },
                folhaDeRosto: this._folhaDeRosto,
                header: this.header,
                footer: this.footer,
                comMarcaDaguaRascunho: this.comMarcaDaguaRascunho,
                ordemAlternativa: this.tipoOrdenacaoAlternativa,
                tipoAlternativa: this._tipoAlternativa,
                handlers: [],
            });
        }
    }

    function getBoundingClientRect(element) {
    	if (!element) {
    		return;
    	}
    	let rect;
    	if (typeof element.getBoundingClientRect !== "undefined") {
    		rect = element.getBoundingClientRect();
    	} else {
    		let range = document.createRange();
    		range.selectNode(element);
    		rect = range.getBoundingClientRect();
    	}
    	return rect;
    }

    function getClientRects(element) {
    	if (!element) {
    		return;
    	}
    	let rect;
    	if (typeof element.getClientRects !== "undefined") {
    		rect = element.getClientRects();
    	} else {
    		let range = document.createRange();
    		range.selectNode(element);
    		rect = range.getClientRects();
    	}
    	return rect;
    }

    /**
     * Generates a UUID
     * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
     * @returns {string} uuid
     */
    function UUID() {
    	var d = new Date().getTime();
    	if (typeof performance !== "undefined" && typeof performance.now === "function") {
    		d += performance.now(); //use high-precision timer if available
    	}
    	return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    		var r = (d + Math.random() * 16) % 16 | 0;
    		d = Math.floor(d / 16);
    		return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
    	});
    }

    function attr(element, attributes) {
    	for (var i = 0; i < attributes.length; i++) {
    		if (element.hasAttribute(attributes[i])) {
    			return element.getAttribute(attributes[i]);
    		}
    	}
    }

    /* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
     * Allows # and .
     */
    function querySelectorEscape(value) {
    	if (arguments.length == 0) {
    		throw new TypeError("`CSS.escape` requires an argument.");
    	}
    	var string = String(value);

    	var length = string.length;
    	var index = -1;
    	var codeUnit;
    	var result = "";
    	var firstCodeUnit = string.charCodeAt(0);
    	while (++index < length) {
    		codeUnit = string.charCodeAt(index);



    		// Note: theres no need to special-case astral symbols, surrogate
    		// pairs, or lone surrogates.

    		// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
    		// (U+FFFD).
    		if (codeUnit == 0x0000) {
    			result += "\uFFFD";
    			continue;
    		}

    		if (
    			// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
    			// U+007F, []
    			(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
    			// If the character is the first character and is in the range [0-9]
    			// (U+0030 to U+0039), []
    			(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
    			// If the character is the second character and is in the range [0-9]
    			// (U+0030 to U+0039) and the first character is a `-` (U+002D), []
    			(
    				index == 1 &&
    				codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
    				firstCodeUnit == 0x002D
    			)
    		) {
    			// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
    			result += "\\" + codeUnit.toString(16) + " ";
    			continue;
    		}

    		if (
    			// If the character is the first character and is a `-` (U+002D), and
    			// there is no second character, []
    			index == 0 &&
    			length == 1 &&
    			codeUnit == 0x002D
    		) {
    			result += "\\" + string.charAt(index);
    			continue;
    		}

    		// support for period character in id
    		if (codeUnit == 0x002E) {
    			if (string.charAt(0) == "#") {
    				result += "\\.";
    				continue;
    			}
    		}


    		// If the character is not handled by one of the above rules and is
    		// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
    		// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
    		// U+005A), or [a-z] (U+0061 to U+007A), []
    		if (
    			codeUnit >= 0x0080 ||
    			codeUnit == 0x002D ||
    			codeUnit == 0x005F ||
    			codeUnit == 35 || // Allow #
    			codeUnit == 46 || // Allow .
    			codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
    			codeUnit >= 0x0041 && codeUnit <= 0x005A ||
    			codeUnit >= 0x0061 && codeUnit <= 0x007A
    		) {
    			// the character itself
    			result += string.charAt(index);
    			continue;
    		}

    		// Otherwise, the escaped character.
    		// https://drafts.csswg.org/cssom/#escape-a-character
    		result += "\\" + string.charAt(index);

    	}
    	return result;
    }

    /**
     * Creates a new pending promise and provides methods to resolve or reject it.
     * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
     * @returns {object} defered
     */
    function defer() {
    	this.resolve = null;

    	this.reject = null;

    	this.id = UUID();

    	this.promise = new Promise((resolve, reject) => {
    		this.resolve = resolve;
    		this.reject = reject;
    	});
    	Object.freeze(this);
    }

    const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

    function CSSValueToString(obj) {
    	return obj.value + (obj.unit || "");
    }

    function isElement(node) {
    	return node && node.nodeType === 1;
    }

    function isText(node) {
    	return node && node.nodeType === 3;
    }

    function* walk$1(start, limiter) {
    	let node = start;

    	while (node) {

    		yield node;

    		if (node.childNodes.length) {
    			node = node.firstChild;
    		} else if (node.nextSibling) {
    			if (limiter && node === limiter) {
    				node = undefined;
    				break;
    			}
    			node = node.nextSibling;
    		} else {
    			while (node) {
    				node = node.parentNode;
    				if (limiter && node === limiter) {
    					node = undefined;
    					break;
    				}
    				if (node && node.nextSibling) {
    					node = node.nextSibling;
    					break;
    				}

    			}
    		}
    	}
    }

    function nodeAfter(node, limiter) {
    	if (limiter && node === limiter) {
    		return;
    	}
    	let significantNode = nextSignificantNode(node);
    	if (significantNode) {
    		return significantNode;
    	}
    	if (node.parentNode) {
    		while ((node = node.parentNode)) {
    			if (limiter && node === limiter) {
    				return;
    			}
    			significantNode = nextSignificantNode(node);
    			if (significantNode) {
    				return significantNode;
    			}
    		}
    	}
    }

    function nodeBefore(node, limiter) {
    	if (limiter && node === limiter) {
    		return;
    	}
    	let significantNode = previousSignificantNode(node);
    	if (significantNode) {
    		return significantNode;
    	}
    	if (node.parentNode) {
    		while ((node = node.parentNode)) {
    			if (limiter && node === limiter) {
    				return;
    			}
    			significantNode = previousSignificantNode(node);
    			if (significantNode) {
    				return significantNode;
    			}
    		}
    	}
    }

    function elementAfter(node, limiter) {
    	let after = nodeAfter(node, limiter);

    	while (after && after.nodeType !== 1) {
    		after = nodeAfter(after, limiter);
    	}

    	return after;
    }

    function elementBefore(node, limiter) {
    	let before = nodeBefore(node, limiter);

    	while (before && before.nodeType !== 1) {
    		before = nodeBefore(before, limiter);
    	}

    	return before;
    }

    function displayedElementAfter(node, limiter) {
    	let after = elementAfter(node, limiter);

    	while (after && after.dataset.undisplayed) {
    		after = elementAfter(after, limiter);
    	}

    	return after;
    }

    function displayedElementBefore(node, limiter) {
    	let before = elementBefore(node, limiter);

    	while (before && before.dataset.undisplayed) {
    		before = elementBefore(before, limiter);
    	}

    	return before;
    }

    function rebuildAncestors(node) {
    	let parent, ancestor;
    	let ancestors = [];
    	let added = [];

    	let fragment = document.createDocumentFragment();

    	// Handle rowspan on table
    	if (node.nodeName === "TR") {
    		let previousRow = node.previousElementSibling;
    		let previousRowDistance = 1;
    		while (previousRow) {
    			// previous row has more columns, might indicate a rowspan.
    			if (previousRow.childElementCount > node.childElementCount) {
    				const initialColumns = Array.from(node.children);
    				while (node.firstChild) {
    					node.firstChild.remove();
    				}
    				let k = 0;
    				for (let j = 0; j < previousRow.children.length; j++) {
    					let column = previousRow.children[j];
    					if (column.rowSpan && column.rowSpan > previousRowDistance) {
    						const duplicatedColumn = column.cloneNode(true);
    						// Adjust rowspan value
    						duplicatedColumn.rowSpan = column.rowSpan - previousRowDistance;
    						// Add the column to the row
    						node.appendChild(duplicatedColumn);
    					} else {
    						// Fill the gap with the initial columns (if exists)
    						const initialColumn = initialColumns[k++];
    						// The initial column can be undefined if the newly created table has less columns than the original table
    						if (initialColumn) {
    							node.appendChild(initialColumn);
    						}
    					}
    				}
    			}
    			previousRow = previousRow.previousElementSibling;
    			previousRowDistance++;
    		}
    	}

    	// Gather all ancestors
    	let element = node;
    	while(element.parentNode && element.parentNode.nodeType === 1) {
    		ancestors.unshift(element.parentNode);
    		element = element.parentNode;
    	}

    	for (var i = 0; i < ancestors.length; i++) {
    		ancestor = ancestors[i];
    		parent = ancestor.cloneNode(false);
    	
    		parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
    		// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

    		if (parent.hasAttribute("id")) {
    			let dataID = parent.getAttribute("id");
    			parent.setAttribute("data-id", dataID);
    			parent.removeAttribute("id");
    		}

    		// This is handled by css :not, but also tidied up here
    		if (parent.hasAttribute("data-break-before")) {
    			parent.removeAttribute("data-break-before");
    		}

    		if (parent.hasAttribute("data-previous-break-after")) {
    			parent.removeAttribute("data-previous-break-after");
    		}

    		if (added.length) {
    			let container = added[added.length-1];
    			container.appendChild(parent);
    		} else {
    			fragment.appendChild(parent);
    		}
    		added.push(parent);

    		// rebuild table rows
    		if (parent.nodeName === "TD" && ancestor.parentElement.contains(ancestor)) {
    			let td = ancestor;
    			let prev = parent;
    			while ((td = td.previousElementSibling)) {
    				let sib = td.cloneNode(false);
    				parent.parentElement.insertBefore(sib, prev);
    				prev = sib;
    			}
    			
    		}
    	}

    	added = undefined;
    	return fragment;
    }
    /*
    export function split(bound, cutElement, breakAfter) {
    		let needsRemoval = [];
    		let index = indexOf(cutElement);

    		if (!breakAfter && index === 0) {
    			return;
    		}

    		if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
    			return;
    		}

    		// Create a fragment with rebuilt ancestors
    		let fragment = rebuildAncestors(cutElement);

    		// Clone cut
    		if (!breakAfter) {
    			let clone = cutElement.cloneNode(true);
    			let ref = cutElement.parentNode.getAttribute('data-ref');
    			let parent = fragment.querySelector("[data-ref='" + ref + "']");
    			parent.appendChild(clone);
    			needsRemoval.push(cutElement);
    		}

    		// Remove all after cut
    		let next = nodeAfter(cutElement, bound);
    		while (next) {
    			let clone = next.cloneNode(true);
    			let ref = next.parentNode.getAttribute('data-ref');
    			let parent = fragment.querySelector("[data-ref='" + ref + "']");
    			parent.appendChild(clone);
    			needsRemoval.push(next);
    			next = nodeAfter(next, bound);
    		}

    		// Remove originals
    		needsRemoval.forEach((node) => {
    			if (node) {
    				node.remove();
    			}
    		});

    		// Insert after bounds
    		bound.parentNode.insertBefore(fragment, bound.nextSibling);
    		return [bound, bound.nextSibling];
    }
    */

    function needsBreakBefore(node) {
    	if( typeof node !== "undefined" &&
    			typeof node.dataset !== "undefined" &&
    			typeof node.dataset.breakBefore !== "undefined" &&
    			(node.dataset.breakBefore === "always" ||
    			 node.dataset.breakBefore === "page" ||
    			 node.dataset.breakBefore === "left" ||
    			 node.dataset.breakBefore === "right" ||
    			 node.dataset.breakBefore === "recto" ||
    			 node.dataset.breakBefore === "verso")
    		 ) {
    		return true;
    	}

    	return false;
    }

    function needsPreviousBreakAfter(node) {
    	if( typeof node !== "undefined" &&
    			typeof node.dataset !== "undefined" &&
    			typeof node.dataset.previousBreakAfter !== "undefined" &&
    			(node.dataset.previousBreakAfter === "always" ||
    			 node.dataset.previousBreakAfter === "page" ||
    			 node.dataset.previousBreakAfter === "left" ||
    			 node.dataset.previousBreakAfter === "right" ||
    			 node.dataset.previousBreakAfter === "recto" ||
    			 node.dataset.previousBreakAfter === "verso")
    		 ) {
    		return true;
    	}

    	return false;
    }

    function needsPageBreak(node, previousSignificantNode) {
    	if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
    		return false;
    	}
    	if (node.dataset && node.dataset.undisplayed) {
    		return false;
    	}
    	let previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
    	if (typeof previousSignificantNodePage === "undefined") {
    		const nodeWithNamedPage = getNodeWithNamedPage(previousSignificantNode);
    		if (nodeWithNamedPage) {
    			previousSignificantNodePage = nodeWithNamedPage.dataset.page;
    		}
    	}
    	let currentNodePage = node.dataset ? node.dataset.page : undefined;
    	if (typeof currentNodePage === "undefined") {
    		const nodeWithNamedPage = getNodeWithNamedPage(node, previousSignificantNode);
    		if (nodeWithNamedPage) {
    			currentNodePage = nodeWithNamedPage.dataset.page;
    		}
    	}
    	return currentNodePage !== previousSignificantNodePage;
    }

    function *words(node) {
    	let currentText = node.nodeValue;
    	let max = currentText.length;
    	let currentOffset = 0;
    	let currentLetter;

    	let range;
    	const significantWhitespaces = node.parentElement && node.parentElement.nodeName === "PRE";

    	while (currentOffset < max) {
    		currentLetter = currentText[currentOffset];
    		if (/^[\S\u202F\u00A0]$/.test(currentLetter) || significantWhitespaces) {
    			if (!range) {
    				range = document.createRange();
    				range.setStart(node, currentOffset);
    			}
    		} else {
    			if (range) {
    				range.setEnd(node, currentOffset);
    				yield range;
    				range = undefined;
    			}
    		}

    		currentOffset += 1;
    	}

    	if (range) {
    		range.setEnd(node, currentOffset);
    		yield range;
    	}
    }

    function *letters$1(wordRange) {
    	let currentText = wordRange.startContainer;
    	let max = currentText.length;
    	let currentOffset = wordRange.startOffset;
    	// let currentLetter;

    	let range;

    	while(currentOffset < max) {
    		 // currentLetter = currentText[currentOffset];
    		 range = document.createRange();
    		 range.setStart(currentText, currentOffset);
    		 range.setEnd(currentText, currentOffset+1);

    		 yield range;

    		 currentOffset += 1;
    	}
    }

    function isContainer(node) {
    	let container;

    	if (typeof node.tagName === "undefined") {
    		return true;
    	}

    	if (node.style && node.style.display === "none") {
    		return false;
    	}

    	switch (node.tagName) {
    		// Inline
    		case "A":
    		case "ABBR":
    		case "ACRONYM":
    		case "B":
    		case "BDO":
    		case "BIG":
    		case "BR":
    		case "BUTTON":
    		case "CITE":
    		case "CODE":
    		case "DFN":
    		case "EM":
    		case "I":
    		case "IMG":
    		case "INPUT":
    		case "KBD":
    		case "LABEL":
    		case "MAP":
    		case "OBJECT":
    		case "Q":
    		case "SAMP":
    		case "SCRIPT":
    		case "SELECT":
    		case "SMALL":
    		case "SPAN":
    		case "STRONG":
    		case "SUB":
    		case "SUP":
    		case "TEXTAREA":
    		case "TIME":
    		case "TT":
    		case "VAR":
    		case "P":
    		case "H1":
    		case "H2":
    		case "H3":
    		case "H4":
    		case "H5":
    		case "H6":
    		case "FIGCAPTION":
    		case "BLOCKQUOTE":
    		case "PRE":
    		case "LI":
    		case "TD":
    		case "DT":
    		case "DD":
    		case "VIDEO":
    		case "CANVAS":
    			container = false;
    			break;
    		default:
    			container = true;
    	}

    	return container;
    }

    function cloneNode(n, deep=false) {
    	return n.cloneNode(deep);
    }

    function findElement(node, doc, forceQuery) {
    	const ref = node.getAttribute("data-ref");
    	return findRef(ref, doc, forceQuery);
    }

    function findRef(ref, doc, forceQuery) {
    	if (!forceQuery && doc.indexOfRefs && doc.indexOfRefs[ref]) {
    		return doc.indexOfRefs[ref];
    	} else {
    		return doc.querySelector(`[data-ref='${ref}']`);
    	}
    }

    function validNode(node) {
    	if (isText(node)) {
    		return true;
    	}

    	if (isElement(node) && node.dataset.ref) {
    		return true;
    	}

    	return false;
    }

    function prevValidNode(node) {
    	while (!validNode(node)) {
    		if (node.previousSibling) {
    			node = node.previousSibling;
    		} else {
    			node = node.parentNode;
    		}

    		if (!node) {
    			break;
    		}
    	}

    	return node;
    }


    function indexOf(node) {
    	let parent = node.parentNode;
    	if (!parent) {
    		return 0;
    	}
    	return Array.prototype.indexOf.call(parent.childNodes, node);
    }

    function child(node, index) {
    	return node.childNodes[index];
    }

    function hasContent(node) {
    	if (isElement(node)) {
    		return true;
    	} else if (isText(node) &&
    			node.textContent.trim().length) {
    		return true;
    	}
    	return false;
    }

    function indexOfTextNode(node, parent) {
    	if (!isText(node)) {
    		return -1;
    	}
    	let nodeTextContent = node.textContent;
    	let child;
    	let index = -1;
    	for (var i = 0; i < parent.childNodes.length; i++) {
    		child = parent.childNodes[i];
    		if (child.nodeType === 3) {
    			let text = parent.childNodes[i].textContent;
    			if (text.includes(nodeTextContent)) {
    				index = i;
    				break;
    			}
    		}
    	}

    	return index;
    }


    /**
     * Throughout, whitespace is defined as one of the characters
     *  "\t" TAB \u0009
     *  "\n" LF  \u000A
     *  "\r" CR  \u000D
     *  " "  SPC \u0020
     *
     * This does not use Javascript's "\s" because that includes non-breaking
     * spaces (and also some other characters).
     */

    /**
     * Determine if a node should be ignored by the iterator functions.
     * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
     *
     * @param {Node} node An object implementing the DOM1 |Node| interface.
     * @return {boolean} true if the node is:
     *  1) A |Text| node that is all whitespace
     *  2) A |Comment| node
     *  and otherwise false.
     */
    function isIgnorable(node) {
    	return (node.nodeType === 8) || // A comment node
    		((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
    }

    /**
     * Determine whether a node's text content is entirely whitespace.
     *
     * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
     * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
     */
    function isAllWhitespace(node) {
    	return !(/[^\t\n\r ]/.test(node.textContent));
    }

    /**
     * Version of |previousSibling| that skips nodes that are entirely
     * whitespace or comments.  (Normally |previousSibling| is a property
     * of all DOM nodes that gives the sibling node, the node that is
     * a child of the same parent, that occurs immediately before the
     * reference node.)
     *
     * @param {ChildNode} sib  The reference node.
     * @return {Node|null} Either:
     *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
     *  2) null if no such node exists.
     */
    function previousSignificantNode(sib) {
    	while ((sib = sib.previousSibling)) {
    		if (!isIgnorable(sib)) return sib;
    	}
    	return null;
    }

    function getNodeWithNamedPage(node, limiter) {
    	if (node && node.dataset && node.dataset.page) {
    		return node;
    	}
    	if (node.parentNode) {
    		while ((node = node.parentNode)) {
    			if (limiter && node === limiter) {
    				return;
    			}
    			if (node.dataset && node.dataset.page) {
    				return node;
    			}
    		}
    	}
    	return null;
    }

    function breakInsideAvoidParentNode(node) {
    	while ((node = node.parentNode)) {
    		if (node && node.dataset && node.dataset.breakInside === "avoid") {
    			return node;
    		}
    	}
    	return null;
    }

    /**
     * Find a parent with a given node name.
     * @param {Node} node - initial Node
     * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
     * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
     * @returns {Node|undefined} - Either:
     *  1) The closest parent for a the given node name, or
     *  2) undefined if no such node exists.
     */
    function parentOf(node, nodeName, limiter) {
    	if (limiter && node === limiter) {
    		return;
    	}
    	if (node.parentNode) {
    		while ((node = node.parentNode)) {
    			if (limiter && node === limiter) {
    				return;
    			}
    			if (node.nodeName === nodeName) {
    				return node;
    			}
    		}
    	}
    }

    /**
     * Version of |nextSibling| that skips nodes that are entirely
     * whitespace or comments.
     *
     * @param {ChildNode} sib  The reference node.
     * @return {Node|null} Either:
     *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
     *  2) null if no such node exists.
     */
    function nextSignificantNode(sib) {
    	while ((sib = sib.nextSibling)) {
    		if (!isIgnorable(sib)) return sib;
    	}
    	return null;
    }

    function filterTree(content, func, what) {
    	const treeWalker = document.createTreeWalker(
    		content || this.dom,
    		what || NodeFilter.SHOW_ALL,
    		func ? { acceptNode: func } : null,
    		false
    	);

    	let node;
    	let current;
    	node = treeWalker.nextNode();
    	while(node) {
    		current = node;
    		node = treeWalker.nextNode();
    		current.parentNode.removeChild(current);
    	}
    }

    /**
     * BreakToken
     * @class
     */
    class BreakToken {

    	constructor(node, offset) {
    		this.node = node;
    		this.offset = offset;
    	}

    	equals(otherBreakToken) {
    		if (!otherBreakToken) {
    			return false;
    		}
    		if (this["node"] && otherBreakToken["node"] &&
    			this["node"] !== otherBreakToken["node"]) {
    			return false;
    		}
    		if (this["offset"] && otherBreakToken["offset"] &&
    			this["offset"] !== otherBreakToken["offset"]) {
    			return false;
    		}
    		return true;
    	}

    	toJSON(hash) {
    		let node;
    		let index = 0;
    		if (!this.node) {
    			return {};
    		}
    		if (isElement(this.node) && this.node.dataset.ref) {
    			node = this.node.dataset.ref;
    		} else if (hash) {
    			node = this.node.parentElement.dataset.ref;
    		}

    		if (this.node.parentElement) {
    			const children = Array.from(this.node.parentElement.childNodes);
    			index = children.indexOf(this.node);
    		}

    		return JSON.stringify({
    			"node": node,
    			"index" : index,
    			"offset": this.offset
    		});
    	}

    }

    /**
     * Render result.
     * @class
     */
    class RenderResult {

    	constructor(breakToken, error) {
    		this.breakToken = breakToken;
    		this.error = error;
    	}
    }

    class OverflowContentError extends Error {
    	constructor(message, items) {
    		super(message);
    		this.items = items;
    	}
    }

    var eventEmitter = {exports: {}};

    var d = {exports: {}};

    var is$4;
    var hasRequiredIs$4;

    function requireIs$4 () {
    	if (hasRequiredIs$4) return is$4;
    	hasRequiredIs$4 = 1;

    	// ES3 safe
    	var _undefined = void 0;

    	is$4 = function (value) { return value !== _undefined && value !== null; };
    	return is$4;
    }

    var is$3;
    var hasRequiredIs$3;

    function requireIs$3 () {
    	if (hasRequiredIs$3) return is$3;
    	hasRequiredIs$3 = 1;

    	var isValue = requireIs$4();

    	// prettier-ignore
    	var possibleTypes = { "object": true, "function": true, "undefined": true /* document.all */ };

    	is$3 = function (value) {
    		if (!isValue(value)) return false;
    		return hasOwnProperty.call(possibleTypes, typeof value);
    	};
    	return is$3;
    }

    var is$2;
    var hasRequiredIs$2;

    function requireIs$2 () {
    	if (hasRequiredIs$2) return is$2;
    	hasRequiredIs$2 = 1;

    	var isObject = requireIs$3();

    	is$2 = function (value) {
    		if (!isObject(value)) return false;
    		try {
    			if (!value.constructor) return false;
    			return value.constructor.prototype === value;
    		} catch (error) {
    			return false;
    		}
    	};
    	return is$2;
    }

    var is$1;
    var hasRequiredIs$1;

    function requireIs$1 () {
    	if (hasRequiredIs$1) return is$1;
    	hasRequiredIs$1 = 1;

    	var isPrototype = requireIs$2();

    	is$1 = function (value) {
    		if (typeof value !== "function") return false;

    		if (!hasOwnProperty.call(value, "length")) return false;

    		try {
    			if (typeof value.length !== "number") return false;
    			if (typeof value.call !== "function") return false;
    			if (typeof value.apply !== "function") return false;
    		} catch (error) {
    			return false;
    		}

    		return !isPrototype(value);
    	};
    	return is$1;
    }

    var is;
    var hasRequiredIs;

    function requireIs () {
    	if (hasRequiredIs) return is;
    	hasRequiredIs = 1;

    	var isFunction = requireIs$1();

    	var classRe = /^\s*class[\s{/}]/, functionToString = Function.prototype.toString;

    	is = function (value) {
    		if (!isFunction(value)) return false;
    		if (classRe.test(functionToString.call(value))) return false;
    		return true;
    	};
    	return is;
    }

    var isImplemented$7;
    var hasRequiredIsImplemented$7;

    function requireIsImplemented$7 () {
    	if (hasRequiredIsImplemented$7) return isImplemented$7;
    	hasRequiredIsImplemented$7 = 1;

    	isImplemented$7 = function () {
    		var assign = Object.assign, obj;
    		if (typeof assign !== "function") return false;
    		obj = { foo: "raz" };
    		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
    		return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
    	};
    	return isImplemented$7;
    }

    var isImplemented$6;
    var hasRequiredIsImplemented$6;

    function requireIsImplemented$6 () {
    	if (hasRequiredIsImplemented$6) return isImplemented$6;
    	hasRequiredIsImplemented$6 = 1;

    	isImplemented$6 = function () {
    		try {
    			Object.keys("primitive");
    			return true;
    		} catch (e) {
    			return false;
    		}
    	};
    	return isImplemented$6;
    }

    var noop;
    var hasRequiredNoop;

    function requireNoop () {
    	if (hasRequiredNoop) return noop;
    	hasRequiredNoop = 1;

    	// eslint-disable-next-line no-empty-function
    	noop = function () {};
    	return noop;
    }

    var isValue;
    var hasRequiredIsValue;

    function requireIsValue () {
    	if (hasRequiredIsValue) return isValue;
    	hasRequiredIsValue = 1;

    	var _undefined = requireNoop()(); // Support ES3 engines

    	isValue = function (val) { return val !== _undefined && val !== null; };
    	return isValue;
    }

    var shim$5;
    var hasRequiredShim$5;

    function requireShim$5 () {
    	if (hasRequiredShim$5) return shim$5;
    	hasRequiredShim$5 = 1;

    	var isValue = requireIsValue();

    	var keys = Object.keys;

    	shim$5 = function (object) { return keys(isValue(object) ? Object(object) : object); };
    	return shim$5;
    }

    var keys;
    var hasRequiredKeys;

    function requireKeys () {
    	if (hasRequiredKeys) return keys;
    	hasRequiredKeys = 1;

    	keys = requireIsImplemented$6()() ? Object.keys : requireShim$5();
    	return keys;
    }

    var validValue;
    var hasRequiredValidValue;

    function requireValidValue () {
    	if (hasRequiredValidValue) return validValue;
    	hasRequiredValidValue = 1;

    	var isValue = requireIsValue();

    	validValue = function (value) {
    		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
    		return value;
    	};
    	return validValue;
    }

    var shim$4;
    var hasRequiredShim$4;

    function requireShim$4 () {
    	if (hasRequiredShim$4) return shim$4;
    	hasRequiredShim$4 = 1;

    	var keys  = requireKeys()
    	  , value = requireValidValue()
    	  , max   = Math.max;

    	shim$4 = function (dest, src /*, srcn*/) {
    		var error, i, length = max(arguments.length, 2), assign;
    		dest = Object(value(dest));
    		assign = function (key) {
    			try {
    				dest[key] = src[key];
    			} catch (e) {
    				if (!error) error = e;
    			}
    		};
    		for (i = 1; i < length; ++i) {
    			src = arguments[i];
    			keys(src).forEach(assign);
    		}
    		if (error !== undefined) throw error;
    		return dest;
    	};
    	return shim$4;
    }

    var assign;
    var hasRequiredAssign;

    function requireAssign () {
    	if (hasRequiredAssign) return assign;
    	hasRequiredAssign = 1;

    	assign = requireIsImplemented$7()() ? Object.assign : requireShim$4();
    	return assign;
    }

    var normalizeOptions;
    var hasRequiredNormalizeOptions;

    function requireNormalizeOptions () {
    	if (hasRequiredNormalizeOptions) return normalizeOptions;
    	hasRequiredNormalizeOptions = 1;

    	var isValue = requireIsValue();

    	var forEach = Array.prototype.forEach, create = Object.create;

    	var process = function (src, obj) {
    		var key;
    		for (key in src) obj[key] = src[key];
    	};

    	// eslint-disable-next-line no-unused-vars
    	normalizeOptions = function (opts1 /*, options*/) {
    		var result = create(null);
    		forEach.call(arguments, function (options) {
    			if (!isValue(options)) return;
    			process(Object(options), result);
    		});
    		return result;
    	};
    	return normalizeOptions;
    }

    var isImplemented$5;
    var hasRequiredIsImplemented$5;

    function requireIsImplemented$5 () {
    	if (hasRequiredIsImplemented$5) return isImplemented$5;
    	hasRequiredIsImplemented$5 = 1;

    	var str = "razdwatrzy";

    	isImplemented$5 = function () {
    		if (typeof str.contains !== "function") return false;
    		return str.contains("dwa") === true && str.contains("foo") === false;
    	};
    	return isImplemented$5;
    }

    var shim$3;
    var hasRequiredShim$3;

    function requireShim$3 () {
    	if (hasRequiredShim$3) return shim$3;
    	hasRequiredShim$3 = 1;

    	var indexOf = String.prototype.indexOf;

    	shim$3 = function (searchString /*, position*/) {
    		return indexOf.call(this, searchString, arguments[1]) > -1;
    	};
    	return shim$3;
    }

    var contains;
    var hasRequiredContains;

    function requireContains () {
    	if (hasRequiredContains) return contains;
    	hasRequiredContains = 1;

    	contains = requireIsImplemented$5()() ? String.prototype.contains : requireShim$3();
    	return contains;
    }

    var hasRequiredD;

    function requireD () {
    	if (hasRequiredD) return d.exports;
    	hasRequiredD = 1;

    	var isValue         = requireIs$4()
    	  , isPlainFunction = requireIs()
    	  , assign          = requireAssign()
    	  , normalizeOpts   = requireNormalizeOptions()
    	  , contains        = requireContains();

    	var d$1 = (d.exports = function (dscr, value/*, options*/) {
    		var c, e, w, options, desc;
    		if (arguments.length < 2 || typeof dscr !== "string") {
    			options = value;
    			value = dscr;
    			dscr = null;
    		} else {
    			options = arguments[2];
    		}
    		if (isValue(dscr)) {
    			c = contains.call(dscr, "c");
    			e = contains.call(dscr, "e");
    			w = contains.call(dscr, "w");
    		} else {
    			c = w = true;
    			e = false;
    		}

    		desc = { value: value, configurable: c, enumerable: e, writable: w };
    		return !options ? desc : assign(normalizeOpts(options), desc);
    	});

    	d$1.gs = function (dscr, get, set/*, options*/) {
    		var c, e, options, desc;
    		if (typeof dscr !== "string") {
    			options = set;
    			set = get;
    			get = dscr;
    			dscr = null;
    		} else {
    			options = arguments[3];
    		}
    		if (!isValue(get)) {
    			get = undefined;
    		} else if (!isPlainFunction(get)) {
    			options = get;
    			get = set = undefined;
    		} else if (!isValue(set)) {
    			set = undefined;
    		} else if (!isPlainFunction(set)) {
    			options = set;
    			set = undefined;
    		}
    		if (isValue(dscr)) {
    			c = contains.call(dscr, "c");
    			e = contains.call(dscr, "e");
    		} else {
    			c = true;
    			e = false;
    		}

    		desc = { get: get, set: set, configurable: c, enumerable: e };
    		return !options ? desc : assign(normalizeOpts(options), desc);
    	};
    	return d.exports;
    }

    var validCallable;
    var hasRequiredValidCallable;

    function requireValidCallable () {
    	if (hasRequiredValidCallable) return validCallable;
    	hasRequiredValidCallable = 1;

    	validCallable = function (fn) {
    		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
    		return fn;
    	};
    	return validCallable;
    }

    var hasRequiredEventEmitter;

    function requireEventEmitter () {
    	if (hasRequiredEventEmitter) return eventEmitter.exports;
    	hasRequiredEventEmitter = 1;
    	(function (module, exports) {

    		var d        = requireD()
    		  , callable = requireValidCallable()

    		  , apply = Function.prototype.apply, call = Function.prototype.call
    		  , create = Object.create, defineProperty = Object.defineProperty
    		  , defineProperties = Object.defineProperties
    		  , hasOwnProperty = Object.prototype.hasOwnProperty
    		  , descriptor = { configurable: true, enumerable: false, writable: true }

    		  , on, once, off, emit, methods, descriptors, base;

    		on = function (type, listener) {
    			var data;

    			callable(listener);

    			if (!hasOwnProperty.call(this, '__ee__')) {
    				data = descriptor.value = create(null);
    				defineProperty(this, '__ee__', descriptor);
    				descriptor.value = null;
    			} else {
    				data = this.__ee__;
    			}
    			if (!data[type]) data[type] = listener;
    			else if (typeof data[type] === 'object') data[type].push(listener);
    			else data[type] = [data[type], listener];

    			return this;
    		};

    		once = function (type, listener) {
    			var once, self;

    			callable(listener);
    			self = this;
    			on.call(this, type, once = function () {
    				off.call(self, type, once);
    				apply.call(listener, this, arguments);
    			});

    			once.__eeOnceListener__ = listener;
    			return this;
    		};

    		off = function (type, listener) {
    			var data, listeners, candidate, i;

    			callable(listener);

    			if (!hasOwnProperty.call(this, '__ee__')) return this;
    			data = this.__ee__;
    			if (!data[type]) return this;
    			listeners = data[type];

    			if (typeof listeners === 'object') {
    				for (i = 0; (candidate = listeners[i]); ++i) {
    					if ((candidate === listener) ||
    							(candidate.__eeOnceListener__ === listener)) {
    						if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
    						else listeners.splice(i, 1);
    					}
    				}
    			} else {
    				if ((listeners === listener) ||
    						(listeners.__eeOnceListener__ === listener)) {
    					delete data[type];
    				}
    			}

    			return this;
    		};

    		emit = function (type) {
    			var i, l, listener, listeners, args;

    			if (!hasOwnProperty.call(this, '__ee__')) return;
    			listeners = this.__ee__[type];
    			if (!listeners) return;

    			if (typeof listeners === 'object') {
    				l = arguments.length;
    				args = new Array(l - 1);
    				for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

    				listeners = listeners.slice();
    				for (i = 0; (listener = listeners[i]); ++i) {
    					apply.call(listener, this, args);
    				}
    			} else {
    				switch (arguments.length) {
    				case 1:
    					call.call(listeners, this);
    					break;
    				case 2:
    					call.call(listeners, this, arguments[1]);
    					break;
    				case 3:
    					call.call(listeners, this, arguments[1], arguments[2]);
    					break;
    				default:
    					l = arguments.length;
    					args = new Array(l - 1);
    					for (i = 1; i < l; ++i) {
    						args[i - 1] = arguments[i];
    					}
    					apply.call(listeners, this, args);
    				}
    			}
    		};

    		methods = {
    			on: on,
    			once: once,
    			off: off,
    			emit: emit
    		};

    		descriptors = {
    			on: d(on),
    			once: d(once),
    			off: d(off),
    			emit: d(emit)
    		};

    		base = defineProperties({}, descriptors);

    		module.exports = exports = function (o) {
    			return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
    		};
    		exports.methods = methods; 
    	} (eventEmitter, eventEmitter.exports));
    	return eventEmitter.exports;
    }

    var eventEmitterExports = requireEventEmitter();
    var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventEmitterExports);

    /**
     * Hooks allow for injecting functions that must all complete in order before finishing
     * They will execute in parallel but all must finish before continuing
     * Functions may return a promise if they are asycn.
     * From epubjs/src/utils/hooks
     * @param {any} context scope of this
     * @example this.content = new Hook(this);
     */
    class Hook {
    	constructor(context){
    		this.context = context || this;
    		this.hooks = [];
    	}

    	/**
    	 * Adds a function to be run before a hook completes
    	 * @example this.content.register(function(){...});
    	 * @return {undefined} void
    	 */
    	register(){
    		for(var i = 0; i < arguments.length; ++i) {
    			if (typeof arguments[i]  === "function") {
    				this.hooks.push(arguments[i]);
    			} else {
    				// unpack array
    				for(var j = 0; j < arguments[i].length; ++j) {
    					this.hooks.push(arguments[i][j]);
    				}
    			}
    		}
    	}

    	/**
    	 * Triggers a hook to run all functions
    	 * @example this.content.trigger(args).then(function(){...});
    	 * @return {Promise} results
    	 */
    	trigger(){
    		var args = arguments;
    		var context = this.context;
    		var promises = [];

    		this.hooks.forEach(function(task) {
    			var executing = task.apply(context, args);

    			if(executing && typeof executing["then"] === "function") {
    				// Task is a function that returns a promise
    				promises.push(executing);
    			} else {
    				// Otherwise Task resolves immediately, add resolved promise with result
    				promises.push(new Promise((resolve, reject) => {
    					resolve(executing);
    				}));
    			}
    		});


    		return Promise.all(promises);
    	}

    	/**
       * Triggers a hook to run all functions synchronously
       * @example this.content.trigger(args).then(function(){...});
       * @return {Array} results
       */
    	triggerSync(){
    		var args = arguments;
    		var context = this.context;
    		var results = [];

    		this.hooks.forEach(function(task) {
    			var executing = task.apply(context, args);

    			results.push(executing);
    		});


    		return results;
    	}

    	// Adds a function to be run before a hook completes
    	list(){
    		return this.hooks;
    	}

    	clear(){
    		return this.hooks = [];
    	}
    }

    const MAX_CHARS_PER_BREAK = 1500;

    /**
     * Layout
     * @class
     */
    class Layout {

    	constructor(element, hooks, options) {
    		this.element = element;

    		this.bounds = this.element.getBoundingClientRect();
    		this.parentBounds = this.element.offsetParent.getBoundingClientRect();
    		let gap = parseFloat(window.getComputedStyle(this.element).columnGap);
    	
    		if (gap) {
    			let leftMargin = this.bounds.left - this.parentBounds.left;
    			this.gap =  gap - leftMargin;	
    		} else {
    			this.gap = 0;
    		}

    		if (hooks) {
    			this.hooks = hooks;
    		} else {
    			this.hooks = {};
    			this.hooks.onPageLayout = new Hook();
    			this.hooks.layout = new Hook();
    			this.hooks.renderNode = new Hook();
    			this.hooks.layoutNode = new Hook();
    			this.hooks.beforeOverflow = new Hook();
    			this.hooks.onOverflow = new Hook();
    			this.hooks.afterOverflowRemoved = new Hook();
    			this.hooks.onBreakToken = new Hook();
    			this.hooks.beforeRenderResult = new Hook();
    		}

    		this.settings = options || {};

    		this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
    		this.forceRenderBreak = false;
    	}

    	async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
    		let start = this.getStart(source, breakToken);
    		let walker = walk$1(start, source);

    		let node;
    		let prevNode;
    		let done;
    		let next;

    		let hasRenderedContent = false;
    		let newBreakToken;

    		let length = 0;

    		let prevBreakToken = breakToken || new BreakToken(start);

    		this.hooks && this.hooks.onPageLayout.trigger(wrapper, prevBreakToken, this);

    		while (!done && !newBreakToken) {
    			next = walker.next();
    			prevNode = node;
    			node = next.value;
    			done = next.done;

    			if (!node) {
    				this.hooks && this.hooks.layout.trigger(wrapper, this);

    				let imgs = wrapper.querySelectorAll("img");
    				if (imgs.length) {
    					await this.waitForImages(imgs);
    				}

    				newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

    				if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
    					console.warn("Unable to layout item: ", prevNode);
    					this.hooks && this.hooks.beforeRenderResult.trigger(undefined, wrapper, this);
    					return new RenderResult(undefined, new OverflowContentError("Unable to layout item", [prevNode]));
    				}

    				this.rebuildTableFromBreakToken(newBreakToken, wrapper);

    				this.hooks && this.hooks.beforeRenderResult.trigger(newBreakToken, wrapper, this);
    				return new RenderResult(newBreakToken);
    			}

    			this.hooks && this.hooks.layoutNode.trigger(node);

    			// Check if the rendered element has a break set
    			if (hasRenderedContent && this.shouldBreak(node, start)) {
    				this.hooks && this.hooks.layout.trigger(wrapper, this);

    				let imgs = wrapper.querySelectorAll("img");
    				if (imgs.length) {
    					await this.waitForImages(imgs);
    				}

    				newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

    				if (!newBreakToken) {
    					newBreakToken = this.breakAt(node);
    				} else {
    					this.rebuildTableFromBreakToken(newBreakToken, wrapper);
    				}

    				if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
    					console.warn("Unable to layout item: ", node);
    					let after = newBreakToken.node && nodeAfter(newBreakToken.node);
    					if (after) {
    						newBreakToken = new BreakToken(after);
    					} else {
    						return new RenderResult(undefined, new OverflowContentError("Unable to layout item", [node]));
    					}
    				}

    				length = 0;

    				break;
    			}

    			if (node.dataset && node.dataset.page) {
    				let named = node.dataset.page;
    				let page = this.element.closest(".pagedjs_page");
    				page.classList.add("pagedjs_named_page");
    				page.classList.add("pagedjs_" + named + "_page");

    				if (!node.dataset.splitFrom) {
    					page.classList.add("pagedjs_" + named + "_first_page");
    				}
    			}

    			// Should the Node be a shallow or deep clone
    			let shallow = isContainer(node);

    			let rendered = this.append(node, wrapper, breakToken, shallow);

    			length += rendered.textContent.length;

    			// Check if layout has content yet
    			if (!hasRenderedContent) {
    				hasRenderedContent = hasContent(node);
    			}

    			// Skip to the next node if a deep clone was rendered
    			if (!shallow) {
    				walker = walk$1(nodeAfter(node, source), source);
    			}

    			if (this.forceRenderBreak) {
    				this.hooks && this.hooks.layout.trigger(wrapper, this);

    				newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

    				if (!newBreakToken) {
    					newBreakToken = this.breakAt(node);
    				} else {
    					this.rebuildTableFromBreakToken(newBreakToken, wrapper);
    				}

    				length = 0;
    				this.forceRenderBreak = false;

    				break;
    			}

    			// Only check x characters
    			if (length >= this.maxChars) {

    				this.hooks && this.hooks.layout.trigger(wrapper, this);

    				let imgs = wrapper.querySelectorAll("img");
    				if (imgs.length) {
    					await this.waitForImages(imgs);
    				}

    				newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

    				if (newBreakToken) {
    					length = 0;
    					this.rebuildTableFromBreakToken(newBreakToken, wrapper);
    				}

    				if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
    					console.warn("Unable to layout item: ", node);
    					let after = newBreakToken.node && nodeAfter(newBreakToken.node);
    					if (after) {
    						newBreakToken = new BreakToken(after);
    					} else {
    						this.hooks && this.hooks.beforeRenderResult.trigger(undefined, wrapper, this);
    						return new RenderResult(undefined, new OverflowContentError("Unable to layout item", [node]));
    					}
    				}
    			}

    		}

    		this.hooks && this.hooks.beforeRenderResult.trigger(newBreakToken, wrapper, this);
    		return new RenderResult(newBreakToken);
    	}

    	breakAt(node, offset = 0) {
    		let newBreakToken = new BreakToken(
    			node,
    			offset
    		);
    		let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
    		breakHooks.forEach((newToken) => {
    			if (typeof newToken != "undefined") {
    				newBreakToken = newToken;
    			}
    		});

    		return newBreakToken;
    	}

    	shouldBreak(node, limiter) {
    		let previousNode = nodeBefore(node, limiter);
    		let parentNode = node.parentNode;
    		let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousNode && needsBreakBefore(parentNode);
    		let doubleBreakBefore;

    		if (parentBreakBefore) {
    			doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
    		}

    		return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousNode);
    	}

    	forceBreak() {
    		this.forceRenderBreak = true;
    	}

    	getStart(source, breakToken) {
    		let start;
    		let node = breakToken && breakToken.node;

    		if (node) {
    			start = node;
    		} else {
    			start = source.firstChild;
    		}

    		return start;
    	}

    	append(node, dest, breakToken, shallow = true, rebuild = true) {

    		let clone = cloneNode(node, !shallow);

    		if (node.parentNode && isElement(node.parentNode)) {
    			let parent = findElement(node.parentNode, dest);
    			// Rebuild chain
    			if (parent) {
    				parent.appendChild(clone);
    			} else if (rebuild) {
    				let fragment = rebuildAncestors(node);
    				parent = findElement(node.parentNode, fragment);
    				if (!parent) {
    					dest.appendChild(clone);
    				} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
    					clone.textContent = clone.textContent.substring(breakToken.offset);
    					parent.appendChild(clone);
    				} else {
    					parent.appendChild(clone);
    				}

    				dest.appendChild(fragment);
    			} else {
    				dest.appendChild(clone);
    			}


    		} else {
    			dest.appendChild(clone);
    		}

    		if (clone.dataset && clone.dataset.ref) {
    			if (!dest.indexOfRefs) {
    				dest.indexOfRefs = {};
    			}
    			dest.indexOfRefs[clone.dataset.ref] = clone;
    		}

    		let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
    		nodeHooks.forEach((newNode) => {
    			if (typeof newNode != "undefined") {
    				clone = newNode;
    			}
    		});

    		return clone;
    	}

    	rebuildTableFromBreakToken(breakToken, dest) {
    		if (!breakToken || !breakToken.node) {
    			return;
    		}
    		let node = breakToken.node;
    		let td = isElement(node) ? node.closest("td") : node.parentElement.closest("td");
    		if (td) {
    			let rendered = findElement(td, dest, true);
    			if (!rendered) {
    				return;
    			}
    			while ((td = td.nextElementSibling)) {
    				this.append(td, dest, null, true);
    			}
    		}
    	}

    	async waitForImages(imgs) {
    		let results = Array.from(imgs).map(async (img) => {
    			return this.awaitImageLoaded(img);
    		});
    		await Promise.all(results);
    	}

    	async awaitImageLoaded(image) {
    		return new Promise(resolve => {
    			if (image.complete !== true) {
    				image.onload = function () {
    					let {width, height} = window.getComputedStyle(image);
    					resolve(width, height);
    				};
    				image.onerror = function (e) {
    					let {width, height} = window.getComputedStyle(image);
    					resolve(width, height, e);
    				};
    			} else {
    				let {width, height} = window.getComputedStyle(image);
    				resolve(width, height);
    			}
    		});
    	}

    	avoidBreakInside(node, limiter) {
    		let breakNode;

    		if (node === limiter) {
    			return;
    		}

    		while (node.parentNode) {
    			node = node.parentNode;

    			if (node === limiter) {
    				break;
    			}

    			if (window.getComputedStyle(node)["break-inside"] === "avoid") {
    				breakNode = node;
    				break;
    			}

    		}
    		return breakNode;
    	}

    	createBreakToken(overflow, rendered, source) {
    		let container = overflow.startContainer;
    		let offset = overflow.startOffset;
    		let node, renderedNode, parent, index, temp;

    		if (isElement(container)) {
    			temp = child(container, offset);

    			if (isElement(temp)) {
    				renderedNode = findElement(temp, rendered);

    				if (!renderedNode) {
    					// Find closest element with data-ref
    					let prevNode = prevValidNode(temp);
    					if (!isElement(prevNode)) {
    						prevNode = prevNode.parentElement;
    					}
    					renderedNode = findElement(prevNode, rendered);
    					// Check if temp is the last rendered node at its level.
    					if (!temp.nextSibling) {
    						// We need to ensure that the previous sibling of temp is fully rendered.
    						const renderedNodeFromSource = findElement(renderedNode, source);
    						const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
    						const lastChildOfRenderedNodeFromSource = walker.lastChild();
    						const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
    						// Check if we found that the last child in source
    						if (!lastChildOfRenderedNodeMatchingFromRendered) {
    							// Pending content to be rendered before virtual break token
    							return;
    						}
    						// Otherwise we will return a break token as per below
    					}
    					// renderedNode is actually the last unbroken box that does not overflow.
    					// Break Token is therefore the next sibling of renderedNode within source node.
    					node = findElement(renderedNode, source).nextSibling;
    					offset = 0;
    				} else {
    					node = findElement(renderedNode, source);
    					offset = 0;
    				}
    			} else {
    				renderedNode = findElement(container, rendered);

    				if (!renderedNode) {
    					renderedNode = findElement(prevValidNode(container), rendered);
    				}

    				parent = findElement(renderedNode, source);
    				index = indexOfTextNode(temp, parent);
    				// No seperatation for the first textNode of an element
    				if(index === 0) {
    					node = parent;
    					offset = 0;
    				} else {
    					node = child(parent, index);
    					offset = 0;
    				}
    			}
    		} else {
    			renderedNode = findElement(container.parentNode, rendered);

    			if (!renderedNode) {
    				renderedNode = findElement(prevValidNode(container.parentNode), rendered);
    			}

    			parent = findElement(renderedNode, source);
    			index = indexOfTextNode(container, parent);

    			if (index === -1) {
    				return;
    			}

    			node = child(parent, index);

    			offset += node.textContent.indexOf(container.textContent);
    		}

    		if (!node) {
    			return;
    		}

    		return new BreakToken(
    			node,
    			offset
    		);

    	}

    	findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
    		let overflow = this.findOverflow(rendered, bounds);
    		let breakToken, breakLetter;

    		let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
    		overflowHooks.forEach((newOverflow) => {
    			if (typeof newOverflow != "undefined") {
    				overflow = newOverflow;
    			}
    		});

    		if (overflow) {
    			breakToken = this.createBreakToken(overflow, rendered, source);
    			// breakToken is nullable
    			let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
    			breakHooks.forEach((newToken) => {
    				if (typeof newToken != "undefined") {
    					breakToken = newToken;
    				}
    			});

    			// Stop removal if we are in a loop
    			if (breakToken && breakToken.equals(prevBreakToken)) {
    				return breakToken;
    			}

    			if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
    				breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
    			} else {
    				breakLetter = undefined;
    			}

    			if (breakToken && breakToken.node && extract) {
    				let removed = this.removeOverflow(overflow, breakLetter);
    				this.hooks && this.hooks.afterOverflowRemoved.trigger(removed, rendered, this);
    			}

    		}
    		return breakToken;
    	}

    	hasOverflow(element, bounds = this.bounds) {
    		let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
    		let {width, height} = element.getBoundingClientRect();
    		let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
    		let scrollHeight = constrainingElement ? constrainingElement.scrollHeight : 0;
    		return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width) ||
    			Math.max(Math.floor(height), scrollHeight) > Math.round(bounds.height);
    	}

    	findOverflow(rendered, bounds = this.bounds, gap = this.gap) {
    		if (!this.hasOverflow(rendered, bounds)) return;

    		let start = Math.floor(bounds.left);
    		let end = Math.round(bounds.right + gap);
    		let vStart = Math.round(bounds.top);
    		let vEnd = Math.round(bounds.bottom);
    		let range;

    		let walker = walk$1(rendered.firstChild, rendered);

    		// Find Start
    		let next, done, node, offset, skip, breakAvoid, prev, br;
    		while (!done) {
    			next = walker.next();
    			done = next.done;
    			node = next.value;
    			skip = false;
    			breakAvoid = false;
    			prev = undefined;
    			br = undefined;

    			if (node) {
    				let pos = getBoundingClientRect(node);
    				let left = Math.round(pos.left);
    				let right = Math.floor(pos.right);
    				let top = Math.round(pos.top);
    				let bottom = Math.floor(pos.bottom);

    				if (!range && (left >= end || top >= vEnd)) {
    					// Check if it is a float
    					let isFloat = false;

    					// Check if the node is inside a break-inside: avoid table cell
    					const insideTableCell = parentOf(node, "TD", rendered);
    					if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
    						// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
    						// But we take the whole row, not just the cell that is causing the break.
    						prev = insideTableCell.parentElement;
    					} else if (isElement(node)) {
    						let styles = window.getComputedStyle(node);
    						isFloat = styles.getPropertyValue("float") !== "none";
    						skip = styles.getPropertyValue("break-inside") === "avoid";
    						breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
    						prev = breakAvoid && nodeBefore(node, rendered);
    						br = node.tagName === "BR" || node.tagName === "WBR";
    					}

    					let tableRow;
    					if (node.nodeName === "TR") {
    						tableRow = node;
    					} else {
    						tableRow = parentOf(node, "TR", rendered);
    					}
    					if (tableRow) {
    						// honor break-inside="avoid" in parent tbody/thead
    						let container = tableRow.parentElement;
    						if (["TBODY", "THEAD"].includes(container.nodeName)) {
    							let styles = window.getComputedStyle(container);
    							if (styles.getPropertyValue("break-inside") === "avoid") prev = container;
    						}

    						// Check if the node is inside a row with a rowspan
    						const table = parentOf(tableRow, "TABLE", rendered);
    						const rowspan = table.querySelector("[colspan]");
    						if (table && rowspan) {
    							let columnCount = 0;
    							for (const cell of Array.from(table.rows[0].cells)) {
    								columnCount += parseInt(cell.getAttribute("colspan") || "1");
    							}
    							if (tableRow.cells.length !== columnCount) {
    								let previousRow = tableRow.previousElementSibling;
    								let previousRowColumnCount;
    								while (previousRow !== null) {
    									previousRowColumnCount = 0;
    									for (const cell of Array.from(previousRow.cells)) {
    										previousRowColumnCount += parseInt(cell.getAttribute("colspan") || "1");
    									}
    									if (previousRowColumnCount === columnCount) {
    										break;
    									}
    									previousRow = previousRow.previousElementSibling;
    								}
    								if (previousRowColumnCount === columnCount) {
    									prev = previousRow;
    								}
    							}
    						}
    					}

    					if (prev) {
    						range = document.createRange();
    						range.selectNode(prev);
    						break;
    					}

    					if (!br && !isFloat && isElement(node)) {
    						range = document.createRange();
    						range.selectNode(node);
    						break;
    					}

    					if (isText(node) && node.textContent.trim().length) {
    						range = document.createRange();
    						range.selectNode(node);
    						break;
    					}

    				}

    				if (!range && isText(node) &&
    					node.textContent.trim().length &&
    					!breakInsideAvoidParentNode(node.parentNode)) {

    					let rects = getClientRects(node);
    					let rect;
    					left = 0;
    					top = 0;
    					for (var i = 0; i != rects.length; i++) {
    						rect = rects[i];
    						if (rect.width > 0 && (!left || rect.left > left)) {
    							left = rect.left;
    						}
    						if (rect.height > 0 && (!top || rect.top > top)) {
    							top = rect.top;
    						}
    					}

    					if (left >= end || top >= vEnd) {
    						range = document.createRange();
    						offset = this.textBreak(node, start, end, vStart, vEnd);
    						if (!offset) {
    							range = undefined;
    						} else {
    							range.setStart(node, offset);
    						}
    						break;
    					}
    				}

    				// Skip children
    				if (skip || (right <= end && bottom <= vEnd)) {
    					next = nodeAfter(node, rendered);
    					if (next) {
    						walker = walk$1(next, rendered);
    					}

    				}

    			}
    		}

    		// Find End
    		if (range) {
    			range.setEndAfter(rendered.lastChild);
    			return range;
    		}

    	}

    	findEndToken(rendered, source) {
    		if (rendered.childNodes.length === 0) {
    			return;
    		}

    		let lastChild = rendered.lastChild;

    		let lastNodeIndex;
    		while (lastChild && lastChild.lastChild) {
    			if (!validNode(lastChild)) {
    				// Only get elements with refs
    				lastChild = lastChild.previousSibling;
    			} else if (!validNode(lastChild.lastChild)) {
    				// Deal with invalid dom items
    				lastChild = prevValidNode(lastChild.lastChild);
    				break;
    			} else {
    				lastChild = lastChild.lastChild;
    			}
    		}

    		if (isText(lastChild)) {

    			if (lastChild.parentNode.dataset.ref) {
    				lastNodeIndex = indexOf(lastChild);
    				lastChild = lastChild.parentNode;
    			} else {
    				lastChild = lastChild.previousSibling;
    			}
    		}

    		let original = findElement(lastChild, source);

    		if (lastNodeIndex) {
    			original = original.childNodes[lastNodeIndex];
    		}

    		let after = nodeAfter(original);

    		return this.breakAt(after);
    	}

    	textBreak(node, start, end, vStart, vEnd) {
    		let wordwalker = words(node);
    		let left = 0;
    		let right = 0;
    		let top = 0;
    		let bottom = 0;
    		let word, next, done, pos;
    		let offset;
    		while (!done) {
    			next = wordwalker.next();
    			word = next.value;
    			done = next.done;

    			if (!word) {
    				break;
    			}

    			pos = getBoundingClientRect(word);

    			left = Math.floor(pos.left);
    			right = Math.floor(pos.right);
    			top = Math.floor(pos.top);
    			bottom = Math.floor(pos.bottom);

    			if (left >= end || top >= vEnd) {
    				offset = word.startOffset;
    				break;
    			}

    			if (right > end || bottom > vEnd) {
    				let letterwalker = letters$1(word);
    				let letter, nextLetter, doneLetter;

    				while (!doneLetter) {
    					nextLetter = letterwalker.next();
    					letter = nextLetter.value;
    					doneLetter = nextLetter.done;

    					if (!letter) {
    						break;
    					}

    					pos = getBoundingClientRect(letter);
    					left = Math.floor(pos.left);
    					top = Math.floor(pos.top);

    					if (left >= end || top >= vEnd) {
    						offset = letter.startOffset;
    						done = true;

    						break;
    					}
    				}
    			}

    		}

    		return offset;
    	}

    	removeOverflow(overflow, breakLetter) {
    		let {startContainer} = overflow;
    		let extracted = overflow.extractContents();

    		this.hyphenateAtBreak(startContainer, breakLetter);

    		return extracted;
    	}

    	hyphenateAtBreak(startContainer, breakLetter) {
    		if (isText(startContainer)) {
    			let startText = startContainer.textContent;
    			let prevLetter = startText[startText.length - 1];

    			// Add a hyphen if previous character is a letter or soft hyphen
    			if (
    				(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
    				(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
    			) {
    				startContainer.parentNode.classList.add("pagedjs_hyphen");
    				startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
    			}
    		}
    	}

    	equalTokens(a, b) {
    		if (!a || !b) {
    			return false;
    		}
    		if (a["node"] && b["node"] && a["node"] !== b["node"]) {
    			return false;
    		}
    		if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
    			return false;
    		}
    		return true;
    	}
    }

    EventEmitter(Layout.prototype);

    /**
     * Render a page
     * @class
     */
    class Page {
    	constructor(pagesArea, pageTemplate, blank, hooks, options) {
    		this.pagesArea = pagesArea;
    		this.pageTemplate = pageTemplate;
    		this.blank = blank;

    		this.width = undefined;
    		this.height = undefined;

    		this.hooks = hooks;

    		this.settings = options || {};

    		// this.element = this.create(this.pageTemplate);
    	}

    	create(template, after) {
    		//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
    		//let page = documentFragment.children[0];
    		let clone = document.importNode(this.pageTemplate.content, true);

    		let page, index;
    		if (after) {
    			this.pagesArea.insertBefore(clone, after.nextElementSibling);
    			index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
    			page = this.pagesArea.children[index];
    		} else {
    			this.pagesArea.appendChild(clone);
    			page = this.pagesArea.lastChild;
    		}

    		let pagebox = page.querySelector(".pagedjs_pagebox");
    		let area = page.querySelector(".pagedjs_page_content");
    		let footnotesArea = page.querySelector(".pagedjs_footnote_area");


    		let size = area.getBoundingClientRect();


    		area.style.columnWidth = Math.round(size.width) + "px";
    		area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left) + var(--pagedjs-bleed-right) + var(--pagedjs-bleed-left) + var(--pagedjs-column-gap-offset))";
    		// area.style.overflow = "scroll";

    		this.width = Math.round(size.width);
    		this.height = Math.round(size.height);

    		this.element = page;
    		this.pagebox = pagebox;
    		this.area = area;
    		this.footnotesArea = footnotesArea;

    		return page;
    	}

    	createWrapper() {
    		let wrapper = document.createElement("div");

    		this.area.appendChild(wrapper);

    		this.wrapper = wrapper;

    		return wrapper;
    	}

    	index(pgnum) {
    		this.position = pgnum;

    		let page = this.element;
    		// let pagebox = this.pagebox;

    		let index = pgnum + 1;

    		let id = `page-${index}`;

    		this.id = id;

    		// page.dataset.pageNumber = index;

    		page.dataset.pageNumber = index;
    		page.setAttribute("id", id);

    		if (this.name) {
    			page.classList.add("pagedjs_" + this.name + "_page");
    		}

    		if (this.blank) {
    			page.classList.add("pagedjs_blank_page");
    		}

    		if (pgnum === 0) {
    			page.classList.add("pagedjs_first_page");
    		}

    		if (pgnum % 2 !== 1) {
    			page.classList.remove("pagedjs_left_page");
    			page.classList.add("pagedjs_right_page");
    		} else {
    			page.classList.remove("pagedjs_right_page");
    			page.classList.add("pagedjs_left_page");
    		}
    	}

    	/*
    	size(width, height) {
    		if (width === this.width && height === this.height) {
    			return;
    		}
    		this.width = width;
    		this.height = height;

    		this.element.style.width = Math.round(width) + "px";
    		this.element.style.height = Math.round(height) + "px";
    		this.element.style.columnWidth = Math.round(width) + "px";
    	}
    	*/

    	async layout(contents, breakToken, maxChars) {

    		this.clear();

    		this.startToken = breakToken;

    		let settings = this.settings;
    		if (!settings.maxChars && maxChars) {
    			settings.maxChars = maxChars;
    		}

    		this.layoutMethod = new Layout(this.area, this.hooks, settings);

    		let renderResult = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
    		let newBreakToken = renderResult.breakToken;

    		this.addListeners(contents);

    		this.endToken = newBreakToken;

    		return newBreakToken;
    	}

    	async append(contents, breakToken) {

    		if (!this.layoutMethod) {
    			return this.layout(contents, breakToken);
    		}

    		let renderResult = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
    		let newBreakToken = renderResult.breakToken;

    		this.endToken = newBreakToken;

    		return newBreakToken;
    	}

    	getByParent(ref, entries) {
    		let e;
    		for (var i = 0; i < entries.length; i++) {
    			e = entries[i];
    			if (e.dataset.ref === ref) {
    				return e;
    			}
    		}
    	}

    	onOverflow(func) {
    		this._onOverflow = func;
    	}

    	onUnderflow(func) {
    		this._onUnderflow = func;
    	}

    	clear() {
    		this.removeListeners();
    		this.wrapper && this.wrapper.remove();
    		this.createWrapper();
    	}

    	addListeners(contents) {
    		if (typeof ResizeObserver !== "undefined") {
    			this.addResizeObserver(contents);
    		} else {
    			this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
    			this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
    			this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
    		}
    		// TODO: fall back to mutation observer?

    		this._onScroll = function () {
    			if (this.listening) {
    				this.element.scrollLeft = 0;
    			}
    		}.bind(this);

    		// Keep scroll left from changing
    		this.element.addEventListener("scroll", this._onScroll);

    		this.listening = true;

    		return true;
    	}

    	removeListeners() {
    		this.listening = false;

    		if (typeof ResizeObserver !== "undefined" && this.ro) {
    			this.ro.disconnect();
    		} else if (this.element) {
    			this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
    			this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
    		}

    		this.element && this.element.removeEventListener("scroll", this._onScroll);

    	}

    	addResizeObserver(contents) {
    		let wrapper = this.wrapper;
    		let prevHeight = wrapper.getBoundingClientRect().height;
    		this.ro = new ResizeObserver(entries => {

    			if (!this.listening) {
    				return;
    			}
    			requestAnimationFrame(() => {
    				for (let entry of entries) {
    					const cr = entry.contentRect;

    					if (cr.height > prevHeight) {
    						this.checkOverflowAfterResize(contents);
    						prevHeight = wrapper.getBoundingClientRect().height;
    					} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
    						this.checkUnderflowAfterResize(contents);
    						prevHeight = cr.height;
    					}
    				}
    			});
    		});

    		this.ro.observe(wrapper);
    	}

    	checkOverflowAfterResize(contents) {
    		if (!this.listening || !this.layoutMethod) {
    			return;
    		}

    		let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

    		if (newBreakToken) {
    			this.endToken = newBreakToken;
    			this._onOverflow && this._onOverflow(newBreakToken);
    		}
    	}

    	checkUnderflowAfterResize(contents) {
    		if (!this.listening || !this.layoutMethod) {
    			return;
    		}

    		let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

    		if (endToken) {
    			this._onUnderflow && this._onUnderflow(endToken);
    		}
    	}


    	destroy() {
    		this.removeListeners();

    		this.element.remove();

    		this.element = undefined;
    		this.wrapper = undefined;
    	}
    }

    EventEmitter(Page.prototype);

    /**
     * Render a flow of text offscreen
     * @class
     */
    class ContentParser {

    	constructor(content, cb) {
    		if (content && content.nodeType) {
    			// handle dom
    			this.dom = this.add(content);
    		} else if (typeof content === "string") {
    			this.dom = this.parse(content);
    		}

    		return this.dom;
    	}

    	parse(markup, mime) {
    		let range = document.createRange();
    		let fragment = range.createContextualFragment(markup);

    		this.addRefs(fragment);

    		return fragment;
    	}

    	add(contents) {
    		// let fragment = document.createDocumentFragment();
    		//
    		// let children = [...contents.childNodes];
    		// for (let child of children) {
    		// 	let clone = child.cloneNode(true);
    		// 	fragment.appendChild(clone);
    		// }

    		this.addRefs(contents);

    		return contents;
    	}

    	addRefs(content) {
    		var treeWalker = document.createTreeWalker(
    			content,
    			NodeFilter.SHOW_ELEMENT,
    			null,
    			false
    		);

    		let node = treeWalker.nextNode();
    		while(node) {

    			if (!node.hasAttribute("data-ref")) {
    				let uuid = UUID();
    				node.setAttribute("data-ref", uuid);
    			}

    			if (node.id) {
    				node.setAttribute("data-id", node.id);
    			}

    			// node.setAttribute("data-children", node.childNodes.length);

    			// node.setAttribute("data-text", node.textContent.trim().length);
    			node = treeWalker.nextNode();
    		}
    	}

    	find(ref) {
    		return this.refs[ref];
    	}

    	destroy() {
    		this.refs = undefined;
    		this.dom = undefined;
    	}
    }

    /**
     * Queue for handling tasks one at a time
     * @class
     * @param {scope} context what this will resolve to in the tasks
     */
    class Queue {
    	constructor(context){
    		this._q = [];
    		this.context = context;
    		this.tick = requestAnimationFrame;
    		this.running = false;
    		this.paused = false;
    	}

    	/**
    	 * Add an item to the queue
    	 * @return {Promise} enqueued
    	 */
    	enqueue() {
    		var deferred, promise;
    		var queued;
    		var task = [].shift.call(arguments);
    		var args = arguments;

    		// Handle single args without context
    		// if(args && !Array.isArray(args)) {
    		//   args = [args];
    		// }
    		if(!task) {
    			throw new Error("No Task Provided");
    		}

    		if(typeof task === "function"){

    			deferred = new defer();
    			promise = deferred.promise;

    			queued = {
    				"task" : task,
    				"args"     : args,
    				//"context"  : context,
    				"deferred" : deferred,
    				"promise" : promise
    			};

    		} else {
    			// Task is a promise
    			queued = {
    				"promise" : task
    			};

    		}

    		this._q.push(queued);

    		// Wait to start queue flush
    		if (this.paused == false && !this.running) {
    			this.run();
    		}

    		return queued.promise;
    	}

    	/**
    	 * Run one item
    	 * @return {Promise} dequeued
    	 */
    	dequeue(){
    		var inwait, task, result;

    		if(this._q.length && !this.paused) {
    			inwait = this._q.shift();
    			task = inwait.task;
    			if(task){
    				// console.log(task)

    				result = task.apply(this.context, inwait.args);

    				if(result && typeof result["then"] === "function") {
    					// Task is a function that returns a promise
    					return result.then(function(){
    						inwait.deferred.resolve.apply(this.context, arguments);
    					}.bind(this), function() {
    						inwait.deferred.reject.apply(this.context, arguments);
    					}.bind(this));
    				} else {
    					// Task resolves immediately
    					inwait.deferred.resolve.apply(this.context, result);
    					return inwait.promise;
    				}



    			} else if(inwait.promise) {
    				// Task is a promise
    				return inwait.promise;
    			}

    		} else {
    			inwait = new defer();
    			inwait.deferred.resolve();
    			return inwait.promise;
    		}

    	}

    	// Run All Immediately
    	dump(){
    		while(this._q.length) {
    			this.dequeue();
    		}
    	}

    	/**
    	 * Run all tasks sequentially, at convince
    	 * @return {Promise} all run
    	 */
    	run(){

    		if(!this.running){
    			this.running = true;
    			this.defered = new defer();
    		}

    		this.tick.call(window, () => {

    			if(this._q.length) {

    				this.dequeue()
    					.then(function(){
    						this.run();
    					}.bind(this));

    			} else {
    				this.defered.resolve();
    				this.running = undefined;
    			}

    		});

    		// Unpause
    		if(this.paused == true) {
    			this.paused = false;
    		}

    		return this.defered.promise;
    	}

    	/**
    	 * Flush all, as quickly as possible
    	 * @return {Promise} ran
    	 */
    	flush(){

    		if(this.running){
    			return this.running;
    		}

    		if(this._q.length) {
    			this.running = this.dequeue()
    				.then(function(){
    					this.running = undefined;
    					return this.flush();
    				}.bind(this));

    			return this.running;
    		}

    	}

    	/**
    	 * Clear all items in wait
    	 * @return {void}
    	 */
    	clear(){
    		this._q = [];
    	}

    	/**
    	 * Get the number of tasks in the queue
    	 * @return {number} tasks
    	 */
    	length(){
    		return this._q.length;
    	}

    	/**
    	 * Pause a running queue
    	 * @return {void}
    	 */
    	pause(){
    		this.paused = true;
    	}

    	/**
    	 * End the queue
    	 * @return {void}
    	 */
    	stop(){
    		this._q = [];
    		this.running = false;
    		this.paused = true;
    	}
    }

    const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
				<div class="pagedjs_footnote_area">
					<div class="pagedjs_footnote_content pagedjs_footnote_empty">
						<div class="pagedjs_footnote_inner_content"></div>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>`;

    /**
     * Chop up text into flows
     * @class
     */
    class Chunker {
    	constructor(content, renderTo, options) {
    		// this.preview = preview;

    		this.settings = options || {};

    		this.hooks = {};
    		this.hooks.beforeParsed = new Hook(this);
    		this.hooks.filter = new Hook(this);
    		this.hooks.afterParsed = new Hook(this);
    		this.hooks.beforePageLayout = new Hook(this);
    		this.hooks.onPageLayout = new Hook(this);
    		this.hooks.layout = new Hook(this);
    		this.hooks.renderNode = new Hook(this);
    		this.hooks.layoutNode = new Hook(this);
    		this.hooks.onOverflow = new Hook(this);
    		this.hooks.afterOverflowRemoved = new Hook(this);
    		this.hooks.onBreakToken = new Hook();
    		this.hooks.beforeRenderResult = new Hook(this);
    		this.hooks.afterPageLayout = new Hook(this);
    		this.hooks.finalizePage = new Hook(this);
    		this.hooks.afterRendered = new Hook(this);

    		this.pages = [];
    		this.total = 0;

    		this.q = new Queue(this);
    		this.stopped = false;
    		this.rendered = false;

    		this.content = content;

    		this.charsPerBreak = [];
    		this.maxChars;

    		if (content) {
    			this.flow(content, renderTo);
    		}
    	}

    	setup(renderTo) {
    		this.pagesArea = document.createElement("div");
    		this.pagesArea.classList.add("pagedjs_pages");

    		if (renderTo) {
    			renderTo.appendChild(this.pagesArea);
    		} else {
    			document.querySelector("body").appendChild(this.pagesArea);
    		}

    		this.pageTemplate = document.createElement("template");
    		this.pageTemplate.innerHTML = TEMPLATE;

    	}

    	async flow(content, renderTo) {
    		let parsed;

    		await this.hooks.beforeParsed.trigger(content, this);

    		parsed = new ContentParser(content);

    		this.hooks.filter.triggerSync(parsed);

    		this.source = parsed;
    		this.breakToken = undefined;

    		if (this.pagesArea && this.pageTemplate) {
    			this.q.clear();
    			this.removePages();
    		} else {
    			this.setup(renderTo);
    		}

    		this.emit("rendering", parsed);

    		await this.hooks.afterParsed.trigger(parsed, this);

    		await this.loadFonts();

    		let rendered = await this.render(parsed, this.breakToken);
    		while (rendered.canceled) {
    			this.start();
    			rendered = await this.render(parsed, this.breakToken);
    		}

    		this.rendered = true;
    		this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

    		await this.hooks.afterRendered.trigger(this.pages, this);

    		this.emit("rendered", this.pages);



    		return this;
    	}

    	// oversetPages() {
    	// 	let overset = [];
    	// 	for (let i = 0; i < this.pages.length; i++) {
    	// 		let page = this.pages[i];
    	// 		if (page.overset) {
    	// 			overset.push(page);
    	// 			// page.overset = false;
    	// 		}
    	// 	}
    	// 	return overset;
    	// }
    	//
    	// async handleOverset(parsed) {
    	// 	let overset = this.oversetPages();
    	// 	if (overset.length) {
    	// 		console.log("overset", overset);
    	// 		let index = this.pages.indexOf(overset[0]) + 1;
    	// 		console.log("INDEX", index);
    	//
    	// 		// Remove pages
    	// 		// this.removePages(index);
    	//
    	// 		// await this.render(parsed, overset[0].overset);
    	//
    	// 		// return this.handleOverset(parsed);
    	// 	}
    	// }

    	async render(parsed, startAt) {
    		let renderer = this.layout(parsed, startAt);

    		let done = false;
    		let result;
    		while (!done) {
    			result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
    			done = result.done;
    		}

    		return result;
    	}

    	start() {
    		this.rendered = false;
    		this.stopped = false;
    	}

    	stop() {
    		this.stopped = true;
    		// this.q.clear();
    	}

    	renderOnIdle(renderer) {
    		return new Promise(resolve => {
    			requestIdleCallback(async () => {
    				if (this.stopped) {
    					return resolve({ done: true, canceled: true });
    				}
    				let result = await renderer.next();
    				if (this.stopped) {
    					resolve({ done: true, canceled: true });
    				} else {
    					resolve(result);
    				}
    			});
    		});
    	}

    	async renderAsync(renderer) {
    		if (this.stopped) {
    			return { done: true, canceled: true };
    		}
    		let result = await renderer.next();
    		if (this.stopped) {
    			return { done: true, canceled: true };
    		} else {
    			return result;
    		}
    	}

    	async handleBreaks(node, force) {
    		let currentPage = this.total + 1;
    		let currentPosition = currentPage % 2 === 0 ? "left" : "right";
    		// TODO: Recto and Verso should reverse for rtl languages
    		let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
    		let previousBreakAfter;
    		let breakBefore;
    		let page;

    		if (currentPage === 1) {
    			return;
    		}

    		if (node &&
    				typeof node.dataset !== "undefined" &&
    				typeof node.dataset.previousBreakAfter !== "undefined") {
    			previousBreakAfter = node.dataset.previousBreakAfter;
    		}

    		if (node &&
    				typeof node.dataset !== "undefined" &&
    				typeof node.dataset.breakBefore !== "undefined") {
    			breakBefore = node.dataset.breakBefore;
    		}

    		if (force) {
    			page = this.addPage(true);
    		} else if( previousBreakAfter &&
    				(previousBreakAfter === "left" || previousBreakAfter === "right") &&
    				previousBreakAfter !== currentPosition) {
    			page = this.addPage(true);
    		} else if( previousBreakAfter &&
    				(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
    				previousBreakAfter !== currentSide) {
    			page = this.addPage(true);
    		} else if( breakBefore &&
    				(breakBefore === "left" || breakBefore === "right") &&
    				breakBefore !== currentPosition) {
    			page = this.addPage(true);
    		} else if( breakBefore &&
    				(breakBefore === "verso" || breakBefore === "recto") &&
    				breakBefore !== currentSide) {
    			page = this.addPage(true);
    		}

    		if (page) {
    			await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
    			this.emit("page", page);
    			// await this.hooks.layout.trigger(page.element, page, undefined, this);
    			await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
    			await this.hooks.finalizePage.trigger(page.element, page, undefined, this);
    			this.emit("renderedPage", page);
    		}
    	}

    	async *layout(content, startAt) {
    		let breakToken = startAt || false;
    		let tokens = [];

    		while (breakToken !== undefined && (true)) {

    			if (breakToken && breakToken.node) {
    				await this.handleBreaks(breakToken.node);
    			} else {
    				await this.handleBreaks(content.firstChild);
    			}

    			let page = this.addPage();

    			await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
    			this.emit("page", page);

    			// Layout content in the page, starting from the breakToken
    			breakToken = await page.layout(content, breakToken, this.maxChars);

    			if (breakToken) {
    				let newToken = breakToken.toJSON(true);
    				if (tokens.lastIndexOf(newToken) > -1) {
    					// loop
    					let err = new OverflowContentError("Layout repeated", [breakToken.node]);
    					console.error("Layout repeated at: ", breakToken.node);
    					return err;
    				} else {
    					tokens.push(newToken);
    				}
    			}

    			await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
    			await this.hooks.finalizePage.trigger(page.element, page, undefined, this);
    			this.emit("renderedPage", page);

    			this.recoredCharLength(page.wrapper.textContent.length);

    			yield breakToken;

    			// Stop if we get undefined, showing we have reached the end of the content
    		}


    	}

    	recoredCharLength(length) {
    		if (length === 0) {
    			return;
    		}

    		this.charsPerBreak.push(length);

    		// Keep the length of the last few breaks
    		if (this.charsPerBreak.length > 4) {
    			this.charsPerBreak.shift();
    		}

    		this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
    	}

    	removePages(fromIndex=0) {

    		if (fromIndex >= this.pages.length) {
    			return;
    		}

    		// Remove pages
    		for (let i = fromIndex; i < this.pages.length; i++) {
    			this.pages[i].destroy();
    		}

    		if (fromIndex > 0) {
    			this.pages.splice(fromIndex);
    		} else {
    			this.pages = [];
    		}

    		this.total = this.pages.length;
    	}

    	addPage(blank) {
    		let lastPage = this.pages[this.pages.length - 1];
    		// Create a new page from the template
    		let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks, this.settings);

    		this.pages.push(page);

    		// Create the pages
    		page.create(undefined, lastPage && lastPage.element);

    		page.index(this.total);

    		if (!blank) {
    			// Listen for page overflow
    			page.onOverflow((overflowToken) => {
    				console.warn("overflow on", page.id, overflowToken);

    				// Only reflow while rendering
    				if (this.rendered) {
    					return;
    				}

    				let index = this.pages.indexOf(page) + 1;

    				// Stop the rendering
    				this.stop();

    				// Set the breakToken to resume at
    				this.breakToken = overflowToken;

    				// Remove pages
    				this.removePages(index);

    				if (this.rendered === true) {
    					this.rendered = false;

    					this.q.enqueue(async () => {

    						this.start();

    						await this.render(this.source, this.breakToken);

    						this.rendered = true;

    					});
    				}


    			});

    			page.onUnderflow((overflowToken) => {
    				// console.log("underflow on", page.id, overflowToken);

    				// page.append(this.source, overflowToken);

    			});
    		}

    		this.total = this.pages.length;

    		return page;
    	}
    	/*
    	insertPage(index, blank) {
    		let lastPage = this.pages[index];
    		// Create a new page from the template
    		let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

    		let total = this.pages.splice(index, 0, page);

    		// Create the pages
    		page.create(undefined, lastPage && lastPage.element);

    		page.index(index + 1);

    		for (let i = index + 2; i < this.pages.length; i++) {
    			this.pages[i].index(i);
    		}

    		if (!blank) {
    			// Listen for page overflow
    			page.onOverflow((overflowToken) => {
    				if (total < this.pages.length) {
    					this.pages[total].layout(this.source, overflowToken);
    				} else {
    					let newPage = this.addPage();
    					newPage.layout(this.source, overflowToken);
    				}
    			});

    			page.onUnderflow(() => {
    				// console.log("underflow on", page.id);
    			});
    		}

    		this.total += 1;

    		return page;
    	}
    	*/

    	async clonePage(originalPage) {
    		let lastPage = this.pages[this.pages.length - 1];

    		let page = new Page(this.pagesArea, this.pageTemplate, false, this.hooks);

    		this.pages.push(page);

    		// Create the pages
    		page.create(undefined, lastPage && lastPage.element);

    		page.index(this.total);

    		await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
    		this.emit("page", page);

    		for (const className of originalPage.element.classList) {
    			if (className !== "pagedjs_left_page" && className !== "pagedjs_right_page") {
    				page.element.classList.add(className);
    			}
    		}

    		await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
    		await this.hooks.finalizePage.trigger(page.element, page, undefined, this);
    		this.emit("renderedPage", page);
    	}

    	loadFonts() {
    		let fontPromises = [];
    		(document.fonts || []).forEach((fontFace) => {
    			if (fontFace.status !== "loaded") {
    				let fontLoaded = fontFace.load().then((r) => {
    					return fontFace.family;
    				}, (r) => {
    					console.warn("Failed to preload font-family:", fontFace.family);
    					return fontFace.family;
    				});
    				fontPromises.push(fontLoaded);
    			}
    		});
    		return Promise.all(fontPromises).catch((err) => {
    			console.warn(err);
    		});
    	}

    	destroy() {
    		this.pagesArea.remove();
    		this.pageTemplate.remove();
    	}

    }

    EventEmitter(Chunker.prototype);

    var syntax = {exports: {}};

    var create$4 = {};

    var List_1;
    var hasRequiredList;

    function requireList () {
    	if (hasRequiredList) return List_1;
    	hasRequiredList = 1;
    	//
    	//                              list
    	//                            
    	//             head 
    	//                            tail
    	//                                         
    	//                                                 
    	//            item        item        item        item
    	//                      
    	//  null prev prev prev prev 
    	//           next next next next null
    	//                      
    	//           data      data      data      data 
    	//                      
    	//

    	function createItem(data) {
    	    return {
    	        prev: null,
    	        next: null,
    	        data: data
    	    };
    	}

    	function allocateCursor(node, prev, next) {
    	    var cursor;

    	    if (cursors !== null) {
    	        cursor = cursors;
    	        cursors = cursors.cursor;
    	        cursor.prev = prev;
    	        cursor.next = next;
    	        cursor.cursor = node.cursor;
    	    } else {
    	        cursor = {
    	            prev: prev,
    	            next: next,
    	            cursor: node.cursor
    	        };
    	    }

    	    node.cursor = cursor;

    	    return cursor;
    	}

    	function releaseCursor(node) {
    	    var cursor = node.cursor;

    	    node.cursor = cursor.cursor;
    	    cursor.prev = null;
    	    cursor.next = null;
    	    cursor.cursor = cursors;
    	    cursors = cursor;
    	}

    	var cursors = null;
    	var List = function() {
    	    this.cursor = null;
    	    this.head = null;
    	    this.tail = null;
    	};

    	List.createItem = createItem;
    	List.prototype.createItem = createItem;

    	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
    	    var cursor = this.cursor;

    	    while (cursor !== null) {
    	        if (cursor.prev === prevOld) {
    	            cursor.prev = prevNew;
    	        }

    	        if (cursor.next === nextOld) {
    	            cursor.next = nextNew;
    	        }

    	        cursor = cursor.cursor;
    	    }
    	};

    	List.prototype.getSize = function() {
    	    var size = 0;
    	    var cursor = this.head;

    	    while (cursor) {
    	        size++;
    	        cursor = cursor.next;
    	    }

    	    return size;
    	};

    	List.prototype.fromArray = function(array) {
    	    var cursor = null;

    	    this.head = null;

    	    for (var i = 0; i < array.length; i++) {
    	        var item = createItem(array[i]);

    	        if (cursor !== null) {
    	            cursor.next = item;
    	        } else {
    	            this.head = item;
    	        }

    	        item.prev = cursor;
    	        cursor = item;
    	    }

    	    this.tail = cursor;

    	    return this;
    	};

    	List.prototype.toArray = function() {
    	    var cursor = this.head;
    	    var result = [];

    	    while (cursor) {
    	        result.push(cursor.data);
    	        cursor = cursor.next;
    	    }

    	    return result;
    	};

    	List.prototype.toJSON = List.prototype.toArray;

    	List.prototype.isEmpty = function() {
    	    return this.head === null;
    	};

    	List.prototype.first = function() {
    	    return this.head && this.head.data;
    	};

    	List.prototype.last = function() {
    	    return this.tail && this.tail.data;
    	};

    	List.prototype.each = function(fn, context) {
    	    var item;

    	    if (context === undefined) {
    	        context = this;
    	    }

    	    // push cursor
    	    var cursor = allocateCursor(this, null, this.head);

    	    while (cursor.next !== null) {
    	        item = cursor.next;
    	        cursor.next = item.next;

    	        fn.call(context, item.data, item, this);
    	    }

    	    // pop cursor
    	    releaseCursor(this);
    	};

    	List.prototype.forEach = List.prototype.each;

    	List.prototype.eachRight = function(fn, context) {
    	    var item;

    	    if (context === undefined) {
    	        context = this;
    	    }

    	    // push cursor
    	    var cursor = allocateCursor(this, this.tail, null);

    	    while (cursor.prev !== null) {
    	        item = cursor.prev;
    	        cursor.prev = item.prev;

    	        fn.call(context, item.data, item, this);
    	    }

    	    // pop cursor
    	    releaseCursor(this);
    	};

    	List.prototype.forEachRight = List.prototype.eachRight;

    	List.prototype.reduce = function(fn, initialValue, context) {
    	    var item;

    	    if (context === undefined) {
    	        context = this;
    	    }

    	    // push cursor
    	    var cursor = allocateCursor(this, null, this.head);
    	    var acc = initialValue;

    	    while (cursor.next !== null) {
    	        item = cursor.next;
    	        cursor.next = item.next;

    	        acc = fn.call(context, acc, item.data, item, this);
    	    }

    	    // pop cursor
    	    releaseCursor(this);

    	    return acc;
    	};

    	List.prototype.reduceRight = function(fn, initialValue, context) {
    	    var item;

    	    if (context === undefined) {
    	        context = this;
    	    }

    	    // push cursor
    	    var cursor = allocateCursor(this, this.tail, null);
    	    var acc = initialValue;

    	    while (cursor.prev !== null) {
    	        item = cursor.prev;
    	        cursor.prev = item.prev;

    	        acc = fn.call(context, acc, item.data, item, this);
    	    }

    	    // pop cursor
    	    releaseCursor(this);

    	    return acc;
    	};

    	List.prototype.nextUntil = function(start, fn, context) {
    	    if (start === null) {
    	        return;
    	    }

    	    var item;

    	    if (context === undefined) {
    	        context = this;
    	    }

    	    // push cursor
    	    var cursor = allocateCursor(this, null, start);

    	    while (cursor.next !== null) {
    	        item = cursor.next;
    	        cursor.next = item.next;

    	        if (fn.call(context, item.data, item, this)) {
    	            break;
    	        }
    	    }

    	    // pop cursor
    	    releaseCursor(this);
    	};

    	List.prototype.prevUntil = function(start, fn, context) {
    	    if (start === null) {
    	        return;
    	    }

    	    var item;

    	    if (context === undefined) {
    	        context = this;
    	    }

    	    // push cursor
    	    var cursor = allocateCursor(this, start, null);

    	    while (cursor.prev !== null) {
    	        item = cursor.prev;
    	        cursor.prev = item.prev;

    	        if (fn.call(context, item.data, item, this)) {
    	            break;
    	        }
    	    }

    	    // pop cursor
    	    releaseCursor(this);
    	};

    	List.prototype.some = function(fn, context) {
    	    var cursor = this.head;

    	    if (context === undefined) {
    	        context = this;
    	    }

    	    while (cursor !== null) {
    	        if (fn.call(context, cursor.data, cursor, this)) {
    	            return true;
    	        }

    	        cursor = cursor.next;
    	    }

    	    return false;
    	};

    	List.prototype.map = function(fn, context) {
    	    var result = new List();
    	    var cursor = this.head;

    	    if (context === undefined) {
    	        context = this;
    	    }

    	    while (cursor !== null) {
    	        result.appendData(fn.call(context, cursor.data, cursor, this));
    	        cursor = cursor.next;
    	    }

    	    return result;
    	};

    	List.prototype.filter = function(fn, context) {
    	    var result = new List();
    	    var cursor = this.head;

    	    if (context === undefined) {
    	        context = this;
    	    }

    	    while (cursor !== null) {
    	        if (fn.call(context, cursor.data, cursor, this)) {
    	            result.appendData(cursor.data);
    	        }
    	        cursor = cursor.next;
    	    }

    	    return result;
    	};

    	List.prototype.clear = function() {
    	    this.head = null;
    	    this.tail = null;
    	};

    	List.prototype.copy = function() {
    	    var result = new List();
    	    var cursor = this.head;

    	    while (cursor !== null) {
    	        result.insert(createItem(cursor.data));
    	        cursor = cursor.next;
    	    }

    	    return result;
    	};

    	List.prototype.prepend = function(item) {
    	    //      head
    	    //    ^
    	    // item
    	    this.updateCursors(null, item, this.head, item);

    	    // insert to the beginning of the list
    	    if (this.head !== null) {
    	        // new item <- first item
    	        this.head.prev = item;

    	        // new item -> first item
    	        item.next = this.head;
    	    } else {
    	        // if list has no head, then it also has no tail
    	        // in this case tail points to the new item
    	        this.tail = item;
    	    }

    	    // head always points to new item
    	    this.head = item;

    	    return this;
    	};

    	List.prototype.prependData = function(data) {
    	    return this.prepend(createItem(data));
    	};

    	List.prototype.append = function(item) {
    	    return this.insert(item);
    	};

    	List.prototype.appendData = function(data) {
    	    return this.insert(createItem(data));
    	};

    	List.prototype.insert = function(item, before) {
    	    if (before !== undefined && before !== null) {
    	        // prev   before
    	        //      ^
    	        //     item
    	        this.updateCursors(before.prev, item, before, item);

    	        if (before.prev === null) {
    	            // insert to the beginning of list
    	            if (this.head !== before) {
    	                throw new Error('before doesn\'t belong to list');
    	            }

    	            // since head points to before therefore list doesn't empty
    	            // no need to check tail
    	            this.head = item;
    	            before.prev = item;
    	            item.next = before;

    	            this.updateCursors(null, item);
    	        } else {

    	            // insert between two items
    	            before.prev.next = item;
    	            item.prev = before.prev;

    	            before.prev = item;
    	            item.next = before;
    	        }
    	    } else {
    	        // tail
    	        //      ^
    	        //      item
    	        this.updateCursors(this.tail, item, null, item);

    	        // insert to the ending of the list
    	        if (this.tail !== null) {
    	            // last item -> new item
    	            this.tail.next = item;

    	            // last item <- new item
    	            item.prev = this.tail;
    	        } else {
    	            // if list has no tail, then it also has no head
    	            // in this case head points to new item
    	            this.head = item;
    	        }

    	        // tail always points to new item
    	        this.tail = item;
    	    }

    	    return this;
    	};

    	List.prototype.insertData = function(data, before) {
    	    return this.insert(createItem(data), before);
    	};

    	List.prototype.remove = function(item) {
    	    //      item
    	    //       ^
    	    // prev     next
    	    this.updateCursors(item, item.prev, item, item.next);

    	    if (item.prev !== null) {
    	        item.prev.next = item.next;
    	    } else {
    	        if (this.head !== item) {
    	            throw new Error('item doesn\'t belong to list');
    	        }

    	        this.head = item.next;
    	    }

    	    if (item.next !== null) {
    	        item.next.prev = item.prev;
    	    } else {
    	        if (this.tail !== item) {
    	            throw new Error('item doesn\'t belong to list');
    	        }

    	        this.tail = item.prev;
    	    }

    	    item.prev = null;
    	    item.next = null;

    	    return item;
    	};

    	List.prototype.push = function(data) {
    	    this.insert(createItem(data));
    	};

    	List.prototype.pop = function() {
    	    if (this.tail !== null) {
    	        return this.remove(this.tail);
    	    }
    	};

    	List.prototype.unshift = function(data) {
    	    this.prepend(createItem(data));
    	};

    	List.prototype.shift = function() {
    	    if (this.head !== null) {
    	        return this.remove(this.head);
    	    }
    	};

    	List.prototype.prependList = function(list) {
    	    return this.insertList(list, this.head);
    	};

    	List.prototype.appendList = function(list) {
    	    return this.insertList(list);
    	};

    	List.prototype.insertList = function(list, before) {
    	    // ignore empty lists
    	    if (list.head === null) {
    	        return this;
    	    }

    	    if (before !== undefined && before !== null) {
    	        this.updateCursors(before.prev, list.tail, before, list.head);

    	        // insert in the middle of dist list
    	        if (before.prev !== null) {
    	            // before.prev <-> list.head
    	            before.prev.next = list.head;
    	            list.head.prev = before.prev;
    	        } else {
    	            this.head = list.head;
    	        }

    	        before.prev = list.tail;
    	        list.tail.next = before;
    	    } else {
    	        this.updateCursors(this.tail, list.tail, null, list.head);

    	        // insert to end of the list
    	        if (this.tail !== null) {
    	            // if destination list has a tail, then it also has a head,
    	            // but head doesn't change

    	            // dest tail -> source head
    	            this.tail.next = list.head;

    	            // dest tail <- source head
    	            list.head.prev = this.tail;
    	        } else {
    	            // if list has no a tail, then it also has no a head
    	            // in this case points head to new item
    	            this.head = list.head;
    	        }

    	        // tail always start point to new item
    	        this.tail = list.tail;
    	    }

    	    list.head = null;
    	    list.tail = null;

    	    return this;
    	};

    	List.prototype.replace = function(oldItem, newItemOrList) {
    	    if ('head' in newItemOrList) {
    	        this.insertList(newItemOrList, oldItem);
    	    } else {
    	        this.insert(newItemOrList, oldItem);
    	    }

    	    this.remove(oldItem);
    	};

    	List_1 = List;
    	return List_1;
    }

    var createCustomError;
    var hasRequiredCreateCustomError;

    function requireCreateCustomError () {
    	if (hasRequiredCreateCustomError) return createCustomError;
    	hasRequiredCreateCustomError = 1;
    	createCustomError = function createCustomError(name, message) {
    	    // use Object.create(), because some VMs prevent setting line/column otherwise
    	    // (iOS Safari 10 even throws an exception)
    	    var error = Object.create(SyntaxError.prototype);
    	    var errorStack = new Error();

    	    error.name = name;
    	    error.message = message;

    	    Object.defineProperty(error, 'stack', {
    	        get: function() {
    	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
    	        }
    	    });

    	    return error;
    	};
    	return createCustomError;
    }

    var _SyntaxError$1;
    var hasRequired_SyntaxError$1;

    function require_SyntaxError$1 () {
    	if (hasRequired_SyntaxError$1) return _SyntaxError$1;
    	hasRequired_SyntaxError$1 = 1;
    	var createCustomError = requireCreateCustomError();
    	var MAX_LINE_LENGTH = 100;
    	var OFFSET_CORRECTION = 60;
    	var TAB_REPLACEMENT = '    ';

    	function sourceFragment(error, extraLines) {
    	    function processLines(start, end) {
    	        return lines.slice(start, end).map(function(line, idx) {
    	            var num = String(start + idx + 1);

    	            while (num.length < maxNumLength) {
    	                num = ' ' + num;
    	            }

    	            return num + ' |' + line;
    	        }).join('\n');
    	    }

    	    var lines = error.source.split(/\r\n?|\n|\f/);
    	    var line = error.line;
    	    var column = error.column;
    	    var startLine = Math.max(1, line - extraLines) - 1;
    	    var endLine = Math.min(line + extraLines, lines.length + 1);
    	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
    	    var cutLeft = 0;

    	    // column correction according to replaced tab before column
    	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

    	    if (column > MAX_LINE_LENGTH) {
    	        cutLeft = column - OFFSET_CORRECTION + 3;
    	        column = OFFSET_CORRECTION - 2;
    	    }

    	    for (var i = startLine; i <= endLine; i++) {
    	        if (i >= 0 && i < lines.length) {
    	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
    	            lines[i] =
    	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
    	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
    	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
    	        }
    	    }

    	    return [
    	        processLines(startLine, line),
    	        new Array(column + maxNumLength + 2).join('-') + '^',
    	        processLines(line, endLine)
    	    ].filter(Boolean).join('\n');
    	}

    	var SyntaxError = function(message, source, offset, line, column) {
    	    var error = createCustomError('SyntaxError', message);

    	    error.source = source;
    	    error.offset = offset;
    	    error.line = line;
    	    error.column = column;

    	    error.sourceFragment = function(extraLines) {
    	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
    	    };
    	    Object.defineProperty(error, 'formattedMessage', {
    	        get: function() {
    	            return (
    	                'Parse error: ' + error.message + '\n' +
    	                sourceFragment(error, 2)
    	            );
    	        }
    	    });

    	    // for backward capability
    	    error.parseError = {
    	        offset: offset,
    	        line: line,
    	        column: column
    	    };

    	    return error;
    	};

    	_SyntaxError$1 = SyntaxError;
    	return _SyntaxError$1;
    }

    var _const;
    var hasRequired_const;

    function require_const () {
    	if (hasRequired_const) return _const;
    	hasRequired_const = 1;
    	// CSS Syntax Module Level 3
    	// https://www.w3.org/TR/css-syntax-3/
    	var TYPE = {
    	    EOF: 0,                 // <EOF-token>
    	    Ident: 1,               // <ident-token>
    	    Function: 2,            // <function-token>
    	    AtKeyword: 3,           // <at-keyword-token>
    	    Hash: 4,                // <hash-token>
    	    String: 5,              // <string-token>
    	    BadString: 6,           // <bad-string-token>
    	    Url: 7,                 // <url-token>
    	    BadUrl: 8,              // <bad-url-token>
    	    Delim: 9,               // <delim-token>
    	    Number: 10,             // <number-token>
    	    Percentage: 11,         // <percentage-token>
    	    Dimension: 12,          // <dimension-token>
    	    WhiteSpace: 13,         // <whitespace-token>
    	    CDO: 14,                // <CDO-token>
    	    CDC: 15,                // <CDC-token>
    	    Colon: 16,              // <colon-token>     :
    	    Semicolon: 17,          // <semicolon-token> ;
    	    Comma: 18,              // <comma-token>     ,
    	    LeftSquareBracket: 19,  // <[-token>
    	    RightSquareBracket: 20, // <]-token>
    	    LeftParenthesis: 21,    // <(-token>
    	    RightParenthesis: 22,   // <)-token>
    	    LeftCurlyBracket: 23,   // <{-token>
    	    RightCurlyBracket: 24,  // <}-token>
    	    Comment: 25
    	};

    	var NAME = Object.keys(TYPE).reduce(function(result, key) {
    	    result[TYPE[key]] = key;
    	    return result;
    	}, {});

    	_const = {
    	    TYPE: TYPE,
    	    NAME: NAME
    	};
    	return _const;
    }

    var charCodeDefinitions;
    var hasRequiredCharCodeDefinitions;

    function requireCharCodeDefinitions () {
    	if (hasRequiredCharCodeDefinitions) return charCodeDefinitions;
    	hasRequiredCharCodeDefinitions = 1;
    	var EOF = 0;

    	// https://drafts.csswg.org/css-syntax-3/
    	//  4.2. Definitions

    	// digit
    	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
    	function isDigit(code) {
    	    return code >= 0x0030 && code <= 0x0039;
    	}

    	// hex digit
    	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
    	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
    	function isHexDigit(code) {
    	    return (
    	        isDigit(code) || // 0 .. 9
    	        (code >= 0x0041 && code <= 0x0046) || // A .. F
    	        (code >= 0x0061 && code <= 0x0066)    // a .. f
    	    );
    	}

    	// uppercase letter
    	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
    	function isUppercaseLetter(code) {
    	    return code >= 0x0041 && code <= 0x005A;
    	}

    	// lowercase letter
    	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
    	function isLowercaseLetter(code) {
    	    return code >= 0x0061 && code <= 0x007A;
    	}

    	// letter
    	// An uppercase letter or a lowercase letter.
    	function isLetter(code) {
    	    return isUppercaseLetter(code) || isLowercaseLetter(code);
    	}

    	// non-ASCII code point
    	// A code point with a value equal to or greater than U+0080 <control>.
    	function isNonAscii(code) {
    	    return code >= 0x0080;
    	}

    	// name-start code point
    	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
    	function isNameStart(code) {
    	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
    	}

    	// name code point
    	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
    	function isName(code) {
    	    return isNameStart(code) || isDigit(code) || code === 0x002D;
    	}

    	// non-printable code point
    	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
    	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
    	function isNonPrintable(code) {
    	    return (
    	        (code >= 0x0000 && code <= 0x0008) ||
    	        (code === 0x000B) ||
    	        (code >= 0x000E && code <= 0x001F) ||
    	        (code === 0x007F)
    	    );
    	}

    	// newline
    	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
    	// as they are converted to U+000A LINE FEED during preprocessing.
    	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
    	function isNewline(code) {
    	    return code === 0x000A || code === 0x000D || code === 0x000C;
    	}

    	// whitespace
    	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
    	function isWhiteSpace(code) {
    	    return isNewline(code) || code === 0x0020 || code === 0x0009;
    	}

    	//  4.3.8. Check if two code points are a valid escape
    	function isValidEscape(first, second) {
    	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
    	    if (first !== 0x005C) {
    	        return false;
    	    }

    	    // Otherwise, if the second code point is a newline or EOF, return false.
    	    if (isNewline(second) || second === EOF) {
    	        return false;
    	    }

    	    // Otherwise, return true.
    	    return true;
    	}

    	//  4.3.9. Check if three code points would start an identifier
    	function isIdentifierStart(first, second, third) {
    	    // Look at the first code point:

    	    // U+002D HYPHEN-MINUS
    	    if (first === 0x002D) {
    	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
    	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
    	        return (
    	            isNameStart(second) ||
    	            second === 0x002D ||
    	            isValidEscape(second, third)
    	        );
    	    }

    	    // name-start code point
    	    if (isNameStart(first)) {
    	        // Return true.
    	        return true;
    	    }

    	    // U+005C REVERSE SOLIDUS (\)
    	    if (first === 0x005C) {
    	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
    	        return isValidEscape(first, second);
    	    }

    	    // anything else
    	    // Return false.
    	    return false;
    	}

    	//  4.3.10. Check if three code points would start a number
    	function isNumberStart(first, second, third) {
    	    // Look at the first code point:

    	    // U+002B PLUS SIGN (+)
    	    // U+002D HYPHEN-MINUS (-)
    	    if (first === 0x002B || first === 0x002D) {
    	        // If the second code point is a digit, return true.
    	        if (isDigit(second)) {
    	            return 2;
    	        }

    	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
    	        // and the third code point is a digit, return true.
    	        // Otherwise, return false.
    	        return second === 0x002E && isDigit(third) ? 3 : 0;
    	    }

    	    // U+002E FULL STOP (.)
    	    if (first === 0x002E) {
    	        // If the second code point is a digit, return true. Otherwise, return false.
    	        return isDigit(second) ? 2 : 0;
    	    }

    	    // digit
    	    if (isDigit(first)) {
    	        // Return true.
    	        return 1;
    	    }

    	    // anything else
    	    // Return false.
    	    return 0;
    	}

    	//
    	// Misc
    	//

    	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
    	function isBOM(code) {
    	    // UTF-16BE
    	    if (code === 0xFEFF) {
    	        return 1;
    	    }

    	    // UTF-16LE
    	    if (code === 0xFFFE) {
    	        return 1;
    	    }

    	    return 0;
    	}

    	// Fast code category
    	//
    	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
    	// > non-ASCII code point
    	// >   A code point with a value equal to or greater than U+0080 <control>
    	// > name-start code point
    	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
    	// > name code point
    	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
    	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
    	var CATEGORY = new Array(0x80);
    	charCodeCategory.Eof = 0x80;
    	charCodeCategory.WhiteSpace = 0x82;
    	charCodeCategory.Digit = 0x83;
    	charCodeCategory.NameStart = 0x84;
    	charCodeCategory.NonPrintable = 0x85;

    	for (var i = 0; i < CATEGORY.length; i++) {
    	    switch (true) {
    	        case isWhiteSpace(i):
    	            CATEGORY[i] = charCodeCategory.WhiteSpace;
    	            break;

    	        case isDigit(i):
    	            CATEGORY[i] = charCodeCategory.Digit;
    	            break;

    	        case isNameStart(i):
    	            CATEGORY[i] = charCodeCategory.NameStart;
    	            break;

    	        case isNonPrintable(i):
    	            CATEGORY[i] = charCodeCategory.NonPrintable;
    	            break;

    	        default:
    	            CATEGORY[i] = i || charCodeCategory.Eof;
    	    }
    	}

    	function charCodeCategory(code) {
    	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
    	}
    	charCodeDefinitions = {
    	    isDigit: isDigit,
    	    isHexDigit: isHexDigit,
    	    isUppercaseLetter: isUppercaseLetter,
    	    isLowercaseLetter: isLowercaseLetter,
    	    isLetter: isLetter,
    	    isNonAscii: isNonAscii,
    	    isNameStart: isNameStart,
    	    isName: isName,
    	    isNonPrintable: isNonPrintable,
    	    isNewline: isNewline,
    	    isWhiteSpace: isWhiteSpace,
    	    isValidEscape: isValidEscape,
    	    isIdentifierStart: isIdentifierStart,
    	    isNumberStart: isNumberStart,

    	    isBOM: isBOM,
    	    charCodeCategory: charCodeCategory
    	};
    	return charCodeDefinitions;
    }

    var utils$1;
    var hasRequiredUtils;

    function requireUtils () {
    	if (hasRequiredUtils) return utils$1;
    	hasRequiredUtils = 1;
    	var charCodeDef = requireCharCodeDefinitions();
    	var isDigit = charCodeDef.isDigit;
    	var isHexDigit = charCodeDef.isHexDigit;
    	var isUppercaseLetter = charCodeDef.isUppercaseLetter;
    	var isName = charCodeDef.isName;
    	var isWhiteSpace = charCodeDef.isWhiteSpace;
    	var isValidEscape = charCodeDef.isValidEscape;

    	function getCharCode(source, offset) {
    	    return offset < source.length ? source.charCodeAt(offset) : 0;
    	}

    	function getNewlineLength(source, offset, code) {
    	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
    	        return 2;
    	    }

    	    return 1;
    	}

    	function cmpChar(testStr, offset, referenceCode) {
    	    var code = testStr.charCodeAt(offset);

    	    // code.toLowerCase() for A..Z
    	    if (isUppercaseLetter(code)) {
    	        code = code | 32;
    	    }

    	    return code === referenceCode;
    	}

    	function cmpStr(testStr, start, end, referenceStr) {
    	    if (end - start !== referenceStr.length) {
    	        return false;
    	    }

    	    if (start < 0 || end > testStr.length) {
    	        return false;
    	    }

    	    for (var i = start; i < end; i++) {
    	        var testCode = testStr.charCodeAt(i);
    	        var referenceCode = referenceStr.charCodeAt(i - start);

    	        // testCode.toLowerCase() for A..Z
    	        if (isUppercaseLetter(testCode)) {
    	            testCode = testCode | 32;
    	        }

    	        if (testCode !== referenceCode) {
    	            return false;
    	        }
    	    }

    	    return true;
    	}

    	function findWhiteSpaceStart(source, offset) {
    	    for (; offset >= 0; offset--) {
    	        if (!isWhiteSpace(source.charCodeAt(offset))) {
    	            break;
    	        }
    	    }

    	    return offset + 1;
    	}

    	function findWhiteSpaceEnd(source, offset) {
    	    for (; offset < source.length; offset++) {
    	        if (!isWhiteSpace(source.charCodeAt(offset))) {
    	            break;
    	        }
    	    }

    	    return offset;
    	}

    	function findDecimalNumberEnd(source, offset) {
    	    for (; offset < source.length; offset++) {
    	        if (!isDigit(source.charCodeAt(offset))) {
    	            break;
    	        }
    	    }

    	    return offset;
    	}

    	//  4.3.7. Consume an escaped code point
    	function consumeEscaped(source, offset) {
    	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
    	    // that the next input code point has already been verified to be part of a valid escape.
    	    offset += 2;

    	    // hex digit
    	    if (isHexDigit(getCharCode(source, offset - 1))) {
    	        // Consume as many hex digits as possible, but no more than 5.
    	        // Note that this means 1-6 hex digits have been consumed in total.
    	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
    	            if (!isHexDigit(getCharCode(source, offset))) {
    	                break;
    	            }
    	        }

    	        // If the next input code point is whitespace, consume it as well.
    	        var code = getCharCode(source, offset);
    	        if (isWhiteSpace(code)) {
    	            offset += getNewlineLength(source, offset, code);
    	        }
    	    }

    	    return offset;
    	}

    	// 4.3.11. Consume a name
    	// Note: This algorithm does not do the verification of the first few code points that are necessary
    	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
    	// ensure that the stream starts with an identifier before calling this algorithm.
    	function consumeName(source, offset) {
    	    // Let result initially be an empty string.
    	    // Repeatedly consume the next input code point from the stream:
    	    for (; offset < source.length; offset++) {
    	        var code = source.charCodeAt(offset);

    	        // name code point
    	        if (isName(code)) {
    	            // Append the code point to result.
    	            continue;
    	        }

    	        // the stream starts with a valid escape
    	        if (isValidEscape(code, getCharCode(source, offset + 1))) {
    	            // Consume an escaped code point. Append the returned code point to result.
    	            offset = consumeEscaped(source, offset) - 1;
    	            continue;
    	        }

    	        // anything else
    	        // Reconsume the current input code point. Return result.
    	        break;
    	    }

    	    return offset;
    	}

    	// 4.3.12. Consume a number
    	function consumeNumber(source, offset) {
    	    var code = source.charCodeAt(offset);

    	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
    	    // consume it and append it to repr.
    	    if (code === 0x002B || code === 0x002D) {
    	        code = source.charCodeAt(offset += 1);
    	    }

    	    // 3. While the next input code point is a digit, consume it and append it to repr.
    	    if (isDigit(code)) {
    	        offset = findDecimalNumberEnd(source, offset + 1);
    	        code = source.charCodeAt(offset);
    	    }

    	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
    	    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {
    	        // 4.1 Consume them.
    	        // 4.2 Append them to repr.
    	        code = source.charCodeAt(offset += 2);

    	        // 4.3 Set type to "number".
    	        // TODO

    	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

    	        offset = findDecimalNumberEnd(source, offset);
    	    }

    	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
    	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
    	    if (cmpChar(source, offset, 101 /* e */)) {
    	        var sign = 0;
    	        code = source.charCodeAt(offset + 1);

    	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
    	        if (code === 0x002D || code === 0x002B) {
    	            sign = 1;
    	            code = source.charCodeAt(offset + 2);
    	        }

    	        // ... followed by a digit
    	        if (isDigit(code)) {
    	            // 5.1 Consume them.
    	            // 5.2 Append them to repr.

    	            // 5.3 Set type to "number".
    	            // TODO

    	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
    	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
    	        }
    	    }

    	    return offset;
    	}

    	//  4.3.14. Consume the remnants of a bad url
    	// ... its sole use is to consume enough of the input stream to reach a recovery point
    	// where normal tokenizing can resume.
    	function consumeBadUrlRemnants(source, offset) {
    	    // Repeatedly consume the next input code point from the stream:
    	    for (; offset < source.length; offset++) {
    	        var code = source.charCodeAt(offset);

    	        // U+0029 RIGHT PARENTHESIS ())
    	        // EOF
    	        if (code === 0x0029) {
    	            // Return.
    	            offset++;
    	            break;
    	        }

    	        if (isValidEscape(code, getCharCode(source, offset + 1))) {
    	            // Consume an escaped code point.
    	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
    	            // without ending the <bad-url-token>. This is otherwise identical to
    	            // the "anything else" clause.
    	            offset = consumeEscaped(source, offset);
    	        }
    	    }

    	    return offset;
    	}

    	utils$1 = {
    	    consumeEscaped: consumeEscaped,
    	    consumeName: consumeName,
    	    consumeNumber: consumeNumber,
    	    consumeBadUrlRemnants: consumeBadUrlRemnants,

    	    cmpChar: cmpChar,
    	    cmpStr: cmpStr,

    	    getNewlineLength: getNewlineLength,
    	    findWhiteSpaceStart: findWhiteSpaceStart,
    	    findWhiteSpaceEnd: findWhiteSpaceEnd
    	};
    	return utils$1;
    }

    var TokenStream_1;
    var hasRequiredTokenStream;

    function requireTokenStream () {
    	if (hasRequiredTokenStream) return TokenStream_1;
    	hasRequiredTokenStream = 1;
    	var constants = require_const();
    	var TYPE = constants.TYPE;
    	var NAME = constants.NAME;

    	var utils = requireUtils();
    	var cmpStr = utils.cmpStr;

    	var EOF = TYPE.EOF;
    	var WHITESPACE = TYPE.WhiteSpace;
    	var COMMENT = TYPE.Comment;

    	var OFFSET_MASK = 0x00FFFFFF;
    	var TYPE_SHIFT = 24;

    	var TokenStream = function() {
    	    this.offsetAndType = null;
    	    this.balance = null;

    	    this.reset();
    	};

    	TokenStream.prototype = {
    	    reset: function() {
    	        this.eof = false;
    	        this.tokenIndex = -1;
    	        this.tokenType = 0;
    	        this.tokenStart = this.firstCharOffset;
    	        this.tokenEnd = this.firstCharOffset;
    	    },

    	    lookupType: function(offset) {
    	        offset += this.tokenIndex;

    	        if (offset < this.tokenCount) {
    	            return this.offsetAndType[offset] >> TYPE_SHIFT;
    	        }

    	        return EOF;
    	    },
    	    lookupOffset: function(offset) {
    	        offset += this.tokenIndex;

    	        if (offset < this.tokenCount) {
    	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
    	        }

    	        return this.source.length;
    	    },
    	    lookupValue: function(offset, referenceStr) {
    	        offset += this.tokenIndex;

    	        if (offset < this.tokenCount) {
    	            return cmpStr(
    	                this.source,
    	                this.offsetAndType[offset - 1] & OFFSET_MASK,
    	                this.offsetAndType[offset] & OFFSET_MASK,
    	                referenceStr
    	            );
    	        }

    	        return false;
    	    },
    	    getTokenStart: function(tokenIndex) {
    	        if (tokenIndex === this.tokenIndex) {
    	            return this.tokenStart;
    	        }

    	        if (tokenIndex > 0) {
    	            return tokenIndex < this.tokenCount
    	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
    	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
    	        }

    	        return this.firstCharOffset;
    	    },

    	    // TODO: -> skipUntilBalanced
    	    getRawLength: function(startToken, mode) {
    	        var cursor = startToken;
    	        var balanceEnd;
    	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
    	        var type;

    	        loop:
    	        for (; cursor < this.tokenCount; cursor++) {
    	            balanceEnd = this.balance[cursor];

    	            // stop scanning on balance edge that points to offset before start token
    	            if (balanceEnd < startToken) {
    	                break loop;
    	            }

    	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

    	            // check token is stop type
    	            switch (mode(type, this.source, offset)) {
    	                case 1:
    	                    break loop;

    	                case 2:
    	                    cursor++;
    	                    break loop;

    	                default:
    	                    // fast forward to the end of balanced block
    	                    if (this.balance[balanceEnd] === cursor) {
    	                        cursor = balanceEnd;
    	                    }

    	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;
    	            }
    	        }

    	        return cursor - this.tokenIndex;
    	    },
    	    isBalanceEdge: function(pos) {
    	        return this.balance[this.tokenIndex] < pos;
    	    },
    	    isDelim: function(code, offset) {
    	        if (offset) {
    	            return (
    	                this.lookupType(offset) === TYPE.Delim &&
    	                this.source.charCodeAt(this.lookupOffset(offset)) === code
    	            );
    	        }

    	        return (
    	            this.tokenType === TYPE.Delim &&
    	            this.source.charCodeAt(this.tokenStart) === code
    	        );
    	    },

    	    getTokenValue: function() {
    	        return this.source.substring(this.tokenStart, this.tokenEnd);
    	    },
    	    getTokenLength: function() {
    	        return this.tokenEnd - this.tokenStart;
    	    },
    	    substrToCursor: function(start) {
    	        return this.source.substring(start, this.tokenStart);
    	    },

    	    skipWS: function() {
    	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
    	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
    	                break;
    	            }
    	        }

    	        if (skipTokenCount > 0) {
    	            this.skip(skipTokenCount);
    	        }
    	    },
    	    skipSC: function() {
    	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
    	            this.next();
    	        }
    	    },
    	    skip: function(tokenCount) {
    	        var next = this.tokenIndex + tokenCount;

    	        if (next < this.tokenCount) {
    	            this.tokenIndex = next;
    	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
    	            next = this.offsetAndType[next];
    	            this.tokenType = next >> TYPE_SHIFT;
    	            this.tokenEnd = next & OFFSET_MASK;
    	        } else {
    	            this.tokenIndex = this.tokenCount;
    	            this.next();
    	        }
    	    },
    	    next: function() {
    	        var next = this.tokenIndex + 1;

    	        if (next < this.tokenCount) {
    	            this.tokenIndex = next;
    	            this.tokenStart = this.tokenEnd;
    	            next = this.offsetAndType[next];
    	            this.tokenType = next >> TYPE_SHIFT;
    	            this.tokenEnd = next & OFFSET_MASK;
    	        } else {
    	            this.tokenIndex = this.tokenCount;
    	            this.eof = true;
    	            this.tokenType = EOF;
    	            this.tokenStart = this.tokenEnd = this.source.length;
    	        }
    	    },

    	    forEachToken(fn) {
    	        for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
    	            var start = offset;
    	            var item = this.offsetAndType[i];
    	            var end = item & OFFSET_MASK;
    	            var type = item >> TYPE_SHIFT;

    	            offset = end;

    	            fn(type, start, end, i);
    	        }
    	    },

    	    dump() {
    	        var tokens = new Array(this.tokenCount);

    	        this.forEachToken((type, start, end, index) => {
    	            tokens[index] = {
    	                idx: index,
    	                type: NAME[type],
    	                chunk: this.source.substring(start, end),
    	                balance: this.balance[index]
    	            };
    	        });

    	        return tokens;
    	    }
    	};

    	TokenStream_1 = TokenStream;
    	return TokenStream_1;
    }

    var generate_1;
    var hasRequiredGenerate;

    function requireGenerate () {
    	if (hasRequiredGenerate) return generate_1;
    	hasRequiredGenerate = 1;
    	function noop(value) {
    	    return value;
    	}

    	function generateMultiplier(multiplier) {
    	    if (multiplier.min === 0 && multiplier.max === 0) {
    	        return '*';
    	    }

    	    if (multiplier.min === 0 && multiplier.max === 1) {
    	        return '?';
    	    }

    	    if (multiplier.min === 1 && multiplier.max === 0) {
    	        return multiplier.comma ? '#' : '+';
    	    }

    	    if (multiplier.min === 1 && multiplier.max === 1) {
    	        return '';
    	    }

    	    return (
    	        (multiplier.comma ? '#' : '') +
    	        (multiplier.min === multiplier.max
    	            ? '{' + multiplier.min + '}'
    	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
    	        )
    	    );
    	}

    	function generateTypeOpts(node) {
    	    switch (node.type) {
    	        case 'Range':
    	            return (
    	                ' [' +
    	                (node.min === null ? '-' : node.min) +
    	                ',' +
    	                (node.max === null ? '' : node.max) +
    	                ']'
    	            );

    	        default:
    	            throw new Error('Unknown node type `' + node.type + '`');
    	    }
    	}

    	function generateSequence(node, decorate, forceBraces, compact) {
    	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
    	    var result = node.terms.map(function(term) {
    	        return generate(term, decorate, forceBraces, compact);
    	    }).join(combinator);

    	    if (node.explicit || forceBraces) {
    	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
    	    }

    	    return result;
    	}

    	function generate(node, decorate, forceBraces, compact) {
    	    var result;

    	    switch (node.type) {
    	        case 'Group':
    	            result =
    	                generateSequence(node, decorate, forceBraces, compact) +
    	                (node.disallowEmpty ? '!' : '');
    	            break;

    	        case 'Multiplier':
    	            // return since node is a composition
    	            return (
    	                generate(node.term, decorate, forceBraces, compact) +
    	                decorate(generateMultiplier(node), node)
    	            );

    	        case 'Type':
    	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
    	            break;

    	        case 'Property':
    	            result = '<\'' + node.name + '\'>';
    	            break;

    	        case 'Keyword':
    	            result = node.name;
    	            break;

    	        case 'AtKeyword':
    	            result = '@' + node.name;
    	            break;

    	        case 'Function':
    	            result = node.name + '(';
    	            break;

    	        case 'String':
    	        case 'Token':
    	            result = node.value;
    	            break;

    	        case 'Comma':
    	            result = ',';
    	            break;

    	        default:
    	            throw new Error('Unknown node type `' + node.type + '`');
    	    }

    	    return decorate(result, node);
    	}

    	generate_1 = function(node, options) {
    	    var decorate = noop;
    	    var forceBraces = false;
    	    var compact = false;

    	    if (typeof options === 'function') {
    	        decorate = options;
    	    } else if (options) {
    	        forceBraces = Boolean(options.forceBraces);
    	        compact = Boolean(options.compact);
    	        if (typeof options.decorate === 'function') {
    	            decorate = options.decorate;
    	        }
    	    }

    	    return generate(node, decorate, forceBraces, compact);
    	};
    	return generate_1;
    }

    var error;
    var hasRequiredError;

    function requireError () {
    	if (hasRequiredError) return error;
    	hasRequiredError = 1;
    	const createCustomError = requireCreateCustomError();
    	const generate = requireGenerate();
    	const defaultLoc = { offset: 0, line: 1, column: 1 };

    	function locateMismatch(matchResult, node) {
    	    const tokens = matchResult.tokens;
    	    const longestMatch = matchResult.longestMatch;
    	    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
    	    const badNode = mismatchNode !== node ? mismatchNode : null;
    	    let mismatchOffset = 0;
    	    let mismatchLength = 0;
    	    let entries = 0;
    	    let css = '';
    	    let start;
    	    let end;

    	    for (let i = 0; i < tokens.length; i++) {
    	        const token = tokens[i].value;

    	        if (i === longestMatch) {
    	            mismatchLength = token.length;
    	            mismatchOffset = css.length;
    	        }

    	        if (badNode !== null && tokens[i].node === badNode) {
    	            if (i <= longestMatch) {
    	                entries++;
    	            } else {
    	                entries = 0;
    	            }
    	        }

    	        css += token;
    	    }

    	    if (longestMatch === tokens.length || entries > 1) { // last
    	        start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);
    	        end = buildLoc(start);
    	    } else {
    	        start = fromLoc(badNode, 'start') ||
    	            buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));
    	        end = fromLoc(badNode, 'end') ||
    	            buildLoc(start, css.substr(mismatchOffset, mismatchLength));
    	    }

    	    return {
    	        css,
    	        mismatchOffset,
    	        mismatchLength,
    	        start,
    	        end
    	    };
    	}

    	function fromLoc(node, point) {
    	    const value = node && node.loc && node.loc[point];

    	    if (value) {
    	        return 'line' in value ? buildLoc(value) : value;
    	    }

    	    return null;
    	}

    	function buildLoc({ offset, line, column }, extra) {
    	    const loc = {
    	        offset,
    	        line,
    	        column
    	    };

    	    if (extra) {
    	        const lines = extra.split(/\n|\r\n?|\f/);

    	        loc.offset += extra.length;
    	        loc.line += lines.length - 1;
    	        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
    	    }

    	    return loc;
    	}

    	const SyntaxReferenceError = function(type, referenceName) {
    	    const error = createCustomError(
    	        'SyntaxReferenceError',
    	        type + (referenceName ? ' `' + referenceName + '`' : '')
    	    );

    	    error.reference = referenceName;

    	    return error;
    	};

    	const SyntaxMatchError = function(message, syntax, node, matchResult) {
    	    const error = createCustomError('SyntaxMatchError', message);
    	    const {
    	        css,
    	        mismatchOffset,
    	        mismatchLength,
    	        start,
    	        end
    	    } = locateMismatch(matchResult, node);

    	    error.rawMessage = message;
    	    error.syntax = syntax ? generate(syntax) : '<generic>';
    	    error.css = css;
    	    error.mismatchOffset = mismatchOffset;
    	    error.mismatchLength = mismatchLength;
    	    error.message = message + '\n' +
    	        '  syntax: ' + error.syntax + '\n' +
    	        '   value: ' + (css || '<empty string>') + '\n' +
    	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

    	    Object.assign(error, start);
    	    error.loc = {
    	        source: (node && node.loc && node.loc.source) || '<unknown>',
    	        start,
    	        end
    	    };

    	    return error;
    	};

    	error = {
    	    SyntaxReferenceError,
    	    SyntaxMatchError
    	};
    	return error;
    }

    var names;
    var hasRequiredNames;

    function requireNames () {
    	if (hasRequiredNames) return names;
    	hasRequiredNames = 1;
    	var hasOwnProperty = Object.prototype.hasOwnProperty;
    	var keywords = Object.create(null);
    	var properties = Object.create(null);
    	var HYPHENMINUS = 45; // '-'.charCodeAt()

    	function isCustomProperty(str, offset) {
    	    offset = offset || 0;

    	    return str.length - offset >= 2 &&
    	           str.charCodeAt(offset) === HYPHENMINUS &&
    	           str.charCodeAt(offset + 1) === HYPHENMINUS;
    	}

    	function getVendorPrefix(str, offset) {
    	    offset = offset || 0;

    	    // verdor prefix should be at least 3 chars length
    	    if (str.length - offset >= 3) {
    	        // vendor prefix starts with hyper minus following non-hyper minus
    	        if (str.charCodeAt(offset) === HYPHENMINUS &&
    	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
    	            // vendor prefix should contain a hyper minus at the ending
    	            var secondDashIndex = str.indexOf('-', offset + 2);

    	            if (secondDashIndex !== -1) {
    	                return str.substring(offset, secondDashIndex + 1);
    	            }
    	        }
    	    }

    	    return '';
    	}

    	function getKeywordDescriptor(keyword) {
    	    if (hasOwnProperty.call(keywords, keyword)) {
    	        return keywords[keyword];
    	    }

    	    var name = keyword.toLowerCase();

    	    if (hasOwnProperty.call(keywords, name)) {
    	        return keywords[keyword] = keywords[name];
    	    }

    	    var custom = isCustomProperty(name, 0);
    	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

    	    return keywords[keyword] = Object.freeze({
    	        basename: name.substr(vendor.length),
    	        name: name,
    	        vendor: vendor,
    	        prefix: vendor,
    	        custom: custom
    	    });
    	}

    	function getPropertyDescriptor(property) {
    	    if (hasOwnProperty.call(properties, property)) {
    	        return properties[property];
    	    }

    	    var name = property;
    	    var hack = property[0];

    	    if (hack === '/') {
    	        hack = property[1] === '/' ? '//' : '/';
    	    } else if (hack !== '_' &&
    	               hack !== '*' &&
    	               hack !== '$' &&
    	               hack !== '#' &&
    	               hack !== '+' &&
    	               hack !== '&') {
    	        hack = '';
    	    }

    	    var custom = isCustomProperty(name, hack.length);

    	    // re-use result when possible (the same as for lower case)
    	    if (!custom) {
    	        name = name.toLowerCase();
    	        if (hasOwnProperty.call(properties, name)) {
    	            return properties[property] = properties[name];
    	        }
    	    }

    	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
    	    var prefix = name.substr(0, hack.length + vendor.length);

    	    return properties[property] = Object.freeze({
    	        basename: name.substr(prefix.length),
    	        name: name.substr(hack.length),
    	        hack: hack,
    	        vendor: vendor,
    	        prefix: prefix,
    	        custom: custom
    	    });
    	}

    	names = {
    	    keyword: getKeywordDescriptor,
    	    property: getPropertyDescriptor,
    	    isCustomProperty: isCustomProperty,
    	    vendorPrefix: getVendorPrefix
    	};
    	return names;
    }

    var adoptBuffer;
    var hasRequiredAdoptBuffer;

    function requireAdoptBuffer () {
    	if (hasRequiredAdoptBuffer) return adoptBuffer;
    	hasRequiredAdoptBuffer = 1;
    	var MIN_SIZE = 16 * 1024;
    	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

    	adoptBuffer = function adoptBuffer(buffer, size) {
    	    if (buffer === null || buffer.length < size) {
    	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
    	    }

    	    return buffer;
    	};
    	return adoptBuffer;
    }

    var tokenizer$1;
    var hasRequiredTokenizer$1;

    function requireTokenizer$1 () {
    	if (hasRequiredTokenizer$1) return tokenizer$1;
    	hasRequiredTokenizer$1 = 1;
    	var TokenStream = requireTokenStream();
    	var adoptBuffer = requireAdoptBuffer();

    	var constants = require_const();
    	var TYPE = constants.TYPE;

    	var charCodeDefinitions = requireCharCodeDefinitions();
    	var isNewline = charCodeDefinitions.isNewline;
    	var isName = charCodeDefinitions.isName;
    	var isValidEscape = charCodeDefinitions.isValidEscape;
    	var isNumberStart = charCodeDefinitions.isNumberStart;
    	var isIdentifierStart = charCodeDefinitions.isIdentifierStart;
    	var charCodeCategory = charCodeDefinitions.charCodeCategory;
    	var isBOM = charCodeDefinitions.isBOM;

    	var utils = requireUtils();
    	var cmpStr = utils.cmpStr;
    	var getNewlineLength = utils.getNewlineLength;
    	var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
    	var consumeEscaped = utils.consumeEscaped;
    	var consumeName = utils.consumeName;
    	var consumeNumber = utils.consumeNumber;
    	var consumeBadUrlRemnants = utils.consumeBadUrlRemnants;

    	var OFFSET_MASK = 0x00FFFFFF;
    	var TYPE_SHIFT = 24;

    	function tokenize(source, stream) {
    	    function getCharCode(offset) {
    	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
    	    }

    	    //  4.3.3. Consume a numeric token
    	    function consumeNumericToken() {
    	        // Consume a number and let number be the result.
    	        offset = consumeNumber(source, offset);

    	        // If the next 3 input code points would start an identifier, then:
    	        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
    	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
    	            // Consume a name. Set the <dimension-token>s unit to the returned value.
    	            // Return the <dimension-token>.
    	            type = TYPE.Dimension;
    	            offset = consumeName(source, offset);
    	            return;
    	        }

    	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
    	        if (getCharCode(offset) === 0x0025) {
    	            // Create a <percentage-token> with the same value as number, and return it.
    	            type = TYPE.Percentage;
    	            offset++;
    	            return;
    	        }

    	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
    	        type = TYPE.Number;
    	    }

    	    //  4.3.4. Consume an ident-like token
    	    function consumeIdentLikeToken() {
    	        const nameStartOffset = offset;

    	        // Consume a name, and let string be the result.
    	        offset = consumeName(source, offset);

    	        // If strings value is an ASCII case-insensitive match for "url",
    	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
    	        if (cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
    	            // While the next two input code points are whitespace, consume the next input code point.
    	            offset = findWhiteSpaceEnd(source, offset + 1);

    	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
    	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
    	            // then create a <function-token> with its value set to string and return it.
    	            if (getCharCode(offset) === 0x0022 ||
    	                getCharCode(offset) === 0x0027) {
    	                type = TYPE.Function;
    	                offset = nameStartOffset + 4;
    	                return;
    	            }

    	            // Otherwise, consume a url token, and return it.
    	            consumeUrlToken();
    	            return;
    	        }

    	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
    	        // Create a <function-token> with its value set to string and return it.
    	        if (getCharCode(offset) === 0x0028) {
    	            type = TYPE.Function;
    	            offset++;
    	            return;
    	        }

    	        // Otherwise, create an <ident-token> with its value set to string and return it.
    	        type = TYPE.Ident;
    	    }

    	    //  4.3.5. Consume a string token
    	    function consumeStringToken(endingCodePoint) {
    	        // This algorithm may be called with an ending code point, which denotes the code point
    	        // that ends the string. If an ending code point is not specified,
    	        // the current input code point is used.
    	        if (!endingCodePoint) {
    	            endingCodePoint = getCharCode(offset++);
    	        }

    	        // Initially create a <string-token> with its value set to the empty string.
    	        type = TYPE.String;

    	        // Repeatedly consume the next input code point from the stream:
    	        for (; offset < source.length; offset++) {
    	            var code = source.charCodeAt(offset);

    	            switch (charCodeCategory(code)) {
    	                // ending code point
    	                case endingCodePoint:
    	                    // Return the <string-token>.
    	                    offset++;
    	                    return;

    	                // EOF
    	                case charCodeCategory.Eof:
    	                    // This is a parse error. Return the <string-token>.
    	                    return;

    	                // newline
    	                case charCodeCategory.WhiteSpace:
    	                    if (isNewline(code)) {
    	                        // This is a parse error. Reconsume the current input code point,
    	                        // create a <bad-string-token>, and return it.
    	                        offset += getNewlineLength(source, offset, code);
    	                        type = TYPE.BadString;
    	                        return;
    	                    }
    	                    break;

    	                // U+005C REVERSE SOLIDUS (\)
    	                case 0x005C:
    	                    // If the next input code point is EOF, do nothing.
    	                    if (offset === source.length - 1) {
    	                        break;
    	                    }

    	                    var nextCode = getCharCode(offset + 1);

    	                    // Otherwise, if the next input code point is a newline, consume it.
    	                    if (isNewline(nextCode)) {
    	                        offset += getNewlineLength(source, offset + 1, nextCode);
    	                    } else if (isValidEscape(code, nextCode)) {
    	                        // Otherwise, (the stream starts with a valid escape) consume
    	                        // an escaped code point and append the returned code point to
    	                        // the <string-token>s value.
    	                        offset = consumeEscaped(source, offset) - 1;
    	                    }
    	                    break;

    	                // anything else
    	                // Append the current input code point to the <string-token>s value.
    	            }
    	        }
    	    }

    	    //  4.3.6. Consume a url token
    	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
    	    // This algorithm also assumes that its being called to consume an "unquoted" value, like url(foo).
    	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
    	    // automatically handles this distinction; this algorithm shouldnt be called directly otherwise.
    	    function consumeUrlToken() {
    	        // Initially create a <url-token> with its value set to the empty string.
    	        type = TYPE.Url;

    	        // Consume as much whitespace as possible.
    	        offset = findWhiteSpaceEnd(source, offset);

    	        // Repeatedly consume the next input code point from the stream:
    	        for (; offset < source.length; offset++) {
    	            var code = source.charCodeAt(offset);

    	            switch (charCodeCategory(code)) {
    	                // U+0029 RIGHT PARENTHESIS ())
    	                case 0x0029:
    	                    // Return the <url-token>.
    	                    offset++;
    	                    return;

    	                // EOF
    	                case charCodeCategory.Eof:
    	                    // This is a parse error. Return the <url-token>.
    	                    return;

    	                // whitespace
    	                case charCodeCategory.WhiteSpace:
    	                    // Consume as much whitespace as possible.
    	                    offset = findWhiteSpaceEnd(source, offset);

    	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
    	                    // consume it and return the <url-token>
    	                    // (if EOF was encountered, this is a parse error);
    	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
    	                        if (offset < source.length) {
    	                            offset++;
    	                        }
    	                        return;
    	                    }

    	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
    	                    // and return it.
    	                    offset = consumeBadUrlRemnants(source, offset);
    	                    type = TYPE.BadUrl;
    	                    return;

    	                // U+0022 QUOTATION MARK (")
    	                // U+0027 APOSTROPHE (')
    	                // U+0028 LEFT PARENTHESIS (()
    	                // non-printable code point
    	                case 0x0022:
    	                case 0x0027:
    	                case 0x0028:
    	                case charCodeCategory.NonPrintable:
    	                    // This is a parse error. Consume the remnants of a bad url,
    	                    // create a <bad-url-token>, and return it.
    	                    offset = consumeBadUrlRemnants(source, offset);
    	                    type = TYPE.BadUrl;
    	                    return;

    	                // U+005C REVERSE SOLIDUS (\)
    	                case 0x005C:
    	                    // If the stream starts with a valid escape, consume an escaped code point and
    	                    // append the returned code point to the <url-token>s value.
    	                    if (isValidEscape(code, getCharCode(offset + 1))) {
    	                        offset = consumeEscaped(source, offset) - 1;
    	                        break;
    	                    }

    	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
    	                    // create a <bad-url-token>, and return it.
    	                    offset = consumeBadUrlRemnants(source, offset);
    	                    type = TYPE.BadUrl;
    	                    return;

    	                // anything else
    	                // Append the current input code point to the <url-token>s value.
    	            }
    	        }
    	    }

    	    if (!stream) {
    	        stream = new TokenStream();
    	    }

    	    // ensure source is a string
    	    source = String(source || '');

    	    var sourceLength = source.length;
    	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
    	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
    	    var tokenCount = 0;
    	    var start = isBOM(getCharCode(0));
    	    var offset = start;
    	    var balanceCloseType = 0;
    	    var balanceStart = 0;
    	    var balancePrev = 0;

    	    // https://drafts.csswg.org/css-syntax-3/#consume-token
    	    //  4.3.1. Consume a token
    	    while (offset < sourceLength) {
    	        var code = source.charCodeAt(offset);
    	        var type = 0;

    	        balance[tokenCount] = sourceLength;

    	        switch (charCodeCategory(code)) {
    	            // whitespace
    	            case charCodeCategory.WhiteSpace:
    	                // Consume as much whitespace as possible. Return a <whitespace-token>.
    	                type = TYPE.WhiteSpace;
    	                offset = findWhiteSpaceEnd(source, offset + 1);
    	                break;

    	            // U+0022 QUOTATION MARK (")
    	            case 0x0022:
    	                // Consume a string token and return it.
    	                consumeStringToken();
    	                break;

    	            // U+0023 NUMBER SIGN (#)
    	            case 0x0023:
    	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
    	                if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
    	                    // Create a <hash-token>.
    	                    type = TYPE.Hash;

    	                    // If the next 3 input code points would start an identifier, set the <hash-token>s type flag to "id".
    	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
    	                    //     // TODO: set id flag
    	                    // }

    	                    // Consume a name, and set the <hash-token>s value to the returned string.
    	                    offset = consumeName(source, offset + 1);

    	                    // Return the <hash-token>.
    	                } else {
    	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
    	                    type = TYPE.Delim;
    	                    offset++;
    	                }

    	                break;

    	            // U+0027 APOSTROPHE (')
    	            case 0x0027:
    	                // Consume a string token and return it.
    	                consumeStringToken();
    	                break;

    	            // U+0028 LEFT PARENTHESIS (()
    	            case 0x0028:
    	                // Return a <(-token>.
    	                type = TYPE.LeftParenthesis;
    	                offset++;
    	                break;

    	            // U+0029 RIGHT PARENTHESIS ())
    	            case 0x0029:
    	                // Return a <)-token>.
    	                type = TYPE.RightParenthesis;
    	                offset++;
    	                break;

    	            // U+002B PLUS SIGN (+)
    	            case 0x002B:
    	                // If the input stream starts with a number, ...
    	                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
    	                    // ... reconsume the current input code point, consume a numeric token, and return it.
    	                    consumeNumericToken();
    	                } else {
    	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
    	                    type = TYPE.Delim;
    	                    offset++;
    	                }
    	                break;

    	            // U+002C COMMA (,)
    	            case 0x002C:
    	                // Return a <comma-token>.
    	                type = TYPE.Comma;
    	                offset++;
    	                break;

    	            // U+002D HYPHEN-MINUS (-)
    	            case 0x002D:
    	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
    	                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
    	                    consumeNumericToken();
    	                } else {
    	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
    	                    if (getCharCode(offset + 1) === 0x002D &&
    	                        getCharCode(offset + 2) === 0x003E) {
    	                        type = TYPE.CDC;
    	                        offset = offset + 3;
    	                    } else {
    	                        // Otherwise, if the input stream starts with an identifier, ...
    	                        if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
    	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
    	                            consumeIdentLikeToken();
    	                        } else {
    	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
    	                            type = TYPE.Delim;
    	                            offset++;
    	                        }
    	                    }
    	                }
    	                break;

    	            // U+002E FULL STOP (.)
    	            case 0x002E:
    	                // If the input stream starts with a number, ...
    	                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
    	                    // ... reconsume the current input code point, consume a numeric token, and return it.
    	                    consumeNumericToken();
    	                } else {
    	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
    	                    type = TYPE.Delim;
    	                    offset++;
    	                }

    	                break;

    	            // U+002F SOLIDUS (/)
    	            case 0x002F:
    	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
    	                if (getCharCode(offset + 1) === 0x002A) {
    	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
    	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
    	                    type = TYPE.Comment;
    	                    offset = source.indexOf('*/', offset + 2) + 2;
    	                    if (offset === 1) {
    	                        offset = source.length;
    	                    }
    	                } else {
    	                    type = TYPE.Delim;
    	                    offset++;
    	                }
    	                break;

    	            // U+003A COLON (:)
    	            case 0x003A:
    	                // Return a <colon-token>.
    	                type = TYPE.Colon;
    	                offset++;
    	                break;

    	            // U+003B SEMICOLON (;)
    	            case 0x003B:
    	                // Return a <semicolon-token>.
    	                type = TYPE.Semicolon;
    	                offset++;
    	                break;

    	            // U+003C LESS-THAN SIGN (<)
    	            case 0x003C:
    	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
    	                if (getCharCode(offset + 1) === 0x0021 &&
    	                    getCharCode(offset + 2) === 0x002D &&
    	                    getCharCode(offset + 3) === 0x002D) {
    	                    // ... consume them and return a <CDO-token>.
    	                    type = TYPE.CDO;
    	                    offset = offset + 4;
    	                } else {
    	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
    	                    type = TYPE.Delim;
    	                    offset++;
    	                }

    	                break;

    	            // U+0040 COMMERCIAL AT (@)
    	            case 0x0040:
    	                // If the next 3 input code points would start an identifier, ...
    	                if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
    	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
    	                    type = TYPE.AtKeyword;
    	                    offset = consumeName(source, offset + 1);
    	                } else {
    	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
    	                    type = TYPE.Delim;
    	                    offset++;
    	                }

    	                break;

    	            // U+005B LEFT SQUARE BRACKET ([)
    	            case 0x005B:
    	                // Return a <[-token>.
    	                type = TYPE.LeftSquareBracket;
    	                offset++;
    	                break;

    	            // U+005C REVERSE SOLIDUS (\)
    	            case 0x005C:
    	                // If the input stream starts with a valid escape, ...
    	                if (isValidEscape(code, getCharCode(offset + 1))) {
    	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
    	                    consumeIdentLikeToken();
    	                } else {
    	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
    	                    type = TYPE.Delim;
    	                    offset++;
    	                }
    	                break;

    	            // U+005D RIGHT SQUARE BRACKET (])
    	            case 0x005D:
    	                // Return a <]-token>.
    	                type = TYPE.RightSquareBracket;
    	                offset++;
    	                break;

    	            // U+007B LEFT CURLY BRACKET ({)
    	            case 0x007B:
    	                // Return a <{-token>.
    	                type = TYPE.LeftCurlyBracket;
    	                offset++;
    	                break;

    	            // U+007D RIGHT CURLY BRACKET (})
    	            case 0x007D:
    	                // Return a <}-token>.
    	                type = TYPE.RightCurlyBracket;
    	                offset++;
    	                break;

    	            // digit
    	            case charCodeCategory.Digit:
    	                // Reconsume the current input code point, consume a numeric token, and return it.
    	                consumeNumericToken();
    	                break;

    	            // name-start code point
    	            case charCodeCategory.NameStart:
    	                // Reconsume the current input code point, consume an ident-like token, and return it.
    	                consumeIdentLikeToken();
    	                break;

    	            // EOF
    	            case charCodeCategory.Eof:
    	                // Return an <EOF-token>.
    	                break;

    	            // anything else
    	            default:
    	                // Return a <delim-token> with its value set to the current input code point.
    	                type = TYPE.Delim;
    	                offset++;
    	        }

    	        switch (type) {
    	            case balanceCloseType:
    	                balancePrev = balanceStart & OFFSET_MASK;
    	                balanceStart = balance[balancePrev];
    	                balanceCloseType = balanceStart >> TYPE_SHIFT;
    	                balance[tokenCount] = balancePrev;
    	                balance[balancePrev++] = tokenCount;
    	                for (; balancePrev < tokenCount; balancePrev++) {
    	                    if (balance[balancePrev] === sourceLength) {
    	                        balance[balancePrev] = tokenCount;
    	                    }
    	                }
    	                break;

    	            case TYPE.LeftParenthesis:
    	            case TYPE.Function:
    	                balance[tokenCount] = balanceStart;
    	                balanceCloseType = TYPE.RightParenthesis;
    	                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
    	                break;

    	            case TYPE.LeftSquareBracket:
    	                balance[tokenCount] = balanceStart;
    	                balanceCloseType = TYPE.RightSquareBracket;
    	                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
    	                break;

    	            case TYPE.LeftCurlyBracket:
    	                balance[tokenCount] = balanceStart;
    	                balanceCloseType = TYPE.RightCurlyBracket;
    	                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
    	                break;
    	        }

    	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
    	    }

    	    // finalize buffers
    	    offsetAndType[tokenCount] = (TYPE.EOF << TYPE_SHIFT) | offset; // <EOF-token>
    	    balance[tokenCount] = sourceLength;
    	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
    	    while (balanceStart !== 0) {
    	        balancePrev = balanceStart & OFFSET_MASK;
    	        balanceStart = balance[balancePrev];
    	        balance[balancePrev] = sourceLength;
    	    }

    	    // update stream
    	    stream.source = source;
    	    stream.firstCharOffset = start;
    	    stream.offsetAndType = offsetAndType;
    	    stream.tokenCount = tokenCount;
    	    stream.balance = balance;
    	    stream.reset();
    	    stream.next();

    	    return stream;
    	}

    	// extend tokenizer with constants
    	Object.keys(constants).forEach(function(key) {
    	    tokenize[key] = constants[key];
    	});

    	// extend tokenizer with static methods from utils
    	Object.keys(charCodeDefinitions).forEach(function(key) {
    	    tokenize[key] = charCodeDefinitions[key];
    	});
    	Object.keys(utils).forEach(function(key) {
    	    tokenize[key] = utils[key];
    	});

    	tokenizer$1 = tokenize;
    	return tokenizer$1;
    }

    var genericAnPlusB;
    var hasRequiredGenericAnPlusB;

    function requireGenericAnPlusB () {
    	if (hasRequiredGenericAnPlusB) return genericAnPlusB;
    	hasRequiredGenericAnPlusB = 1;
    	var isDigit = requireTokenizer$1().isDigit;
    	var cmpChar = requireTokenizer$1().cmpChar;
    	var TYPE = requireTokenizer$1().TYPE;

    	var DELIM = TYPE.Delim;
    	var WHITESPACE = TYPE.WhiteSpace;
    	var COMMENT = TYPE.Comment;
    	var IDENT = TYPE.Ident;
    	var NUMBER = TYPE.Number;
    	var DIMENSION = TYPE.Dimension;
    	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
    	var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
    	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
    	var DISALLOW_SIGN = true;
    	var ALLOW_SIGN = false;

    	function isDelim(token, code) {
    	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
    	}

    	function skipSC(token, offset, getNextToken) {
    	    while (token !== null && (token.type === WHITESPACE || token.type === COMMENT)) {
    	        token = getNextToken(++offset);
    	    }

    	    return offset;
    	}

    	function checkInteger(token, valueOffset, disallowSign, offset) {
    	    if (!token) {
    	        return 0;
    	    }

    	    var code = token.value.charCodeAt(valueOffset);

    	    if (code === PLUSSIGN || code === HYPHENMINUS) {
    	        if (disallowSign) {
    	            // Number sign is not allowed
    	            return 0;
    	        }
    	        valueOffset++;
    	    }

    	    for (; valueOffset < token.value.length; valueOffset++) {
    	        if (!isDigit(token.value.charCodeAt(valueOffset))) {
    	            // Integer is expected
    	            return 0;
    	        }
    	    }

    	    return offset + 1;
    	}

    	// ... <signed-integer>
    	// ... ['+' | '-'] <signless-integer>
    	function consumeB(token, offset_, getNextToken) {
    	    var sign = false;
    	    var offset = skipSC(token, offset_, getNextToken);

    	    token = getNextToken(offset);

    	    if (token === null) {
    	        return offset_;
    	    }

    	    if (token.type !== NUMBER) {
    	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
    	            sign = true;
    	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
    	            token = getNextToken(offset);

    	            if (token === null && token.type !== NUMBER) {
    	                return 0;
    	            }
    	        } else {
    	            return offset_;
    	        }
    	    }

    	    if (!sign) {
    	        var code = token.value.charCodeAt(0);
    	        if (code !== PLUSSIGN && code !== HYPHENMINUS) {
    	            // Number sign is expected
    	            return 0;
    	        }
    	    }

    	    return checkInteger(token, sign ? 0 : 1, sign, offset);
    	}

    	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
    	genericAnPlusB = function anPlusB(token, getNextToken) {
    	    /* eslint-disable brace-style*/
    	    var offset = 0;

    	    if (!token) {
    	        return 0;
    	    }

    	    // <integer>
    	    if (token.type === NUMBER) {
    	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
    	    }

    	    // -n
    	    // -n <signed-integer>
    	    // -n ['+' | '-'] <signless-integer>
    	    // -n- <signless-integer>
    	    // <dashndashdigit-ident>
    	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS) {
    	        // expect 1st char is N
    	        if (!cmpChar(token.value, 1, N)) {
    	            return 0;
    	        }

    	        switch (token.value.length) {
    	            // -n
    	            // -n <signed-integer>
    	            // -n ['+' | '-'] <signless-integer>
    	            case 2:
    	                return consumeB(getNextToken(++offset), offset, getNextToken);

    	            // -n- <signless-integer>
    	            case 3:
    	                if (token.value.charCodeAt(2) !== HYPHENMINUS) {
    	                    return 0;
    	                }

    	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
    	                token = getNextToken(offset);

    	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

    	            // <dashndashdigit-ident>
    	            default:
    	                if (token.value.charCodeAt(2) !== HYPHENMINUS) {
    	                    return 0;
    	                }

    	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
    	        }
    	    }

    	    // '+'? n
    	    // '+'? n <signed-integer>
    	    // '+'? n ['+' | '-'] <signless-integer>
    	    // '+'? n- <signless-integer>
    	    // '+'? <ndashdigit-ident>
    	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
    	        // just ignore a plus
    	        if (token.type !== IDENT) {
    	            token = getNextToken(++offset);
    	        }

    	        if (token === null || !cmpChar(token.value, 0, N)) {
    	            return 0;
    	        }

    	        switch (token.value.length) {
    	            // '+'? n
    	            // '+'? n <signed-integer>
    	            // '+'? n ['+' | '-'] <signless-integer>
    	            case 1:
    	                return consumeB(getNextToken(++offset), offset, getNextToken);

    	            // '+'? n- <signless-integer>
    	            case 2:
    	                if (token.value.charCodeAt(1) !== HYPHENMINUS) {
    	                    return 0;
    	                }

    	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
    	                token = getNextToken(offset);

    	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

    	            // '+'? <ndashdigit-ident>
    	            default:
    	                if (token.value.charCodeAt(1) !== HYPHENMINUS) {
    	                    return 0;
    	                }

    	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
    	        }
    	    }

    	    // <ndashdigit-dimension>
    	    // <ndash-dimension> <signless-integer>
    	    // <n-dimension>
    	    // <n-dimension> <signed-integer>
    	    // <n-dimension> ['+' | '-'] <signless-integer>
    	    else if (token.type === DIMENSION) {
    	        var code = token.value.charCodeAt(0);
    	        var sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;

    	        for (var i = sign; i < token.value.length; i++) {
    	            if (!isDigit(token.value.charCodeAt(i))) {
    	                break;
    	            }
    	        }

    	        if (i === sign) {
    	            // Integer is expected
    	            return 0;
    	        }

    	        if (!cmpChar(token.value, i, N)) {
    	            return 0;
    	        }

    	        // <n-dimension>
    	        // <n-dimension> <signed-integer>
    	        // <n-dimension> ['+' | '-'] <signless-integer>
    	        if (i + 1 === token.value.length) {
    	            return consumeB(getNextToken(++offset), offset, getNextToken);
    	        } else {
    	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
    	                return 0;
    	            }

    	            // <ndash-dimension> <signless-integer>
    	            if (i + 2 === token.value.length) {
    	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
    	                token = getNextToken(offset);

    	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
    	            }
    	            // <ndashdigit-dimension>
    	            else {
    	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
    	            }
    	        }
    	    }

    	    return 0;
    	};
    	return genericAnPlusB;
    }

    var genericUrange;
    var hasRequiredGenericUrange;

    function requireGenericUrange () {
    	if (hasRequiredGenericUrange) return genericUrange;
    	hasRequiredGenericUrange = 1;
    	var isHexDigit = requireTokenizer$1().isHexDigit;
    	var cmpChar = requireTokenizer$1().cmpChar;
    	var TYPE = requireTokenizer$1().TYPE;

    	var IDENT = TYPE.Ident;
    	var DELIM = TYPE.Delim;
    	var NUMBER = TYPE.Number;
    	var DIMENSION = TYPE.Dimension;
    	var PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)
    	var HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)
    	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
    	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

    	function isDelim(token, code) {
    	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
    	}

    	function startsWith(token, code) {
    	    return token.value.charCodeAt(0) === code;
    	}

    	function hexSequence(token, offset, allowDash) {
    	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
    	        var code = token.value.charCodeAt(pos);

    	        if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
    	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
    	                return 6; // dissallow following question marks
    	            }

    	            return 0; // dash at the ending of a hex sequence is not allowed
    	        }

    	        if (!isHexDigit(code)) {
    	            return 0; // not a hex digit
    	        }

    	        if (++hexlen > 6) {
    	            return 0; // too many hex digits
    	        }	    }

    	    return hexlen;
    	}

    	function withQuestionMarkSequence(consumed, length, getNextToken) {
    	    if (!consumed) {
    	        return 0; // nothing consumed
    	    }

    	    while (isDelim(getNextToken(length), QUESTIONMARK)) {
    	        if (++consumed > 6) {
    	            return 0; // too many question marks
    	        }

    	        length++;
    	    }

    	    return length;
    	}

    	// https://drafts.csswg.org/css-syntax/#urange
    	// Informally, the <urange> production has three forms:
    	// U+0001
    	//      Defines a range consisting of a single code point, in this case the code point "1".
    	// U+0001-00ff
    	//      Defines a range of codepoints between the first and the second value, in this case
    	//      the range between "1" and "ff" (255 in decimal) inclusive.
    	// U+00??
    	//      Defines a range of codepoints where the "?" characters range over all hex digits,
    	//      in this case defining the same as the value U+0000-00ff.
    	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
    	//
    	// <urange> =
    	//   u '+' <ident-token> '?'* |
    	//   u <dimension-token> '?'* |
    	//   u <number-token> '?'* |
    	//   u <number-token> <dimension-token> |
    	//   u <number-token> <number-token> |
    	//   u '+' '?'+
    	genericUrange = function urange(token, getNextToken) {
    	    var length = 0;

    	    // should start with `u` or `U`
    	    if (token === null || token.type !== IDENT || !cmpChar(token.value, 0, U)) {
    	        return 0;
    	    }

    	    token = getNextToken(++length);
    	    if (token === null) {
    	        return 0;
    	    }

    	    // u '+' <ident-token> '?'*
    	    // u '+' '?'+
    	    if (isDelim(token, PLUSSIGN)) {
    	        token = getNextToken(++length);
    	        if (token === null) {
    	            return 0;
    	        }

    	        if (token.type === IDENT) {
    	            // u '+' <ident-token> '?'*
    	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
    	        }

    	        if (isDelim(token, QUESTIONMARK)) {
    	            // u '+' '?'+
    	            return withQuestionMarkSequence(1, ++length, getNextToken);
    	        }

    	        // Hex digit or question mark is expected
    	        return 0;
    	    }

    	    // u <number-token> '?'*
    	    // u <number-token> <dimension-token>
    	    // u <number-token> <number-token>
    	    if (token.type === NUMBER) {
    	        if (!startsWith(token, PLUSSIGN)) {
    	            return 0;
    	        }

    	        var consumedHexLength = hexSequence(token, 1, true);
    	        if (consumedHexLength === 0) {
    	            return 0;
    	        }

    	        token = getNextToken(++length);
    	        if (token === null) {
    	            // u <number-token> <eof>
    	            return length;
    	        }

    	        if (token.type === DIMENSION || token.type === NUMBER) {
    	            // u <number-token> <dimension-token>
    	            // u <number-token> <number-token>
    	            if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {
    	                return 0;
    	            }

    	            return length + 1;
    	        }

    	        // u <number-token> '?'*
    	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
    	    }

    	    // u <dimension-token> '?'*
    	    if (token.type === DIMENSION) {
    	        if (!startsWith(token, PLUSSIGN)) {
    	            return 0;
    	        }

    	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
    	    }

    	    return 0;
    	};
    	return genericUrange;
    }

    var generic;
    var hasRequiredGeneric;

    function requireGeneric () {
    	if (hasRequiredGeneric) return generic;
    	hasRequiredGeneric = 1;
    	var tokenizer = requireTokenizer$1();
    	var isIdentifierStart = tokenizer.isIdentifierStart;
    	var isHexDigit = tokenizer.isHexDigit;
    	var isDigit = tokenizer.isDigit;
    	var cmpStr = tokenizer.cmpStr;
    	var consumeNumber = tokenizer.consumeNumber;
    	var TYPE = tokenizer.TYPE;
    	var anPlusB = requireGenericAnPlusB();
    	var urange = requireGenericUrange();

    	var cssWideKeywords = ['unset', 'initial', 'inherit'];
    	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

    	// https://www.w3.org/TR/css-values-3/#lengths
    	var LENGTH = {
    	    // absolute length units
    	    'px': true,
    	    'mm': true,
    	    'cm': true,
    	    'in': true,
    	    'pt': true,
    	    'pc': true,
    	    'q': true,

    	    // relative length units
    	    'em': true,
    	    'ex': true,
    	    'ch': true,
    	    'rem': true,

    	    // viewport-percentage lengths
    	    'vh': true,
    	    'vw': true,
    	    'vmin': true,
    	    'vmax': true,
    	    'vm': true
    	};

    	var ANGLE = {
    	    'deg': true,
    	    'grad': true,
    	    'rad': true,
    	    'turn': true
    	};

    	var TIME = {
    	    's': true,
    	    'ms': true
    	};

    	var FREQUENCY = {
    	    'hz': true,
    	    'khz': true
    	};

    	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
    	var RESOLUTION = {
    	    'dpi': true,
    	    'dpcm': true,
    	    'dppx': true,
    	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
    	};

    	// https://drafts.csswg.org/css-grid/#fr-unit
    	var FLEX = {
    	    'fr': true
    	};

    	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
    	var DECIBEL = {
    	    'db': true
    	};

    	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
    	var SEMITONES = {
    	    'st': true
    	};

    	// safe char code getter
    	function charCode(str, index) {
    	    return index < str.length ? str.charCodeAt(index) : 0;
    	}

    	function eqStr(actual, expected) {
    	    return cmpStr(actual, 0, actual.length, expected);
    	}

    	function eqStrAny(actual, expected) {
    	    for (var i = 0; i < expected.length; i++) {
    	        if (eqStr(actual, expected[i])) {
    	            return true;
    	        }
    	    }

    	    return false;
    	}

    	// IE postfix hack, i.e. 123\0 or 123px\9
    	function isPostfixIeHack(str, offset) {
    	    if (offset !== str.length - 2) {
    	        return false;
    	    }

    	    return (
    	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
    	        isDigit(str.charCodeAt(offset + 1))
    	    );
    	}

    	function outOfRange(opts, value, numEnd) {
    	    if (opts && opts.type === 'Range') {
    	        var num = Number(
    	            numEnd !== undefined && numEnd !== value.length
    	                ? value.substr(0, numEnd)
    	                : value
    	        );

    	        if (isNaN(num)) {
    	            return true;
    	        }

    	        if (opts.min !== null && num < opts.min) {
    	            return true;
    	        }

    	        if (opts.max !== null && num > opts.max) {
    	            return true;
    	        }
    	    }

    	    return false;
    	}

    	function consumeFunction(token, getNextToken) {
    	    var startIdx = token.index;
    	    var length = 0;

    	    // balanced token consuming
    	    do {
    	        length++;

    	        if (token.balance <= startIdx) {
    	            break;
    	        }
    	    } while (token = getNextToken(length));

    	    return length;
    	}

    	// TODO: implement
    	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
    	// https://drafts.csswg.org/css-values/#calc-notation
    	function calc(next) {
    	    return function(token, getNextToken, opts) {
    	        if (token === null) {
    	            return 0;
    	        }

    	        if (token.type === TYPE.Function && eqStrAny(token.value, calcFunctionNames)) {
    	            return consumeFunction(token, getNextToken);
    	        }

    	        return next(token, getNextToken, opts);
    	    };
    	}

    	function tokenType(expectedTokenType) {
    	    return function(token) {
    	        if (token === null || token.type !== expectedTokenType) {
    	            return 0;
    	        }

    	        return 1;
    	    };
    	}

    	function func(name) {
    	    name = name + '(';

    	    return function(token, getNextToken) {
    	        if (token !== null && eqStr(token.value, name)) {
    	            return consumeFunction(token, getNextToken);
    	        }

    	        return 0;
    	    };
    	}

    	// =========================
    	// Complex types
    	//

    	// https://drafts.csswg.org/css-values-4/#custom-idents
    	// 4.2. Author-defined Identifiers: the <custom-ident> type
    	// Some properties accept arbitrary author-defined identifiers as a component value.
    	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
    	// that would not be misinterpreted as a pre-defined keyword in that propertys value definition.
    	//
    	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
    	function customIdent(token) {
    	    if (token === null || token.type !== TYPE.Ident) {
    	        return 0;
    	    }

    	    var name = token.value.toLowerCase();

    	    // The CSS-wide keywords are not valid <custom-ident>s
    	    if (eqStrAny(name, cssWideKeywords)) {
    	        return 0;
    	    }

    	    // The default keyword is reserved and is also not a valid <custom-ident>
    	    if (eqStr(name, 'default')) {
    	        return 0;
    	    }

    	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
    	    // Specifications using <custom-ident> must specify clearly what other keywords
    	    // are excluded from <custom-ident>, if anyfor example by saying that any pre-defined keywords
    	    // in that propertys value definition are excluded. Excluded keywords are excluded
    	    // in all ASCII case permutations.

    	    return 1;
    	}

    	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
    	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
    	// The <custom-property-name> production corresponds to this: its defined as any valid identifier
    	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
    	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
    	function customPropertyName(token) {
    	    // ... defined as any valid identifier
    	    if (token === null || token.type !== TYPE.Ident) {
    	        return 0;
    	    }

    	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
    	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
    	        return 0;
    	    }

    	    return 1;
    	}

    	// https://drafts.csswg.org/css-color-4/#hex-notation
    	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
    	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
    	// letters a-f (the case of the letters doesnt matter - #00ff00 is identical to #00FF00).
    	function hexColor(token) {
    	    if (token === null || token.type !== TYPE.Hash) {
    	        return 0;
    	    }

    	    var length = token.value.length;

    	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
    	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
    	        return 0;
    	    }

    	    for (var i = 1; i < length; i++) {
    	        if (!isHexDigit(token.value.charCodeAt(i))) {
    	            return 0;
    	        }
    	    }

    	    return 1;
    	}

    	function idSelector(token) {
    	    if (token === null || token.type !== TYPE.Hash) {
    	        return 0;
    	    }

    	    if (!isIdentifierStart(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
    	        return 0;
    	    }

    	    return 1;
    	}

    	// https://drafts.csswg.org/css-syntax/#any-value
    	// It represents the entirety of what a valid declaration can have as its value.
    	function declarationValue(token, getNextToken) {
    	    if (!token) {
    	        return 0;
    	    }

    	    var length = 0;
    	    var level = 0;
    	    var startIdx = token.index;

    	    // The <declaration-value> production matches any sequence of one or more tokens,
    	    // so long as the sequence ...
    	    scan:
    	    do {
    	        switch (token.type) {
    	            // ... does not contain <bad-string-token>, <bad-url-token>,
    	            case TYPE.BadString:
    	            case TYPE.BadUrl:
    	                break scan;

    	            // ... unmatched <)-token>, <]-token>, or <}-token>,
    	            case TYPE.RightCurlyBracket:
    	            case TYPE.RightParenthesis:
    	            case TYPE.RightSquareBracket:
    	                if (token.balance > token.index || token.balance < startIdx) {
    	                    break scan;
    	                }

    	                level--;
    	                break;

    	            // ... or top-level <semicolon-token> tokens
    	            case TYPE.Semicolon:
    	                if (level === 0) {
    	                    break scan;
    	                }

    	                break;

    	            // ... or <delim-token> tokens with a value of "!"
    	            case TYPE.Delim:
    	                if (token.value === '!' && level === 0) {
    	                    break scan;
    	                }

    	                break;

    	            case TYPE.Function:
    	            case TYPE.LeftParenthesis:
    	            case TYPE.LeftSquareBracket:
    	            case TYPE.LeftCurlyBracket:
    	                level++;
    	                break;
    	        }

    	        length++;

    	        // until balance closing
    	        if (token.balance <= startIdx) {
    	            break;
    	        }
    	    } while (token = getNextToken(length));

    	    return length;
    	}

    	// https://drafts.csswg.org/css-syntax/#any-value
    	// The <any-value> production is identical to <declaration-value>, but also
    	// allows top-level <semicolon-token> tokens and <delim-token> tokens
    	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
    	function anyValue(token, getNextToken) {
    	    if (!token) {
    	        return 0;
    	    }

    	    var startIdx = token.index;
    	    var length = 0;

    	    // The <any-value> production matches any sequence of one or more tokens,
    	    // so long as the sequence ...
    	    scan:
    	    do {
    	        switch (token.type) {
    	            // ... does not contain <bad-string-token>, <bad-url-token>,
    	            case TYPE.BadString:
    	            case TYPE.BadUrl:
    	                break scan;

    	            // ... unmatched <)-token>, <]-token>, or <}-token>,
    	            case TYPE.RightCurlyBracket:
    	            case TYPE.RightParenthesis:
    	            case TYPE.RightSquareBracket:
    	                if (token.balance > token.index || token.balance < startIdx) {
    	                    break scan;
    	                }

    	                break;
    	        }

    	        length++;

    	        // until balance closing
    	        if (token.balance <= startIdx) {
    	            break;
    	        }
    	    } while (token = getNextToken(length));

    	    return length;
    	}

    	// =========================
    	// Dimensions
    	//

    	function dimension(type) {
    	    return function(token, getNextToken, opts) {
    	        if (token === null || token.type !== TYPE.Dimension) {
    	            return 0;
    	        }

    	        var numberEnd = consumeNumber(token.value, 0);

    	        // check unit
    	        if (type !== null) {
    	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
    	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
    	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
    	                ? token.value.substr(numberEnd)
    	                : token.value.substring(numberEnd, reverseSolidusOffset);

    	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
    	                return 0;
    	            }
    	        }

    	        // check range if specified
    	        if (outOfRange(opts, token.value, numberEnd)) {
    	            return 0;
    	        }

    	        return 1;
    	    };
    	}

    	// =========================
    	// Percentage
    	//

    	// 5.5. Percentages: the <percentage> type
    	// https://drafts.csswg.org/css-values-4/#percentages
    	function percentage(token, getNextToken, opts) {
    	    // ... corresponds to the <percentage-token> production
    	    if (token === null || token.type !== TYPE.Percentage) {
    	        return 0;
    	    }

    	    // check range if specified
    	    if (outOfRange(opts, token.value, token.value.length - 1)) {
    	        return 0;
    	    }

    	    return 1;
    	}

    	// =========================
    	// Numeric
    	//

    	// https://drafts.csswg.org/css-values-4/#numbers
    	// The value <zero> represents a literal number with the value 0. Expressions that merely
    	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
    	// only literal <number-token>s do.
    	function zero(next) {
    	    if (typeof next !== 'function') {
    	        next = function() {
    	            return 0;
    	        };
    	    }

    	    return function(token, getNextToken, opts) {
    	        if (token !== null && token.type === TYPE.Number) {
    	            if (Number(token.value) === 0) {
    	                return 1;
    	            }
    	        }

    	        return next(token, getNextToken, opts);
    	    };
    	}

    	//  5.3. Real Numbers: the <number> type
    	// https://drafts.csswg.org/css-values-4/#numbers
    	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
    	// ... It corresponds to the <number-token> production
    	function number(token, getNextToken, opts) {
    	    if (token === null) {
    	        return 0;
    	    }

    	    var numberEnd = consumeNumber(token.value, 0);
    	    var isNumber = numberEnd === token.value.length;
    	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
    	        return 0;
    	    }

    	    // check range if specified
    	    if (outOfRange(opts, token.value, numberEnd)) {
    	        return 0;
    	    }

    	    return 1;
    	}

    	// 5.2. Integers: the <integer> type
    	// https://drafts.csswg.org/css-values-4/#integers
    	function integer(token, getNextToken, opts) {
    	    // ... corresponds to a subset of the <number-token> production
    	    if (token === null || token.type !== TYPE.Number) {
    	        return 0;
    	    }

    	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integers sign.
    	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
    	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

    	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
    	    for (; i < token.value.length; i++) {
    	        if (!isDigit(token.value.charCodeAt(i))) {
    	            return 0;
    	        }
    	    }

    	    // check range if specified
    	    if (outOfRange(opts, token.value, i)) {
    	        return 0;
    	    }

    	    return 1;
    	}

    	generic = {
    	    // token types
    	    'ident-token': tokenType(TYPE.Ident),
    	    'function-token': tokenType(TYPE.Function),
    	    'at-keyword-token': tokenType(TYPE.AtKeyword),
    	    'hash-token': tokenType(TYPE.Hash),
    	    'string-token': tokenType(TYPE.String),
    	    'bad-string-token': tokenType(TYPE.BadString),
    	    'url-token': tokenType(TYPE.Url),
    	    'bad-url-token': tokenType(TYPE.BadUrl),
    	    'delim-token': tokenType(TYPE.Delim),
    	    'number-token': tokenType(TYPE.Number),
    	    'percentage-token': tokenType(TYPE.Percentage),
    	    'dimension-token': tokenType(TYPE.Dimension),
    	    'whitespace-token': tokenType(TYPE.WhiteSpace),
    	    'CDO-token': tokenType(TYPE.CDO),
    	    'CDC-token': tokenType(TYPE.CDC),
    	    'colon-token': tokenType(TYPE.Colon),
    	    'semicolon-token': tokenType(TYPE.Semicolon),
    	    'comma-token': tokenType(TYPE.Comma),
    	    '[-token': tokenType(TYPE.LeftSquareBracket),
    	    ']-token': tokenType(TYPE.RightSquareBracket),
    	    '(-token': tokenType(TYPE.LeftParenthesis),
    	    ')-token': tokenType(TYPE.RightParenthesis),
    	    '{-token': tokenType(TYPE.LeftCurlyBracket),
    	    '}-token': tokenType(TYPE.RightCurlyBracket),

    	    // token type aliases
    	    'string': tokenType(TYPE.String),
    	    'ident': tokenType(TYPE.Ident),

    	    // complex types
    	    'custom-ident': customIdent,
    	    'custom-property-name': customPropertyName,
    	    'hex-color': hexColor,
    	    'id-selector': idSelector, // element( <id-selector> )
    	    'an-plus-b': anPlusB,
    	    'urange': urange,
    	    'declaration-value': declarationValue,
    	    'any-value': anyValue,

    	    // dimensions
    	    'dimension': calc(dimension(null)),
    	    'angle': calc(dimension(ANGLE)),
    	    'decibel': calc(dimension(DECIBEL)),
    	    'frequency': calc(dimension(FREQUENCY)),
    	    'flex': calc(dimension(FLEX)),
    	    'length': calc(zero(dimension(LENGTH))),
    	    'resolution': calc(dimension(RESOLUTION)),
    	    'semitones': calc(dimension(SEMITONES)),
    	    'time': calc(dimension(TIME)),

    	    // percentage
    	    'percentage': calc(percentage),

    	    // numeric
    	    'zero': zero(),
    	    'number': calc(number),
    	    'integer': calc(integer),

    	    // old IE stuff
    	    '-ms-legacy-expression': func('expression')
    	};
    	return generic;
    }

    var _SyntaxError;
    var hasRequired_SyntaxError;

    function require_SyntaxError () {
    	if (hasRequired_SyntaxError) return _SyntaxError;
    	hasRequired_SyntaxError = 1;
    	var createCustomError = requireCreateCustomError();

    	_SyntaxError = function SyntaxError(message, input, offset) {
    	    var error = createCustomError('SyntaxError', message);

    	    error.input = input;
    	    error.offset = offset;
    	    error.rawMessage = message;
    	    error.message = error.rawMessage + '\n' +
    	        '  ' + error.input + '\n' +
    	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

    	    return error;
    	};
    	return _SyntaxError;
    }

    var tokenizer;
    var hasRequiredTokenizer;

    function requireTokenizer () {
    	if (hasRequiredTokenizer) return tokenizer;
    	hasRequiredTokenizer = 1;
    	var SyntaxError = require_SyntaxError();

    	var TAB = 9;
    	var N = 10;
    	var F = 12;
    	var R = 13;
    	var SPACE = 32;

    	var Tokenizer = function(str) {
    	    this.str = str;
    	    this.pos = 0;
    	};

    	Tokenizer.prototype = {
    	    charCodeAt: function(pos) {
    	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    	    },
    	    charCode: function() {
    	        return this.charCodeAt(this.pos);
    	    },
    	    nextCharCode: function() {
    	        return this.charCodeAt(this.pos + 1);
    	    },
    	    nextNonWsCode: function(pos) {
    	        return this.charCodeAt(this.findWsEnd(pos));
    	    },
    	    findWsEnd: function(pos) {
    	        for (; pos < this.str.length; pos++) {
    	            var code = this.str.charCodeAt(pos);
    	            if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
    	                break;
    	            }
    	        }

    	        return pos;
    	    },
    	    substringToPos: function(end) {
    	        return this.str.substring(this.pos, this.pos = end);
    	    },
    	    eat: function(code) {
    	        if (this.charCode() !== code) {
    	            this.error('Expect `' + String.fromCharCode(code) + '`');
    	        }

    	        this.pos++;
    	    },
    	    peek: function() {
    	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
    	    },
    	    error: function(message) {
    	        throw new SyntaxError(message, this.str, this.pos);
    	    }
    	};

    	tokenizer = Tokenizer;
    	return tokenizer;
    }

    var parse_1;
    var hasRequiredParse;

    function requireParse () {
    	if (hasRequiredParse) return parse_1;
    	hasRequiredParse = 1;
    	var Tokenizer = requireTokenizer();
    	var TAB = 9;
    	var N = 10;
    	var F = 12;
    	var R = 13;
    	var SPACE = 32;
    	var EXCLAMATIONMARK = 33;    // !
    	var NUMBERSIGN = 35;         // #
    	var AMPERSAND = 38;          // &
    	var APOSTROPHE = 39;         // '
    	var LEFTPARENTHESIS = 40;    // (
    	var RIGHTPARENTHESIS = 41;   // )
    	var ASTERISK = 42;           // *
    	var PLUSSIGN = 43;           // +
    	var COMMA = 44;              // ,
    	var HYPERMINUS = 45;         // -
    	var LESSTHANSIGN = 60;       // <
    	var GREATERTHANSIGN = 62;    // >
    	var QUESTIONMARK = 63;       // ?
    	var COMMERCIALAT = 64;       // @
    	var LEFTSQUAREBRACKET = 91;  // [
    	var RIGHTSQUAREBRACKET = 93; // ]
    	var LEFTCURLYBRACKET = 123;  // {
    	var VERTICALLINE = 124;      // |
    	var RIGHTCURLYBRACKET = 125; // }
    	var INFINITY = 8734;         // 
    	var NAME_CHAR = createCharMap(function(ch) {
    	    return /[a-zA-Z0-9\-]/.test(ch);
    	});
    	var COMBINATOR_PRECEDENCE = {
    	    ' ': 1,
    	    '&&': 2,
    	    '||': 3,
    	    '|': 4
    	};

    	function createCharMap(fn) {
    	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
    	    for (var i = 0; i < 128; i++) {
    	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
    	    }
    	    return array;
    	}

    	function scanSpaces(tokenizer) {
    	    return tokenizer.substringToPos(
    	        tokenizer.findWsEnd(tokenizer.pos)
    	    );
    	}

    	function scanWord(tokenizer) {
    	    var end = tokenizer.pos;

    	    for (; end < tokenizer.str.length; end++) {
    	        var code = tokenizer.str.charCodeAt(end);
    	        if (code >= 128 || NAME_CHAR[code] === 0) {
    	            break;
    	        }
    	    }

    	    if (tokenizer.pos === end) {
    	        tokenizer.error('Expect a keyword');
    	    }

    	    return tokenizer.substringToPos(end);
    	}

    	function scanNumber(tokenizer) {
    	    var end = tokenizer.pos;

    	    for (; end < tokenizer.str.length; end++) {
    	        var code = tokenizer.str.charCodeAt(end);
    	        if (code < 48 || code > 57) {
    	            break;
    	        }
    	    }

    	    if (tokenizer.pos === end) {
    	        tokenizer.error('Expect a number');
    	    }

    	    return tokenizer.substringToPos(end);
    	}

    	function scanString(tokenizer) {
    	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

    	    if (end === -1) {
    	        tokenizer.pos = tokenizer.str.length;
    	        tokenizer.error('Expect an apostrophe');
    	    }

    	    return tokenizer.substringToPos(end + 1);
    	}

    	function readMultiplierRange(tokenizer) {
    	    var min = null;
    	    var max = null;

    	    tokenizer.eat(LEFTCURLYBRACKET);

    	    min = scanNumber(tokenizer);

    	    if (tokenizer.charCode() === COMMA) {
    	        tokenizer.pos++;
    	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
    	            max = scanNumber(tokenizer);
    	        }
    	    } else {
    	        max = min;
    	    }

    	    tokenizer.eat(RIGHTCURLYBRACKET);

    	    return {
    	        min: Number(min),
    	        max: max ? Number(max) : 0
    	    };
    	}

    	function readMultiplier(tokenizer) {
    	    var range = null;
    	    var comma = false;

    	    switch (tokenizer.charCode()) {
    	        case ASTERISK:
    	            tokenizer.pos++;

    	            range = {
    	                min: 0,
    	                max: 0
    	            };

    	            break;

    	        case PLUSSIGN:
    	            tokenizer.pos++;

    	            range = {
    	                min: 1,
    	                max: 0
    	            };

    	            break;

    	        case QUESTIONMARK:
    	            tokenizer.pos++;

    	            range = {
    	                min: 0,
    	                max: 1
    	            };

    	            break;

    	        case NUMBERSIGN:
    	            tokenizer.pos++;

    	            comma = true;

    	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
    	                range = readMultiplierRange(tokenizer);
    	            } else {
    	                range = {
    	                    min: 1,
    	                    max: 0
    	                };
    	            }

    	            break;

    	        case LEFTCURLYBRACKET:
    	            range = readMultiplierRange(tokenizer);
    	            break;

    	        default:
    	            return null;
    	    }

    	    return {
    	        type: 'Multiplier',
    	        comma: comma,
    	        min: range.min,
    	        max: range.max,
    	        term: null
    	    };
    	}

    	function maybeMultiplied(tokenizer, node) {
    	    var multiplier = readMultiplier(tokenizer);

    	    if (multiplier !== null) {
    	        multiplier.term = node;
    	        return multiplier;
    	    }

    	    return node;
    	}

    	function maybeToken(tokenizer) {
    	    var ch = tokenizer.peek();

    	    if (ch === '') {
    	        return null;
    	    }

    	    return {
    	        type: 'Token',
    	        value: ch
    	    };
    	}

    	function readProperty(tokenizer) {
    	    var name;

    	    tokenizer.eat(LESSTHANSIGN);
    	    tokenizer.eat(APOSTROPHE);

    	    name = scanWord(tokenizer);

    	    tokenizer.eat(APOSTROPHE);
    	    tokenizer.eat(GREATERTHANSIGN);

    	    return maybeMultiplied(tokenizer, {
    	        type: 'Property',
    	        name: name
    	    });
    	}

    	// https://drafts.csswg.org/css-values-3/#numeric-ranges
    	// 4.1. Range Restrictions and Range Definition Notation
    	//
    	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
    	// range notation[min,max]within the angle brackets, after the identifying keyword,
    	// indicating a closed range between (and including) min and max.
    	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
    	function readTypeRange(tokenizer) {
    	    // use null for Infinity to make AST format JSON serializable/deserializable
    	    var min = null; // -Infinity
    	    var max = null; // Infinity
    	    var sign = 1;

    	    tokenizer.eat(LEFTSQUAREBRACKET);

    	    if (tokenizer.charCode() === HYPERMINUS) {
    	        tokenizer.peek();
    	        sign = -1;
    	    }

    	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
    	        tokenizer.peek();
    	    } else {
    	        min = sign * Number(scanNumber(tokenizer));
    	    }

    	    scanSpaces(tokenizer);
    	    tokenizer.eat(COMMA);
    	    scanSpaces(tokenizer);

    	    if (tokenizer.charCode() === INFINITY) {
    	        tokenizer.peek();
    	    } else {
    	        sign = 1;

    	        if (tokenizer.charCode() === HYPERMINUS) {
    	            tokenizer.peek();
    	            sign = -1;
    	        }

    	        max = sign * Number(scanNumber(tokenizer));
    	    }

    	    tokenizer.eat(RIGHTSQUAREBRACKET);

    	    // If no range is indicated, either by using the bracketed range notation
    	    // or in the property description, then [,] is assumed.
    	    if (min === null && max === null) {
    	        return null;
    	    }

    	    return {
    	        type: 'Range',
    	        min: min,
    	        max: max
    	    };
    	}

    	function readType(tokenizer) {
    	    var name;
    	    var opts = null;

    	    tokenizer.eat(LESSTHANSIGN);
    	    name = scanWord(tokenizer);

    	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
    	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
    	        tokenizer.pos += 2;
    	        name += '()';
    	    }

    	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
    	        scanSpaces(tokenizer);
    	        opts = readTypeRange(tokenizer);
    	    }

    	    tokenizer.eat(GREATERTHANSIGN);

    	    return maybeMultiplied(tokenizer, {
    	        type: 'Type',
    	        name: name,
    	        opts: opts
    	    });
    	}

    	function readKeywordOrFunction(tokenizer) {
    	    var name;

    	    name = scanWord(tokenizer);

    	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
    	        tokenizer.pos++;

    	        return {
    	            type: 'Function',
    	            name: name
    	        };
    	    }

    	    return maybeMultiplied(tokenizer, {
    	        type: 'Keyword',
    	        name: name
    	    });
    	}

    	function regroupTerms(terms, combinators) {
    	    function createGroup(terms, combinator) {
    	        return {
    	            type: 'Group',
    	            terms: terms,
    	            combinator: combinator,
    	            disallowEmpty: false,
    	            explicit: false
    	        };
    	    }

    	    combinators = Object.keys(combinators).sort(function(a, b) {
    	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
    	    });

    	    while (combinators.length > 0) {
    	        var combinator = combinators.shift();
    	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
    	            var term = terms[i];
    	            if (term.type === 'Combinator') {
    	                if (term.value === combinator) {
    	                    if (subgroupStart === -1) {
    	                        subgroupStart = i - 1;
    	                    }
    	                    terms.splice(i, 1);
    	                    i--;
    	                } else {
    	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
    	                        terms.splice(
    	                            subgroupStart,
    	                            i - subgroupStart,
    	                            createGroup(terms.slice(subgroupStart, i), combinator)
    	                        );
    	                        i = subgroupStart + 1;
    	                    }
    	                    subgroupStart = -1;
    	                }
    	            }
    	        }

    	        if (subgroupStart !== -1 && combinators.length) {
    	            terms.splice(
    	                subgroupStart,
    	                i - subgroupStart,
    	                createGroup(terms.slice(subgroupStart, i), combinator)
    	            );
    	        }
    	    }

    	    return combinator;
    	}

    	function readImplicitGroup(tokenizer) {
    	    var terms = [];
    	    var combinators = {};
    	    var token;
    	    var prevToken = null;
    	    var prevTokenPos = tokenizer.pos;

    	    while (token = peek(tokenizer)) {
    	        if (token.type !== 'Spaces') {
    	            if (token.type === 'Combinator') {
    	                // check for combinator in group beginning and double combinator sequence
    	                if (prevToken === null || prevToken.type === 'Combinator') {
    	                    tokenizer.pos = prevTokenPos;
    	                    tokenizer.error('Unexpected combinator');
    	                }

    	                combinators[token.value] = true;
    	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
    	                combinators[' '] = true;  // a b
    	                terms.push({
    	                    type: 'Combinator',
    	                    value: ' '
    	                });
    	            }

    	            terms.push(token);
    	            prevToken = token;
    	            prevTokenPos = tokenizer.pos;
    	        }
    	    }

    	    // check for combinator in group ending
    	    if (prevToken !== null && prevToken.type === 'Combinator') {
    	        tokenizer.pos -= prevTokenPos;
    	        tokenizer.error('Unexpected combinator');
    	    }

    	    return {
    	        type: 'Group',
    	        terms: terms,
    	        combinator: regroupTerms(terms, combinators) || ' ',
    	        disallowEmpty: false,
    	        explicit: false
    	    };
    	}

    	function readGroup(tokenizer) {
    	    var result;

    	    tokenizer.eat(LEFTSQUAREBRACKET);
    	    result = readImplicitGroup(tokenizer);
    	    tokenizer.eat(RIGHTSQUAREBRACKET);

    	    result.explicit = true;

    	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
    	        tokenizer.pos++;
    	        result.disallowEmpty = true;
    	    }

    	    return result;
    	}

    	function peek(tokenizer) {
    	    var code = tokenizer.charCode();

    	    if (code < 128 && NAME_CHAR[code] === 1) {
    	        return readKeywordOrFunction(tokenizer);
    	    }

    	    switch (code) {
    	        case RIGHTSQUAREBRACKET:
    	            // don't eat, stop scan a group
    	            break;

    	        case LEFTSQUAREBRACKET:
    	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

    	        case LESSTHANSIGN:
    	            return tokenizer.nextCharCode() === APOSTROPHE
    	                ? readProperty(tokenizer)
    	                : readType(tokenizer);

    	        case VERTICALLINE:
    	            return {
    	                type: 'Combinator',
    	                value: tokenizer.substringToPos(
    	                    tokenizer.nextCharCode() === VERTICALLINE
    	                        ? tokenizer.pos + 2
    	                        : tokenizer.pos + 1
    	                )
    	            };

    	        case AMPERSAND:
    	            tokenizer.pos++;
    	            tokenizer.eat(AMPERSAND);

    	            return {
    	                type: 'Combinator',
    	                value: '&&'
    	            };

    	        case COMMA:
    	            tokenizer.pos++;
    	            return {
    	                type: 'Comma'
    	            };

    	        case APOSTROPHE:
    	            return maybeMultiplied(tokenizer, {
    	                type: 'String',
    	                value: scanString(tokenizer)
    	            });

    	        case SPACE:
    	        case TAB:
    	        case N:
    	        case R:
    	        case F:
    	            return {
    	                type: 'Spaces',
    	                value: scanSpaces(tokenizer)
    	            };

    	        case COMMERCIALAT:
    	            code = tokenizer.nextCharCode();

    	            if (code < 128 && NAME_CHAR[code] === 1) {
    	                tokenizer.pos++;
    	                return {
    	                    type: 'AtKeyword',
    	                    name: scanWord(tokenizer)
    	                };
    	            }

    	            return maybeToken(tokenizer);

    	        case ASTERISK:
    	        case PLUSSIGN:
    	        case QUESTIONMARK:
    	        case NUMBERSIGN:
    	        case EXCLAMATIONMARK:
    	            // prohibited tokens (used as a multiplier start)
    	            break;

    	        case LEFTCURLYBRACKET:
    	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
    	            // check next char isn't a number, because it's likely a disjoined multiplier
    	            code = tokenizer.nextCharCode();

    	            if (code < 48 || code > 57) {
    	                return maybeToken(tokenizer);
    	            }

    	            break;

    	        default:
    	            return maybeToken(tokenizer);
    	    }
    	}

    	function parse(source) {
    	    var tokenizer = new Tokenizer(source);
    	    var result = readImplicitGroup(tokenizer);

    	    if (tokenizer.pos !== source.length) {
    	        tokenizer.error('Unexpected input');
    	    }

    	    // reduce redundant groups with single group term
    	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
    	        result = result.terms[0];
    	    }

    	    return result;
    	}

    	// warm up parse to elimitate code branches that never execute
    	// fix soft deoptimizations (insufficient type feedback)
    	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

    	parse_1 = parse;
    	return parse_1;
    }

    var walk;
    var hasRequiredWalk;

    function requireWalk () {
    	if (hasRequiredWalk) return walk;
    	hasRequiredWalk = 1;
    	var noop = function() {};

    	function ensureFunction(value) {
    	    return typeof value === 'function' ? value : noop;
    	}

    	walk = function(node, options, context) {
    	    function walk(node) {
    	        enter.call(context, node);

    	        switch (node.type) {
    	            case 'Group':
    	                node.terms.forEach(walk);
    	                break;

    	            case 'Multiplier':
    	                walk(node.term);
    	                break;

    	            case 'Type':
    	            case 'Property':
    	            case 'Keyword':
    	            case 'AtKeyword':
    	            case 'Function':
    	            case 'String':
    	            case 'Token':
    	            case 'Comma':
    	                break;

    	            default:
    	                throw new Error('Unknown type: ' + node.type);
    	        }

    	        leave.call(context, node);
    	    }

    	    var enter = noop;
    	    var leave = noop;

    	    if (typeof options === 'function') {
    	        enter = options;
    	    } else if (options) {
    	        enter = ensureFunction(options.enter);
    	        leave = ensureFunction(options.leave);
    	    }

    	    if (enter === noop && leave === noop) {
    	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    	    }

    	    walk(node);
    	};
    	return walk;
    }

    var prepareTokens_1;
    var hasRequiredPrepareTokens;

    function requirePrepareTokens () {
    	if (hasRequiredPrepareTokens) return prepareTokens_1;
    	hasRequiredPrepareTokens = 1;
    	var tokenize = requireTokenizer$1();
    	var TokenStream = requireTokenStream();
    	var tokenStream = new TokenStream();
    	var astToTokens = {
    	    decorator: function(handlers) {
    	        var curNode = null;
    	        var prev = { len: 0, node: null };
    	        var nodes = [prev];
    	        var buffer = '';

    	        return {
    	            children: handlers.children,
    	            node: function(node) {
    	                var tmp = curNode;
    	                curNode = node;
    	                handlers.node.call(this, node);
    	                curNode = tmp;
    	            },
    	            chunk: function(chunk) {
    	                buffer += chunk;
    	                if (prev.node !== curNode) {
    	                    nodes.push({
    	                        len: chunk.length,
    	                        node: curNode
    	                    });
    	                } else {
    	                    prev.len += chunk.length;
    	                }
    	            },
    	            result: function() {
    	                return prepareTokens(buffer, nodes);
    	            }
    	        };
    	    }
    	};

    	function prepareTokens(str, nodes) {
    	    var tokens = [];
    	    var nodesOffset = 0;
    	    var nodesIndex = 0;
    	    var currentNode = nodes ? nodes[nodesIndex].node : null;

    	    tokenize(str, tokenStream);

    	    while (!tokenStream.eof) {
    	        if (nodes) {
    	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
    	                nodesOffset += nodes[nodesIndex++].len;
    	                currentNode = nodes[nodesIndex].node;
    	            }
    	        }

    	        tokens.push({
    	            type: tokenStream.tokenType,
    	            value: tokenStream.getTokenValue(),
    	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
    	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
    	            node: currentNode
    	        });
    	        tokenStream.next();
    	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
    	    }

    	    return tokens;
    	}

    	prepareTokens_1 = function(value, syntax) {
    	    if (typeof value === 'string') {
    	        return prepareTokens(value, null);
    	    }

    	    return syntax.generate(value, astToTokens);
    	};
    	return prepareTokens_1;
    }

    var matchGraph;
    var hasRequiredMatchGraph;

    function requireMatchGraph () {
    	if (hasRequiredMatchGraph) return matchGraph;
    	hasRequiredMatchGraph = 1;
    	var parse = requireParse();

    	var MATCH = { type: 'Match' };
    	var MISMATCH = { type: 'Mismatch' };
    	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
    	var LEFTPARENTHESIS = 40;  // (
    	var RIGHTPARENTHESIS = 41; // )

    	function createCondition(match, thenBranch, elseBranch) {
    	    // reduce node count
    	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
    	        return match;
    	    }

    	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
    	        return match;
    	    }

    	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
    	        thenBranch = match.then;
    	        match = match.match;
    	    }

    	    return {
    	        type: 'If',
    	        match: match,
    	        then: thenBranch,
    	        else: elseBranch
    	    };
    	}

    	function isFunctionType(name) {
    	    return (
    	        name.length > 2 &&
    	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&
    	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS
    	    );
    	}

    	function isEnumCapatible(term) {
    	    return (
    	        term.type === 'Keyword' ||
    	        term.type === 'AtKeyword' ||
    	        term.type === 'Function' ||
    	        term.type === 'Type' && isFunctionType(term.name)
    	    );
    	}

    	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    	    switch (combinator) {
    	        case ' ':
    	            // Juxtaposing components means that all of them must occur, in the given order.
    	            //
    	            // a b c
    	            // =
    	            // match a
    	            //   then match b
    	            //     then match c
    	            //       then MATCH
    	            //       else MISMATCH
    	            //     else MISMATCH
    	            //   else MISMATCH
    	            var result = MATCH;

    	            for (var i = terms.length - 1; i >= 0; i--) {
    	                var term = terms[i];

    	                result = createCondition(
    	                    term,
    	                    result,
    	                    MISMATCH
    	                );
    	            }
    	            return result;

    	        case '|':
    	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
    	            //
    	            // a | b | c
    	            // =
    	            // match a
    	            //   then MATCH
    	            //   else match b
    	            //     then MATCH
    	            //     else match c
    	            //       then MATCH
    	            //       else MISMATCH

    	            var result = MISMATCH;
    	            var map = null;

    	            for (var i = terms.length - 1; i >= 0; i--) {
    	                var term = terms[i];

    	                // reduce sequence of keywords into a Enum
    	                if (isEnumCapatible(term)) {
    	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
    	                        map = Object.create(null);
    	                        result = createCondition(
    	                            {
    	                                type: 'Enum',
    	                                map: map
    	                            },
    	                            MATCH,
    	                            result
    	                        );
    	                    }

    	                    if (map !== null) {
    	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
    	                        if (key in map === false) {
    	                            map[key] = term;
    	                            continue;
    	                        }
    	                    }
    	                }

    	                map = null;

    	                // create a new conditonal node
    	                result = createCondition(
    	                    term,
    	                    MATCH,
    	                    result
    	                );
    	            }
    	            return result;

    	        case '&&':
    	            // A double ampersand (&&) separates two or more components,
    	            // all of which must occur, in any order.

    	            // Use MatchOnce for groups with a large number of terms,
    	            // since &&-groups produces at least N!-node trees
    	            if (terms.length > 5) {
    	                return {
    	                    type: 'MatchOnce',
    	                    terms: terms,
    	                    all: true
    	                };
    	            }

    	            // Use a combination tree for groups with small number of terms
    	            //
    	            // a && b && c
    	            // =
    	            // match a
    	            //   then [b && c]
    	            //   else match b
    	            //     then [a && c]
    	            //     else match c
    	            //       then [a && b]
    	            //       else MISMATCH
    	            //
    	            // a && b
    	            // =
    	            // match a
    	            //   then match b
    	            //     then MATCH
    	            //     else MISMATCH
    	            //   else match b
    	            //     then match a
    	            //       then MATCH
    	            //       else MISMATCH
    	            //     else MISMATCH
    	            var result = MISMATCH;

    	            for (var i = terms.length - 1; i >= 0; i--) {
    	                var term = terms[i];
    	                var thenClause;

    	                if (terms.length > 1) {
    	                    thenClause = buildGroupMatchGraph(
    	                        combinator,
    	                        terms.filter(function(newGroupTerm) {
    	                            return newGroupTerm !== term;
    	                        }),
    	                        false
    	                    );
    	                } else {
    	                    thenClause = MATCH;
    	                }

    	                result = createCondition(
    	                    term,
    	                    thenClause,
    	                    result
    	                );
    	            }
    	            return result;

    	        case '||':
    	            // A double bar (||) separates two or more options:
    	            // one or more of them must occur, in any order.

    	            // Use MatchOnce for groups with a large number of terms,
    	            // since ||-groups produces at least N!-node trees
    	            if (terms.length > 5) {
    	                return {
    	                    type: 'MatchOnce',
    	                    terms: terms,
    	                    all: false
    	                };
    	            }

    	            // Use a combination tree for groups with small number of terms
    	            //
    	            // a || b || c
    	            // =
    	            // match a
    	            //   then [b || c]
    	            //   else match b
    	            //     then [a || c]
    	            //     else match c
    	            //       then [a || b]
    	            //       else MISMATCH
    	            //
    	            // a || b
    	            // =
    	            // match a
    	            //   then match b
    	            //     then MATCH
    	            //     else MATCH
    	            //   else match b
    	            //     then match a
    	            //       then MATCH
    	            //       else MATCH
    	            //     else MISMATCH
    	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

    	            for (var i = terms.length - 1; i >= 0; i--) {
    	                var term = terms[i];
    	                var thenClause;

    	                if (terms.length > 1) {
    	                    thenClause = buildGroupMatchGraph(
    	                        combinator,
    	                        terms.filter(function(newGroupTerm) {
    	                            return newGroupTerm !== term;
    	                        }),
    	                        true
    	                    );
    	                } else {
    	                    thenClause = MATCH;
    	                }

    	                result = createCondition(
    	                    term,
    	                    thenClause,
    	                    result
    	                );
    	            }
    	            return result;
    	    }
    	}

    	function buildMultiplierMatchGraph(node) {
    	    var result = MATCH;
    	    var matchTerm = buildMatchGraph(node.term);

    	    if (node.max === 0) {
    	        // disable repeating of empty match to prevent infinite loop
    	        matchTerm = createCondition(
    	            matchTerm,
    	            DISALLOW_EMPTY,
    	            MISMATCH
    	        );

    	        // an occurrence count is not limited, make a cycle;
    	        // to collect more terms on each following matching mismatch
    	        result = createCondition(
    	            matchTerm,
    	            null, // will be a loop
    	            MISMATCH
    	        );

    	        result.then = createCondition(
    	            MATCH,
    	            MATCH,
    	            result // make a loop
    	        );

    	        if (node.comma) {
    	            result.then.else = createCondition(
    	                { type: 'Comma', syntax: node },
    	                result,
    	                MISMATCH
    	            );
    	        }
    	    } else {
    	        // create a match node chain for [min .. max] interval with optional matches
    	        for (var i = node.min || 1; i <= node.max; i++) {
    	            if (node.comma && result !== MATCH) {
    	                result = createCondition(
    	                    { type: 'Comma', syntax: node },
    	                    result,
    	                    MISMATCH
    	                );
    	            }

    	            result = createCondition(
    	                matchTerm,
    	                createCondition(
    	                    MATCH,
    	                    MATCH,
    	                    result
    	                ),
    	                MISMATCH
    	            );
    	        }
    	    }

    	    if (node.min === 0) {
    	        // allow zero match
    	        result = createCondition(
    	            MATCH,
    	            MATCH,
    	            result
    	        );
    	    } else {
    	        // create a match node chain to collect [0 ... min - 1] required matches
    	        for (var i = 0; i < node.min - 1; i++) {
    	            if (node.comma && result !== MATCH) {
    	                result = createCondition(
    	                    { type: 'Comma', syntax: node },
    	                    result,
    	                    MISMATCH
    	                );
    	            }

    	            result = createCondition(
    	                matchTerm,
    	                result,
    	                MISMATCH
    	            );
    	        }
    	    }

    	    return result;
    	}

    	function buildMatchGraph(node) {
    	    if (typeof node === 'function') {
    	        return {
    	            type: 'Generic',
    	            fn: node
    	        };
    	    }

    	    switch (node.type) {
    	        case 'Group':
    	            var result = buildGroupMatchGraph(
    	                node.combinator,
    	                node.terms.map(buildMatchGraph),
    	                false
    	            );

    	            if (node.disallowEmpty) {
    	                result = createCondition(
    	                    result,
    	                    DISALLOW_EMPTY,
    	                    MISMATCH
    	                );
    	            }

    	            return result;

    	        case 'Multiplier':
    	            return buildMultiplierMatchGraph(node);

    	        case 'Type':
    	        case 'Property':
    	            return {
    	                type: node.type,
    	                name: node.name,
    	                syntax: node
    	            };

    	        case 'Keyword':
    	            return {
    	                type: node.type,
    	                name: node.name.toLowerCase(),
    	                syntax: node
    	            };

    	        case 'AtKeyword':
    	            return {
    	                type: node.type,
    	                name: '@' + node.name.toLowerCase(),
    	                syntax: node
    	            };

    	        case 'Function':
    	            return {
    	                type: node.type,
    	                name: node.name.toLowerCase() + '(',
    	                syntax: node
    	            };

    	        case 'String':
    	            // convert a one char length String to a Token
    	            if (node.value.length === 3) {
    	                return {
    	                    type: 'Token',
    	                    value: node.value.charAt(1),
    	                    syntax: node
    	                };
    	            }

    	            // otherwise use it as is
    	            return {
    	                type: node.type,
    	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
    	                syntax: node
    	            };

    	        case 'Token':
    	            return {
    	                type: node.type,
    	                value: node.value,
    	                syntax: node
    	            };

    	        case 'Comma':
    	            return {
    	                type: node.type,
    	                syntax: node
    	            };

    	        default:
    	            throw new Error('Unknown node type:', node.type);
    	    }
    	}

    	matchGraph = {
    	    MATCH: MATCH,
    	    MISMATCH: MISMATCH,
    	    DISALLOW_EMPTY: DISALLOW_EMPTY,
    	    buildMatchGraph: function(syntaxTree, ref) {
    	        if (typeof syntaxTree === 'string') {
    	            syntaxTree = parse(syntaxTree);
    	        }

    	        return {
    	            type: 'MatchGraph',
    	            match: buildMatchGraph(syntaxTree),
    	            syntax: ref || null,
    	            source: syntaxTree
    	        };
    	    }
    	};
    	return matchGraph;
    }

    var match;
    var hasRequiredMatch;

    function requireMatch () {
    	if (hasRequiredMatch) return match;
    	hasRequiredMatch = 1;
    	var hasOwnProperty = Object.prototype.hasOwnProperty;
    	var matchGraph = requireMatchGraph();
    	var MATCH = matchGraph.MATCH;
    	var MISMATCH = matchGraph.MISMATCH;
    	var DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;
    	var TYPE = require_const().TYPE;

    	var STUB = 0;
    	var TOKEN = 1;
    	var OPEN_SYNTAX = 2;
    	var CLOSE_SYNTAX = 3;

    	var EXIT_REASON_MATCH = 'Match';
    	var EXIT_REASON_MISMATCH = 'Mismatch';
    	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

    	var ITERATION_LIMIT = 15000;
    	var totalIterationCount = 0;

    	function reverseList(list) {
    	    var prev = null;
    	    var next = null;
    	    var item = list;

    	    while (item !== null) {
    	        next = item.prev;
    	        item.prev = prev;
    	        prev = item;
    	        item = next;
    	    }

    	    return prev;
    	}

    	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    	    if (testStr.length !== referenceStr.length) {
    	        return false;
    	    }

    	    for (var i = 0; i < testStr.length; i++) {
    	        var testCode = testStr.charCodeAt(i);
    	        var referenceCode = referenceStr.charCodeAt(i);

    	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
    	        if (testCode >= 0x0041 && testCode <= 0x005A) {
    	            testCode = testCode | 32;
    	        }

    	        if (testCode !== referenceCode) {
    	            return false;
    	        }
    	    }

    	    return true;
    	}

    	function isContextEdgeDelim(token) {
    	    if (token.type !== TYPE.Delim) {
    	        return false;
    	    }

    	    // Fix matching for unicode-range: U+30??, U+FF00-FF9F
    	    // Probably we need to check out previous match instead
    	    return token.value !== '?';
    	}

    	function isCommaContextStart(token) {
    	    if (token === null) {
    	        return true;
    	    }

    	    return (
    	        token.type === TYPE.Comma ||
    	        token.type === TYPE.Function ||
    	        token.type === TYPE.LeftParenthesis ||
    	        token.type === TYPE.LeftSquareBracket ||
    	        token.type === TYPE.LeftCurlyBracket ||
    	        isContextEdgeDelim(token)
    	    );
    	}

    	function isCommaContextEnd(token) {
    	    if (token === null) {
    	        return true;
    	    }

    	    return (
    	        token.type === TYPE.RightParenthesis ||
    	        token.type === TYPE.RightSquareBracket ||
    	        token.type === TYPE.RightCurlyBracket ||
    	        token.type === TYPE.Delim
    	    );
    	}

    	function internalMatch(tokens, state, syntaxes) {
    	    function moveToNextToken() {
    	        do {
    	            tokenIndex++;
    	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
    	        } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));
    	    }

    	    function getNextToken(offset) {
    	        var nextIndex = tokenIndex + offset;

    	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
    	    }

    	    function stateSnapshotFromSyntax(nextState, prev) {
    	        return {
    	            nextState: nextState,
    	            matchStack: matchStack,
    	            syntaxStack: syntaxStack,
    	            thenStack: thenStack,
    	            tokenIndex: tokenIndex,
    	            prev: prev
    	        };
    	    }

    	    function pushThenStack(nextState) {
    	        thenStack = {
    	            nextState: nextState,
    	            matchStack: matchStack,
    	            syntaxStack: syntaxStack,
    	            prev: thenStack
    	        };
    	    }

    	    function pushElseStack(nextState) {
    	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    	    }

    	    function addTokenToMatch() {
    	        matchStack = {
    	            type: TOKEN,
    	            syntax: state.syntax,
    	            token: token,
    	            prev: matchStack
    	        };

    	        moveToNextToken();
    	        syntaxStash = null;

    	        if (tokenIndex > longestMatch) {
    	            longestMatch = tokenIndex;
    	        }
    	    }

    	    function openSyntax() {
    	        syntaxStack = {
    	            syntax: state.syntax,
    	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
    	            prev: syntaxStack
    	        };

    	        matchStack = {
    	            type: OPEN_SYNTAX,
    	            syntax: state.syntax,
    	            token: matchStack.token,
    	            prev: matchStack
    	        };
    	    }

    	    function closeSyntax() {
    	        if (matchStack.type === OPEN_SYNTAX) {
    	            matchStack = matchStack.prev;
    	        } else {
    	            matchStack = {
    	                type: CLOSE_SYNTAX,
    	                syntax: syntaxStack.syntax,
    	                token: matchStack.token,
    	                prev: matchStack
    	            };
    	        }

    	        syntaxStack = syntaxStack.prev;
    	    }

    	    var syntaxStack = null;
    	    var thenStack = null;
    	    var elseStack = null;

    	    // null  stashing allowed, nothing stashed
    	    // false  stashing disabled, nothing stashed
    	    // anithing else  fail stashable syntaxes, some syntax stashed
    	    var syntaxStash = null;

    	    var iterationCount = 0; // count iterations and prevent infinite loop
    	    var exitReason = null;

    	    var token = null;
    	    var tokenIndex = -1;
    	    var longestMatch = 0;
    	    var matchStack = {
    	        type: STUB,
    	        syntax: null,
    	        token: null,
    	        prev: null
    	    };

    	    moveToNextToken();

    	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
    	        // function mapList(list, fn) {
    	        //     var result = [];
    	        //     while (list) {
    	        //         result.unshift(fn(list));
    	        //         list = list.prev;
    	        //     }
    	        //     return result;
    	        // }
    	        // console.log('--\n',
    	        //     '#' + iterationCount,
    	        //     require('util').inspect({
    	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
    	        //         token: token && token.value,
    	        //         tokenIndex,
    	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
    	        //     }, { depth: null })
    	        // );
    	        switch (state.type) {
    	            case 'Match':
    	                if (thenStack === null) {
    	                    // turn to MISMATCH when some tokens left unmatched
    	                    if (token !== null) {
    	                        // doesn't mismatch if just one token left and it's an IE hack
    	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
    	                            state = MISMATCH;
    	                            break;
    	                        }
    	                    }

    	                    // break the main loop, return a result - MATCH
    	                    exitReason = EXIT_REASON_MATCH;
    	                    break;
    	                }

    	                // go to next syntax (`then` branch)
    	                state = thenStack.nextState;

    	                // check match is not empty
    	                if (state === DISALLOW_EMPTY) {
    	                    if (thenStack.matchStack === matchStack) {
    	                        state = MISMATCH;
    	                        break;
    	                    } else {
    	                        state = MATCH;
    	                    }
    	                }

    	                // close syntax if needed
    	                while (thenStack.syntaxStack !== syntaxStack) {
    	                    closeSyntax();
    	                }

    	                // pop stack
    	                thenStack = thenStack.prev;
    	                break;

    	            case 'Mismatch':
    	                // when some syntax is stashed
    	                if (syntaxStash !== null && syntaxStash !== false) {
    	                    // there is no else branches or a branch reduce match stack
    	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
    	                        // restore state from the stash
    	                        elseStack = syntaxStash;
    	                        syntaxStash = false; // disable stashing
    	                    }
    	                } else if (elseStack === null) {
    	                    // no else branches -> break the main loop
    	                    // return a result - MISMATCH
    	                    exitReason = EXIT_REASON_MISMATCH;
    	                    break;
    	                }

    	                // go to next syntax (`else` branch)
    	                state = elseStack.nextState;

    	                // restore all the rest stack states
    	                thenStack = elseStack.thenStack;
    	                syntaxStack = elseStack.syntaxStack;
    	                matchStack = elseStack.matchStack;
    	                tokenIndex = elseStack.tokenIndex;
    	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

    	                // pop stack
    	                elseStack = elseStack.prev;
    	                break;

    	            case 'MatchGraph':
    	                state = state.match;
    	                break;

    	            case 'If':
    	                // IMPORTANT: else stack push must go first,
    	                // since it stores the state of thenStack before changes
    	                if (state.else !== MISMATCH) {
    	                    pushElseStack(state.else);
    	                }

    	                if (state.then !== MATCH) {
    	                    pushThenStack(state.then);
    	                }

    	                state = state.match;
    	                break;

    	            case 'MatchOnce':
    	                state = {
    	                    type: 'MatchOnceBuffer',
    	                    syntax: state,
    	                    index: 0,
    	                    mask: 0
    	                };
    	                break;

    	            case 'MatchOnceBuffer':
    	                var terms = state.syntax.terms;

    	                if (state.index === terms.length) {
    	                    // no matches at all or it's required all terms to be matched
    	                    if (state.mask === 0 || state.syntax.all) {
    	                        state = MISMATCH;
    	                        break;
    	                    }

    	                    // a partial match is ok
    	                    state = MATCH;
    	                    break;
    	                }

    	                // all terms are matched
    	                if (state.mask === (1 << terms.length) - 1) {
    	                    state = MATCH;
    	                    break;
    	                }

    	                for (; state.index < terms.length; state.index++) {
    	                    var matchFlag = 1 << state.index;

    	                    if ((state.mask & matchFlag) === 0) {
    	                        // IMPORTANT: else stack push must go first,
    	                        // since it stores the state of thenStack before changes
    	                        pushElseStack(state);
    	                        pushThenStack({
    	                            type: 'AddMatchOnce',
    	                            syntax: state.syntax,
    	                            mask: state.mask | matchFlag
    	                        });

    	                        // match
    	                        state = terms[state.index++];
    	                        break;
    	                    }
    	                }
    	                break;

    	            case 'AddMatchOnce':
    	                state = {
    	                    type: 'MatchOnceBuffer',
    	                    syntax: state.syntax,
    	                    index: 0,
    	                    mask: state.mask
    	                };
    	                break;

    	            case 'Enum':
    	                if (token !== null) {
    	                    var name = token.value.toLowerCase();

    	                    // drop \0 and \9 hack from keyword name
    	                    if (name.indexOf('\\') !== -1) {
    	                        name = name.replace(/\\[09].*$/, '');
    	                    }

    	                    if (hasOwnProperty.call(state.map, name)) {
    	                        state = state.map[name];
    	                        break;
    	                    }
    	                }

    	                state = MISMATCH;
    	                break;

    	            case 'Generic':
    	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
    	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

    	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
    	                    while (tokenIndex < lastTokenIndex) {
    	                        addTokenToMatch();
    	                    }

    	                    state = MATCH;
    	                } else {
    	                    state = MISMATCH;
    	                }

    	                break;

    	            case 'Type':
    	            case 'Property':
    	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
    	                var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

    	                if (!dictSyntax || !dictSyntax.match) {
    	                    throw new Error(
    	                        'Bad syntax reference: ' +
    	                        (state.type === 'Type'
    	                            ? '<' + state.name + '>'
    	                            : '<\'' + state.name + '\'>')
    	                    );
    	                }

    	                // stash a syntax for types with low priority
    	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
    	                    var lowPriorityMatching =
    	                        // https://drafts.csswg.org/css-values-4/#custom-idents
    	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
    	                        // can only claim the keyword if no other unfulfilled production can claim it.
    	                        (state.name === 'custom-ident' && token.type === TYPE.Ident) ||

    	                        // https://drafts.csswg.org/css-values-4/#lengths
    	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
    	                        // it must parse as a <number>
    	                        (state.name === 'length' && token.value === '0');

    	                    if (lowPriorityMatching) {
    	                        if (syntaxStash === null) {
    	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
    	                        }

    	                        state = MISMATCH;
    	                        break;
    	                    }
    	                }

    	                openSyntax();
    	                state = dictSyntax.match;
    	                break;

    	            case 'Keyword':
    	                var name = state.name;

    	                if (token !== null) {
    	                    var keywordName = token.value;

    	                    // drop \0 and \9 hack from keyword name
    	                    if (keywordName.indexOf('\\') !== -1) {
    	                        keywordName = keywordName.replace(/\\[09].*$/, '');
    	                    }

    	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
    	                        addTokenToMatch();
    	                        state = MATCH;
    	                        break;
    	                    }
    	                }

    	                state = MISMATCH;
    	                break;

    	            case 'AtKeyword':
    	            case 'Function':
    	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
    	                    addTokenToMatch();
    	                    state = MATCH;
    	                    break;
    	                }

    	                state = MISMATCH;
    	                break;

    	            case 'Token':
    	                if (token !== null && token.value === state.value) {
    	                    addTokenToMatch();
    	                    state = MATCH;
    	                    break;
    	                }

    	                state = MISMATCH;
    	                break;

    	            case 'Comma':
    	                if (token !== null && token.type === TYPE.Comma) {
    	                    if (isCommaContextStart(matchStack.token)) {
    	                        state = MISMATCH;
    	                    } else {
    	                        addTokenToMatch();
    	                        state = isCommaContextEnd(token) ? MISMATCH : MATCH;
    	                    }
    	                } else {
    	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
    	                }

    	                break;

    	            case 'String':
    	                var string = '';

    	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
    	                    string += tokens[lastTokenIndex].value;
    	                }

    	                if (areStringsEqualCaseInsensitive(string, state.value)) {
    	                    while (tokenIndex < lastTokenIndex) {
    	                        addTokenToMatch();
    	                    }

    	                    state = MATCH;
    	                } else {
    	                    state = MISMATCH;
    	                }

    	                break;

    	            default:
    	                throw new Error('Unknown node type: ' + state.type);
    	        }
    	    }

    	    totalIterationCount += iterationCount;

    	    switch (exitReason) {
    	        case null:
    	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
    	            exitReason = EXIT_REASON_ITERATION_LIMIT;
    	            matchStack = null;
    	            break;

    	        case EXIT_REASON_MATCH:
    	            while (syntaxStack !== null) {
    	                closeSyntax();
    	            }
    	            break;

    	        default:
    	            matchStack = null;
    	    }

    	    return {
    	        tokens: tokens,
    	        reason: exitReason,
    	        iterations: iterationCount,
    	        match: matchStack,
    	        longestMatch: longestMatch
    	    };
    	}

    	function matchAsList(tokens, matchGraph, syntaxes) {
    	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    	    if (matchResult.match !== null) {
    	        var item = reverseList(matchResult.match).prev;

    	        matchResult.match = [];

    	        while (item !== null) {
    	            switch (item.type) {
    	                case STUB:
    	                    break;

    	                case OPEN_SYNTAX:
    	                case CLOSE_SYNTAX:
    	                    matchResult.match.push({
    	                        type: item.type,
    	                        syntax: item.syntax
    	                    });
    	                    break;

    	                default:
    	                    matchResult.match.push({
    	                        token: item.token.value,
    	                        node: item.token.node
    	                    });
    	                    break;
    	            }

    	            item = item.prev;
    	        }
    	    }

    	    return matchResult;
    	}

    	function matchAsTree(tokens, matchGraph, syntaxes) {
    	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    	    if (matchResult.match === null) {
    	        return matchResult;
    	    }

    	    var item = matchResult.match;
    	    var host = matchResult.match = {
    	        syntax: matchGraph.syntax || null,
    	        match: []
    	    };
    	    var hostStack = [host];

    	    // revert a list and start with 2nd item since 1st is a stub item
    	    item = reverseList(item).prev;

    	    // build a tree
    	    while (item !== null) {
    	        switch (item.type) {
    	            case OPEN_SYNTAX:
    	                host.match.push(host = {
    	                    syntax: item.syntax,
    	                    match: []
    	                });
    	                hostStack.push(host);
    	                break;

    	            case CLOSE_SYNTAX:
    	                hostStack.pop();
    	                host = hostStack[hostStack.length - 1];
    	                break;

    	            default:
    	                host.match.push({
    	                    syntax: item.syntax || null,
    	                    token: item.token.value,
    	                    node: item.token.node
    	                });
    	        }

    	        item = item.prev;
    	    }

    	    return matchResult;
    	}

    	match = {
    	    matchAsList: matchAsList,
    	    matchAsTree: matchAsTree,
    	    getTotalIterationCount: function() {
    	        return totalIterationCount;
    	    }
    	};
    	return match;
    }

    var trace;
    var hasRequiredTrace;

    function requireTrace () {
    	if (hasRequiredTrace) return trace;
    	hasRequiredTrace = 1;
    	function getTrace(node) {
    	    function shouldPutToTrace(syntax) {
    	        if (syntax === null) {
    	            return false;
    	        }

    	        return (
    	            syntax.type === 'Type' ||
    	            syntax.type === 'Property' ||
    	            syntax.type === 'Keyword'
    	        );
    	    }

    	    function hasMatch(matchNode) {
    	        if (Array.isArray(matchNode.match)) {
    	            // use for-loop for better perfomance
    	            for (var i = 0; i < matchNode.match.length; i++) {
    	                if (hasMatch(matchNode.match[i])) {
    	                    if (shouldPutToTrace(matchNode.syntax)) {
    	                        result.unshift(matchNode.syntax);
    	                    }

    	                    return true;
    	                }
    	            }
    	        } else if (matchNode.node === node) {
    	            result = shouldPutToTrace(matchNode.syntax)
    	                ? [matchNode.syntax]
    	                : [];

    	            return true;
    	        }

    	        return false;
    	    }

    	    var result = null;

    	    if (this.matched !== null) {
    	        hasMatch(this.matched);
    	    }

    	    return result;
    	}

    	function testNode(match, node, fn) {
    	    var trace = getTrace.call(match, node);

    	    if (trace === null) {
    	        return false;
    	    }

    	    return trace.some(fn);
    	}

    	function isType(node, type) {
    	    return testNode(this, node, function(matchNode) {
    	        return matchNode.type === 'Type' && matchNode.name === type;
    	    });
    	}

    	function isProperty(node, property) {
    	    return testNode(this, node, function(matchNode) {
    	        return matchNode.type === 'Property' && matchNode.name === property;
    	    });
    	}

    	function isKeyword(node) {
    	    return testNode(this, node, function(matchNode) {
    	        return matchNode.type === 'Keyword';
    	    });
    	}

    	trace = {
    	    getTrace: getTrace,
    	    isType: isType,
    	    isProperty: isProperty,
    	    isKeyword: isKeyword
    	};
    	return trace;
    }

    var search;
    var hasRequiredSearch;

    function requireSearch () {
    	if (hasRequiredSearch) return search;
    	hasRequiredSearch = 1;
    	var List = requireList();

    	function getFirstMatchNode(matchNode) {
    	    if ('node' in matchNode) {
    	        return matchNode.node;
    	    }

    	    return getFirstMatchNode(matchNode.match[0]);
    	}

    	function getLastMatchNode(matchNode) {
    	    if ('node' in matchNode) {
    	        return matchNode.node;
    	    }

    	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
    	}

    	function matchFragments(lexer, ast, match, type, name) {
    	    function findFragments(matchNode) {
    	        if (matchNode.syntax !== null &&
    	            matchNode.syntax.type === type &&
    	            matchNode.syntax.name === name) {
    	            var start = getFirstMatchNode(matchNode);
    	            var end = getLastMatchNode(matchNode);

    	            lexer.syntax.walk(ast, function(node, item, list) {
    	                if (node === start) {
    	                    var nodes = new List();

    	                    do {
    	                        nodes.appendData(item.data);

    	                        if (item.data === end) {
    	                            break;
    	                        }

    	                        item = item.next;
    	                    } while (item !== null);

    	                    fragments.push({
    	                        parent: list,
    	                        nodes: nodes
    	                    });
    	                }
    	            });
    	        }

    	        if (Array.isArray(matchNode.match)) {
    	            matchNode.match.forEach(findFragments);
    	        }
    	    }

    	    var fragments = [];

    	    if (match.matched !== null) {
    	        findFragments(match.matched);
    	    }

    	    return fragments;
    	}

    	search = {
    	    matchFragments: matchFragments
    	};
    	return search;
    }

    var structure;
    var hasRequiredStructure;

    function requireStructure () {
    	if (hasRequiredStructure) return structure;
    	hasRequiredStructure = 1;
    	var List = requireList();
    	var hasOwnProperty = Object.prototype.hasOwnProperty;

    	function isValidNumber(value) {
    	    // Number.isInteger(value) && value >= 0
    	    return (
    	        typeof value === 'number' &&
    	        isFinite(value) &&
    	        Math.floor(value) === value &&
    	        value >= 0
    	    );
    	}

    	function isValidLocation(loc) {
    	    return (
    	        Boolean(loc) &&
    	        isValidNumber(loc.offset) &&
    	        isValidNumber(loc.line) &&
    	        isValidNumber(loc.column)
    	    );
    	}

    	function createNodeStructureChecker(type, fields) {
    	    return function checkNode(node, warn) {
    	        if (!node || node.constructor !== Object) {
    	            return warn(node, 'Type of node should be an Object');
    	        }

    	        for (var key in node) {
    	            var valid = true;

    	            if (hasOwnProperty.call(node, key) === false) {
    	                continue;
    	            }

    	            if (key === 'type') {
    	                if (node.type !== type) {
    	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
    	                }
    	            } else if (key === 'loc') {
    	                if (node.loc === null) {
    	                    continue;
    	                } else if (node.loc && node.loc.constructor === Object) {
    	                    if (typeof node.loc.source !== 'string') {
    	                        key += '.source';
    	                    } else if (!isValidLocation(node.loc.start)) {
    	                        key += '.start';
    	                    } else if (!isValidLocation(node.loc.end)) {
    	                        key += '.end';
    	                    } else {
    	                        continue;
    	                    }
    	                }

    	                valid = false;
    	            } else if (fields.hasOwnProperty(key)) {
    	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
    	                    var fieldType = fields[key][i];

    	                    switch (fieldType) {
    	                        case String:
    	                            valid = typeof node[key] === 'string';
    	                            break;

    	                        case Boolean:
    	                            valid = typeof node[key] === 'boolean';
    	                            break;

    	                        case null:
    	                            valid = node[key] === null;
    	                            break;

    	                        default:
    	                            if (typeof fieldType === 'string') {
    	                                valid = node[key] && node[key].type === fieldType;
    	                            } else if (Array.isArray(fieldType)) {
    	                                valid = node[key] instanceof List;
    	                            }
    	                    }
    	                }
    	            } else {
    	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
    	            }

    	            if (!valid) {
    	                warn(node, 'Bad value for `' + type + '.' + key + '`');
    	            }
    	        }

    	        for (var key in fields) {
    	            if (hasOwnProperty.call(fields, key) &&
    	                hasOwnProperty.call(node, key) === false) {
    	                warn(node, 'Field `' + type + '.' + key + '` is missed');
    	            }
    	        }
    	    };
    	}

    	function processStructure(name, nodeType) {
    	    var structure = nodeType.structure;
    	    var fields = {
    	        type: String,
    	        loc: true
    	    };
    	    var docs = {
    	        type: '"' + name + '"'
    	    };

    	    for (var key in structure) {
    	        if (hasOwnProperty.call(structure, key) === false) {
    	            continue;
    	        }

    	        var docsTypes = [];
    	        var fieldTypes = fields[key] = Array.isArray(structure[key])
    	            ? structure[key].slice()
    	            : [structure[key]];

    	        for (var i = 0; i < fieldTypes.length; i++) {
    	            var fieldType = fieldTypes[i];
    	            if (fieldType === String || fieldType === Boolean) {
    	                docsTypes.push(fieldType.name);
    	            } else if (fieldType === null) {
    	                docsTypes.push('null');
    	            } else if (typeof fieldType === 'string') {
    	                docsTypes.push('<' + fieldType + '>');
    	            } else if (Array.isArray(fieldType)) {
    	                docsTypes.push('List'); // TODO: use type enum
    	            } else {
    	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
    	            }
    	        }

    	        docs[key] = docsTypes.join(' | ');
    	    }

    	    return {
    	        docs: docs,
    	        check: createNodeStructureChecker(name, fields)
    	    };
    	}

    	structure = {
    	    getStructureFromConfig: function(config) {
    	        var structure = {};

    	        if (config.node) {
    	            for (var name in config.node) {
    	                if (hasOwnProperty.call(config.node, name)) {
    	                    var nodeType = config.node[name];

    	                    if (nodeType.structure) {
    	                        structure[name] = processStructure(name, nodeType);
    	                    } else {
    	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
    	                    }
    	                }
    	            }
    	        }

    	        return structure;
    	    }
    	};
    	return structure;
    }

    var Lexer_1;
    var hasRequiredLexer$1;

    function requireLexer$1 () {
    	if (hasRequiredLexer$1) return Lexer_1;
    	hasRequiredLexer$1 = 1;
    	var SyntaxReferenceError = requireError().SyntaxReferenceError;
    	var SyntaxMatchError = requireError().SyntaxMatchError;
    	var names = requireNames();
    	var generic = requireGeneric();
    	var parse = requireParse();
    	var generate = requireGenerate();
    	var walk = requireWalk();
    	var prepareTokens = requirePrepareTokens();
    	var buildMatchGraph = requireMatchGraph().buildMatchGraph;
    	var matchAsTree = requireMatch().matchAsTree;
    	var trace = requireTrace();
    	var search = requireSearch();
    	var getStructureFromConfig = requireStructure().getStructureFromConfig;
    	var cssWideKeywords = buildMatchGraph('inherit | initial | unset');
    	var cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');

    	function dumpMapSyntax(map, compact, syntaxAsAst) {
    	    var result = {};

    	    for (var name in map) {
    	        if (map[name].syntax) {
    	            result[name] = syntaxAsAst
    	                ? map[name].syntax
    	                : generate(map[name].syntax, { compact: compact });
    	        }
    	    }

    	    return result;
    	}

    	function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    	    const result = {};

    	    for (const [name, atrule] of Object.entries(map)) {
    	        result[name] = {
    	            prelude: atrule.prelude && (
    	                syntaxAsAst
    	                    ? atrule.prelude.syntax
    	                    : generate(atrule.prelude.syntax, { compact })
    	            ),
    	            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
    	        };
    	    }

    	    return result;
    	}

    	function valueHasVar(tokens) {
    	    for (var i = 0; i < tokens.length; i++) {
    	        if (tokens[i].value.toLowerCase() === 'var(') {
    	            return true;
    	        }
    	    }

    	    return false;
    	}

    	function buildMatchResult(match, error, iterations) {
    	    return {
    	        matched: match,
    	        iterations: iterations,
    	        error: error,
    	        getTrace: trace.getTrace,
    	        isType: trace.isType,
    	        isProperty: trace.isProperty,
    	        isKeyword: trace.isKeyword
    	    };
    	}

    	function matchSyntax(lexer, syntax, value, useCommon) {
    	    var tokens = prepareTokens(value, lexer.syntax);
    	    var result;

    	    if (valueHasVar(tokens)) {
    	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
    	    }

    	    if (useCommon) {
    	        result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
    	    }

    	    if (!useCommon || !result.match) {
    	        result = matchAsTree(tokens, syntax.match, lexer);
    	        if (!result.match) {
    	            return buildMatchResult(
    	                null,
    	                new SyntaxMatchError(result.reason, syntax.syntax, value, result),
    	                result.iterations
    	            );
    	        }
    	    }

    	    return buildMatchResult(result.match, null, result.iterations);
    	}

    	var Lexer = function(config, syntax, structure) {
    	    this.valueCommonSyntax = cssWideKeywords;
    	    this.syntax = syntax;
    	    this.generic = false;
    	    this.atrules = {};
    	    this.properties = {};
    	    this.types = {};
    	    this.structure = structure || getStructureFromConfig(config);

    	    if (config) {
    	        if (config.types) {
    	            for (var name in config.types) {
    	                this.addType_(name, config.types[name]);
    	            }
    	        }

    	        if (config.generic) {
    	            this.generic = true;
    	            for (var name in generic) {
    	                this.addType_(name, generic[name]);
    	            }
    	        }

    	        if (config.atrules) {
    	            for (var name in config.atrules) {
    	                this.addAtrule_(name, config.atrules[name]);
    	            }
    	        }

    	        if (config.properties) {
    	            for (var name in config.properties) {
    	                this.addProperty_(name, config.properties[name]);
    	            }
    	        }
    	    }
    	};

    	Lexer.prototype = {
    	    structure: {},
    	    checkStructure: function(ast) {
    	        function collectWarning(node, message) {
    	            warns.push({
    	                node: node,
    	                message: message
    	            });
    	        }

    	        var structure = this.structure;
    	        var warns = [];

    	        this.syntax.walk(ast, function(node) {
    	            if (structure.hasOwnProperty(node.type)) {
    	                structure[node.type].check(node, collectWarning);
    	            } else {
    	                collectWarning(node, 'Unknown node type `' + node.type + '`');
    	            }
    	        });

    	        return warns.length ? warns : false;
    	    },

    	    createDescriptor: function(syntax, type, name, parent = null) {
    	        var ref = {
    	            type: type,
    	            name: name
    	        };
    	        var descriptor = {
    	            type: type,
    	            name: name,
    	            parent: parent,
    	            syntax: null,
    	            match: null
    	        };

    	        if (typeof syntax === 'function') {
    	            descriptor.match = buildMatchGraph(syntax, ref);
    	        } else {
    	            if (typeof syntax === 'string') {
    	                // lazy parsing on first access
    	                Object.defineProperty(descriptor, 'syntax', {
    	                    get: function() {
    	                        Object.defineProperty(descriptor, 'syntax', {
    	                            value: parse(syntax)
    	                        });

    	                        return descriptor.syntax;
    	                    }
    	                });
    	            } else {
    	                descriptor.syntax = syntax;
    	            }

    	            // lazy graph build on first access
    	            Object.defineProperty(descriptor, 'match', {
    	                get: function() {
    	                    Object.defineProperty(descriptor, 'match', {
    	                        value: buildMatchGraph(descriptor.syntax, ref)
    	                    });

    	                    return descriptor.match;
    	                }
    	            });
    	        }

    	        return descriptor;
    	    },
    	    addAtrule_: function(name, syntax) {
    	        if (!syntax) {
    	            return;
    	        }

    	        this.atrules[name] = {
    	            type: 'Atrule',
    	            name: name,
    	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
    	            descriptors: syntax.descriptors
    	                ? Object.keys(syntax.descriptors).reduce((res, descName) => {
    	                    res[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);
    	                    return res;
    	                }, {})
    	                : null
    	        };
    	    },
    	    addProperty_: function(name, syntax) {
    	        if (!syntax) {
    	            return;
    	        }

    	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
    	    },
    	    addType_: function(name, syntax) {
    	        if (!syntax) {
    	            return;
    	        }

    	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

    	        if (syntax === generic['-ms-legacy-expression']) {
    	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
    	        }
    	    },

    	    checkAtruleName: function(atruleName) {
    	        if (!this.getAtrule(atruleName)) {
    	            return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);
    	        }
    	    },
    	    checkAtrulePrelude: function(atruleName, prelude) {
    	        let error = this.checkAtruleName(atruleName);

    	        if (error) {
    	            return error;
    	        }

    	        var atrule = this.getAtrule(atruleName);

    	        if (!atrule.prelude && prelude) {
    	            return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');
    	        }

    	        if (atrule.prelude && !prelude) {
    	            return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');
    	        }
    	    },
    	    checkAtruleDescriptorName: function(atruleName, descriptorName) {
    	        let error = this.checkAtruleName(atruleName);

    	        if (error) {
    	            return error;
    	        }

    	        var atrule = this.getAtrule(atruleName);
    	        var descriptor = names.keyword(descriptorName);

    	        if (!atrule.descriptors) {
    	            return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');
    	        }

    	        if (!atrule.descriptors[descriptor.name] &&
    	            !atrule.descriptors[descriptor.basename]) {
    	            return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);
    	        }
    	    },
    	    checkPropertyName: function(propertyName) {
    	        var property = names.property(propertyName);

    	        // don't match syntax for a custom property
    	        if (property.custom) {
    	            return new Error('Lexer matching doesn\'t applicable for custom properties');
    	        }

    	        if (!this.getProperty(propertyName)) {
    	            return new SyntaxReferenceError('Unknown property', propertyName);
    	        }
    	    },

    	    matchAtrulePrelude: function(atruleName, prelude) {
    	        var error = this.checkAtrulePrelude(atruleName, prelude);

    	        if (error) {
    	            return buildMatchResult(null, error);
    	        }

    	        if (!prelude) {
    	            return buildMatchResult(null, null);
    	        }

    	        return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);
    	    },
    	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
    	        var error = this.checkAtruleDescriptorName(atruleName, descriptorName);

    	        if (error) {
    	            return buildMatchResult(null, error);
    	        }

    	        var atrule = this.getAtrule(atruleName);
    	        var descriptor = names.keyword(descriptorName);

    	        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
    	    },
    	    matchDeclaration: function(node) {
    	        if (node.type !== 'Declaration') {
    	            return buildMatchResult(null, new Error('Not a Declaration node'));
    	        }

    	        return this.matchProperty(node.property, node.value);
    	    },
    	    matchProperty: function(propertyName, value) {
    	        var error = this.checkPropertyName(propertyName);

    	        if (error) {
    	            return buildMatchResult(null, error);
    	        }

    	        return matchSyntax(this, this.getProperty(propertyName), value, true);
    	    },
    	    matchType: function(typeName, value) {
    	        var typeSyntax = this.getType(typeName);

    	        if (!typeSyntax) {
    	            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));
    	        }

    	        return matchSyntax(this, typeSyntax, value, false);
    	    },
    	    match: function(syntax, value) {
    	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
    	            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));
    	        }

    	        if (typeof syntax === 'string' || !syntax.match) {
    	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
    	        }

    	        return matchSyntax(this, syntax, value, false);
    	    },

    	    findValueFragments: function(propertyName, value, type, name) {
    	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    	    },
    	    findDeclarationValueFragments: function(declaration, type, name) {
    	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    	    },
    	    findAllFragments: function(ast, type, name) {
    	        var result = [];

    	        this.syntax.walk(ast, {
    	            visit: 'Declaration',
    	            enter: function(declaration) {
    	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
    	            }.bind(this)
    	        });

    	        return result;
    	    },

    	    getAtrule: function(atruleName, fallbackBasename = true) {
    	        var atrule = names.keyword(atruleName);
    	        var atruleEntry = atrule.vendor && fallbackBasename
    	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
    	            : this.atrules[atrule.name];

    	        return atruleEntry || null;
    	    },
    	    getAtrulePrelude: function(atruleName, fallbackBasename = true) {
    	        const atrule = this.getAtrule(atruleName, fallbackBasename);

    	        return atrule && atrule.prelude || null;
    	    },
    	    getAtruleDescriptor: function(atruleName, name) {
    	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
    	            ? this.atrules[atruleName].declarators[name] || null
    	            : null;
    	    },
    	    getProperty: function(propertyName, fallbackBasename = true) {
    	        var property = names.property(propertyName);
    	        var propertyEntry = property.vendor && fallbackBasename
    	            ? this.properties[property.name] || this.properties[property.basename]
    	            : this.properties[property.name];

    	        return propertyEntry || null;
    	    },
    	    getType: function(name) {
    	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
    	    },

    	    validate: function() {
    	        function validate(syntax, name, broken, descriptor) {
    	            if (broken.hasOwnProperty(name)) {
    	                return broken[name];
    	            }

    	            broken[name] = false;
    	            if (descriptor.syntax !== null) {
    	                walk(descriptor.syntax, function(node) {
    	                    if (node.type !== 'Type' && node.type !== 'Property') {
    	                        return;
    	                    }

    	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
    	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

    	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
    	                        broken[name] = true;
    	                    }
    	                }, this);
    	            }
    	        }

    	        var brokenTypes = {};
    	        var brokenProperties = {};

    	        for (var key in this.types) {
    	            validate(this, key, brokenTypes, this.types[key]);
    	        }

    	        for (var key in this.properties) {
    	            validate(this, key, brokenProperties, this.properties[key]);
    	        }

    	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
    	            return brokenTypes[name];
    	        });
    	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
    	            return brokenProperties[name];
    	        });

    	        if (brokenTypes.length || brokenProperties.length) {
    	            return {
    	                types: brokenTypes,
    	                properties: brokenProperties
    	            };
    	        }

    	        return null;
    	    },
    	    dump: function(syntaxAsAst, pretty) {
    	        return {
    	            generic: this.generic,
    	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
    	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
    	            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
    	        };
    	    },
    	    toString: function() {
    	        return JSON.stringify(this.dump());
    	    }
    	};

    	Lexer_1 = Lexer;
    	return Lexer_1;
    }

    var definitionSyntax;
    var hasRequiredDefinitionSyntax;

    function requireDefinitionSyntax () {
    	if (hasRequiredDefinitionSyntax) return definitionSyntax;
    	hasRequiredDefinitionSyntax = 1;
    	definitionSyntax = {
    	    SyntaxError: require_SyntaxError(),
    	    parse: requireParse(),
    	    generate: requireGenerate(),
    	    walk: requireWalk()
    	};
    	return definitionSyntax;
    }

    var OffsetToLocation_1;
    var hasRequiredOffsetToLocation;

    function requireOffsetToLocation () {
    	if (hasRequiredOffsetToLocation) return OffsetToLocation_1;
    	hasRequiredOffsetToLocation = 1;
    	var adoptBuffer = requireAdoptBuffer();
    	var isBOM = requireTokenizer$1().isBOM;

    	var N = 10;
    	var F = 12;
    	var R = 13;

    	function computeLinesAndColumns(host, source) {
    	    var sourceLength = source.length;
    	    var lines = adoptBuffer(host.lines, sourceLength); // +1
    	    var line = host.startLine;
    	    var columns = adoptBuffer(host.columns, sourceLength);
    	    var column = host.startColumn;
    	    var startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;

    	    for (var i = startOffset; i < sourceLength; i++) { // -1
    	        var code = source.charCodeAt(i);

    	        lines[i] = line;
    	        columns[i] = column++;

    	        if (code === N || code === R || code === F) {
    	            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
    	                i++;
    	                lines[i] = line;
    	                columns[i] = column;
    	            }

    	            line++;
    	            column = 1;
    	        }
    	    }

    	    lines[i] = line;
    	    columns[i] = column;

    	    host.lines = lines;
    	    host.columns = columns;
    	}

    	var OffsetToLocation = function() {
    	    this.lines = null;
    	    this.columns = null;
    	    this.linesAndColumnsComputed = false;
    	};

    	OffsetToLocation.prototype = {
    	    setSource: function(source, startOffset, startLine, startColumn) {
    	        this.source = source;
    	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
    	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
    	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
    	        this.linesAndColumnsComputed = false;
    	    },

    	    ensureLinesAndColumnsComputed: function() {
    	        if (!this.linesAndColumnsComputed) {
    	            computeLinesAndColumns(this, this.source);
    	            this.linesAndColumnsComputed = true;
    	        }
    	    },
    	    getLocation: function(offset, filename) {
    	        this.ensureLinesAndColumnsComputed();

    	        return {
    	            source: filename,
    	            offset: this.startOffset + offset,
    	            line: this.lines[offset],
    	            column: this.columns[offset]
    	        };
    	    },
    	    getLocationRange: function(start, end, filename) {
    	        this.ensureLinesAndColumnsComputed();

    	        return {
    	            source: filename,
    	            start: {
    	                offset: this.startOffset + start,
    	                line: this.lines[start],
    	                column: this.columns[start]
    	            },
    	            end: {
    	                offset: this.startOffset + end,
    	                line: this.lines[end],
    	                column: this.columns[end]
    	            }
    	        };
    	    }
    	};

    	OffsetToLocation_1 = OffsetToLocation;
    	return OffsetToLocation_1;
    }

    var sequence;
    var hasRequiredSequence;

    function requireSequence () {
    	if (hasRequiredSequence) return sequence;
    	hasRequiredSequence = 1;
    	var TYPE = requireTokenizer$1().TYPE;
    	var WHITESPACE = TYPE.WhiteSpace;
    	var COMMENT = TYPE.Comment;

    	sequence = function readSequence(recognizer) {
    	    var children = this.createList();
    	    var child = null;
    	    var context = {
    	        recognizer: recognizer,
    	        space: null,
    	        ignoreWS: false,
    	        ignoreWSAfter: false
    	    };

    	    this.scanner.skipSC();

    	    while (!this.scanner.eof) {
    	        switch (this.scanner.tokenType) {
    	            case COMMENT:
    	                this.scanner.next();
    	                continue;

    	            case WHITESPACE:
    	                if (context.ignoreWS) {
    	                    this.scanner.next();
    	                } else {
    	                    context.space = this.WhiteSpace();
    	                }
    	                continue;
    	        }

    	        child = recognizer.getNode.call(this, context);

    	        if (child === undefined) {
    	            break;
    	        }

    	        if (context.space !== null) {
    	            children.push(context.space);
    	            context.space = null;
    	        }

    	        children.push(child);

    	        if (context.ignoreWSAfter) {
    	            context.ignoreWSAfter = false;
    	            context.ignoreWS = true;
    	        } else {
    	            context.ignoreWS = false;
    	        }
    	    }

    	    return children;
    	};
    	return sequence;
    }

    var create$3;
    var hasRequiredCreate$4;

    function requireCreate$4 () {
    	if (hasRequiredCreate$4) return create$3;
    	hasRequiredCreate$4 = 1;
    	var OffsetToLocation = requireOffsetToLocation();
    	var SyntaxError = require_SyntaxError$1();
    	var TokenStream = requireTokenStream();
    	var List = requireList();
    	var tokenize = requireTokenizer$1();
    	var constants = require_const();
    	var { findWhiteSpaceStart, cmpStr } = requireUtils();
    	var sequence = requireSequence();
    	var noop = function() {};

    	var TYPE = constants.TYPE;
    	var NAME = constants.NAME;
    	var WHITESPACE = TYPE.WhiteSpace;
    	var COMMENT = TYPE.Comment;
    	var IDENT = TYPE.Ident;
    	var FUNCTION = TYPE.Function;
    	var URL = TYPE.Url;
    	var HASH = TYPE.Hash;
    	var PERCENTAGE = TYPE.Percentage;
    	var NUMBER = TYPE.Number;
    	var NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)
    	var NULL = 0;

    	function createParseContext(name) {
    	    return function() {
    	        return this[name]();
    	    };
    	}

    	function processConfig(config) {
    	    var parserConfig = {
    	        context: {},
    	        scope: {},
    	        atrule: {},
    	        pseudo: {}
    	    };

    	    if (config.parseContext) {
    	        for (var name in config.parseContext) {
    	            switch (typeof config.parseContext[name]) {
    	                case 'function':
    	                    parserConfig.context[name] = config.parseContext[name];
    	                    break;

    	                case 'string':
    	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
    	                    break;
    	            }
    	        }
    	    }

    	    if (config.scope) {
    	        for (var name in config.scope) {
    	            parserConfig.scope[name] = config.scope[name];
    	        }
    	    }

    	    if (config.atrule) {
    	        for (var name in config.atrule) {
    	            var atrule = config.atrule[name];

    	            if (atrule.parse) {
    	                parserConfig.atrule[name] = atrule.parse;
    	            }
    	        }
    	    }

    	    if (config.pseudo) {
    	        for (var name in config.pseudo) {
    	            var pseudo = config.pseudo[name];

    	            if (pseudo.parse) {
    	                parserConfig.pseudo[name] = pseudo.parse;
    	            }
    	        }
    	    }

    	    if (config.node) {
    	        for (var name in config.node) {
    	            parserConfig[name] = config.node[name].parse;
    	        }
    	    }

    	    return parserConfig;
    	}

    	create$3 = function createParser(config) {
    	    var parser = {
    	        scanner: new TokenStream(),
    	        locationMap: new OffsetToLocation(),

    	        filename: '<unknown>',
    	        needPositions: false,
    	        onParseError: noop,
    	        onParseErrorThrow: false,
    	        parseAtrulePrelude: true,
    	        parseRulePrelude: true,
    	        parseValue: true,
    	        parseCustomProperty: false,

    	        readSequence: sequence,

    	        createList: function() {
    	            return new List();
    	        },
    	        createSingleNodeList: function(node) {
    	            return new List().appendData(node);
    	        },
    	        getFirstListNode: function(list) {
    	            return list && list.first();
    	        },
    	        getLastListNode: function(list) {
    	            return list.last();
    	        },

    	        parseWithFallback: function(consumer, fallback) {
    	            var startToken = this.scanner.tokenIndex;

    	            try {
    	                return consumer.call(this);
    	            } catch (e) {
    	                if (this.onParseErrorThrow) {
    	                    throw e;
    	                }

    	                var fallbackNode = fallback.call(this, startToken);

    	                this.onParseErrorThrow = true;
    	                this.onParseError(e, fallbackNode);
    	                this.onParseErrorThrow = false;

    	                return fallbackNode;
    	            }
    	        },

    	        lookupNonWSType: function(offset) {
    	            do {
    	                var type = this.scanner.lookupType(offset++);
    	                if (type !== WHITESPACE) {
    	                    return type;
    	                }
    	            } while (type !== NULL);

    	            return NULL;
    	        },

    	        eat: function(tokenType) {
    	            if (this.scanner.tokenType !== tokenType) {
    	                var offset = this.scanner.tokenStart;
    	                var message = NAME[tokenType] + ' is expected';

    	                // tweak message and offset
    	                switch (tokenType) {
    	                    case IDENT:
    	                        // when identifier is expected but there is a function or url
    	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {
    	                            offset = this.scanner.tokenEnd - 1;
    	                            message = 'Identifier is expected but function found';
    	                        } else {
    	                            message = 'Identifier is expected';
    	                        }
    	                        break;

    	                    case HASH:
    	                        if (this.scanner.isDelim(NUMBERSIGN)) {
    	                            this.scanner.next();
    	                            offset++;
    	                            message = 'Name is expected';
    	                        }
    	                        break;

    	                    case PERCENTAGE:
    	                        if (this.scanner.tokenType === NUMBER) {
    	                            offset = this.scanner.tokenEnd;
    	                            message = 'Percent sign is expected';
    	                        }
    	                        break;

    	                    default:
    	                        // when test type is part of another token show error for current position + 1
    	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
    	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
    	                            offset = offset + 1;
    	                        }
    	                }

    	                this.error(message, offset);
    	            }

    	            this.scanner.next();
    	        },

    	        consume: function(tokenType) {
    	            var value = this.scanner.getTokenValue();

    	            this.eat(tokenType);

    	            return value;
    	        },
    	        consumeFunctionName: function() {
    	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

    	            this.eat(FUNCTION);

    	            return name;
    	        },

    	        getLocation: function(start, end) {
    	            if (this.needPositions) {
    	                return this.locationMap.getLocationRange(
    	                    start,
    	                    end,
    	                    this.filename
    	                );
    	            }

    	            return null;
    	        },
    	        getLocationFromList: function(list) {
    	            if (this.needPositions) {
    	                var head = this.getFirstListNode(list);
    	                var tail = this.getLastListNode(list);
    	                return this.locationMap.getLocationRange(
    	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
    	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
    	                    this.filename
    	                );
    	            }

    	            return null;
    	        },

    	        error: function(message, offset) {
    	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
    	                ? this.locationMap.getLocation(offset)
    	                : this.scanner.eof
    	                    ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1))
    	                    : this.locationMap.getLocation(this.scanner.tokenStart);

    	            throw new SyntaxError(
    	                message || 'Unexpected input',
    	                this.scanner.source,
    	                location.offset,
    	                location.line,
    	                location.column
    	            );
    	        }
    	    };

    	    config = processConfig(config || {});
    	    for (var key in config) {
    	        parser[key] = config[key];
    	    }

    	    return function(source, options) {
    	        options = options || {};

    	        var context = options.context || 'default';
    	        var onComment = options.onComment;
    	        var ast;

    	        tokenize(source, parser.scanner);
    	        parser.locationMap.setSource(
    	            source,
    	            options.offset,
    	            options.line,
    	            options.column
    	        );

    	        parser.filename = options.filename || '<unknown>';
    	        parser.needPositions = Boolean(options.positions);
    	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;
    	        parser.onParseErrorThrow = false;
    	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
    	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
    	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
    	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

    	        if (!parser.context.hasOwnProperty(context)) {
    	            throw new Error('Unknown context `' + context + '`');
    	        }

    	        if (typeof onComment === 'function') {
    	            parser.scanner.forEachToken((type, start, end) => {
    	                if (type === COMMENT) {
    	                    const loc = parser.getLocation(start, end);
    	                    const value = cmpStr(source, end - 2, end, '*/')
    	                        ? source.slice(start + 2, end - 2)
    	                        : source.slice(start + 2, end);

    	                    onComment(value, loc);
    	                }
    	            });
    	        }

    	        ast = parser.context[context].call(parser, options);

    	        if (!parser.scanner.eof) {
    	            parser.error();
    	        }

    	        return ast;
    	    };
    	};
    	return create$3;
    }

    var sourceMapGenerator = {};

    var base64Vlq = {};

    var base64 = {};

    /* -*- Mode: js; js-indent-level: 2; -*- */

    var hasRequiredBase64;

    function requireBase64 () {
    	if (hasRequiredBase64) return base64;
    	hasRequiredBase64 = 1;
    	/*
    	 * Copyright 2011 Mozilla Foundation and contributors
    	 * Licensed under the New BSD license. See LICENSE or:
    	 * http://opensource.org/licenses/BSD-3-Clause
    	 */

    	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

    	/**
    	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
    	 */
    	base64.encode = function (number) {
    	  if (0 <= number && number < intToCharMap.length) {
    	    return intToCharMap[number];
    	  }
    	  throw new TypeError("Must be between 0 and 63: " + number);
    	};

    	/**
    	 * Decode a single base 64 character code digit to an integer. Returns -1 on
    	 * failure.
    	 */
    	base64.decode = function (charCode) {
    	  var bigA = 65;     // 'A'
    	  var bigZ = 90;     // 'Z'

    	  var littleA = 97;  // 'a'
    	  var littleZ = 122; // 'z'

    	  var zero = 48;     // '0'
    	  var nine = 57;     // '9'

    	  var plus = 43;     // '+'
    	  var slash = 47;    // '/'

    	  var littleOffset = 26;
    	  var numberOffset = 52;

    	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    	  if (bigA <= charCode && charCode <= bigZ) {
    	    return (charCode - bigA);
    	  }

    	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
    	  if (littleA <= charCode && charCode <= littleZ) {
    	    return (charCode - littleA + littleOffset);
    	  }

    	  // 52 - 61: 0123456789
    	  if (zero <= charCode && charCode <= nine) {
    	    return (charCode - zero + numberOffset);
    	  }

    	  // 62: +
    	  if (charCode == plus) {
    	    return 62;
    	  }

    	  // 63: /
    	  if (charCode == slash) {
    	    return 63;
    	  }

    	  // Invalid base64 digit.
    	  return -1;
    	};
    	return base64;
    }

    /* -*- Mode: js; js-indent-level: 2; -*- */

    var hasRequiredBase64Vlq;

    function requireBase64Vlq () {
    	if (hasRequiredBase64Vlq) return base64Vlq;
    	hasRequiredBase64Vlq = 1;
    	/*
    	 * Copyright 2011 Mozilla Foundation and contributors
    	 * Licensed under the New BSD license. See LICENSE or:
    	 * http://opensource.org/licenses/BSD-3-Clause
    	 *
    	 * Based on the Base 64 VLQ implementation in Closure Compiler:
    	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
    	 *
    	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
    	 * Redistribution and use in source and binary forms, with or without
    	 * modification, are permitted provided that the following conditions are
    	 * met:
    	 *
    	 *  * Redistributions of source code must retain the above copyright
    	 *    notice, this list of conditions and the following disclaimer.
    	 *  * Redistributions in binary form must reproduce the above
    	 *    copyright notice, this list of conditions and the following
    	 *    disclaimer in the documentation and/or other materials provided
    	 *    with the distribution.
    	 *  * Neither the name of Google Inc. nor the names of its
    	 *    contributors may be used to endorse or promote products derived
    	 *    from this software without specific prior written permission.
    	 *
    	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    	 */

    	var base64 = requireBase64();

    	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
    	// length quantities we use in the source map spec, the first bit is the sign,
    	// the next four bits are the actual value, and the 6th bit is the
    	// continuation bit. The continuation bit tells us whether there are more
    	// digits in this value following this digit.
    	//
    	//   Continuation
    	//   |    Sign
    	//   |    |
    	//   V    V
    	//   101011

    	var VLQ_BASE_SHIFT = 5;

    	// binary: 100000
    	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

    	// binary: 011111
    	var VLQ_BASE_MASK = VLQ_BASE - 1;

    	// binary: 100000
    	var VLQ_CONTINUATION_BIT = VLQ_BASE;

    	/**
    	 * Converts from a two-complement value to a value where the sign bit is
    	 * placed in the least significant bit.  For example, as decimals:
    	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
    	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
    	 */
    	function toVLQSigned(aValue) {
    	  return aValue < 0
    	    ? ((-aValue) << 1) + 1
    	    : (aValue << 1) + 0;
    	}

    	/**
    	 * Converts to a two-complement value from a value where the sign bit is
    	 * placed in the least significant bit.  For example, as decimals:
    	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
    	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
    	 */
    	function fromVLQSigned(aValue) {
    	  var isNegative = (aValue & 1) === 1;
    	  var shifted = aValue >> 1;
    	  return isNegative
    	    ? -shifted
    	    : shifted;
    	}

    	/**
    	 * Returns the base 64 VLQ encoded value.
    	 */
    	base64Vlq.encode = function base64VLQ_encode(aValue) {
    	  var encoded = "";
    	  var digit;

    	  var vlq = toVLQSigned(aValue);

    	  do {
    	    digit = vlq & VLQ_BASE_MASK;
    	    vlq >>>= VLQ_BASE_SHIFT;
    	    if (vlq > 0) {
    	      // There are still more digits in this value, so we must make sure the
    	      // continuation bit is marked.
    	      digit |= VLQ_CONTINUATION_BIT;
    	    }
    	    encoded += base64.encode(digit);
    	  } while (vlq > 0);

    	  return encoded;
    	};

    	/**
    	 * Decodes the next base 64 VLQ value from the given string and returns the
    	 * value and the rest of the string via the out parameter.
    	 */
    	base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    	  var strLen = aStr.length;
    	  var result = 0;
    	  var shift = 0;
    	  var continuation, digit;

    	  do {
    	    if (aIndex >= strLen) {
    	      throw new Error("Expected more digits in base 64 VLQ value.");
    	    }

    	    digit = base64.decode(aStr.charCodeAt(aIndex++));
    	    if (digit === -1) {
    	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    	    }

    	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    	    digit &= VLQ_BASE_MASK;
    	    result = result + (digit << shift);
    	    shift += VLQ_BASE_SHIFT;
    	  } while (continuation);

    	  aOutParam.value = fromVLQSigned(result);
    	  aOutParam.rest = aIndex;
    	};
    	return base64Vlq;
    }

    var util = {};

    /* -*- Mode: js; js-indent-level: 2; -*- */

    var hasRequiredUtil;

    function requireUtil () {
    	if (hasRequiredUtil) return util;
    	hasRequiredUtil = 1;
    	(function (exports) {
    		/*
    		 * Copyright 2011 Mozilla Foundation and contributors
    		 * Licensed under the New BSD license. See LICENSE or:
    		 * http://opensource.org/licenses/BSD-3-Clause
    		 */

    		/**
    		 * This is a helper function for getting values from parameter/options
    		 * objects.
    		 *
    		 * @param args The object we are extracting values from
    		 * @param name The name of the property we are getting.
    		 * @param defaultValue An optional value to return if the property is missing
    		 * from the object. If this is not specified and the property is missing, an
    		 * error will be thrown.
    		 */
    		function getArg(aArgs, aName, aDefaultValue) {
    		  if (aName in aArgs) {
    		    return aArgs[aName];
    		  } else if (arguments.length === 3) {
    		    return aDefaultValue;
    		  } else {
    		    throw new Error('"' + aName + '" is a required argument.');
    		  }
    		}
    		exports.getArg = getArg;

    		var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    		var dataUrlRegexp = /^data:.+\,.+$/;

    		function urlParse(aUrl) {
    		  var match = aUrl.match(urlRegexp);
    		  if (!match) {
    		    return null;
    		  }
    		  return {
    		    scheme: match[1],
    		    auth: match[2],
    		    host: match[3],
    		    port: match[4],
    		    path: match[5]
    		  };
    		}
    		exports.urlParse = urlParse;

    		function urlGenerate(aParsedUrl) {
    		  var url = '';
    		  if (aParsedUrl.scheme) {
    		    url += aParsedUrl.scheme + ':';
    		  }
    		  url += '//';
    		  if (aParsedUrl.auth) {
    		    url += aParsedUrl.auth + '@';
    		  }
    		  if (aParsedUrl.host) {
    		    url += aParsedUrl.host;
    		  }
    		  if (aParsedUrl.port) {
    		    url += ":" + aParsedUrl.port;
    		  }
    		  if (aParsedUrl.path) {
    		    url += aParsedUrl.path;
    		  }
    		  return url;
    		}
    		exports.urlGenerate = urlGenerate;

    		/**
    		 * Normalizes a path, or the path portion of a URL:
    		 *
    		 * - Replaces consecutive slashes with one slash.
    		 * - Removes unnecessary '.' parts.
    		 * - Removes unnecessary '<dir>/..' parts.
    		 *
    		 * Based on code in the Node.js 'path' core module.
    		 *
    		 * @param aPath The path or url to normalize.
    		 */
    		function normalize(aPath) {
    		  var path = aPath;
    		  var url = urlParse(aPath);
    		  if (url) {
    		    if (!url.path) {
    		      return aPath;
    		    }
    		    path = url.path;
    		  }
    		  var isAbsolute = exports.isAbsolute(path);

    		  var parts = path.split(/\/+/);
    		  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    		    part = parts[i];
    		    if (part === '.') {
    		      parts.splice(i, 1);
    		    } else if (part === '..') {
    		      up++;
    		    } else if (up > 0) {
    		      if (part === '') {
    		        // The first part is blank if the path is absolute. Trying to go
    		        // above the root is a no-op. Therefore we can remove all '..' parts
    		        // directly after the root.
    		        parts.splice(i + 1, up);
    		        up = 0;
    		      } else {
    		        parts.splice(i, 2);
    		        up--;
    		      }
    		    }
    		  }
    		  path = parts.join('/');

    		  if (path === '') {
    		    path = isAbsolute ? '/' : '.';
    		  }

    		  if (url) {
    		    url.path = path;
    		    return urlGenerate(url);
    		  }
    		  return path;
    		}
    		exports.normalize = normalize;

    		/**
    		 * Joins two paths/URLs.
    		 *
    		 * @param aRoot The root path or URL.
    		 * @param aPath The path or URL to be joined with the root.
    		 *
    		 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
    		 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
    		 *   first.
    		 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
    		 *   is updated with the result and aRoot is returned. Otherwise the result
    		 *   is returned.
    		 *   - If aPath is absolute, the result is aPath.
    		 *   - Otherwise the two paths are joined with a slash.
    		 * - Joining for example 'http://' and 'www.example.com' is also supported.
    		 */
    		function join(aRoot, aPath) {
    		  if (aRoot === "") {
    		    aRoot = ".";
    		  }
    		  if (aPath === "") {
    		    aPath = ".";
    		  }
    		  var aPathUrl = urlParse(aPath);
    		  var aRootUrl = urlParse(aRoot);
    		  if (aRootUrl) {
    		    aRoot = aRootUrl.path || '/';
    		  }

    		  // `join(foo, '//www.example.org')`
    		  if (aPathUrl && !aPathUrl.scheme) {
    		    if (aRootUrl) {
    		      aPathUrl.scheme = aRootUrl.scheme;
    		    }
    		    return urlGenerate(aPathUrl);
    		  }

    		  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    		    return aPath;
    		  }

    		  // `join('http://', 'www.example.com')`
    		  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    		    aRootUrl.host = aPath;
    		    return urlGenerate(aRootUrl);
    		  }

    		  var joined = aPath.charAt(0) === '/'
    		    ? aPath
    		    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    		  if (aRootUrl) {
    		    aRootUrl.path = joined;
    		    return urlGenerate(aRootUrl);
    		  }
    		  return joined;
    		}
    		exports.join = join;

    		exports.isAbsolute = function (aPath) {
    		  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
    		};

    		/**
    		 * Make a path relative to a URL or another path.
    		 *
    		 * @param aRoot The root path or URL.
    		 * @param aPath The path or URL to be made relative to aRoot.
    		 */
    		function relative(aRoot, aPath) {
    		  if (aRoot === "") {
    		    aRoot = ".";
    		  }

    		  aRoot = aRoot.replace(/\/$/, '');

    		  // It is possible for the path to be above the root. In this case, simply
    		  // checking whether the root is a prefix of the path won't work. Instead, we
    		  // need to remove components from the root one by one, until either we find
    		  // a prefix that fits, or we run out of components to remove.
    		  var level = 0;
    		  while (aPath.indexOf(aRoot + '/') !== 0) {
    		    var index = aRoot.lastIndexOf("/");
    		    if (index < 0) {
    		      return aPath;
    		    }

    		    // If the only part of the root that is left is the scheme (i.e. http://,
    		    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    		    // have exhausted all components, so the path is not relative to the root.
    		    aRoot = aRoot.slice(0, index);
    		    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
    		      return aPath;
    		    }

    		    ++level;
    		  }

    		  // Make sure we add a "../" for each component we removed from the root.
    		  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    		}
    		exports.relative = relative;

    		var supportsNullProto = (function () {
    		  var obj = Object.create(null);
    		  return !('__proto__' in obj);
    		}());

    		function identity (s) {
    		  return s;
    		}

    		/**
    		 * Because behavior goes wacky when you set `__proto__` on objects, we
    		 * have to prefix all the strings in our set with an arbitrary character.
    		 *
    		 * See https://github.com/mozilla/source-map/pull/31 and
    		 * https://github.com/mozilla/source-map/issues/30
    		 *
    		 * @param String aStr
    		 */
    		function toSetString(aStr) {
    		  if (isProtoString(aStr)) {
    		    return '$' + aStr;
    		  }

    		  return aStr;
    		}
    		exports.toSetString = supportsNullProto ? identity : toSetString;

    		function fromSetString(aStr) {
    		  if (isProtoString(aStr)) {
    		    return aStr.slice(1);
    		  }

    		  return aStr;
    		}
    		exports.fromSetString = supportsNullProto ? identity : fromSetString;

    		function isProtoString(s) {
    		  if (!s) {
    		    return false;
    		  }

    		  var length = s.length;

    		  if (length < 9 /* "__proto__".length */) {
    		    return false;
    		  }

    		  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
    		      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
    		      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
    		      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
    		      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
    		      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
    		      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
    		      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
    		      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    		    return false;
    		  }

    		  for (var i = length - 10; i >= 0; i--) {
    		    if (s.charCodeAt(i) !== 36 /* '$' */) {
    		      return false;
    		    }
    		  }

    		  return true;
    		}

    		/**
    		 * Comparator between two mappings where the original positions are compared.
    		 *
    		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
    		 * mappings with the same original source/line/column, but different generated
    		 * line and column the same. Useful when searching for a mapping with a
    		 * stubbed out mapping.
    		 */
    		function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    		  var cmp = strcmp(mappingA.source, mappingB.source);
    		  if (cmp !== 0) {
    		    return cmp;
    		  }

    		  cmp = mappingA.originalLine - mappingB.originalLine;
    		  if (cmp !== 0) {
    		    return cmp;
    		  }

    		  cmp = mappingA.originalColumn - mappingB.originalColumn;
    		  if (cmp !== 0 || onlyCompareOriginal) {
    		    return cmp;
    		  }

    		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    		  if (cmp !== 0) {
    		    return cmp;
    		  }

    		  cmp = mappingA.generatedLine - mappingB.generatedLine;
    		  if (cmp !== 0) {
    		    return cmp;
    		  }

    		  return strcmp(mappingA.name, mappingB.name);
    		}
    		exports.compareByOriginalPositions = compareByOriginalPositions;

    		/**
    		 * Comparator between two mappings with deflated source and name indices where
    		 * the generated positions are compared.
    		 *
    		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
    		 * mappings with the same generated line and column, but different
    		 * source/name/original line and column the same. Useful when searching for a
    		 * mapping with a stubbed out mapping.
    		 */
    		function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
    		  if (cmp !== 0) {
    		    return cmp;
    		  }

    		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    		  if (cmp !== 0 || onlyCompareGenerated) {
    		    return cmp;
    		  }

    		  cmp = strcmp(mappingA.source, mappingB.source);
    		  if (cmp !== 0) {
    		    return cmp;
    		  }

    		  cmp = mappingA.originalLine - mappingB.originalLine;
    		  if (cmp !== 0) {
    		    return cmp;
    		  }

    		  cmp = mappingA.originalColumn - mappingB.originalColumn;
    		  if (cmp !== 0) {
    		    return cmp;
    		  }

    		  return strcmp(mappingA.name, mappingB.name);
    		}
    		exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

    		function strcmp(aStr1, aStr2) {
    		  if (aStr1 === aStr2) {
    		    return 0;
    		  }

    		  if (aStr1 === null) {
    		    return 1; // aStr2 !== null
    		  }

    		  if (aStr2 === null) {
    		    return -1; // aStr1 !== null
    		  }

    		  if (aStr1 > aStr2) {
    		    return 1;
    		  }

    		  return -1;
    		}

    		/**
    		 * Comparator between two mappings with inflated source and name strings where
    		 * the generated positions are compared.
    		 */
    		function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
    		  if (cmp !== 0) {
    		    return cmp;
    		  }

    		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    		  if (cmp !== 0) {
    		    return cmp;
    		  }

    		  cmp = strcmp(mappingA.source, mappingB.source);
    		  if (cmp !== 0) {
    		    return cmp;
    		  }

    		  cmp = mappingA.originalLine - mappingB.originalLine;
    		  if (cmp !== 0) {
    		    return cmp;
    		  }

    		  cmp = mappingA.originalColumn - mappingB.originalColumn;
    		  if (cmp !== 0) {
    		    return cmp;
    		  }

    		  return strcmp(mappingA.name, mappingB.name);
    		}
    		exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

    		/**
    		 * Strip any JSON XSSI avoidance prefix from the string (as documented
    		 * in the source maps specification), and then parse the string as
    		 * JSON.
    		 */
    		function parseSourceMapInput(str) {
    		  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
    		}
    		exports.parseSourceMapInput = parseSourceMapInput;

    		/**
    		 * Compute the URL of a source given the the source root, the source's
    		 * URL, and the source map's URL.
    		 */
    		function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    		  sourceURL = sourceURL || '';

    		  if (sourceRoot) {
    		    // This follows what Chrome does.
    		    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
    		      sourceRoot += '/';
    		    }
    		    // The spec says:
    		    //   Line 4: An optional source root, useful for relocating source
    		    //   files on a server or removing repeated values in the
    		    //   sources entry.  This value is prepended to the individual
    		    //   entries in the source field.
    		    sourceURL = sourceRoot + sourceURL;
    		  }

    		  // Historically, SourceMapConsumer did not take the sourceMapURL as
    		  // a parameter.  This mode is still somewhat supported, which is why
    		  // this code block is conditional.  However, it's preferable to pass
    		  // the source map URL to SourceMapConsumer, so that this function
    		  // can implement the source URL resolution algorithm as outlined in
    		  // the spec.  This block is basically the equivalent of:
    		  //    new URL(sourceURL, sourceMapURL).toString()
    		  // ... except it avoids using URL, which wasn't available in the
    		  // older releases of node still supported by this library.
    		  //
    		  // The spec says:
    		  //   If the sources are not absolute URLs after prepending of the
    		  //   sourceRoot, the sources are resolved relative to the
    		  //   SourceMap (like resolving script src in a html document).
    		  if (sourceMapURL) {
    		    var parsed = urlParse(sourceMapURL);
    		    if (!parsed) {
    		      throw new Error("sourceMapURL could not be parsed");
    		    }
    		    if (parsed.path) {
    		      // Strip the last path component, but keep the "/".
    		      var index = parsed.path.lastIndexOf('/');
    		      if (index >= 0) {
    		        parsed.path = parsed.path.substring(0, index + 1);
    		      }
    		    }
    		    sourceURL = join(urlGenerate(parsed), sourceURL);
    		  }

    		  return normalize(sourceURL);
    		}
    		exports.computeSourceURL = computeSourceURL; 
    	} (util));
    	return util;
    }

    var arraySet = {};

    /* -*- Mode: js; js-indent-level: 2; -*- */

    var hasRequiredArraySet;

    function requireArraySet () {
    	if (hasRequiredArraySet) return arraySet;
    	hasRequiredArraySet = 1;
    	/*
    	 * Copyright 2011 Mozilla Foundation and contributors
    	 * Licensed under the New BSD license. See LICENSE or:
    	 * http://opensource.org/licenses/BSD-3-Clause
    	 */

    	var util = requireUtil();
    	var has = Object.prototype.hasOwnProperty;
    	var hasNativeMap = typeof Map !== "undefined";

    	/**
    	 * A data structure which is a combination of an array and a set. Adding a new
    	 * member is O(1), testing for membership is O(1), and finding the index of an
    	 * element is O(1). Removing elements from the set is not supported. Only
    	 * strings are supported for membership.
    	 */
    	function ArraySet() {
    	  this._array = [];
    	  this._set = hasNativeMap ? new Map() : Object.create(null);
    	}

    	/**
    	 * Static method for creating ArraySet instances from an existing array.
    	 */
    	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    	  var set = new ArraySet();
    	  for (var i = 0, len = aArray.length; i < len; i++) {
    	    set.add(aArray[i], aAllowDuplicates);
    	  }
    	  return set;
    	};

    	/**
    	 * Return how many unique items are in this ArraySet. If duplicates have been
    	 * added, than those do not count towards the size.
    	 *
    	 * @returns Number
    	 */
    	ArraySet.prototype.size = function ArraySet_size() {
    	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    	};

    	/**
    	 * Add the given string to this set.
    	 *
    	 * @param String aStr
    	 */
    	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    	  var idx = this._array.length;
    	  if (!isDuplicate || aAllowDuplicates) {
    	    this._array.push(aStr);
    	  }
    	  if (!isDuplicate) {
    	    if (hasNativeMap) {
    	      this._set.set(aStr, idx);
    	    } else {
    	      this._set[sStr] = idx;
    	    }
    	  }
    	};

    	/**
    	 * Is the given string a member of this set?
    	 *
    	 * @param String aStr
    	 */
    	ArraySet.prototype.has = function ArraySet_has(aStr) {
    	  if (hasNativeMap) {
    	    return this._set.has(aStr);
    	  } else {
    	    var sStr = util.toSetString(aStr);
    	    return has.call(this._set, sStr);
    	  }
    	};

    	/**
    	 * What is the index of the given string in the array?
    	 *
    	 * @param String aStr
    	 */
    	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    	  if (hasNativeMap) {
    	    var idx = this._set.get(aStr);
    	    if (idx >= 0) {
    	        return idx;
    	    }
    	  } else {
    	    var sStr = util.toSetString(aStr);
    	    if (has.call(this._set, sStr)) {
    	      return this._set[sStr];
    	    }
    	  }

    	  throw new Error('"' + aStr + '" is not in the set.');
    	};

    	/**
    	 * What is the element at the given index?
    	 *
    	 * @param Number aIdx
    	 */
    	ArraySet.prototype.at = function ArraySet_at(aIdx) {
    	  if (aIdx >= 0 && aIdx < this._array.length) {
    	    return this._array[aIdx];
    	  }
    	  throw new Error('No element indexed by ' + aIdx);
    	};

    	/**
    	 * Returns the array representation of this set (which has the proper indices
    	 * indicated by indexOf). Note that this is a copy of the internal array used
    	 * for storing the members so that no one can mess with internal state.
    	 */
    	ArraySet.prototype.toArray = function ArraySet_toArray() {
    	  return this._array.slice();
    	};

    	arraySet.ArraySet = ArraySet;
    	return arraySet;
    }

    var mappingList = {};

    /* -*- Mode: js; js-indent-level: 2; -*- */

    var hasRequiredMappingList;

    function requireMappingList () {
    	if (hasRequiredMappingList) return mappingList;
    	hasRequiredMappingList = 1;
    	/*
    	 * Copyright 2014 Mozilla Foundation and contributors
    	 * Licensed under the New BSD license. See LICENSE or:
    	 * http://opensource.org/licenses/BSD-3-Clause
    	 */

    	var util = requireUtil();

    	/**
    	 * Determine whether mappingB is after mappingA with respect to generated
    	 * position.
    	 */
    	function generatedPositionAfter(mappingA, mappingB) {
    	  // Optimized for most common case
    	  var lineA = mappingA.generatedLine;
    	  var lineB = mappingB.generatedLine;
    	  var columnA = mappingA.generatedColumn;
    	  var columnB = mappingB.generatedColumn;
    	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
    	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    	}

    	/**
    	 * A data structure to provide a sorted view of accumulated mappings in a
    	 * performance conscious manner. It trades a neglibable overhead in general
    	 * case for a large speedup in case of mappings being added in order.
    	 */
    	function MappingList() {
    	  this._array = [];
    	  this._sorted = true;
    	  // Serves as infimum
    	  this._last = {generatedLine: -1, generatedColumn: 0};
    	}

    	/**
    	 * Iterate through internal items. This method takes the same arguments that
    	 * `Array.prototype.forEach` takes.
    	 *
    	 * NOTE: The order of the mappings is NOT guaranteed.
    	 */
    	MappingList.prototype.unsortedForEach =
    	  function MappingList_forEach(aCallback, aThisArg) {
    	    this._array.forEach(aCallback, aThisArg);
    	  };

    	/**
    	 * Add the given source mapping.
    	 *
    	 * @param Object aMapping
    	 */
    	MappingList.prototype.add = function MappingList_add(aMapping) {
    	  if (generatedPositionAfter(this._last, aMapping)) {
    	    this._last = aMapping;
    	    this._array.push(aMapping);
    	  } else {
    	    this._sorted = false;
    	    this._array.push(aMapping);
    	  }
    	};

    	/**
    	 * Returns the flat, sorted array of mappings. The mappings are sorted by
    	 * generated position.
    	 *
    	 * WARNING: This method returns internal data without copying, for
    	 * performance. The return value must NOT be mutated, and should be treated as
    	 * an immutable borrow. If you want to take ownership, you must make your own
    	 * copy.
    	 */
    	MappingList.prototype.toArray = function MappingList_toArray() {
    	  if (!this._sorted) {
    	    this._array.sort(util.compareByGeneratedPositionsInflated);
    	    this._sorted = true;
    	  }
    	  return this._array;
    	};

    	mappingList.MappingList = MappingList;
    	return mappingList;
    }

    /* -*- Mode: js; js-indent-level: 2; -*- */

    var hasRequiredSourceMapGenerator;

    function requireSourceMapGenerator () {
    	if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
    	hasRequiredSourceMapGenerator = 1;
    	/*
    	 * Copyright 2011 Mozilla Foundation and contributors
    	 * Licensed under the New BSD license. See LICENSE or:
    	 * http://opensource.org/licenses/BSD-3-Clause
    	 */

    	var base64VLQ = requireBase64Vlq();
    	var util = requireUtil();
    	var ArraySet = requireArraySet().ArraySet;
    	var MappingList = requireMappingList().MappingList;

    	/**
    	 * An instance of the SourceMapGenerator represents a source map which is
    	 * being built incrementally. You may pass an object with the following
    	 * properties:
    	 *
    	 *   - file: The filename of the generated source.
    	 *   - sourceRoot: A root for all relative URLs in this source map.
    	 */
    	function SourceMapGenerator(aArgs) {
    	  if (!aArgs) {
    	    aArgs = {};
    	  }
    	  this._file = util.getArg(aArgs, 'file', null);
    	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    	  this._sources = new ArraySet();
    	  this._names = new ArraySet();
    	  this._mappings = new MappingList();
    	  this._sourcesContents = null;
    	}

    	SourceMapGenerator.prototype._version = 3;

    	/**
    	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
    	 *
    	 * @param aSourceMapConsumer The SourceMap.
    	 */
    	SourceMapGenerator.fromSourceMap =
    	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    	    var sourceRoot = aSourceMapConsumer.sourceRoot;
    	    var generator = new SourceMapGenerator({
    	      file: aSourceMapConsumer.file,
    	      sourceRoot: sourceRoot
    	    });
    	    aSourceMapConsumer.eachMapping(function (mapping) {
    	      var newMapping = {
    	        generated: {
    	          line: mapping.generatedLine,
    	          column: mapping.generatedColumn
    	        }
    	      };

    	      if (mapping.source != null) {
    	        newMapping.source = mapping.source;
    	        if (sourceRoot != null) {
    	          newMapping.source = util.relative(sourceRoot, newMapping.source);
    	        }

    	        newMapping.original = {
    	          line: mapping.originalLine,
    	          column: mapping.originalColumn
    	        };

    	        if (mapping.name != null) {
    	          newMapping.name = mapping.name;
    	        }
    	      }

    	      generator.addMapping(newMapping);
    	    });
    	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
    	      var sourceRelative = sourceFile;
    	      if (sourceRoot !== null) {
    	        sourceRelative = util.relative(sourceRoot, sourceFile);
    	      }

    	      if (!generator._sources.has(sourceRelative)) {
    	        generator._sources.add(sourceRelative);
    	      }

    	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    	      if (content != null) {
    	        generator.setSourceContent(sourceFile, content);
    	      }
    	    });
    	    return generator;
    	  };

    	/**
    	 * Add a single mapping from original source line and column to the generated
    	 * source's line and column for this source map being created. The mapping
    	 * object should have the following properties:
    	 *
    	 *   - generated: An object with the generated line and column positions.
    	 *   - original: An object with the original line and column positions.
    	 *   - source: The original source file (relative to the sourceRoot).
    	 *   - name: An optional original token name for this mapping.
    	 */
    	SourceMapGenerator.prototype.addMapping =
    	  function SourceMapGenerator_addMapping(aArgs) {
    	    var generated = util.getArg(aArgs, 'generated');
    	    var original = util.getArg(aArgs, 'original', null);
    	    var source = util.getArg(aArgs, 'source', null);
    	    var name = util.getArg(aArgs, 'name', null);

    	    if (!this._skipValidation) {
    	      this._validateMapping(generated, original, source, name);
    	    }

    	    if (source != null) {
    	      source = String(source);
    	      if (!this._sources.has(source)) {
    	        this._sources.add(source);
    	      }
    	    }

    	    if (name != null) {
    	      name = String(name);
    	      if (!this._names.has(name)) {
    	        this._names.add(name);
    	      }
    	    }

    	    this._mappings.add({
    	      generatedLine: generated.line,
    	      generatedColumn: generated.column,
    	      originalLine: original != null && original.line,
    	      originalColumn: original != null && original.column,
    	      source: source,
    	      name: name
    	    });
    	  };

    	/**
    	 * Set the source content for a source file.
    	 */
    	SourceMapGenerator.prototype.setSourceContent =
    	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    	    var source = aSourceFile;
    	    if (this._sourceRoot != null) {
    	      source = util.relative(this._sourceRoot, source);
    	    }

    	    if (aSourceContent != null) {
    	      // Add the source content to the _sourcesContents map.
    	      // Create a new _sourcesContents map if the property is null.
    	      if (!this._sourcesContents) {
    	        this._sourcesContents = Object.create(null);
    	      }
    	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    	    } else if (this._sourcesContents) {
    	      // Remove the source file from the _sourcesContents map.
    	      // If the _sourcesContents map is empty, set the property to null.
    	      delete this._sourcesContents[util.toSetString(source)];
    	      if (Object.keys(this._sourcesContents).length === 0) {
    	        this._sourcesContents = null;
    	      }
    	    }
    	  };

    	/**
    	 * Applies the mappings of a sub-source-map for a specific source file to the
    	 * source map being generated. Each mapping to the supplied source file is
    	 * rewritten using the supplied source map. Note: The resolution for the
    	 * resulting mappings is the minimium of this map and the supplied map.
    	 *
    	 * @param aSourceMapConsumer The source map to be applied.
    	 * @param aSourceFile Optional. The filename of the source file.
    	 *        If omitted, SourceMapConsumer's file property will be used.
    	 * @param aSourceMapPath Optional. The dirname of the path to the source map
    	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
    	 *        This parameter is needed when the two source maps aren't in the same
    	 *        directory, and the source map to be applied contains relative source
    	 *        paths. If so, those relative source paths need to be rewritten
    	 *        relative to the SourceMapGenerator.
    	 */
    	SourceMapGenerator.prototype.applySourceMap =
    	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    	    var sourceFile = aSourceFile;
    	    // If aSourceFile is omitted, we will use the file property of the SourceMap
    	    if (aSourceFile == null) {
    	      if (aSourceMapConsumer.file == null) {
    	        throw new Error(
    	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
    	          'or the source map\'s "file" property. Both were omitted.'
    	        );
    	      }
    	      sourceFile = aSourceMapConsumer.file;
    	    }
    	    var sourceRoot = this._sourceRoot;
    	    // Make "sourceFile" relative if an absolute Url is passed.
    	    if (sourceRoot != null) {
    	      sourceFile = util.relative(sourceRoot, sourceFile);
    	    }
    	    // Applying the SourceMap can add and remove items from the sources and
    	    // the names array.
    	    var newSources = new ArraySet();
    	    var newNames = new ArraySet();

    	    // Find mappings for the "sourceFile"
    	    this._mappings.unsortedForEach(function (mapping) {
    	      if (mapping.source === sourceFile && mapping.originalLine != null) {
    	        // Check if it can be mapped by the source map, then update the mapping.
    	        var original = aSourceMapConsumer.originalPositionFor({
    	          line: mapping.originalLine,
    	          column: mapping.originalColumn
    	        });
    	        if (original.source != null) {
    	          // Copy mapping
    	          mapping.source = original.source;
    	          if (aSourceMapPath != null) {
    	            mapping.source = util.join(aSourceMapPath, mapping.source);
    	          }
    	          if (sourceRoot != null) {
    	            mapping.source = util.relative(sourceRoot, mapping.source);
    	          }
    	          mapping.originalLine = original.line;
    	          mapping.originalColumn = original.column;
    	          if (original.name != null) {
    	            mapping.name = original.name;
    	          }
    	        }
    	      }

    	      var source = mapping.source;
    	      if (source != null && !newSources.has(source)) {
    	        newSources.add(source);
    	      }

    	      var name = mapping.name;
    	      if (name != null && !newNames.has(name)) {
    	        newNames.add(name);
    	      }

    	    }, this);
    	    this._sources = newSources;
    	    this._names = newNames;

    	    // Copy sourcesContents of applied map.
    	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
    	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    	      if (content != null) {
    	        if (aSourceMapPath != null) {
    	          sourceFile = util.join(aSourceMapPath, sourceFile);
    	        }
    	        if (sourceRoot != null) {
    	          sourceFile = util.relative(sourceRoot, sourceFile);
    	        }
    	        this.setSourceContent(sourceFile, content);
    	      }
    	    }, this);
    	  };

    	/**
    	 * A mapping can have one of the three levels of data:
    	 *
    	 *   1. Just the generated position.
    	 *   2. The Generated position, original position, and original source.
    	 *   3. Generated and original position, original source, as well as a name
    	 *      token.
    	 *
    	 * To maintain consistency, we validate that any new mapping being added falls
    	 * in to one of these categories.
    	 */
    	SourceMapGenerator.prototype._validateMapping =
    	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
    	                                              aName) {
    	    // When aOriginal is truthy but has empty values for .line and .column,
    	    // it is most likely a programmer error. In this case we throw a very
    	    // specific error message to try to guide them the right way.
    	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
    	        throw new Error(
    	            'original.line and original.column are not numbers -- you probably meant to omit ' +
    	            'the original mapping entirely and only map the generated position. If so, pass ' +
    	            'null for the original mapping instead of an object with empty or null values.'
    	        );
    	    }

    	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
    	        && aGenerated.line > 0 && aGenerated.column >= 0
    	        && !aOriginal && !aSource && !aName) {
    	      // Case 1.
    	      return;
    	    }
    	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
    	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
    	             && aGenerated.line > 0 && aGenerated.column >= 0
    	             && aOriginal.line > 0 && aOriginal.column >= 0
    	             && aSource) {
    	      // Cases 2 and 3.
    	      return;
    	    }
    	    else {
    	      throw new Error('Invalid mapping: ' + JSON.stringify({
    	        generated: aGenerated,
    	        source: aSource,
    	        original: aOriginal,
    	        name: aName
    	      }));
    	    }
    	  };

    	/**
    	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
    	 * specified by the source map format.
    	 */
    	SourceMapGenerator.prototype._serializeMappings =
    	  function SourceMapGenerator_serializeMappings() {
    	    var previousGeneratedColumn = 0;
    	    var previousGeneratedLine = 1;
    	    var previousOriginalColumn = 0;
    	    var previousOriginalLine = 0;
    	    var previousName = 0;
    	    var previousSource = 0;
    	    var result = '';
    	    var next;
    	    var mapping;
    	    var nameIdx;
    	    var sourceIdx;

    	    var mappings = this._mappings.toArray();
    	    for (var i = 0, len = mappings.length; i < len; i++) {
    	      mapping = mappings[i];
    	      next = '';

    	      if (mapping.generatedLine !== previousGeneratedLine) {
    	        previousGeneratedColumn = 0;
    	        while (mapping.generatedLine !== previousGeneratedLine) {
    	          next += ';';
    	          previousGeneratedLine++;
    	        }
    	      }
    	      else {
    	        if (i > 0) {
    	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
    	            continue;
    	          }
    	          next += ',';
    	        }
    	      }

    	      next += base64VLQ.encode(mapping.generatedColumn
    	                                 - previousGeneratedColumn);
    	      previousGeneratedColumn = mapping.generatedColumn;

    	      if (mapping.source != null) {
    	        sourceIdx = this._sources.indexOf(mapping.source);
    	        next += base64VLQ.encode(sourceIdx - previousSource);
    	        previousSource = sourceIdx;

    	        // lines are stored 0-based in SourceMap spec version 3
    	        next += base64VLQ.encode(mapping.originalLine - 1
    	                                   - previousOriginalLine);
    	        previousOriginalLine = mapping.originalLine - 1;

    	        next += base64VLQ.encode(mapping.originalColumn
    	                                   - previousOriginalColumn);
    	        previousOriginalColumn = mapping.originalColumn;

    	        if (mapping.name != null) {
    	          nameIdx = this._names.indexOf(mapping.name);
    	          next += base64VLQ.encode(nameIdx - previousName);
    	          previousName = nameIdx;
    	        }
    	      }

    	      result += next;
    	    }

    	    return result;
    	  };

    	SourceMapGenerator.prototype._generateSourcesContent =
    	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    	    return aSources.map(function (source) {
    	      if (!this._sourcesContents) {
    	        return null;
    	      }
    	      if (aSourceRoot != null) {
    	        source = util.relative(aSourceRoot, source);
    	      }
    	      var key = util.toSetString(source);
    	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
    	        ? this._sourcesContents[key]
    	        : null;
    	    }, this);
    	  };

    	/**
    	 * Externalize the source map.
    	 */
    	SourceMapGenerator.prototype.toJSON =
    	  function SourceMapGenerator_toJSON() {
    	    var map = {
    	      version: this._version,
    	      sources: this._sources.toArray(),
    	      names: this._names.toArray(),
    	      mappings: this._serializeMappings()
    	    };
    	    if (this._file != null) {
    	      map.file = this._file;
    	    }
    	    if (this._sourceRoot != null) {
    	      map.sourceRoot = this._sourceRoot;
    	    }
    	    if (this._sourcesContents) {
    	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    	    }

    	    return map;
    	  };

    	/**
    	 * Render the source map being generated to a string.
    	 */
    	SourceMapGenerator.prototype.toString =
    	  function SourceMapGenerator_toString() {
    	    return JSON.stringify(this.toJSON());
    	  };

    	sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
    	return sourceMapGenerator;
    }

    var sourceMap;
    var hasRequiredSourceMap;

    function requireSourceMap () {
    	if (hasRequiredSourceMap) return sourceMap;
    	hasRequiredSourceMap = 1;
    	var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
    	var trackNodes = {
    	    Atrule: true,
    	    Selector: true,
    	    Declaration: true
    	};

    	sourceMap = function generateSourceMap(handlers) {
    	    var map = new SourceMapGenerator();
    	    var line = 1;
    	    var column = 0;
    	    var generated = {
    	        line: 1,
    	        column: 0
    	    };
    	    var original = {
    	        line: 0, // should be zero to add first mapping
    	        column: 0
    	    };
    	    var sourceMappingActive = false;
    	    var activatedGenerated = {
    	        line: 1,
    	        column: 0
    	    };
    	    var activatedMapping = {
    	        generated: activatedGenerated
    	    };

    	    var handlersNode = handlers.node;
    	    handlers.node = function(node) {
    	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
    	            var nodeLine = node.loc.start.line;
    	            var nodeColumn = node.loc.start.column - 1;

    	            if (original.line !== nodeLine ||
    	                original.column !== nodeColumn) {
    	                original.line = nodeLine;
    	                original.column = nodeColumn;

    	                generated.line = line;
    	                generated.column = column;

    	                if (sourceMappingActive) {
    	                    sourceMappingActive = false;
    	                    if (generated.line !== activatedGenerated.line ||
    	                        generated.column !== activatedGenerated.column) {
    	                        map.addMapping(activatedMapping);
    	                    }
    	                }

    	                sourceMappingActive = true;
    	                map.addMapping({
    	                    source: node.loc.source,
    	                    original: original,
    	                    generated: generated
    	                });
    	            }
    	        }

    	        handlersNode.call(this, node);

    	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
    	            activatedGenerated.line = line;
    	            activatedGenerated.column = column;
    	        }
    	    };

    	    var handlersChunk = handlers.chunk;
    	    handlers.chunk = function(chunk) {
    	        for (var i = 0; i < chunk.length; i++) {
    	            if (chunk.charCodeAt(i) === 10) { // \n
    	                line++;
    	                column = 0;
    	            } else {
    	                column++;
    	            }
    	        }

    	        handlersChunk(chunk);
    	    };

    	    var handlersResult = handlers.result;
    	    handlers.result = function() {
    	        if (sourceMappingActive) {
    	            map.addMapping(activatedMapping);
    	        }

    	        return {
    	            css: handlersResult(),
    	            map: map
    	        };
    	    };

    	    return handlers;
    	};
    	return sourceMap;
    }

    var create$2;
    var hasRequiredCreate$3;

    function requireCreate$3 () {
    	if (hasRequiredCreate$3) return create$2;
    	hasRequiredCreate$3 = 1;
    	var sourceMap = requireSourceMap();
    	var hasOwnProperty = Object.prototype.hasOwnProperty;

    	function processChildren(node, delimeter) {
    	    var list = node.children;
    	    var prev = null;

    	    if (typeof delimeter !== 'function') {
    	        list.forEach(this.node, this);
    	    } else {
    	        list.forEach(function(node) {
    	            if (prev !== null) {
    	                delimeter.call(this, prev);
    	            }

    	            this.node(node);
    	            prev = node;
    	        }, this);
    	    }
    	}

    	create$2 = function createGenerator(config) {
    	    function processNode(node) {
    	        if (hasOwnProperty.call(types, node.type)) {
    	            types[node.type].call(this, node);
    	        } else {
    	            throw new Error('Unknown node type: ' + node.type);
    	        }
    	    }

    	    var types = {};

    	    if (config.node) {
    	        for (var name in config.node) {
    	            types[name] = config.node[name].generate;
    	        }
    	    }

    	    return function(node, options) {
    	        var buffer = '';
    	        var handlers = {
    	            children: processChildren,
    	            node: processNode,
    	            chunk: function(chunk) {
    	                buffer += chunk;
    	            },
    	            result: function() {
    	                return buffer;
    	            }
    	        };

    	        if (options) {
    	            if (typeof options.decorator === 'function') {
    	                handlers = options.decorator(handlers);
    	            }

    	            if (options.sourceMap) {
    	                handlers = sourceMap(handlers);
    	            }
    	        }

    	        handlers.node(node);

    	        return handlers.result();
    	    };
    	};
    	return create$2;
    }

    var create$1;
    var hasRequiredCreate$2;

    function requireCreate$2 () {
    	if (hasRequiredCreate$2) return create$1;
    	hasRequiredCreate$2 = 1;
    	var List = requireList();

    	create$1 = function createConvertors(walk) {
    	    return {
    	        fromPlainObject: function(ast) {
    	            walk(ast, {
    	                enter: function(node) {
    	                    if (node.children && node.children instanceof List === false) {
    	                        node.children = new List().fromArray(node.children);
    	                    }
    	                }
    	            });

    	            return ast;
    	        },
    	        toPlainObject: function(ast) {
    	            walk(ast, {
    	                leave: function(node) {
    	                    if (node.children && node.children instanceof List) {
    	                        node.children = node.children.toArray();
    	                    }
    	                }
    	            });

    	            return ast;
    	        }
    	    };
    	};
    	return create$1;
    }

    var create;
    var hasRequiredCreate$1;

    function requireCreate$1 () {
    	if (hasRequiredCreate$1) return create;
    	hasRequiredCreate$1 = 1;
    	var hasOwnProperty = Object.prototype.hasOwnProperty;
    	var noop = function() {};

    	function ensureFunction(value) {
    	    return typeof value === 'function' ? value : noop;
    	}

    	function invokeForType(fn, type) {
    	    return function(node, item, list) {
    	        if (node.type === type) {
    	            fn.call(this, node, item, list);
    	        }
    	    };
    	}

    	function getWalkersFromStructure(name, nodeType) {
    	    var structure = nodeType.structure;
    	    var walkers = [];

    	    for (var key in structure) {
    	        if (hasOwnProperty.call(structure, key) === false) {
    	            continue;
    	        }

    	        var fieldTypes = structure[key];
    	        var walker = {
    	            name: key,
    	            type: false,
    	            nullable: false
    	        };

    	        if (!Array.isArray(structure[key])) {
    	            fieldTypes = [structure[key]];
    	        }

    	        for (var i = 0; i < fieldTypes.length; i++) {
    	            var fieldType = fieldTypes[i];
    	            if (fieldType === null) {
    	                walker.nullable = true;
    	            } else if (typeof fieldType === 'string') {
    	                walker.type = 'node';
    	            } else if (Array.isArray(fieldType)) {
    	                walker.type = 'list';
    	            }
    	        }

    	        if (walker.type) {
    	            walkers.push(walker);
    	        }
    	    }

    	    if (walkers.length) {
    	        return {
    	            context: nodeType.walkContext,
    	            fields: walkers
    	        };
    	    }

    	    return null;
    	}

    	function getTypesFromConfig(config) {
    	    var types = {};

    	    for (var name in config.node) {
    	        if (hasOwnProperty.call(config.node, name)) {
    	            var nodeType = config.node[name];

    	            if (!nodeType.structure) {
    	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
    	            }

    	            types[name] = getWalkersFromStructure(name, nodeType);
    	        }
    	    }

    	    return types;
    	}

    	function createTypeIterator(config, reverse) {
    	    var fields = config.fields.slice();
    	    var contextName = config.context;
    	    var useContext = typeof contextName === 'string';

    	    if (reverse) {
    	        fields.reverse();
    	    }

    	    return function(node, context, walk, walkReducer) {
    	        var prevContextValue;

    	        if (useContext) {
    	            prevContextValue = context[contextName];
    	            context[contextName] = node;
    	        }

    	        for (var i = 0; i < fields.length; i++) {
    	            var field = fields[i];
    	            var ref = node[field.name];

    	            if (!field.nullable || ref) {
    	                if (field.type === 'list') {
    	                    var breakWalk = reverse
    	                        ? ref.reduceRight(walkReducer, false)
    	                        : ref.reduce(walkReducer, false);

    	                    if (breakWalk) {
    	                        return true;
    	                    }
    	                } else if (walk(ref)) {
    	                    return true;
    	                }
    	            }
    	        }

    	        if (useContext) {
    	            context[contextName] = prevContextValue;
    	        }
    	    };
    	}

    	function createFastTraveralMap(iterators) {
    	    return {
    	        Atrule: {
    	            StyleSheet: iterators.StyleSheet,
    	            Atrule: iterators.Atrule,
    	            Rule: iterators.Rule,
    	            Block: iterators.Block
    	        },
    	        Rule: {
    	            StyleSheet: iterators.StyleSheet,
    	            Atrule: iterators.Atrule,
    	            Rule: iterators.Rule,
    	            Block: iterators.Block
    	        },
    	        Declaration: {
    	            StyleSheet: iterators.StyleSheet,
    	            Atrule: iterators.Atrule,
    	            Rule: iterators.Rule,
    	            Block: iterators.Block,
    	            DeclarationList: iterators.DeclarationList
    	        }
    	    };
    	}

    	create = function createWalker(config) {
    	    var types = getTypesFromConfig(config);
    	    var iteratorsNatural = {};
    	    var iteratorsReverse = {};
    	    var breakWalk = Symbol('break-walk');
    	    var skipNode = Symbol('skip-node');

    	    for (var name in types) {
    	        if (hasOwnProperty.call(types, name) && types[name] !== null) {
    	            iteratorsNatural[name] = createTypeIterator(types[name], false);
    	            iteratorsReverse[name] = createTypeIterator(types[name], true);
    	        }
    	    }

    	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

    	    var walk = function(root, options) {
    	        function walkNode(node, item, list) {
    	            var enterRet = enter.call(context, node, item, list);

    	            if (enterRet === breakWalk) {
    	                debugger;
    	                return true;
    	            }

    	            if (enterRet === skipNode) {
    	                return false;
    	            }

    	            if (iterators.hasOwnProperty(node.type)) {
    	                if (iterators[node.type](node, context, walkNode, walkReducer)) {
    	                    return true;
    	                }
    	            }

    	            if (leave.call(context, node, item, list) === breakWalk) {
    	                return true;
    	            }

    	            return false;
    	        }

    	        var walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
    	        var enter = noop;
    	        var leave = noop;
    	        var iterators = iteratorsNatural;
    	        var context = {
    	            break: breakWalk,
    	            skip: skipNode,

    	            root: root,
    	            stylesheet: null,
    	            atrule: null,
    	            atrulePrelude: null,
    	            rule: null,
    	            selector: null,
    	            block: null,
    	            declaration: null,
    	            function: null
    	        };

    	        if (typeof options === 'function') {
    	            enter = options;
    	        } else if (options) {
    	            enter = ensureFunction(options.enter);
    	            leave = ensureFunction(options.leave);

    	            if (options.reverse) {
    	                iterators = iteratorsReverse;
    	            }

    	            if (options.visit) {
    	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
    	                    iterators = options.reverse
    	                        ? fastTraversalIteratorsReverse[options.visit]
    	                        : fastTraversalIteratorsNatural[options.visit];
    	                } else if (!types.hasOwnProperty(options.visit)) {
    	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
    	                }

    	                enter = invokeForType(enter, options.visit);
    	                leave = invokeForType(leave, options.visit);
    	            }
    	        }

    	        if (enter === noop && leave === noop) {
    	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    	        }

    	        walkNode(root);
    	    };

    	    walk.break = breakWalk;
    	    walk.skip = skipNode;

    	    walk.find = function(ast, fn) {
    	        var found = null;

    	        walk(ast, function(node, item, list) {
    	            if (fn.call(this, node, item, list)) {
    	                found = node;
    	                return breakWalk;
    	            }
    	        });

    	        return found;
    	    };

    	    walk.findLast = function(ast, fn) {
    	        var found = null;

    	        walk(ast, {
    	            reverse: true,
    	            enter: function(node, item, list) {
    	                if (fn.call(this, node, item, list)) {
    	                    found = node;
    	                    return breakWalk;
    	                }
    	            }
    	        });

    	        return found;
    	    };

    	    walk.findAll = function(ast, fn) {
    	        var found = [];

    	        walk(ast, function(node, item, list) {
    	            if (fn.call(this, node, item, list)) {
    	                found.push(node);
    	            }
    	        });

    	        return found;
    	    };

    	    return walk;
    	};
    	return create;
    }

    var clone;
    var hasRequiredClone;

    function requireClone () {
    	if (hasRequiredClone) return clone;
    	hasRequiredClone = 1;
    	var List = requireList();

    	clone = function clone(node) {
    	    var result = {};

    	    for (var key in node) {
    	        var value = node[key];

    	        if (value) {
    	            if (Array.isArray(value) || value instanceof List) {
    	                value = value.map(clone);
    	            } else if (value.constructor === Object) {
    	                value = clone(value);
    	            }
    	        }

    	        result[key] = value;
    	    }

    	    return result;
    	};
    	return clone;
    }

    var mix_1;
    var hasRequiredMix;

    function requireMix () {
    	if (hasRequiredMix) return mix_1;
    	hasRequiredMix = 1;
    	const hasOwnProperty = Object.prototype.hasOwnProperty;
    	const shape = {
    	    generic: true,
    	    types: appendOrAssign,
    	    atrules: {
    	        prelude: appendOrAssignOrNull,
    	        descriptors: appendOrAssignOrNull
    	    },
    	    properties: appendOrAssign,
    	    parseContext: assign,
    	    scope: deepAssign,
    	    atrule: ['parse'],
    	    pseudo: ['parse'],
    	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
    	};

    	function isObject(value) {
    	    return value && value.constructor === Object;
    	}

    	function copy(value) {
    	    return isObject(value)
    	        ? Object.assign({}, value)
    	        : value;
    	}

    	function assign(dest, src) {
    	    return Object.assign(dest, src);
    	}

    	function deepAssign(dest, src) {
    	    for (const key in src) {
    	        if (hasOwnProperty.call(src, key)) {
    	            if (isObject(dest[key])) {
    	                deepAssign(dest[key], copy(src[key]));
    	            } else {
    	                dest[key] = copy(src[key]);
    	            }
    	        }
    	    }

    	    return dest;
    	}

    	function append(a, b) {
    	    if (typeof b === 'string' && /^\s*\|/.test(b)) {
    	        return typeof a === 'string'
    	            ? a + b
    	            : b.replace(/^\s*\|\s*/, '');
    	    }

    	    return b || null;
    	}

    	function appendOrAssign(a, b) {
    	    if (typeof b === 'string') {
    	        return append(a, b);
    	    }

    	    const result = Object.assign({}, a);
    	    for (let key in b) {
    	        if (hasOwnProperty.call(b, key)) {
    	            result[key] = append(hasOwnProperty.call(a, key) ? a[key] : undefined, b[key]);
    	        }
    	    }

    	    return result;
    	}

    	function appendOrAssignOrNull(a, b) {
    	    const result = appendOrAssign(a, b);

    	    return !isObject(result) || Object.keys(result).length
    	        ? result
    	        : null;
    	}

    	function mix(dest, src, shape) {
    	    for (const key in shape) {
    	        if (hasOwnProperty.call(shape, key) === false) {
    	            continue;
    	        }

    	        if (shape[key] === true) {
    	            if (key in src) {
    	                if (hasOwnProperty.call(src, key)) {
    	                    dest[key] = copy(src[key]);
    	                }
    	            }
    	        } else if (shape[key]) {
    	            if (typeof shape[key] === 'function') {
    	                const fn = shape[key];
    	                dest[key] = fn({}, dest[key]);
    	                dest[key] = fn(dest[key] || {}, src[key]);
    	            } else if (isObject(shape[key])) {
    	                const result = {};

    	                for (let name in dest[key]) {
    	                    result[name] = mix({}, dest[key][name], shape[key]);
    	                }

    	                for (let name in src[key]) {
    	                    result[name] = mix(result[name] || {}, src[key][name], shape[key]);
    	                }

    	                dest[key] = result;
    	            } else if (Array.isArray(shape[key])) {
    	                const res = {};
    	                const innerShape = shape[key].reduce(function(s, k) {
    	                    s[k] = true;
    	                    return s;
    	                }, {});

    	                for (const [name, value] of Object.entries(dest[key] || {})) {
    	                    res[name] = {};
    	                    if (value) {
    	                        mix(res[name], value, innerShape);
    	                    }
    	                }

    	                for (const name in src[key]) {
    	                    if (hasOwnProperty.call(src[key], name)) {
    	                        if (!res[name]) {
    	                            res[name] = {};
    	                        }

    	                        if (src[key] && src[key][name]) {
    	                            mix(res[name], src[key][name], innerShape);
    	                        }
    	                    }
    	                }

    	                dest[key] = res;
    	            }
    	        }
    	    }
    	    return dest;
    	}

    	mix_1 = (dest, src) => mix(dest, src, shape);
    	return mix_1;
    }

    var hasRequiredCreate;

    function requireCreate () {
    	if (hasRequiredCreate) return create$4;
    	hasRequiredCreate = 1;
    	var List = requireList();
    	var SyntaxError = require_SyntaxError$1();
    	var TokenStream = requireTokenStream();
    	var Lexer = requireLexer$1();
    	var definitionSyntax = requireDefinitionSyntax();
    	var tokenize = requireTokenizer$1();
    	var createParser = requireCreate$4();
    	var createGenerator = requireCreate$3();
    	var createConvertor = requireCreate$2();
    	var createWalker = requireCreate$1();
    	var clone = requireClone();
    	var names = requireNames();
    	var mix = requireMix();

    	function createSyntax(config) {
    	    var parse = createParser(config);
    	    var walk = createWalker(config);
    	    var generate = createGenerator(config);
    	    var convert = createConvertor(walk);

    	    var syntax = {
    	        List: List,
    	        SyntaxError: SyntaxError,
    	        TokenStream: TokenStream,
    	        Lexer: Lexer,

    	        vendorPrefix: names.vendorPrefix,
    	        keyword: names.keyword,
    	        property: names.property,
    	        isCustomProperty: names.isCustomProperty,

    	        definitionSyntax: definitionSyntax,
    	        lexer: null,
    	        createLexer: function(config) {
    	            return new Lexer(config, syntax, syntax.lexer.structure);
    	        },

    	        tokenize: tokenize,
    	        parse: parse,
    	        walk: walk,
    	        generate: generate,

    	        find: walk.find,
    	        findLast: walk.findLast,
    	        findAll: walk.findAll,

    	        clone: clone,
    	        fromPlainObject: convert.fromPlainObject,
    	        toPlainObject: convert.toPlainObject,

    	        createSyntax: function(config) {
    	            return createSyntax(mix({}, config));
    	        },
    	        fork: function(extension) {
    	            var base = mix({}, config); // copy of config
    	            return createSyntax(
    	                typeof extension === 'function'
    	                    ? extension(base, Object.assign)
    	                    : mix(base, extension)
    	            );
    	        }
    	    };

    	    syntax.lexer = new Lexer({
    	        generic: true,
    	        types: config.types,
    	        atrules: config.atrules,
    	        properties: config.properties,
    	        node: config.node
    	    }, syntax);

    	    return syntax;
    	}
    	create$4.create = function(config) {
    	    return createSyntax(mix({}, config));
    	};
    	return create$4;
    }

    var require$$0 = {
    	"@charset": {
    	syntax: "@charset \"<charset>\";",
    	groups: [
    		"CSS Charsets"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
    },
    	"@counter-style": {
    	syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
    	interfaces: [
    		"CSSCounterStyleRule"
    	],
    	groups: [
    		"CSS Counter Styles"
    	],
    	descriptors: {
    		"additive-symbols": {
    			syntax: "[ <integer> && <symbol> ]#",
    			media: "all",
    			initial: "n/a (required)",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "orderOfAppearance",
    			status: "standard"
    		},
    		fallback: {
    			syntax: "<counter-style-name>",
    			media: "all",
    			initial: "decimal",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		negative: {
    			syntax: "<symbol> <symbol>?",
    			media: "all",
    			initial: "\"-\" hyphen-minus",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "orderOfAppearance",
    			status: "standard"
    		},
    		pad: {
    			syntax: "<integer> && <symbol>",
    			media: "all",
    			initial: "0 \"\"",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		prefix: {
    			syntax: "<symbol>",
    			media: "all",
    			initial: "\"\"",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		range: {
    			syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
    			media: "all",
    			initial: "auto",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "orderOfAppearance",
    			status: "standard"
    		},
    		"speak-as": {
    			syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
    			media: "all",
    			initial: "auto",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		suffix: {
    			syntax: "<symbol>",
    			media: "all",
    			initial: "\". \"",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		symbols: {
    			syntax: "<symbol>+",
    			media: "all",
    			initial: "n/a (required)",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "orderOfAppearance",
    			status: "standard"
    		},
    		system: {
    			syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
    			media: "all",
    			initial: "symbolic",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		}
    	},
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
    },
    	"@document": {
    	syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
    	interfaces: [
    		"CSSGroupingRule",
    		"CSSConditionRule"
    	],
    	groups: [
    		"CSS Conditional Rules"
    	],
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
    },
    	"@font-face": {
    	syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
    	interfaces: [
    		"CSSFontFaceRule"
    	],
    	groups: [
    		"CSS Fonts"
    	],
    	descriptors: {
    		"font-display": {
    			syntax: "[ auto | block | swap | fallback | optional ]",
    			media: "visual",
    			percentages: "no",
    			initial: "auto",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "experimental"
    		},
    		"font-family": {
    			syntax: "<family-name>",
    			media: "all",
    			initial: "n/a (required)",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		"font-feature-settings": {
    			syntax: "normal | <feature-tag-value>#",
    			media: "all",
    			initial: "normal",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "orderOfAppearance",
    			status: "standard"
    		},
    		"font-variation-settings": {
    			syntax: "normal | [ <string> <number> ]#",
    			media: "all",
    			initial: "normal",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "orderOfAppearance",
    			status: "standard"
    		},
    		"font-stretch": {
    			syntax: "<font-stretch-absolute>{1,2}",
    			media: "all",
    			initial: "normal",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		"font-style": {
    			syntax: "normal | italic | oblique <angle>{0,2}",
    			media: "all",
    			initial: "normal",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		"font-weight": {
    			syntax: "<font-weight-absolute>{1,2}",
    			media: "all",
    			initial: "normal",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		"font-variant": {
    			syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
    			media: "all",
    			initial: "normal",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "orderOfAppearance",
    			status: "standard"
    		},
    		src: {
    			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
    			media: "all",
    			initial: "n/a (required)",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "orderOfAppearance",
    			status: "standard"
    		},
    		"unicode-range": {
    			syntax: "<unicode-range>#",
    			media: "all",
    			initial: "U+0-10FFFF",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "orderOfAppearance",
    			status: "standard"
    		}
    	},
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
    },
    	"@font-feature-values": {
    	syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
    	interfaces: [
    		"CSSFontFeatureValuesRule"
    	],
    	groups: [
    		"CSS Fonts"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
    },
    	"@import": {
    	syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
    	groups: [
    		"Media Queries"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
    },
    	"@keyframes": {
    	syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
    	interfaces: [
    		"CSSKeyframeRule",
    		"CSSKeyframesRule"
    	],
    	groups: [
    		"CSS Animations"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
    },
    	"@media": {
    	syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
    	interfaces: [
    		"CSSGroupingRule",
    		"CSSConditionRule",
    		"CSSMediaRule",
    		"CSSCustomMediaRule"
    	],
    	groups: [
    		"CSS Conditional Rules",
    		"Media Queries"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
    },
    	"@namespace": {
    	syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
    	groups: [
    		"CSS Namespaces"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
    },
    	"@page": {
    	syntax: "@page <page-selector-list> {\n  <page-body>\n}",
    	interfaces: [
    		"CSSPageRule"
    	],
    	groups: [
    		"CSS Pages"
    	],
    	descriptors: {
    		bleed: {
    			syntax: "auto | <length>",
    			media: [
    				"visual",
    				"paged"
    			],
    			initial: "auto",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		marks: {
    			syntax: "none | [ crop || cross ]",
    			media: [
    				"visual",
    				"paged"
    			],
    			initial: "none",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "orderOfAppearance",
    			status: "standard"
    		},
    		size: {
    			syntax: "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
    			media: [
    				"visual",
    				"paged"
    			],
    			initial: "auto",
    			percentages: "no",
    			computed: "asSpecifiedRelativeToAbsoluteLengths",
    			order: "orderOfAppearance",
    			status: "standard"
    		}
    	},
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
    },
    	"@property": {
    	syntax: "@property <custom-property-name> {\n  <declaration-list>\n}",
    	interfaces: [
    		"CSS",
    		"CSSPropertyRule"
    	],
    	groups: [
    		"CSS Houdini"
    	],
    	descriptors: {
    		syntax: {
    			syntax: "<string>",
    			media: "all",
    			percentages: "no",
    			initial: "n/a (required)",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "experimental"
    		},
    		inherits: {
    			syntax: "true | false",
    			media: "all",
    			percentages: "no",
    			initial: "auto",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "experimental"
    		},
    		"initial-value": {
    			syntax: "<string>",
    			media: "all",
    			initial: "n/a (required)",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "experimental"
    		}
    	},
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property"
    },
    	"@supports": {
    	syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
    	interfaces: [
    		"CSSGroupingRule",
    		"CSSConditionRule",
    		"CSSSupportsRule"
    	],
    	groups: [
    		"CSS Conditional Rules"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
    },
    	"@viewport": {
    	syntax: "@viewport {\n  <group-rule-body>\n}",
    	interfaces: [
    		"CSSViewportRule"
    	],
    	groups: [
    		"CSS Device Adaptation"
    	],
    	descriptors: {
    		height: {
    			syntax: "<viewport-length>{1,2}",
    			media: [
    				"visual",
    				"continuous"
    			],
    			initial: [
    				"min-height",
    				"max-height"
    			],
    			percentages: [
    				"min-height",
    				"max-height"
    			],
    			computed: [
    				"min-height",
    				"max-height"
    			],
    			order: "orderOfAppearance",
    			status: "standard"
    		},
    		"max-height": {
    			syntax: "<viewport-length>",
    			media: [
    				"visual",
    				"continuous"
    			],
    			initial: "auto",
    			percentages: "referToHeightOfInitialViewport",
    			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		"max-width": {
    			syntax: "<viewport-length>",
    			media: [
    				"visual",
    				"continuous"
    			],
    			initial: "auto",
    			percentages: "referToWidthOfInitialViewport",
    			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		"max-zoom": {
    			syntax: "auto | <number> | <percentage>",
    			media: [
    				"visual",
    				"continuous"
    			],
    			initial: "auto",
    			percentages: "the zoom factor itself",
    			computed: "autoNonNegativeOrPercentage",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		"min-height": {
    			syntax: "<viewport-length>",
    			media: [
    				"visual",
    				"continuous"
    			],
    			initial: "auto",
    			percentages: "referToHeightOfInitialViewport",
    			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		"min-width": {
    			syntax: "<viewport-length>",
    			media: [
    				"visual",
    				"continuous"
    			],
    			initial: "auto",
    			percentages: "referToWidthOfInitialViewport",
    			computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		"min-zoom": {
    			syntax: "auto | <number> | <percentage>",
    			media: [
    				"visual",
    				"continuous"
    			],
    			initial: "auto",
    			percentages: "the zoom factor itself",
    			computed: "autoNonNegativeOrPercentage",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		orientation: {
    			syntax: "auto | portrait | landscape",
    			media: [
    				"visual",
    				"continuous"
    			],
    			initial: "auto",
    			percentages: "referToSizeOfBoundingBox",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		"user-zoom": {
    			syntax: "zoom | fixed",
    			media: [
    				"visual",
    				"continuous"
    			],
    			initial: "zoom",
    			percentages: "referToSizeOfBoundingBox",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		"viewport-fit": {
    			syntax: "auto | contain | cover",
    			media: [
    				"visual",
    				"continuous"
    			],
    			initial: "auto",
    			percentages: "no",
    			computed: "asSpecified",
    			order: "uniqueOrder",
    			status: "standard"
    		},
    		width: {
    			syntax: "<viewport-length>{1,2}",
    			media: [
    				"visual",
    				"continuous"
    			],
    			initial: [
    				"min-width",
    				"max-width"
    			],
    			percentages: [
    				"min-width",
    				"max-width"
    			],
    			computed: [
    				"min-width",
    				"max-width"
    			],
    			order: "orderOfAppearance",
    			status: "standard"
    		},
    		zoom: {
    			syntax: "auto | <number> | <percentage>",
    			media: [
    				"visual",
    				"continuous"
    			],
    			initial: "auto",
    			percentages: "the zoom factor itself",
    			computed: "autoNonNegativeOrPercentage",
    			order: "uniqueOrder",
    			status: "standard"
    		}
    	},
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
    }
    };

    var all = {
    	syntax: "initial | inherit | unset | revert",
    	media: "noPracticalMedia",
    	inherited: false,
    	animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
    	percentages: "no",
    	groups: [
    		"CSS Miscellaneous"
    	],
    	initial: "noPracticalInitialValue",
    	appliesto: "allElements",
    	computed: "asSpecifiedAppliesToEachProperty",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
    };
    var animation = {
    	syntax: "<single-animation>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Animations"
    	],
    	initial: [
    		"animation-name",
    		"animation-duration",
    		"animation-timing-function",
    		"animation-delay",
    		"animation-iteration-count",
    		"animation-direction",
    		"animation-fill-mode",
    		"animation-play-state"
    	],
    	appliesto: "allElementsAndPseudos",
    	computed: [
    		"animation-name",
    		"animation-duration",
    		"animation-timing-function",
    		"animation-delay",
    		"animation-direction",
    		"animation-iteration-count",
    		"animation-fill-mode",
    		"animation-play-state"
    	],
    	order: "orderOfAppearance",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
    };
    var appearance = {
    	syntax: "none | auto | textfield | menulist-button | <compat-auto>",
    	media: "all",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
    };
    var azimuth = {
    	syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
    	media: "aural",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Speech"
    	],
    	initial: "center",
    	appliesto: "allElements",
    	computed: "normalizedAngle",
    	order: "orderOfAppearance",
    	status: "obsolete",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
    };
    var background = {
    	syntax: "[ <bg-layer> , ]* <final-bg-layer>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"background-color",
    		"background-image",
    		"background-clip",
    		"background-position",
    		"background-size",
    		"background-repeat",
    		"background-attachment"
    	],
    	percentages: [
    		"background-position",
    		"background-size"
    	],
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: [
    		"background-image",
    		"background-position",
    		"background-size",
    		"background-repeat",
    		"background-origin",
    		"background-clip",
    		"background-attachment",
    		"background-color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"background-image",
    		"background-position",
    		"background-size",
    		"background-repeat",
    		"background-origin",
    		"background-clip",
    		"background-attachment",
    		"background-color"
    	],
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
    };
    var border = {
    	syntax: "<line-width> || <line-style> || <color>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"border-color",
    		"border-style",
    		"border-width"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: [
    		"border-width",
    		"border-style",
    		"border-color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-width",
    		"border-style",
    		"border-color"
    	],
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
    };
    var bottom = {
    	syntax: "<length> | <percentage> | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToContainingBlockHeight",
    	groups: [
    		"CSS Positioning"
    	],
    	initial: "auto",
    	appliesto: "positionedElements",
    	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
    };
    var clear = {
    	syntax: "none | left | right | both | inline-start | inline-end",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Positioning"
    	],
    	initial: "none",
    	appliesto: "blockLevelElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
    };
    var clip = {
    	syntax: "<shape> | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "rectangle",
    	percentages: "no",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "auto",
    	appliesto: "absolutelyPositionedElements",
    	computed: "autoOrRectangle",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
    };
    var color$1 = {
    	syntax: "<color>",
    	media: "visual",
    	inherited: true,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Color"
    	],
    	initial: "variesFromBrowserToBrowser",
    	appliesto: "allElements",
    	computed: "translucentValuesRGBAOtherwiseRGB",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
    };
    var columns = {
    	syntax: "<'column-width'> || <'column-count'>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"column-width",
    		"column-count"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Columns"
    	],
    	initial: [
    		"column-width",
    		"column-count"
    	],
    	appliesto: "blockContainersExceptTableWrappers",
    	computed: [
    		"column-width",
    		"column-count"
    	],
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
    };
    var contain = {
    	syntax: "none | strict | content | [ size || layout || style || paint ]",
    	media: "all",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Containment"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
    };
    var content = {
    	syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
    	media: "all",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Generated Content"
    	],
    	initial: "normal",
    	appliesto: "beforeAndAfterPseudos",
    	computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
    };
    var cursor = {
    	syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
    	media: [
    		"visual",
    		"interactive"
    	],
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecifiedURLsAbsolute",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
    };
    var direction = {
    	syntax: "ltr | rtl",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Writing Modes"
    	],
    	initial: "ltr",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
    };
    var display = {
    	syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
    	media: "all",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Display"
    	],
    	initial: "inline",
    	appliesto: "allElements",
    	computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
    };
    var filter = {
    	syntax: "none | <filter-function-list>",
    	media: "visual",
    	inherited: false,
    	animationType: "filterList",
    	percentages: "no",
    	groups: [
    		"Filter Effects"
    	],
    	initial: "none",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
    };
    var flex = {
    	syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"flex-grow",
    		"flex-shrink",
    		"flex-basis"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Flexible Box Layout"
    	],
    	initial: [
    		"flex-grow",
    		"flex-shrink",
    		"flex-basis"
    	],
    	appliesto: "flexItemsAndInFlowPseudos",
    	computed: [
    		"flex-grow",
    		"flex-shrink",
    		"flex-basis"
    	],
    	order: "orderOfAppearance",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
    };
    var float = {
    	syntax: "left | right | none | inline-start | inline-end",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Positioning"
    	],
    	initial: "none",
    	appliesto: "allElementsNoEffectIfDisplayNone",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
    };
    var font = {
    	syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
    	media: "visual",
    	inherited: true,
    	animationType: [
    		"font-style",
    		"font-variant",
    		"font-weight",
    		"font-stretch",
    		"font-size",
    		"line-height",
    		"font-family"
    	],
    	percentages: [
    		"font-size",
    		"line-height"
    	],
    	groups: [
    		"CSS Fonts"
    	],
    	initial: [
    		"font-style",
    		"font-variant",
    		"font-weight",
    		"font-stretch",
    		"font-size",
    		"line-height",
    		"font-family"
    	],
    	appliesto: "allElements",
    	computed: [
    		"font-style",
    		"font-variant",
    		"font-weight",
    		"font-stretch",
    		"font-size",
    		"line-height",
    		"font-family"
    	],
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
    };
    var gap = {
    	syntax: "<'row-gap'> <'column-gap'>?",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"row-gap",
    		"column-gap"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Box Alignment"
    	],
    	initial: [
    		"row-gap",
    		"column-gap"
    	],
    	appliesto: "multiColumnElementsFlexContainersGridContainers",
    	computed: [
    		"row-gap",
    		"column-gap"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
    };
    var grid = {
    	syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: [
    		"grid-template-rows",
    		"grid-template-columns",
    		"grid-auto-rows",
    		"grid-auto-columns"
    	],
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: [
    		"grid-template-rows",
    		"grid-template-columns",
    		"grid-template-areas",
    		"grid-auto-rows",
    		"grid-auto-columns",
    		"grid-auto-flow",
    		"grid-column-gap",
    		"grid-row-gap",
    		"column-gap",
    		"row-gap"
    	],
    	appliesto: "gridContainers",
    	computed: [
    		"grid-template-rows",
    		"grid-template-columns",
    		"grid-template-areas",
    		"grid-auto-rows",
    		"grid-auto-columns",
    		"grid-auto-flow",
    		"grid-column-gap",
    		"grid-row-gap",
    		"column-gap",
    		"row-gap"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
    };
    var height = {
    	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "auto",
    	appliesto: "allElementsButNonReplacedAndTableColumns",
    	computed: "percentageAutoOrAbsoluteLength",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
    };
    var hyphens = {
    	syntax: "none | manual | auto",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "manual",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
    };
    var inset = {
    	syntax: "<'top'>{1,4}",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "logicalHeightOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "auto",
    	appliesto: "positionedElements",
    	computed: "sameAsBoxOffsets",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
    };
    var isolation = {
    	syntax: "auto | isolate",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Compositing and Blending"
    	],
    	initial: "auto",
    	appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
    };
    var left = {
    	syntax: "<length> | <percentage> | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Positioning"
    	],
    	initial: "auto",
    	appliesto: "positionedElements",
    	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
    };
    var margin = {
    	syntax: "[ <length> | <percentage> | auto ]{1,4}",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: [
    		"margin-bottom",
    		"margin-left",
    		"margin-right",
    		"margin-top"
    	],
    	appliesto: "allElementsExceptTableDisplayTypes",
    	computed: [
    		"margin-bottom",
    		"margin-left",
    		"margin-right",
    		"margin-top"
    	],
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
    };
    var mask = {
    	syntax: "<mask-layer>#",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"mask-image",
    		"mask-mode",
    		"mask-repeat",
    		"mask-position",
    		"mask-clip",
    		"mask-origin",
    		"mask-size",
    		"mask-composite"
    	],
    	percentages: [
    		"mask-position"
    	],
    	groups: [
    		"CSS Masking"
    	],
    	initial: [
    		"mask-image",
    		"mask-mode",
    		"mask-repeat",
    		"mask-position",
    		"mask-clip",
    		"mask-origin",
    		"mask-size",
    		"mask-composite"
    	],
    	appliesto: "allElementsSVGContainerElements",
    	computed: [
    		"mask-image",
    		"mask-mode",
    		"mask-repeat",
    		"mask-position",
    		"mask-clip",
    		"mask-origin",
    		"mask-size",
    		"mask-composite"
    	],
    	order: "perGrammar",
    	stacking: true,
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
    };
    var offset = {
    	syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"offset-position",
    		"offset-path",
    		"offset-distance",
    		"offset-anchor",
    		"offset-rotate"
    	],
    	percentages: [
    		"offset-position",
    		"offset-distance",
    		"offset-anchor"
    	],
    	groups: [
    		"CSS Motion Path"
    	],
    	initial: [
    		"offset-position",
    		"offset-path",
    		"offset-distance",
    		"offset-anchor",
    		"offset-rotate"
    	],
    	appliesto: "transformableElements",
    	computed: [
    		"offset-position",
    		"offset-path",
    		"offset-distance",
    		"offset-anchor",
    		"offset-rotate"
    	],
    	order: "perGrammar",
    	stacking: true,
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
    };
    var opacity = {
    	syntax: "<alpha-value>",
    	media: "visual",
    	inherited: false,
    	animationType: "number",
    	percentages: "no",
    	groups: [
    		"CSS Color"
    	],
    	initial: "1.0",
    	appliesto: "allElements",
    	computed: "specifiedValueClipped0To1",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
    };
    var order = {
    	syntax: "<integer>",
    	media: "visual",
    	inherited: false,
    	animationType: "integer",
    	percentages: "no",
    	groups: [
    		"CSS Flexible Box Layout"
    	],
    	initial: "0",
    	appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
    };
    var orphans = {
    	syntax: "<integer>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fragmentation"
    	],
    	initial: "2",
    	appliesto: "blockContainerElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
    };
    var outline = {
    	syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
    	media: [
    		"visual",
    		"interactive"
    	],
    	inherited: false,
    	animationType: [
    		"outline-color",
    		"outline-width",
    		"outline-style"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: [
    		"outline-color",
    		"outline-style",
    		"outline-width"
    	],
    	appliesto: "allElements",
    	computed: [
    		"outline-color",
    		"outline-width",
    		"outline-style"
    	],
    	order: "orderOfAppearance",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
    };
    var overflow = {
    	syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Overflow"
    	],
    	initial: "visible",
    	appliesto: "blockContainersFlexContainersGridContainers",
    	computed: [
    		"overflow-x",
    		"overflow-y"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
    };
    var padding = {
    	syntax: "[ <length> | <percentage> ]{1,4}",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: [
    		"padding-bottom",
    		"padding-left",
    		"padding-right",
    		"padding-top"
    	],
    	appliesto: "allElementsExceptInternalTableDisplayTypes",
    	computed: [
    		"padding-bottom",
    		"padding-left",
    		"padding-right",
    		"padding-top"
    	],
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
    };
    var perspective = {
    	syntax: "none | <length>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "no",
    	groups: [
    		"CSS Transforms"
    	],
    	initial: "none",
    	appliesto: "transformableElements",
    	computed: "absoluteLengthOrNone",
    	order: "uniqueOrder",
    	stacking: true,
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
    };
    var position$1 = {
    	syntax: "static | relative | absolute | sticky | fixed",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Positioning"
    	],
    	initial: "static",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	stacking: true,
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
    };
    var quotes = {
    	syntax: "none | auto | [ <string> <string> ]+",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Generated Content"
    	],
    	initial: "dependsOnUserAgent",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
    };
    var resize = {
    	syntax: "none | both | horizontal | vertical | block | inline",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: "none",
    	appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
    };
    var right = {
    	syntax: "<length> | <percentage> | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Positioning"
    	],
    	initial: "auto",
    	appliesto: "positionedElements",
    	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
    };
    var rotate = {
    	syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
    	media: "visual",
    	inherited: false,
    	animationType: "transform",
    	percentages: "no",
    	groups: [
    		"CSS Transforms"
    	],
    	initial: "none",
    	appliesto: "transformableElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	stacking: true,
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
    };
    var scale = {
    	syntax: "none | <number>{1,3}",
    	media: "visual",
    	inherited: false,
    	animationType: "transform",
    	percentages: "no",
    	groups: [
    		"CSS Transforms"
    	],
    	initial: "none",
    	appliesto: "transformableElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	stacking: true,
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
    };
    var top = {
    	syntax: "<length> | <percentage> | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToContainingBlockHeight",
    	groups: [
    		"CSS Positioning"
    	],
    	initial: "auto",
    	appliesto: "positionedElements",
    	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
    };
    var transform = {
    	syntax: "none | <transform-list>",
    	media: "visual",
    	inherited: false,
    	animationType: "transform",
    	percentages: "referToSizeOfBoundingBox",
    	groups: [
    		"CSS Transforms"
    	],
    	initial: "none",
    	appliesto: "transformableElements",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	stacking: true,
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
    };
    var transition = {
    	syntax: "<single-transition>#",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Transitions"
    	],
    	initial: [
    		"transition-delay",
    		"transition-duration",
    		"transition-property",
    		"transition-timing-function"
    	],
    	appliesto: "allElementsAndPseudos",
    	computed: [
    		"transition-delay",
    		"transition-duration",
    		"transition-property",
    		"transition-timing-function"
    	],
    	order: "orderOfAppearance",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
    };
    var translate = {
    	syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
    	media: "visual",
    	inherited: false,
    	animationType: "transform",
    	percentages: "referToSizeOfBoundingBox",
    	groups: [
    		"CSS Transforms"
    	],
    	initial: "none",
    	appliesto: "transformableElements",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "perGrammar",
    	stacking: true,
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
    };
    var visibility = {
    	syntax: "visible | hidden | collapse",
    	media: "visual",
    	inherited: true,
    	animationType: "visibility",
    	percentages: "no",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "visible",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
    };
    var widows = {
    	syntax: "<integer>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fragmentation"
    	],
    	initial: "2",
    	appliesto: "blockContainerElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
    };
    var width = {
    	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "auto",
    	appliesto: "allElementsButNonReplacedAndTableRows",
    	computed: "percentageAutoOrAbsoluteLength",
    	order: "lengthOrPercentageBeforeKeywordIfBothPresent",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
    };
    var zoom = {
    	syntax: "normal | reset | <number> | <percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "integer",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
    };
    var require$$1 = {
    	"--*": {
    	syntax: "<declaration-value>",
    	media: "all",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Variables"
    	],
    	initial: "seeProse",
    	appliesto: "allElements",
    	computed: "asSpecifiedWithVarsSubstituted",
    	order: "perGrammar",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
    },
    	"-ms-accelerator": {
    	syntax: "false | true",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "false",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
    },
    	"-ms-block-progression": {
    	syntax: "tb | rl | bt | lr",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "tb",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
    },
    	"-ms-content-zoom-chaining": {
    	syntax: "none | chained",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "none",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
    },
    	"-ms-content-zooming": {
    	syntax: "none | zoom",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "zoomForTheTopLevelNoneForTheRest",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
    },
    	"-ms-content-zoom-limit": {
    	syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: [
    		"-ms-content-zoom-limit-max",
    		"-ms-content-zoom-limit-min"
    	],
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: [
    		"-ms-content-zoom-limit-max",
    		"-ms-content-zoom-limit-min"
    	],
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: [
    		"-ms-content-zoom-limit-max",
    		"-ms-content-zoom-limit-min"
    	],
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
    },
    	"-ms-content-zoom-limit-max": {
    	syntax: "<percentage>",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "maxZoomFactor",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "400%",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
    },
    	"-ms-content-zoom-limit-min": {
    	syntax: "<percentage>",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "minZoomFactor",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "100%",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
    },
    	"-ms-content-zoom-snap": {
    	syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: [
    		"-ms-content-zoom-snap-type",
    		"-ms-content-zoom-snap-points"
    	],
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: [
    		"-ms-content-zoom-snap-type",
    		"-ms-content-zoom-snap-points"
    	],
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
    },
    	"-ms-content-zoom-snap-points": {
    	syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "snapInterval(0%, 100%)",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
    },
    	"-ms-content-zoom-snap-type": {
    	syntax: "none | proximity | mandatory",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "none",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
    },
    	"-ms-filter": {
    	syntax: "<string>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "\"\"",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
    },
    	"-ms-flow-from": {
    	syntax: "[ none | <custom-ident> ]#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "none",
    	appliesto: "nonReplacedElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
    },
    	"-ms-flow-into": {
    	syntax: "[ none | <custom-ident> ]#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "none",
    	appliesto: "iframeElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
    },
    	"-ms-grid-columns": {
    	syntax: "none | <track-list> | <auto-track-list>",
    	media: "visual",
    	inherited: false,
    	animationType: "simpleListOfLpcDifferenceLpc",
    	percentages: "referToDimensionOfContentArea",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "none",
    	appliesto: "gridContainers",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"
    },
    	"-ms-grid-rows": {
    	syntax: "none | <track-list> | <auto-track-list>",
    	media: "visual",
    	inherited: false,
    	animationType: "simpleListOfLpcDifferenceLpc",
    	percentages: "referToDimensionOfContentArea",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "none",
    	appliesto: "gridContainers",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"
    },
    	"-ms-high-contrast-adjust": {
    	syntax: "auto | none",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
    },
    	"-ms-hyphenate-limit-chars": {
    	syntax: "auto | <integer>{1,3}",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
    },
    	"-ms-hyphenate-limit-lines": {
    	syntax: "no-limit | <integer>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "no-limit",
    	appliesto: "blockContainerElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
    },
    	"-ms-hyphenate-limit-zone": {
    	syntax: "<percentage> | <length>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "referToLineBoxWidth",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "0",
    	appliesto: "blockContainerElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
    },
    	"-ms-ime-align": {
    	syntax: "auto | after",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
    },
    	"-ms-overflow-style": {
    	syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
    	media: "interactive",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "auto",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
    },
    	"-ms-scrollbar-3dlight-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "dependsOnUserAgent",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
    },
    	"-ms-scrollbar-arrow-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "ButtonText",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
    },
    	"-ms-scrollbar-base-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "dependsOnUserAgent",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
    },
    	"-ms-scrollbar-darkshadow-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "ThreeDDarkShadow",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
    },
    	"-ms-scrollbar-face-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "ThreeDFace",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
    },
    	"-ms-scrollbar-highlight-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "ThreeDHighlight",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
    },
    	"-ms-scrollbar-shadow-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "ThreeDDarkShadow",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
    },
    	"-ms-scrollbar-track-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "Scrollbar",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
    },
    	"-ms-scroll-chaining": {
    	syntax: "chained | none",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "chained",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
    },
    	"-ms-scroll-limit": {
    	syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: [
    		"-ms-scroll-limit-x-min",
    		"-ms-scroll-limit-y-min",
    		"-ms-scroll-limit-x-max",
    		"-ms-scroll-limit-y-max"
    	],
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: [
    		"-ms-scroll-limit-x-min",
    		"-ms-scroll-limit-y-min",
    		"-ms-scroll-limit-x-max",
    		"-ms-scroll-limit-y-max"
    	],
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
    },
    	"-ms-scroll-limit-x-max": {
    	syntax: "auto | <length>",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "auto",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
    },
    	"-ms-scroll-limit-x-min": {
    	syntax: "<length>",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "0",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
    },
    	"-ms-scroll-limit-y-max": {
    	syntax: "auto | <length>",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "auto",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
    },
    	"-ms-scroll-limit-y-min": {
    	syntax: "<length>",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "0",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
    },
    	"-ms-scroll-rails": {
    	syntax: "none | railed",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "railed",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
    },
    	"-ms-scroll-snap-points-x": {
    	syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "snapInterval(0px, 100%)",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
    },
    	"-ms-scroll-snap-points-y": {
    	syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "snapInterval(0px, 100%)",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
    },
    	"-ms-scroll-snap-type": {
    	syntax: "none | proximity | mandatory",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "none",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
    },
    	"-ms-scroll-snap-x": {
    	syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: [
    		"-ms-scroll-snap-type",
    		"-ms-scroll-snap-points-x"
    	],
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: [
    		"-ms-scroll-snap-type",
    		"-ms-scroll-snap-points-x"
    	],
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
    },
    	"-ms-scroll-snap-y": {
    	syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: [
    		"-ms-scroll-snap-type",
    		"-ms-scroll-snap-points-y"
    	],
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: [
    		"-ms-scroll-snap-type",
    		"-ms-scroll-snap-points-y"
    	],
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
    },
    	"-ms-scroll-translation": {
    	syntax: "none | vertical-to-horizontal",
    	media: "interactive",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
    },
    	"-ms-text-autospace": {
    	syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
    },
    	"-ms-touch-select": {
    	syntax: "grippers | none",
    	media: "interactive",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "grippers",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
    },
    	"-ms-user-select": {
    	syntax: "none | element | text",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "text",
    	appliesto: "nonReplacedElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
    },
    	"-ms-wrap-flow": {
    	syntax: "auto | both | start | end | maximum | clear",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "auto",
    	appliesto: "blockLevelElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
    },
    	"-ms-wrap-margin": {
    	syntax: "<length>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "0",
    	appliesto: "exclusionElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
    },
    	"-ms-wrap-through": {
    	syntax: "wrap | none",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Microsoft Extensions"
    	],
    	initial: "wrap",
    	appliesto: "blockLevelElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
    },
    	"-moz-appearance": {
    	syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions",
    		"WebKit Extensions"
    	],
    	initial: "noneButOverriddenInUserAgentCSS",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
    },
    	"-moz-binding": {
    	syntax: "<url> | none",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "none",
    	appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
    },
    	"-moz-border-bottom-colors": {
    	syntax: "<color>+ | none",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
    },
    	"-moz-border-left-colors": {
    	syntax: "<color>+ | none",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
    },
    	"-moz-border-right-colors": {
    	syntax: "<color>+ | none",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
    },
    	"-moz-border-top-colors": {
    	syntax: "<color>+ | none",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
    },
    	"-moz-context-properties": {
    	syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "none",
    	appliesto: "allElementsThatCanReferenceImages",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
    },
    	"-moz-float-edge": {
    	syntax: "border-box | content-box | margin-box | padding-box",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "content-box",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
    },
    	"-moz-force-broken-image-icon": {
    	syntax: "<integer [0,1]>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "0",
    	appliesto: "images",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
    },
    	"-moz-image-region": {
    	syntax: "<shape> | auto",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "auto",
    	appliesto: "xulImageElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
    },
    	"-moz-orient": {
    	syntax: "inline | block | horizontal | vertical",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "inline",
    	appliesto: "anyElementEffectOnProgressAndMeter",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
    },
    	"-moz-outline-radius": {
    	syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"-moz-outline-radius-topleft",
    		"-moz-outline-radius-topright",
    		"-moz-outline-radius-bottomright",
    		"-moz-outline-radius-bottomleft"
    	],
    	percentages: [
    		"-moz-outline-radius-topleft",
    		"-moz-outline-radius-topright",
    		"-moz-outline-radius-bottomright",
    		"-moz-outline-radius-bottomleft"
    	],
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: [
    		"-moz-outline-radius-topleft",
    		"-moz-outline-radius-topright",
    		"-moz-outline-radius-bottomright",
    		"-moz-outline-radius-bottomleft"
    	],
    	appliesto: "allElements",
    	computed: [
    		"-moz-outline-radius-topleft",
    		"-moz-outline-radius-topright",
    		"-moz-outline-radius-bottomright",
    		"-moz-outline-radius-bottomleft"
    	],
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
    },
    	"-moz-outline-radius-bottomleft": {
    	syntax: "<outline-radius>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfBorderBox",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
    },
    	"-moz-outline-radius-bottomright": {
    	syntax: "<outline-radius>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfBorderBox",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
    },
    	"-moz-outline-radius-topleft": {
    	syntax: "<outline-radius>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfBorderBox",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
    },
    	"-moz-outline-radius-topright": {
    	syntax: "<outline-radius>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfBorderBox",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
    },
    	"-moz-stack-sizing": {
    	syntax: "ignore | stretch-to-fit",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "stretch-to-fit",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
    },
    	"-moz-text-blink": {
    	syntax: "none | blink",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
    },
    	"-moz-user-focus": {
    	syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
    },
    	"-moz-user-input": {
    	syntax: "auto | none | enabled | disabled",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
    },
    	"-moz-user-modify": {
    	syntax: "read-only | read-write | write-only",
    	media: "interactive",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "read-only",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
    },
    	"-moz-window-dragging": {
    	syntax: "drag | no-drag",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "drag",
    	appliesto: "allElementsCreatingNativeWindows",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
    },
    	"-moz-window-shadow": {
    	syntax: "default | menu | tooltip | sheet | none",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "default",
    	appliesto: "allElementsCreatingNativeWindows",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
    },
    	"-webkit-appearance": {
    	syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "noneButOverriddenInUserAgentCSS",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
    },
    	"-webkit-border-before": {
    	syntax: "<'border-width'> || <'border-style'> || <'color'>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: [
    		"-webkit-border-before-width"
    	],
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: [
    		"border-width",
    		"border-style",
    		"color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-width",
    		"border-style",
    		"color"
    	],
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
    },
    	"-webkit-border-before-color": {
    	syntax: "<'color'>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	status: "nonstandard"
    },
    	"-webkit-border-before-style": {
    	syntax: "<'border-style'>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard"
    },
    	"-webkit-border-before-width": {
    	syntax: "<'border-width'>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "medium",
    	appliesto: "allElements",
    	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    	order: "uniqueOrder",
    	status: "nonstandard"
    },
    	"-webkit-box-reflect": {
    	syntax: "[ above | below | right | left ]? <length>? <image>?",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
    },
    	"-webkit-line-clamp": {
    	syntax: "none | <integer>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions",
    		"CSS Overflow"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
    },
    	"-webkit-mask": {
    	syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: [
    		"-webkit-mask-image",
    		"-webkit-mask-repeat",
    		"-webkit-mask-attachment",
    		"-webkit-mask-position",
    		"-webkit-mask-origin",
    		"-webkit-mask-clip"
    	],
    	appliesto: "allElements",
    	computed: [
    		"-webkit-mask-image",
    		"-webkit-mask-repeat",
    		"-webkit-mask-attachment",
    		"-webkit-mask-position",
    		"-webkit-mask-origin",
    		"-webkit-mask-clip"
    	],
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
    },
    	"-webkit-mask-attachment": {
    	syntax: "<attachment>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "scroll",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
    },
    	"-webkit-mask-clip": {
    	syntax: "[ <box> | border | padding | content | text ]#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "border",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
    },
    	"-webkit-mask-composite": {
    	syntax: "<composite-style>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "source-over",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
    },
    	"-webkit-mask-image": {
    	syntax: "<mask-reference>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "absoluteURIOrNone",
    	order: "orderOfAppearance",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
    },
    	"-webkit-mask-origin": {
    	syntax: "[ <box> | border | padding | content ]#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "padding",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
    },
    	"-webkit-mask-position": {
    	syntax: "<position>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "referToSizeOfElement",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "0% 0%",
    	appliesto: "allElements",
    	computed: "absoluteLengthOrPercentage",
    	order: "orderOfAppearance",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
    },
    	"-webkit-mask-position-x": {
    	syntax: "[ <length-percentage> | left | center | right ]#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "referToSizeOfElement",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "0%",
    	appliesto: "allElements",
    	computed: "absoluteLengthOrPercentage",
    	order: "orderOfAppearance",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
    },
    	"-webkit-mask-position-y": {
    	syntax: "[ <length-percentage> | top | center | bottom ]#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "referToSizeOfElement",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "0%",
    	appliesto: "allElements",
    	computed: "absoluteLengthOrPercentage",
    	order: "orderOfAppearance",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
    },
    	"-webkit-mask-repeat": {
    	syntax: "<repeat-style>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "repeat",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
    },
    	"-webkit-mask-repeat-x": {
    	syntax: "repeat | no-repeat | space | round",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "repeat",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
    },
    	"-webkit-mask-repeat-y": {
    	syntax: "repeat | no-repeat | space | round",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "repeat",
    	appliesto: "allElements",
    	computed: "absoluteLengthOrPercentage",
    	order: "orderOfAppearance",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
    },
    	"-webkit-mask-size": {
    	syntax: "<bg-size>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "relativeToBackgroundPositioningArea",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "auto auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
    },
    	"-webkit-overflow-scrolling": {
    	syntax: "auto | touch",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "auto",
    	appliesto: "scrollingBoxes",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
    },
    	"-webkit-tap-highlight-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "black",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
    },
    	"-webkit-text-fill-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: true,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
    },
    	"-webkit-text-stroke": {
    	syntax: "<length> || <color>",
    	media: "visual",
    	inherited: true,
    	animationType: [
    		"-webkit-text-stroke-width",
    		"-webkit-text-stroke-color"
    	],
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: [
    		"-webkit-text-stroke-width",
    		"-webkit-text-stroke-color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"-webkit-text-stroke-width",
    		"-webkit-text-stroke-color"
    	],
    	order: "canonicalOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
    },
    	"-webkit-text-stroke-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: true,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
    },
    	"-webkit-text-stroke-width": {
    	syntax: "<length>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "absoluteLength",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
    },
    	"-webkit-touch-callout": {
    	syntax: "default | none",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "default",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
    },
    	"-webkit-user-modify": {
    	syntax: "read-only | read-write | read-write-plaintext-only",
    	media: "interactive",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"WebKit Extensions"
    	],
    	initial: "read-only",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard"
    },
    	"align-content": {
    	syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Alignment"
    	],
    	initial: "normal",
    	appliesto: "multilineFlexContainers",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
    },
    	"align-items": {
    	syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Alignment"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
    },
    	"align-self": {
    	syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Alignment"
    	],
    	initial: "auto",
    	appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
    	computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
    },
    	"align-tracks": {
    	syntax: "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "normal",
    	appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks"
    },
    	all: all,
    	animation: animation,
    	"animation-delay": {
    	syntax: "<time>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Animations"
    	],
    	initial: "0s",
    	appliesto: "allElementsAndPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
    },
    	"animation-direction": {
    	syntax: "<single-animation-direction>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Animations"
    	],
    	initial: "normal",
    	appliesto: "allElementsAndPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
    },
    	"animation-duration": {
    	syntax: "<time>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Animations"
    	],
    	initial: "0s",
    	appliesto: "allElementsAndPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
    },
    	"animation-fill-mode": {
    	syntax: "<single-animation-fill-mode>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Animations"
    	],
    	initial: "none",
    	appliesto: "allElementsAndPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
    },
    	"animation-iteration-count": {
    	syntax: "<single-animation-iteration-count>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Animations"
    	],
    	initial: "1",
    	appliesto: "allElementsAndPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
    },
    	"animation-name": {
    	syntax: "[ none | <keyframes-name> ]#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Animations"
    	],
    	initial: "none",
    	appliesto: "allElementsAndPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
    },
    	"animation-play-state": {
    	syntax: "<single-animation-play-state>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Animations"
    	],
    	initial: "running",
    	appliesto: "allElementsAndPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
    },
    	"animation-timing-function": {
    	syntax: "<timing-function>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Animations"
    	],
    	initial: "ease",
    	appliesto: "allElementsAndPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
    },
    	appearance: appearance,
    	"aspect-ratio": {
    	syntax: "auto | <ratio>",
    	media: "all",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: "auto",
    	appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
    },
    	azimuth: azimuth,
    	"backdrop-filter": {
    	syntax: "none | <filter-function-list>",
    	media: "visual",
    	inherited: false,
    	animationType: "filterList",
    	percentages: "no",
    	groups: [
    		"Filter Effects"
    	],
    	initial: "none",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
    },
    	"backface-visibility": {
    	syntax: "visible | hidden",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Transforms"
    	],
    	initial: "visible",
    	appliesto: "transformableElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
    },
    	background: background,
    	"background-attachment": {
    	syntax: "<attachment>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "scroll",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
    },
    	"background-blend-mode": {
    	syntax: "<blend-mode>#",
    	media: "none",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Compositing and Blending"
    	],
    	initial: "normal",
    	appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
    },
    	"background-clip": {
    	syntax: "<box>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "border-box",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
    },
    	"background-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: false,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "transparent",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
    },
    	"background-image": {
    	syntax: "<bg-image>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecifiedURLsAbsolute",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
    },
    	"background-origin": {
    	syntax: "<box>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "padding-box",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
    },
    	"background-position": {
    	syntax: "<bg-position>#",
    	media: "visual",
    	inherited: false,
    	animationType: "repeatableListOfSimpleListOfLpc",
    	percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "0% 0%",
    	appliesto: "allElements",
    	computed: "listEachItemTwoKeywordsOriginOffsets",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
    },
    	"background-position-x": {
    	syntax: "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "left",
    	appliesto: "allElements",
    	computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
    	order: "uniqueOrder",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
    },
    	"background-position-y": {
    	syntax: "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "top",
    	appliesto: "allElements",
    	computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
    	order: "uniqueOrder",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
    },
    	"background-repeat": {
    	syntax: "<repeat-style>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "repeat",
    	appliesto: "allElements",
    	computed: "listEachItemHasTwoKeywordsOnePerDimension",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
    },
    	"background-size": {
    	syntax: "<bg-size>#",
    	media: "visual",
    	inherited: false,
    	animationType: "repeatableListOfSimpleListOfLpc",
    	percentages: "relativeToBackgroundPositioningArea",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "auto auto",
    	appliesto: "allElements",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
    },
    	"block-overflow": {
    	syntax: "clip | ellipsis | <string>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Overflow"
    	],
    	initial: "clip",
    	appliesto: "blockContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "experimental"
    },
    	"block-size": {
    	syntax: "<'width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "blockSizeOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "auto",
    	appliesto: "sameAsWidthAndHeight",
    	computed: "sameAsWidthAndHeight",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
    },
    	border: border,
    	"border-block": {
    	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: [
    		"border-top-width",
    		"border-top-style",
    		"border-top-color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-top-width",
    		"border-top-style",
    		"border-top-color"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
    },
    	"border-block-color": {
    	syntax: "<'border-top-color'>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
    },
    	"border-block-style": {
    	syntax: "<'border-top-style'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
    },
    	"border-block-width": {
    	syntax: "<'border-top-width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "medium",
    	appliesto: "allElements",
    	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
    },
    	"border-block-end": {
    	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"border-block-end-color",
    		"border-block-end-style",
    		"border-block-end-width"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: [
    		"border-top-width",
    		"border-top-style",
    		"border-top-color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-top-width",
    		"border-top-style",
    		"border-top-color"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
    },
    	"border-block-end-color": {
    	syntax: "<'border-top-color'>",
    	media: "visual",
    	inherited: false,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
    },
    	"border-block-end-style": {
    	syntax: "<'border-top-style'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
    },
    	"border-block-end-width": {
    	syntax: "<'border-top-width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "medium",
    	appliesto: "allElements",
    	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
    },
    	"border-block-start": {
    	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"border-block-start-color",
    		"border-block-start-style",
    		"border-block-start-width"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: [
    		"border-width",
    		"border-style",
    		"color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-width",
    		"border-style",
    		"border-block-start-color"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
    },
    	"border-block-start-color": {
    	syntax: "<'border-top-color'>",
    	media: "visual",
    	inherited: false,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
    },
    	"border-block-start-style": {
    	syntax: "<'border-top-style'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
    },
    	"border-block-start-width": {
    	syntax: "<'border-top-width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "medium",
    	appliesto: "allElements",
    	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
    },
    	"border-bottom": {
    	syntax: "<line-width> || <line-style> || <color>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"border-bottom-color",
    		"border-bottom-style",
    		"border-bottom-width"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: [
    		"border-bottom-width",
    		"border-bottom-style",
    		"border-bottom-color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-bottom-width",
    		"border-bottom-style",
    		"border-bottom-color"
    	],
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
    },
    	"border-bottom-color": {
    	syntax: "<'border-top-color'>",
    	media: "visual",
    	inherited: false,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
    },
    	"border-bottom-left-radius": {
    	syntax: "<length-percentage>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfBorderBox",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "0",
    	appliesto: "allElementsUAsNotRequiredWhenCollapse",
    	computed: "twoAbsoluteLengthOrPercentages",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
    },
    	"border-bottom-right-radius": {
    	syntax: "<length-percentage>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfBorderBox",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "0",
    	appliesto: "allElementsUAsNotRequiredWhenCollapse",
    	computed: "twoAbsoluteLengthOrPercentages",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
    },
    	"border-bottom-style": {
    	syntax: "<line-style>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
    },
    	"border-bottom-width": {
    	syntax: "<line-width>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "medium",
    	appliesto: "allElements",
    	computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
    },
    	"border-collapse": {
    	syntax: "collapse | separate",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Table"
    	],
    	initial: "separate",
    	appliesto: "tableElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
    },
    	"border-color": {
    	syntax: "<color>{1,4}",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"border-bottom-color",
    		"border-left-color",
    		"border-right-color",
    		"border-top-color"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: [
    		"border-top-color",
    		"border-right-color",
    		"border-bottom-color",
    		"border-left-color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-bottom-color",
    		"border-left-color",
    		"border-right-color",
    		"border-top-color"
    	],
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
    },
    	"border-end-end-radius": {
    	syntax: "<length-percentage>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfBorderBox",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "allElementsUAsNotRequiredWhenCollapse",
    	computed: "twoAbsoluteLengthOrPercentages",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
    },
    	"border-end-start-radius": {
    	syntax: "<length-percentage>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfBorderBox",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "allElementsUAsNotRequiredWhenCollapse",
    	computed: "twoAbsoluteLengthOrPercentages",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
    },
    	"border-image": {
    	syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: [
    		"border-image-slice",
    		"border-image-width"
    	],
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: [
    		"border-image-source",
    		"border-image-slice",
    		"border-image-width",
    		"border-image-outset",
    		"border-image-repeat"
    	],
    	appliesto: "allElementsExceptTableElementsWhenCollapse",
    	computed: [
    		"border-image-outset",
    		"border-image-repeat",
    		"border-image-slice",
    		"border-image-source",
    		"border-image-width"
    	],
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
    },
    	"border-image-outset": {
    	syntax: "[ <length> | <number> ]{1,4}",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "0",
    	appliesto: "allElementsExceptTableElementsWhenCollapse",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
    },
    	"border-image-repeat": {
    	syntax: "[ stretch | repeat | round | space ]{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "stretch",
    	appliesto: "allElementsExceptTableElementsWhenCollapse",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
    },
    	"border-image-slice": {
    	syntax: "<number-percentage>{1,4} && fill?",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "referToSizeOfBorderImage",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "100%",
    	appliesto: "allElementsExceptTableElementsWhenCollapse",
    	computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
    	order: "percentagesOrLengthsFollowedByFill",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
    },
    	"border-image-source": {
    	syntax: "none | <image>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "none",
    	appliesto: "allElementsExceptTableElementsWhenCollapse",
    	computed: "noneOrImageWithAbsoluteURI",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
    },
    	"border-image-width": {
    	syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "referToWidthOrHeightOfBorderImageArea",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "1",
    	appliesto: "allElementsExceptTableElementsWhenCollapse",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
    },
    	"border-inline": {
    	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: [
    		"border-top-width",
    		"border-top-style",
    		"border-top-color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-top-width",
    		"border-top-style",
    		"border-top-color"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
    },
    	"border-inline-end": {
    	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"border-inline-end-color",
    		"border-inline-end-style",
    		"border-inline-end-width"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: [
    		"border-width",
    		"border-style",
    		"color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-width",
    		"border-style",
    		"border-inline-end-color"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
    },
    	"border-inline-color": {
    	syntax: "<'border-top-color'>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
    },
    	"border-inline-style": {
    	syntax: "<'border-top-style'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
    },
    	"border-inline-width": {
    	syntax: "<'border-top-width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "medium",
    	appliesto: "allElements",
    	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
    },
    	"border-inline-end-color": {
    	syntax: "<'border-top-color'>",
    	media: "visual",
    	inherited: false,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
    },
    	"border-inline-end-style": {
    	syntax: "<'border-top-style'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
    },
    	"border-inline-end-width": {
    	syntax: "<'border-top-width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "medium",
    	appliesto: "allElements",
    	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
    },
    	"border-inline-start": {
    	syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"border-inline-start-color",
    		"border-inline-start-style",
    		"border-inline-start-width"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: [
    		"border-width",
    		"border-style",
    		"color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-width",
    		"border-style",
    		"border-inline-start-color"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
    },
    	"border-inline-start-color": {
    	syntax: "<'border-top-color'>",
    	media: "visual",
    	inherited: false,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
    },
    	"border-inline-start-style": {
    	syntax: "<'border-top-style'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
    },
    	"border-inline-start-width": {
    	syntax: "<'border-top-width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "medium",
    	appliesto: "allElements",
    	computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
    },
    	"border-left": {
    	syntax: "<line-width> || <line-style> || <color>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"border-left-color",
    		"border-left-style",
    		"border-left-width"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: [
    		"border-left-width",
    		"border-left-style",
    		"border-left-color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-left-width",
    		"border-left-style",
    		"border-left-color"
    	],
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
    },
    	"border-left-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: false,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
    },
    	"border-left-style": {
    	syntax: "<line-style>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
    },
    	"border-left-width": {
    	syntax: "<line-width>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "medium",
    	appliesto: "allElements",
    	computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
    },
    	"border-radius": {
    	syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"border-top-left-radius",
    		"border-top-right-radius",
    		"border-bottom-right-radius",
    		"border-bottom-left-radius"
    	],
    	percentages: "referToDimensionOfBorderBox",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: [
    		"border-top-left-radius",
    		"border-top-right-radius",
    		"border-bottom-right-radius",
    		"border-bottom-left-radius"
    	],
    	appliesto: "allElementsUAsNotRequiredWhenCollapse",
    	computed: [
    		"border-bottom-left-radius",
    		"border-bottom-right-radius",
    		"border-top-left-radius",
    		"border-top-right-radius"
    	],
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
    },
    	"border-right": {
    	syntax: "<line-width> || <line-style> || <color>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"border-right-color",
    		"border-right-style",
    		"border-right-width"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: [
    		"border-right-width",
    		"border-right-style",
    		"border-right-color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-right-width",
    		"border-right-style",
    		"border-right-color"
    	],
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
    },
    	"border-right-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: false,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
    },
    	"border-right-style": {
    	syntax: "<line-style>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
    },
    	"border-right-width": {
    	syntax: "<line-width>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "medium",
    	appliesto: "allElements",
    	computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
    },
    	"border-spacing": {
    	syntax: "<length> <length>?",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Table"
    	],
    	initial: "0",
    	appliesto: "tableElements",
    	computed: "twoAbsoluteLengths",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
    },
    	"border-start-end-radius": {
    	syntax: "<length-percentage>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfBorderBox",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "allElementsUAsNotRequiredWhenCollapse",
    	computed: "twoAbsoluteLengthOrPercentages",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
    },
    	"border-start-start-radius": {
    	syntax: "<length-percentage>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfBorderBox",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "allElementsUAsNotRequiredWhenCollapse",
    	computed: "twoAbsoluteLengthOrPercentages",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
    },
    	"border-style": {
    	syntax: "<line-style>{1,4}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: [
    		"border-top-style",
    		"border-right-style",
    		"border-bottom-style",
    		"border-left-style"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-bottom-style",
    		"border-left-style",
    		"border-right-style",
    		"border-top-style"
    	],
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
    },
    	"border-top": {
    	syntax: "<line-width> || <line-style> || <color>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"border-top-color",
    		"border-top-style",
    		"border-top-width"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: [
    		"border-top-width",
    		"border-top-style",
    		"border-top-color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-top-width",
    		"border-top-style",
    		"border-top-color"
    	],
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
    },
    	"border-top-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: false,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
    },
    	"border-top-left-radius": {
    	syntax: "<length-percentage>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfBorderBox",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "0",
    	appliesto: "allElementsUAsNotRequiredWhenCollapse",
    	computed: "twoAbsoluteLengthOrPercentages",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
    },
    	"border-top-right-radius": {
    	syntax: "<length-percentage>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfBorderBox",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "0",
    	appliesto: "allElementsUAsNotRequiredWhenCollapse",
    	computed: "twoAbsoluteLengthOrPercentages",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
    },
    	"border-top-style": {
    	syntax: "<line-style>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
    },
    	"border-top-width": {
    	syntax: "<line-width>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "medium",
    	appliesto: "allElements",
    	computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
    },
    	"border-width": {
    	syntax: "<line-width>{1,4}",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"border-bottom-width",
    		"border-left-width",
    		"border-right-width",
    		"border-top-width"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: [
    		"border-top-width",
    		"border-right-width",
    		"border-bottom-width",
    		"border-left-width"
    	],
    	appliesto: "allElements",
    	computed: [
    		"border-bottom-width",
    		"border-left-width",
    		"border-right-width",
    		"border-top-width"
    	],
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
    },
    	bottom: bottom,
    	"box-align": {
    	syntax: "start | center | end | baseline | stretch",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions",
    		"WebKit Extensions"
    	],
    	initial: "stretch",
    	appliesto: "elementsWithDisplayBoxOrInlineBox",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
    },
    	"box-decoration-break": {
    	syntax: "slice | clone",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fragmentation"
    	],
    	initial: "slice",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
    },
    	"box-direction": {
    	syntax: "normal | reverse | inherit",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions",
    		"WebKit Extensions"
    	],
    	initial: "normal",
    	appliesto: "elementsWithDisplayBoxOrInlineBox",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
    },
    	"box-flex": {
    	syntax: "<number>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions",
    		"WebKit Extensions"
    	],
    	initial: "0",
    	appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
    },
    	"box-flex-group": {
    	syntax: "<integer>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions",
    		"WebKit Extensions"
    	],
    	initial: "1",
    	appliesto: "inFlowChildrenOfBoxElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
    },
    	"box-lines": {
    	syntax: "single | multiple",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions",
    		"WebKit Extensions"
    	],
    	initial: "single",
    	appliesto: "boxElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
    },
    	"box-ordinal-group": {
    	syntax: "<integer>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions",
    		"WebKit Extensions"
    	],
    	initial: "1",
    	appliesto: "childrenOfBoxElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
    },
    	"box-orient": {
    	syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions",
    		"WebKit Extensions"
    	],
    	initial: "inlineAxisHorizontalInXUL",
    	appliesto: "elementsWithDisplayBoxOrInlineBox",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
    },
    	"box-pack": {
    	syntax: "start | center | end | justify",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions",
    		"WebKit Extensions"
    	],
    	initial: "start",
    	appliesto: "elementsWithDisplayMozBoxMozInlineBox",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
    },
    	"box-shadow": {
    	syntax: "none | <shadow>#",
    	media: "visual",
    	inherited: false,
    	animationType: "shadowList",
    	percentages: "no",
    	groups: [
    		"CSS Backgrounds and Borders"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "absoluteLengthsSpecifiedColorAsSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
    },
    	"box-sizing": {
    	syntax: "content-box | border-box",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: "content-box",
    	appliesto: "allElementsAcceptingWidthOrHeight",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
    },
    	"break-after": {
    	syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fragmentation"
    	],
    	initial: "auto",
    	appliesto: "blockLevelElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
    },
    	"break-before": {
    	syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fragmentation"
    	],
    	initial: "auto",
    	appliesto: "blockLevelElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
    },
    	"break-inside": {
    	syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fragmentation"
    	],
    	initial: "auto",
    	appliesto: "blockLevelElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
    },
    	"caption-side": {
    	syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Table"
    	],
    	initial: "top",
    	appliesto: "tableCaptionElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
    },
    	"caret-color": {
    	syntax: "auto | <color>",
    	media: "interactive",
    	inherited: true,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asAutoOrColor",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
    },
    	clear: clear,
    	clip: clip,
    	"clip-path": {
    	syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
    	media: "visual",
    	inherited: false,
    	animationType: "basicShapeOtherwiseNo",
    	percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "none",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecifiedURLsAbsolute",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
    },
    	color: color$1,
    	"color-adjust": {
    	syntax: "economy | exact",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Color"
    	],
    	initial: "economy",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
    },
    	"column-count": {
    	syntax: "<integer> | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "integer",
    	percentages: "no",
    	groups: [
    		"CSS Columns"
    	],
    	initial: "auto",
    	appliesto: "blockContainersExceptTableWrappers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
    },
    	"column-fill": {
    	syntax: "auto | balance | balance-all",
    	media: "visualInContinuousMediaNoEffectInOverflowColumns",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Columns"
    	],
    	initial: "balance",
    	appliesto: "multicolElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
    },
    	"column-gap": {
    	syntax: "normal | <length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfContentArea",
    	groups: [
    		"CSS Box Alignment"
    	],
    	initial: "normal",
    	appliesto: "multiColumnElementsFlexContainersGridContainers",
    	computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
    },
    	"column-rule": {
    	syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"column-rule-color",
    		"column-rule-style",
    		"column-rule-width"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Columns"
    	],
    	initial: [
    		"column-rule-width",
    		"column-rule-style",
    		"column-rule-color"
    	],
    	appliesto: "multicolElements",
    	computed: [
    		"column-rule-color",
    		"column-rule-style",
    		"column-rule-width"
    	],
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
    },
    	"column-rule-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: false,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Columns"
    	],
    	initial: "currentcolor",
    	appliesto: "multicolElements",
    	computed: "computedColor",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
    },
    	"column-rule-style": {
    	syntax: "<'border-style'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Columns"
    	],
    	initial: "none",
    	appliesto: "multicolElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
    },
    	"column-rule-width": {
    	syntax: "<'border-width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "no",
    	groups: [
    		"CSS Columns"
    	],
    	initial: "medium",
    	appliesto: "multicolElements",
    	computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
    },
    	"column-span": {
    	syntax: "none | all",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Columns"
    	],
    	initial: "none",
    	appliesto: "inFlowBlockLevelElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
    },
    	"column-width": {
    	syntax: "<length> | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "no",
    	groups: [
    		"CSS Columns"
    	],
    	initial: "auto",
    	appliesto: "blockContainersExceptTableWrappers",
    	computed: "absoluteLengthZeroOrLarger",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
    },
    	columns: columns,
    	contain: contain,
    	content: content,
    	"counter-increment": {
    	syntax: "[ <custom-ident> <integer>? ]+ | none",
    	media: "all",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Counter Styles"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
    },
    	"counter-reset": {
    	syntax: "[ <custom-ident> <integer>? ]+ | none",
    	media: "all",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Counter Styles"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
    },
    	"counter-set": {
    	syntax: "[ <custom-ident> <integer>? ]+ | none",
    	media: "all",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Counter Styles"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
    },
    	cursor: cursor,
    	direction: direction,
    	display: display,
    	"empty-cells": {
    	syntax: "show | hide",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Table"
    	],
    	initial: "show",
    	appliesto: "tableCellElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
    },
    	filter: filter,
    	flex: flex,
    	"flex-basis": {
    	syntax: "content | <'width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToFlexContainersInnerMainSize",
    	groups: [
    		"CSS Flexible Box Layout"
    	],
    	initial: "auto",
    	appliesto: "flexItemsAndInFlowPseudos",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "lengthOrPercentageBeforeKeywordIfBothPresent",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
    },
    	"flex-direction": {
    	syntax: "row | row-reverse | column | column-reverse",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Flexible Box Layout"
    	],
    	initial: "row",
    	appliesto: "flexContainers",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
    },
    	"flex-flow": {
    	syntax: "<'flex-direction'> || <'flex-wrap'>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Flexible Box Layout"
    	],
    	initial: [
    		"flex-direction",
    		"flex-wrap"
    	],
    	appliesto: "flexContainers",
    	computed: [
    		"flex-direction",
    		"flex-wrap"
    	],
    	order: "orderOfAppearance",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
    },
    	"flex-grow": {
    	syntax: "<number>",
    	media: "visual",
    	inherited: false,
    	animationType: "number",
    	percentages: "no",
    	groups: [
    		"CSS Flexible Box Layout"
    	],
    	initial: "0",
    	appliesto: "flexItemsAndInFlowPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
    },
    	"flex-shrink": {
    	syntax: "<number>",
    	media: "visual",
    	inherited: false,
    	animationType: "number",
    	percentages: "no",
    	groups: [
    		"CSS Flexible Box Layout"
    	],
    	initial: "1",
    	appliesto: "flexItemsAndInFlowPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
    },
    	"flex-wrap": {
    	syntax: "nowrap | wrap | wrap-reverse",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Flexible Box Layout"
    	],
    	initial: "nowrap",
    	appliesto: "flexContainers",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
    },
    	float: float,
    	font: font,
    	"font-family": {
    	syntax: "[ <family-name> | <generic-family> ]#",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "dependsOnUserAgent",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
    },
    	"font-feature-settings": {
    	syntax: "normal | <feature-tag-value>#",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
    },
    	"font-kerning": {
    	syntax: "auto | normal | none",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
    },
    	"font-language-override": {
    	syntax: "normal | <string>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
    },
    	"font-optical-sizing": {
    	syntax: "auto | none",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
    },
    	"font-variation-settings": {
    	syntax: "normal | [ <string> <number> ]#",
    	media: "visual",
    	inherited: true,
    	animationType: "transform",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
    },
    	"font-size": {
    	syntax: "<absolute-size> | <relative-size> | <length-percentage>",
    	media: "visual",
    	inherited: true,
    	animationType: "length",
    	percentages: "referToParentElementsFontSize",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "medium",
    	appliesto: "allElements",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
    },
    	"font-size-adjust": {
    	syntax: "none | <number>",
    	media: "visual",
    	inherited: true,
    	animationType: "number",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
    },
    	"font-smooth": {
    	syntax: "auto | never | always | <absolute-size> | <length>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth"
    },
    	"font-stretch": {
    	syntax: "<font-stretch-absolute>",
    	media: "visual",
    	inherited: true,
    	animationType: "fontStretch",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
    },
    	"font-style": {
    	syntax: "normal | italic | oblique <angle>?",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
    },
    	"font-synthesis": {
    	syntax: "none | [ weight || style ]",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "weight style",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
    },
    	"font-variant": {
    	syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
    },
    	"font-variant-alternates": {
    	syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
    },
    	"font-variant-caps": {
    	syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
    },
    	"font-variant-east-asian": {
    	syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
    },
    	"font-variant-ligatures": {
    	syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
    },
    	"font-variant-numeric": {
    	syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
    },
    	"font-variant-position": {
    	syntax: "normal | sub | super",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
    },
    	"font-weight": {
    	syntax: "<font-weight-absolute> | bolder | lighter",
    	media: "visual",
    	inherited: true,
    	animationType: "fontWeight",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
    },
    	gap: gap,
    	grid: grid,
    	"grid-area": {
    	syntax: "<grid-line> [ / <grid-line> ]{0,3}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: [
    		"grid-row-start",
    		"grid-column-start",
    		"grid-row-end",
    		"grid-column-end"
    	],
    	appliesto: "gridItemsAndBoxesWithinGridContainer",
    	computed: [
    		"grid-row-start",
    		"grid-column-start",
    		"grid-row-end",
    		"grid-column-end"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
    },
    	"grid-auto-columns": {
    	syntax: "<track-size>+",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "referToDimensionOfContentArea",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "auto",
    	appliesto: "gridContainers",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
    },
    	"grid-auto-flow": {
    	syntax: "[ row | column ] || dense",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "row",
    	appliesto: "gridContainers",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
    },
    	"grid-auto-rows": {
    	syntax: "<track-size>+",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "referToDimensionOfContentArea",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "auto",
    	appliesto: "gridContainers",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
    },
    	"grid-column": {
    	syntax: "<grid-line> [ / <grid-line> ]?",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: [
    		"grid-column-start",
    		"grid-column-end"
    	],
    	appliesto: "gridItemsAndBoxesWithinGridContainer",
    	computed: [
    		"grid-column-start",
    		"grid-column-end"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
    },
    	"grid-column-end": {
    	syntax: "<grid-line>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "auto",
    	appliesto: "gridItemsAndBoxesWithinGridContainer",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
    },
    	"grid-column-gap": {
    	syntax: "<length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "referToDimensionOfContentArea",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "0",
    	appliesto: "gridContainers",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	status: "obsolete",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
    },
    	"grid-column-start": {
    	syntax: "<grid-line>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "auto",
    	appliesto: "gridItemsAndBoxesWithinGridContainer",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
    },
    	"grid-gap": {
    	syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"grid-row-gap",
    		"grid-column-gap"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: [
    		"grid-row-gap",
    		"grid-column-gap"
    	],
    	appliesto: "gridContainers",
    	computed: [
    		"grid-row-gap",
    		"grid-column-gap"
    	],
    	order: "uniqueOrder",
    	status: "obsolete",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
    },
    	"grid-row": {
    	syntax: "<grid-line> [ / <grid-line> ]?",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: [
    		"grid-row-start",
    		"grid-row-end"
    	],
    	appliesto: "gridItemsAndBoxesWithinGridContainer",
    	computed: [
    		"grid-row-start",
    		"grid-row-end"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
    },
    	"grid-row-end": {
    	syntax: "<grid-line>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "auto",
    	appliesto: "gridItemsAndBoxesWithinGridContainer",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
    },
    	"grid-row-gap": {
    	syntax: "<length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "referToDimensionOfContentArea",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "0",
    	appliesto: "gridContainers",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	status: "obsolete",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
    },
    	"grid-row-start": {
    	syntax: "<grid-line>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "auto",
    	appliesto: "gridItemsAndBoxesWithinGridContainer",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
    },
    	"grid-template": {
    	syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: [
    		"grid-template-columns",
    		"grid-template-rows"
    	],
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: [
    		"grid-template-columns",
    		"grid-template-rows",
    		"grid-template-areas"
    	],
    	appliesto: "gridContainers",
    	computed: [
    		"grid-template-columns",
    		"grid-template-rows",
    		"grid-template-areas"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
    },
    	"grid-template-areas": {
    	syntax: "none | <string>+",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "none",
    	appliesto: "gridContainers",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
    },
    	"grid-template-columns": {
    	syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
    	media: "visual",
    	inherited: false,
    	animationType: "simpleListOfLpcDifferenceLpc",
    	percentages: "referToDimensionOfContentArea",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "none",
    	appliesto: "gridContainers",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
    },
    	"grid-template-rows": {
    	syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
    	media: "visual",
    	inherited: false,
    	animationType: "simpleListOfLpcDifferenceLpc",
    	percentages: "referToDimensionOfContentArea",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "none",
    	appliesto: "gridContainers",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
    },
    	"hanging-punctuation": {
    	syntax: "none | [ first || [ force-end | allow-end ] || last ]",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
    },
    	height: height,
    	hyphens: hyphens,
    	"image-orientation": {
    	syntax: "from-image | <angle> | [ <angle>? flip ]",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Images"
    	],
    	initial: "from-image",
    	appliesto: "allElements",
    	computed: "angleRoundedToNextQuarter",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
    },
    	"image-rendering": {
    	syntax: "auto | crisp-edges | pixelated",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Images"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
    },
    	"image-resolution": {
    	syntax: "[ from-image || <resolution> ] && snap?",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Images"
    	],
    	initial: "1dppx",
    	appliesto: "allElements",
    	computed: "asSpecifiedWithExceptionOfResolution",
    	order: "uniqueOrder",
    	status: "experimental"
    },
    	"ime-mode": {
    	syntax: "auto | normal | active | inactive | disabled",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: "auto",
    	appliesto: "textFields",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "obsolete",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
    },
    	"initial-letter": {
    	syntax: "normal | [ <number> <integer>? ]",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Inline"
    	],
    	initial: "normal",
    	appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
    },
    	"initial-letter-align": {
    	syntax: "[ auto | alphabetic | hanging | ideographic ]",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Inline"
    	],
    	initial: "auto",
    	appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
    },
    	"inline-size": {
    	syntax: "<'width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "inlineSizeOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "auto",
    	appliesto: "sameAsWidthAndHeight",
    	computed: "sameAsWidthAndHeight",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
    },
    	inset: inset,
    	"inset-block": {
    	syntax: "<'top'>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "logicalHeightOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "auto",
    	appliesto: "positionedElements",
    	computed: "sameAsBoxOffsets",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
    },
    	"inset-block-end": {
    	syntax: "<'top'>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "logicalHeightOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "auto",
    	appliesto: "positionedElements",
    	computed: "sameAsBoxOffsets",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
    },
    	"inset-block-start": {
    	syntax: "<'top'>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "logicalHeightOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "auto",
    	appliesto: "positionedElements",
    	computed: "sameAsBoxOffsets",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
    },
    	"inset-inline": {
    	syntax: "<'top'>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "auto",
    	appliesto: "positionedElements",
    	computed: "sameAsBoxOffsets",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
    },
    	"inset-inline-end": {
    	syntax: "<'top'>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "auto",
    	appliesto: "positionedElements",
    	computed: "sameAsBoxOffsets",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
    },
    	"inset-inline-start": {
    	syntax: "<'top'>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "auto",
    	appliesto: "positionedElements",
    	computed: "sameAsBoxOffsets",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
    },
    	isolation: isolation,
    	"justify-content": {
    	syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Alignment"
    	],
    	initial: "normal",
    	appliesto: "flexContainers",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
    },
    	"justify-items": {
    	syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Alignment"
    	],
    	initial: "legacy",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
    },
    	"justify-self": {
    	syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Alignment"
    	],
    	initial: "auto",
    	appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
    },
    	"justify-tracks": {
    	syntax: "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "normal",
    	appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks"
    },
    	left: left,
    	"letter-spacing": {
    	syntax: "normal | <length>",
    	media: "visual",
    	inherited: true,
    	animationType: "length",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "optimumValueOfAbsoluteLengthOrNormal",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
    },
    	"line-break": {
    	syntax: "auto | loose | normal | strict | anywhere",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
    },
    	"line-clamp": {
    	syntax: "none | <integer>",
    	media: "visual",
    	inherited: false,
    	animationType: "integer",
    	percentages: "no",
    	groups: [
    		"CSS Overflow"
    	],
    	initial: "none",
    	appliesto: "blockContainersExceptMultiColumnContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "experimental"
    },
    	"line-height": {
    	syntax: "normal | <number> | <length> | <percentage>",
    	media: "visual",
    	inherited: true,
    	animationType: "numberOrLength",
    	percentages: "referToElementFontSize",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "absoluteLengthOrAsSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
    },
    	"line-height-step": {
    	syntax: "<length>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Fonts"
    	],
    	initial: "0",
    	appliesto: "blockContainers",
    	computed: "absoluteLength",
    	order: "perGrammar",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
    },
    	"list-style": {
    	syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Lists and Counters"
    	],
    	initial: [
    		"list-style-type",
    		"list-style-position",
    		"list-style-image"
    	],
    	appliesto: "listItems",
    	computed: [
    		"list-style-image",
    		"list-style-position",
    		"list-style-type"
    	],
    	order: "orderOfAppearance",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
    },
    	"list-style-image": {
    	syntax: "<url> | none",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Lists and Counters"
    	],
    	initial: "none",
    	appliesto: "listItems",
    	computed: "noneOrImageWithAbsoluteURI",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
    },
    	"list-style-position": {
    	syntax: "inside | outside",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Lists and Counters"
    	],
    	initial: "outside",
    	appliesto: "listItems",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
    },
    	"list-style-type": {
    	syntax: "<counter-style> | <string> | none",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Lists and Counters"
    	],
    	initial: "disc",
    	appliesto: "listItems",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
    },
    	margin: margin,
    	"margin-block": {
    	syntax: "<'margin-left'>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "dependsOnLayoutModel",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "sameAsMargin",
    	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
    },
    	"margin-block-end": {
    	syntax: "<'margin-left'>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "dependsOnLayoutModel",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "sameAsMargin",
    	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
    },
    	"margin-block-start": {
    	syntax: "<'margin-left'>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "dependsOnLayoutModel",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "sameAsMargin",
    	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
    },
    	"margin-bottom": {
    	syntax: "<length> | <percentage> | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "0",
    	appliesto: "allElementsExceptTableDisplayTypes",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
    },
    	"margin-inline": {
    	syntax: "<'margin-left'>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "dependsOnLayoutModel",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "sameAsMargin",
    	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
    },
    	"margin-inline-end": {
    	syntax: "<'margin-left'>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "dependsOnLayoutModel",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "sameAsMargin",
    	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
    },
    	"margin-inline-start": {
    	syntax: "<'margin-left'>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "dependsOnLayoutModel",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "sameAsMargin",
    	computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
    },
    	"margin-left": {
    	syntax: "<length> | <percentage> | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "0",
    	appliesto: "allElementsExceptTableDisplayTypes",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
    },
    	"margin-right": {
    	syntax: "<length> | <percentage> | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "0",
    	appliesto: "allElementsExceptTableDisplayTypes",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
    },
    	"margin-top": {
    	syntax: "<length> | <percentage> | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "0",
    	appliesto: "allElementsExceptTableDisplayTypes",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
    },
    	"margin-trim": {
    	syntax: "none | in-flow | all",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "none",
    	appliesto: "blockContainersAndMultiColumnContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line"
    	],
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim"
    },
    	mask: mask,
    	"mask-border": {
    	syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"mask-border-mode",
    		"mask-border-outset",
    		"mask-border-repeat",
    		"mask-border-slice",
    		"mask-border-source",
    		"mask-border-width"
    	],
    	percentages: [
    		"mask-border-slice",
    		"mask-border-width"
    	],
    	groups: [
    		"CSS Masking"
    	],
    	initial: [
    		"mask-border-mode",
    		"mask-border-outset",
    		"mask-border-repeat",
    		"mask-border-slice",
    		"mask-border-source",
    		"mask-border-width"
    	],
    	appliesto: "allElementsSVGContainerElements",
    	computed: [
    		"mask-border-mode",
    		"mask-border-outset",
    		"mask-border-repeat",
    		"mask-border-slice",
    		"mask-border-source",
    		"mask-border-width"
    	],
    	order: "perGrammar",
    	stacking: true,
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
    },
    	"mask-border-mode": {
    	syntax: "luminance | alpha",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "alpha",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
    },
    	"mask-border-outset": {
    	syntax: "[ <length> | <number> ]{1,4}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "0",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
    },
    	"mask-border-repeat": {
    	syntax: "[ stretch | repeat | round | space ]{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "stretch",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
    },
    	"mask-border-slice": {
    	syntax: "<number-percentage>{1,4} fill?",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "referToSizeOfMaskBorderImage",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "0",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
    },
    	"mask-border-source": {
    	syntax: "none | <image>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "none",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecifiedURLsAbsolute",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
    },
    	"mask-border-width": {
    	syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "relativeToMaskBorderImageArea",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "auto",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
    },
    	"mask-clip": {
    	syntax: "[ <geometry-box> | no-clip ]#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "border-box",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
    },
    	"mask-composite": {
    	syntax: "<compositing-operator>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "add",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
    },
    	"mask-image": {
    	syntax: "<mask-reference>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "none",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecifiedURLsAbsolute",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
    },
    	"mask-mode": {
    	syntax: "<masking-mode>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "match-source",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
    },
    	"mask-origin": {
    	syntax: "<geometry-box>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "border-box",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
    },
    	"mask-position": {
    	syntax: "<position>#",
    	media: "visual",
    	inherited: false,
    	animationType: "repeatableListOfSimpleListOfLpc",
    	percentages: "referToSizeOfMaskPaintingArea",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "center",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "consistsOfTwoKeywordsForOriginAndOffsets",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
    },
    	"mask-repeat": {
    	syntax: "<repeat-style>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "no-repeat",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "consistsOfTwoDimensionKeywords",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
    },
    	"mask-size": {
    	syntax: "<bg-size>#",
    	media: "visual",
    	inherited: false,
    	animationType: "repeatableListOfSimpleListOfLpc",
    	percentages: "no",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "auto",
    	appliesto: "allElementsSVGContainerElements",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
    },
    	"mask-type": {
    	syntax: "luminance | alpha",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Masking"
    	],
    	initial: "luminance",
    	appliesto: "maskElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
    },
    	"masonry-auto-flow": {
    	syntax: "[ pack | next ] || [ definite-first | ordered ]",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Grid Layout"
    	],
    	initial: "pack",
    	appliesto: "gridContainersWithMasonryLayout",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"
    },
    	"math-style": {
    	syntax: "normal | compact",
    	media: "visual",
    	inherited: true,
    	animationType: "notAnimatable",
    	percentages: "no",
    	groups: [
    		"MathML"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style"
    },
    	"max-block-size": {
    	syntax: "<'max-width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "blockSizeOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "sameAsWidthAndHeight",
    	computed: "sameAsMaxWidthAndMaxHeight",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
    },
    	"max-height": {
    	syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "none",
    	appliesto: "allElementsButNonReplacedAndTableColumns",
    	computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
    },
    	"max-inline-size": {
    	syntax: "<'max-width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "inlineSizeOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "sameAsWidthAndHeight",
    	computed: "sameAsMaxWidthAndMaxHeight",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
    },
    	"max-lines": {
    	syntax: "none | <integer>",
    	media: "visual",
    	inherited: false,
    	animationType: "integer",
    	percentages: "no",
    	groups: [
    		"CSS Overflow"
    	],
    	initial: "none",
    	appliesto: "blockContainersExceptMultiColumnContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "experimental"
    },
    	"max-width": {
    	syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "none",
    	appliesto: "allElementsButNonReplacedAndTableRows",
    	computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
    },
    	"min-block-size": {
    	syntax: "<'min-width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "blockSizeOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "sameAsWidthAndHeight",
    	computed: "sameAsMinWidthAndMinHeight",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
    },
    	"min-height": {
    	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "auto",
    	appliesto: "allElementsButNonReplacedAndTableColumns",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
    },
    	"min-inline-size": {
    	syntax: "<'min-width'>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "inlineSizeOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "sameAsWidthAndHeight",
    	computed: "sameAsMinWidthAndMinHeight",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
    },
    	"min-width": {
    	syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "auto",
    	appliesto: "allElementsButNonReplacedAndTableRows",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
    },
    	"mix-blend-mode": {
    	syntax: "<blend-mode>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Compositing and Blending"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	stacking: true,
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
    },
    	"object-fit": {
    	syntax: "fill | contain | cover | none | scale-down",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Images"
    	],
    	initial: "fill",
    	appliesto: "replacedElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
    },
    	"object-position": {
    	syntax: "<position>",
    	media: "visual",
    	inherited: true,
    	animationType: "repeatableListOfSimpleListOfLpc",
    	percentages: "referToWidthAndHeightOfElement",
    	groups: [
    		"CSS Images"
    	],
    	initial: "50% 50%",
    	appliesto: "replacedElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
    },
    	offset: offset,
    	"offset-anchor": {
    	syntax: "auto | <position>",
    	media: "visual",
    	inherited: false,
    	animationType: "position",
    	percentages: "relativeToWidthAndHeight",
    	groups: [
    		"CSS Motion Path"
    	],
    	initial: "auto",
    	appliesto: "transformableElements",
    	computed: "forLengthAbsoluteValueOtherwisePercentage",
    	order: "perGrammar",
    	status: "standard"
    },
    	"offset-distance": {
    	syntax: "<length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToTotalPathLength",
    	groups: [
    		"CSS Motion Path"
    	],
    	initial: "0",
    	appliesto: "transformableElements",
    	computed: "forLengthAbsoluteValueOtherwisePercentage",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
    },
    	"offset-path": {
    	syntax: "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
    	media: "visual",
    	inherited: false,
    	animationType: "angleOrBasicShapeOrPath",
    	percentages: "no",
    	groups: [
    		"CSS Motion Path"
    	],
    	initial: "none",
    	appliesto: "transformableElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	stacking: true,
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
    },
    	"offset-position": {
    	syntax: "auto | <position>",
    	media: "visual",
    	inherited: false,
    	animationType: "position",
    	percentages: "referToSizeOfContainingBlock",
    	groups: [
    		"CSS Motion Path"
    	],
    	initial: "auto",
    	appliesto: "transformableElements",
    	computed: "forLengthAbsoluteValueOtherwisePercentage",
    	order: "perGrammar",
    	status: "experimental"
    },
    	"offset-rotate": {
    	syntax: "[ auto | reverse ] || <angle>",
    	media: "visual",
    	inherited: false,
    	animationType: "angleOrBasicShapeOrPath",
    	percentages: "no",
    	groups: [
    		"CSS Motion Path"
    	],
    	initial: "auto",
    	appliesto: "transformableElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
    },
    	opacity: opacity,
    	order: order,
    	orphans: orphans,
    	outline: outline,
    	"outline-color": {
    	syntax: "<color> | invert",
    	media: [
    		"visual",
    		"interactive"
    	],
    	inherited: false,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: "invertOrCurrentColor",
    	appliesto: "allElements",
    	computed: "invertForTranslucentColorRGBAOtherwiseRGB",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
    },
    	"outline-offset": {
    	syntax: "<length>",
    	media: [
    		"visual",
    		"interactive"
    	],
    	inherited: false,
    	animationType: "length",
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
    },
    	"outline-style": {
    	syntax: "auto | <'border-style'>",
    	media: [
    		"visual",
    		"interactive"
    	],
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
    },
    	"outline-width": {
    	syntax: "<line-width>",
    	media: [
    		"visual",
    		"interactive"
    	],
    	inherited: false,
    	animationType: "length",
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: "medium",
    	appliesto: "allElements",
    	computed: "absoluteLength0ForNone",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
    },
    	overflow: overflow,
    	"overflow-anchor": {
    	syntax: "auto | none",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Anchoring"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard"
    },
    	"overflow-block": {
    	syntax: "visible | hidden | clip | scroll | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Overflow"
    	],
    	initial: "auto",
    	appliesto: "blockContainersFlexContainersGridContainers",
    	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
    	order: "perGrammar",
    	status: "standard"
    },
    	"overflow-clip-box": {
    	syntax: "padding-box | content-box",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Mozilla Extensions"
    	],
    	initial: "padding-box",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
    },
    	"overflow-inline": {
    	syntax: "visible | hidden | clip | scroll | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Overflow"
    	],
    	initial: "auto",
    	appliesto: "blockContainersFlexContainersGridContainers",
    	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
    	order: "perGrammar",
    	status: "standard"
    },
    	"overflow-wrap": {
    	syntax: "normal | break-word | anywhere",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "normal",
    	appliesto: "nonReplacedInlineElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
    },
    	"overflow-x": {
    	syntax: "visible | hidden | clip | scroll | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Overflow"
    	],
    	initial: "visible",
    	appliesto: "blockContainersFlexContainersGridContainers",
    	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
    },
    	"overflow-y": {
    	syntax: "visible | hidden | clip | scroll | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Overflow"
    	],
    	initial: "visible",
    	appliesto: "blockContainersFlexContainersGridContainers",
    	computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
    },
    	"overscroll-behavior": {
    	syntax: "[ contain | none | auto ]{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "auto",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
    },
    	"overscroll-behavior-block": {
    	syntax: "contain | none | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "auto",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"
    },
    	"overscroll-behavior-inline": {
    	syntax: "contain | none | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "auto",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"
    },
    	"overscroll-behavior-x": {
    	syntax: "contain | none | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "auto",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
    },
    	"overscroll-behavior-y": {
    	syntax: "contain | none | auto",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "auto",
    	appliesto: "nonReplacedBlockAndInlineBlockElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
    },
    	padding: padding,
    	"padding-block": {
    	syntax: "<'padding-left'>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asLength",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
    },
    	"padding-block-end": {
    	syntax: "<'padding-left'>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asLength",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
    },
    	"padding-block-start": {
    	syntax: "<'padding-left'>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asLength",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
    },
    	"padding-bottom": {
    	syntax: "<length> | <percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "0",
    	appliesto: "allElementsExceptInternalTableDisplayTypes",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
    },
    	"padding-inline": {
    	syntax: "<'padding-left'>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asLength",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
    },
    	"padding-inline-end": {
    	syntax: "<'padding-left'>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asLength",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
    },
    	"padding-inline-start": {
    	syntax: "<'padding-left'>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "logicalWidthOfContainingBlock",
    	groups: [
    		"CSS Logical Properties"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asLength",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
    },
    	"padding-left": {
    	syntax: "<length> | <percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "0",
    	appliesto: "allElementsExceptInternalTableDisplayTypes",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
    },
    	"padding-right": {
    	syntax: "<length> | <percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "0",
    	appliesto: "allElementsExceptInternalTableDisplayTypes",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
    },
    	"padding-top": {
    	syntax: "<length> | <percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Box Model"
    	],
    	initial: "0",
    	appliesto: "allElementsExceptInternalTableDisplayTypes",
    	computed: "percentageAsSpecifiedOrAbsoluteLength",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
    },
    	"page-break-after": {
    	syntax: "auto | always | avoid | left | right | recto | verso",
    	media: [
    		"visual",
    		"paged"
    	],
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Pages"
    	],
    	initial: "auto",
    	appliesto: "blockElementsInNormalFlow",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
    },
    	"page-break-before": {
    	syntax: "auto | always | avoid | left | right | recto | verso",
    	media: [
    		"visual",
    		"paged"
    	],
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Pages"
    	],
    	initial: "auto",
    	appliesto: "blockElementsInNormalFlow",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
    },
    	"page-break-inside": {
    	syntax: "auto | avoid",
    	media: [
    		"visual",
    		"paged"
    	],
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Pages"
    	],
    	initial: "auto",
    	appliesto: "blockElementsInNormalFlow",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
    },
    	"paint-order": {
    	syntax: "normal | [ fill || stroke || markers ]",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "normal",
    	appliesto: "textElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
    },
    	perspective: perspective,
    	"perspective-origin": {
    	syntax: "<position>",
    	media: "visual",
    	inherited: false,
    	animationType: "simpleListOfLpc",
    	percentages: "referToSizeOfBoundingBox",
    	groups: [
    		"CSS Transforms"
    	],
    	initial: "50% 50%",
    	appliesto: "transformableElements",
    	computed: "forLengthAbsoluteValueOtherwisePercentage",
    	order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
    },
    	"place-content": {
    	syntax: "<'align-content'> <'justify-content'>?",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Alignment"
    	],
    	initial: "normal",
    	appliesto: "multilineFlexContainers",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
    },
    	"place-items": {
    	syntax: "<'align-items'> <'justify-items'>?",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Alignment"
    	],
    	initial: [
    		"align-items",
    		"justify-items"
    	],
    	appliesto: "allElements",
    	computed: [
    		"align-items",
    		"justify-items"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
    },
    	"place-self": {
    	syntax: "<'align-self'> <'justify-self'>?",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Box Alignment"
    	],
    	initial: [
    		"align-self",
    		"justify-self"
    	],
    	appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
    	computed: [
    		"align-self",
    		"justify-self"
    	],
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
    },
    	"pointer-events": {
    	syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Pointer Events"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
    },
    	position: position$1,
    	quotes: quotes,
    	resize: resize,
    	right: right,
    	rotate: rotate,
    	"row-gap": {
    	syntax: "normal | <length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToDimensionOfContentArea",
    	groups: [
    		"CSS Box Alignment"
    	],
    	initial: "normal",
    	appliesto: "multiColumnElementsFlexContainersGridContainers",
    	computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
    },
    	"ruby-align": {
    	syntax: "start | center | space-between | space-around",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Ruby"
    	],
    	initial: "space-around",
    	appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
    },
    	"ruby-merge": {
    	syntax: "separate | collapse | auto",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Ruby"
    	],
    	initial: "separate",
    	appliesto: "rubyAnnotationsContainers",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "experimental"
    },
    	"ruby-position": {
    	syntax: "over | under | inter-character",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Ruby"
    	],
    	initial: "over",
    	appliesto: "rubyAnnotationsContainers",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
    },
    	scale: scale,
    	"scrollbar-color": {
    	syntax: "auto | dark | light | <color>{2}",
    	media: "visual",
    	inherited: true,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Scrollbars"
    	],
    	initial: "auto",
    	appliesto: "scrollingBoxes",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
    },
    	"scrollbar-gutter": {
    	syntax: "auto | [ stable | always ] && both? && force?",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Overflow"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"
    },
    	"scrollbar-width": {
    	syntax: "auto | thin | none",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Scrollbars"
    	],
    	initial: "auto",
    	appliesto: "scrollingBoxes",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
    },
    	"scroll-behavior": {
    	syntax: "auto | smooth",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSSOM View"
    	],
    	initial: "auto",
    	appliesto: "scrollingBoxes",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
    },
    	"scroll-margin": {
    	syntax: "<length>{1,4}",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
    },
    	"scroll-margin-block": {
    	syntax: "<length>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
    },
    	"scroll-margin-block-start": {
    	syntax: "<length>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
    },
    	"scroll-margin-block-end": {
    	syntax: "<length>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
    },
    	"scroll-margin-bottom": {
    	syntax: "<length>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
    },
    	"scroll-margin-inline": {
    	syntax: "<length>{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
    },
    	"scroll-margin-inline-start": {
    	syntax: "<length>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
    },
    	"scroll-margin-inline-end": {
    	syntax: "<length>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
    },
    	"scroll-margin-left": {
    	syntax: "<length>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
    },
    	"scroll-margin-right": {
    	syntax: "<length>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
    },
    	"scroll-margin-top": {
    	syntax: "<length>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "0",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
    },
    	"scroll-padding": {
    	syntax: "[ auto | <length-percentage> ]{1,4}",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "relativeToTheScrollContainersScrollport",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "auto",
    	appliesto: "scrollContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
    },
    	"scroll-padding-block": {
    	syntax: "[ auto | <length-percentage> ]{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "relativeToTheScrollContainersScrollport",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "auto",
    	appliesto: "scrollContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
    },
    	"scroll-padding-block-start": {
    	syntax: "auto | <length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "relativeToTheScrollContainersScrollport",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "auto",
    	appliesto: "scrollContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
    },
    	"scroll-padding-block-end": {
    	syntax: "auto | <length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "relativeToTheScrollContainersScrollport",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "auto",
    	appliesto: "scrollContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
    },
    	"scroll-padding-bottom": {
    	syntax: "auto | <length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "relativeToTheScrollContainersScrollport",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "auto",
    	appliesto: "scrollContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
    },
    	"scroll-padding-inline": {
    	syntax: "[ auto | <length-percentage> ]{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "relativeToTheScrollContainersScrollport",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "auto",
    	appliesto: "scrollContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
    },
    	"scroll-padding-inline-start": {
    	syntax: "auto | <length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "relativeToTheScrollContainersScrollport",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "auto",
    	appliesto: "scrollContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
    },
    	"scroll-padding-inline-end": {
    	syntax: "auto | <length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "relativeToTheScrollContainersScrollport",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "auto",
    	appliesto: "scrollContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
    },
    	"scroll-padding-left": {
    	syntax: "auto | <length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "relativeToTheScrollContainersScrollport",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "auto",
    	appliesto: "scrollContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
    },
    	"scroll-padding-right": {
    	syntax: "auto | <length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "relativeToTheScrollContainersScrollport",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "auto",
    	appliesto: "scrollContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
    },
    	"scroll-padding-top": {
    	syntax: "auto | <length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "relativeToTheScrollContainersScrollport",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "auto",
    	appliesto: "scrollContainers",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
    },
    	"scroll-snap-align": {
    	syntax: "[ none | start | end | center ]{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
    },
    	"scroll-snap-coordinate": {
    	syntax: "none | <position>#",
    	media: "interactive",
    	inherited: false,
    	animationType: "position",
    	percentages: "referToBorderBox",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	status: "obsolete",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
    },
    	"scroll-snap-destination": {
    	syntax: "<position>",
    	media: "interactive",
    	inherited: false,
    	animationType: "position",
    	percentages: "relativeToScrollContainerPaddingBoxAxis",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "0px 0px",
    	appliesto: "scrollContainers",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	status: "obsolete",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
    },
    	"scroll-snap-points-x": {
    	syntax: "none | repeat( <length-percentage> )",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "relativeToScrollContainerPaddingBoxAxis",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "none",
    	appliesto: "scrollContainers",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	status: "obsolete",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
    },
    	"scroll-snap-points-y": {
    	syntax: "none | repeat( <length-percentage> )",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "relativeToScrollContainerPaddingBoxAxis",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "none",
    	appliesto: "scrollContainers",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	status: "obsolete",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
    },
    	"scroll-snap-stop": {
    	syntax: "normal | always",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
    },
    	"scroll-snap-type": {
    	syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
    },
    	"scroll-snap-type-x": {
    	syntax: "none | mandatory | proximity",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "none",
    	appliesto: "scrollContainers",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "obsolete",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
    },
    	"scroll-snap-type-y": {
    	syntax: "none | mandatory | proximity",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Scroll Snap"
    	],
    	initial: "none",
    	appliesto: "scrollContainers",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "obsolete",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
    },
    	"shape-image-threshold": {
    	syntax: "<alpha-value>",
    	media: "visual",
    	inherited: false,
    	animationType: "number",
    	percentages: "no",
    	groups: [
    		"CSS Shapes"
    	],
    	initial: "0.0",
    	appliesto: "floats",
    	computed: "specifiedValueNumberClipped0To1",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
    },
    	"shape-margin": {
    	syntax: "<length-percentage>",
    	media: "visual",
    	inherited: false,
    	animationType: "lpc",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Shapes"
    	],
    	initial: "0",
    	appliesto: "floats",
    	computed: "asSpecifiedRelativeToAbsoluteLengths",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
    },
    	"shape-outside": {
    	syntax: "none | <shape-box> || <basic-shape> | <image>",
    	media: "visual",
    	inherited: false,
    	animationType: "basicShapeOtherwiseNo",
    	percentages: "no",
    	groups: [
    		"CSS Shapes"
    	],
    	initial: "none",
    	appliesto: "floats",
    	computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
    },
    	"tab-size": {
    	syntax: "<integer> | <length>",
    	media: "visual",
    	inherited: true,
    	animationType: "length",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "8",
    	appliesto: "blockContainers",
    	computed: "specifiedIntegerOrAbsoluteLength",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
    },
    	"table-layout": {
    	syntax: "auto | fixed",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Table"
    	],
    	initial: "auto",
    	appliesto: "tableElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
    },
    	"text-align": {
    	syntax: "start | end | left | right | center | justify | match-parent",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "startOrNamelessValueIfLTRRightIfRTL",
    	appliesto: "blockContainers",
    	computed: "asSpecifiedExceptMatchParent",
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
    },
    	"text-align-last": {
    	syntax: "auto | start | end | left | right | center | justify",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "auto",
    	appliesto: "blockContainers",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
    },
    	"text-combine-upright": {
    	syntax: "none | all | [ digits <integer>? ]",
    	media: "visual",
    	inherited: true,
    	animationType: "notAnimatable",
    	percentages: "no",
    	groups: [
    		"CSS Writing Modes"
    	],
    	initial: "none",
    	appliesto: "nonReplacedInlineElements",
    	computed: "keywordPlusIntegerIfDigits",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
    },
    	"text-decoration": {
    	syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"text-decoration-color",
    		"text-decoration-style",
    		"text-decoration-line",
    		"text-decoration-thickness"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: [
    		"text-decoration-color",
    		"text-decoration-style",
    		"text-decoration-line"
    	],
    	appliesto: "allElements",
    	computed: [
    		"text-decoration-line",
    		"text-decoration-style",
    		"text-decoration-color",
    		"text-decoration-thickness"
    	],
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
    },
    	"text-decoration-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: false,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
    },
    	"text-decoration-line": {
    	syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
    },
    	"text-decoration-skip": {
    	syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: "objects",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
    },
    	"text-decoration-skip-ink": {
    	syntax: "auto | all | none",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
    },
    	"text-decoration-style": {
    	syntax: "solid | double | dotted | dashed | wavy",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: "solid",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
    },
    	"text-decoration-thickness": {
    	syntax: "auto | from-font | <length> | <percentage> ",
    	media: "visual",
    	inherited: false,
    	animationType: "byComputedValueType",
    	percentages: "referToElementFontSize",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
    },
    	"text-emphasis": {
    	syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
    	media: "visual",
    	inherited: false,
    	animationType: [
    		"text-emphasis-color",
    		"text-emphasis-style"
    	],
    	percentages: "no",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: [
    		"text-emphasis-style",
    		"text-emphasis-color"
    	],
    	appliesto: "allElements",
    	computed: [
    		"text-emphasis-style",
    		"text-emphasis-color"
    	],
    	order: "orderOfAppearance",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
    },
    	"text-emphasis-color": {
    	syntax: "<color>",
    	media: "visual",
    	inherited: false,
    	animationType: "color",
    	percentages: "no",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: "currentcolor",
    	appliesto: "allElements",
    	computed: "computedColor",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
    },
    	"text-emphasis-position": {
    	syntax: "[ over | under ] && [ right | left ]",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: "over right",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
    },
    	"text-emphasis-style": {
    	syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
    },
    	"text-indent": {
    	syntax: "<length-percentage> && hanging? && each-line?",
    	media: "visual",
    	inherited: true,
    	animationType: "lpc",
    	percentages: "referToWidthOfContainingBlock",
    	groups: [
    		"CSS Text"
    	],
    	initial: "0",
    	appliesto: "blockContainers",
    	computed: "percentageOrAbsoluteLengthPlusKeywords",
    	order: "lengthOrPercentageBeforeKeywords",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
    },
    	"text-justify": {
    	syntax: "auto | inter-character | inter-word | none",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "auto",
    	appliesto: "inlineLevelAndTableCellElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
    },
    	"text-orientation": {
    	syntax: "mixed | upright | sideways",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Writing Modes"
    	],
    	initial: "mixed",
    	appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
    },
    	"text-overflow": {
    	syntax: "[ clip | ellipsis | <string> ]{1,2}",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: "clip",
    	appliesto: "blockContainerElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
    },
    	"text-rendering": {
    	syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Miscellaneous"
    	],
    	initial: "auto",
    	appliesto: "textElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
    },
    	"text-shadow": {
    	syntax: "none | <shadow-t>#",
    	media: "visual",
    	inherited: true,
    	animationType: "shadowList",
    	percentages: "no",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "colorPlusThreeAbsoluteLengths",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
    },
    	"text-size-adjust": {
    	syntax: "none | auto | <percentage>",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "referToSizeOfFont",
    	groups: [
    		"CSS Text"
    	],
    	initial: "autoForSmartphoneBrowsersSupportingInflation",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "experimental",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
    },
    	"text-transform": {
    	syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "none",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
    },
    	"text-underline-offset": {
    	syntax: "auto | <length> | <percentage> ",
    	media: "visual",
    	inherited: true,
    	animationType: "byComputedValueType",
    	percentages: "referToElementFontSize",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
    },
    	"text-underline-position": {
    	syntax: "auto | from-font | [ under || [ left | right ] ]",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text Decoration"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "orderOfAppearance",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
    },
    	top: top,
    	"touch-action": {
    	syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"Pointer Events"
    	],
    	initial: "auto",
    	appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
    },
    	transform: transform,
    	"transform-box": {
    	syntax: "content-box | border-box | fill-box | stroke-box | view-box",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Transforms"
    	],
    	initial: "view-box",
    	appliesto: "transformableElements",
    	computed: "asSpecified",
    	order: "perGrammar",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
    },
    	"transform-origin": {
    	syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
    	media: "visual",
    	inherited: false,
    	animationType: "simpleListOfLpc",
    	percentages: "referToSizeOfBoundingBox",
    	groups: [
    		"CSS Transforms"
    	],
    	initial: "50% 50% 0",
    	appliesto: "transformableElements",
    	computed: "forLengthAbsoluteValueOtherwisePercentage",
    	order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
    },
    	"transform-style": {
    	syntax: "flat | preserve-3d",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Transforms"
    	],
    	initial: "flat",
    	appliesto: "transformableElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	stacking: true,
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
    },
    	transition: transition,
    	"transition-delay": {
    	syntax: "<time>#",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Transitions"
    	],
    	initial: "0s",
    	appliesto: "allElementsAndPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
    },
    	"transition-duration": {
    	syntax: "<time>#",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Transitions"
    	],
    	initial: "0s",
    	appliesto: "allElementsAndPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
    },
    	"transition-property": {
    	syntax: "none | <single-transition-property>#",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Transitions"
    	],
    	initial: "all",
    	appliesto: "allElementsAndPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
    },
    	"transition-timing-function": {
    	syntax: "<timing-function>#",
    	media: "interactive",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Transitions"
    	],
    	initial: "ease",
    	appliesto: "allElementsAndPseudos",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
    },
    	translate: translate,
    	"unicode-bidi": {
    	syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Writing Modes"
    	],
    	initial: "normal",
    	appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
    },
    	"user-select": {
    	syntax: "auto | text | none | contain | all",
    	media: "visual",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Basic User Interface"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "nonstandard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
    },
    	"vertical-align": {
    	syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
    	media: "visual",
    	inherited: false,
    	animationType: "length",
    	percentages: "referToLineHeight",
    	groups: [
    		"CSS Table"
    	],
    	initial: "baseline",
    	appliesto: "inlineLevelAndTableCellElements",
    	computed: "absoluteLengthOrKeyword",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
    },
    	visibility: visibility,
    	"white-space": {
    	syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
    },
    	widows: widows,
    	width: width,
    	"will-change": {
    	syntax: "auto | <animateable-feature>#",
    	media: "all",
    	inherited: false,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Will Change"
    	],
    	initial: "auto",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
    },
    	"word-break": {
    	syntax: "normal | break-all | keep-all | break-word",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
    },
    	"word-spacing": {
    	syntax: "normal | <length-percentage>",
    	media: "visual",
    	inherited: true,
    	animationType: "length",
    	percentages: "referToWidthOfAffectedGlyph",
    	groups: [
    		"CSS Text"
    	],
    	initial: "normal",
    	appliesto: "allElements",
    	computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
    	order: "uniqueOrder",
    	alsoAppliesTo: [
    		"::first-letter",
    		"::first-line",
    		"::placeholder"
    	],
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
    },
    	"word-wrap": {
    	syntax: "normal | break-word",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Text"
    	],
    	initial: "normal",
    	appliesto: "nonReplacedInlineElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
    },
    	"writing-mode": {
    	syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
    	media: "visual",
    	inherited: true,
    	animationType: "discrete",
    	percentages: "no",
    	groups: [
    		"CSS Writing Modes"
    	],
    	initial: "horizontal-tb",
    	appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
    },
    	"z-index": {
    	syntax: "auto | <integer>",
    	media: "visual",
    	inherited: false,
    	animationType: "integer",
    	percentages: "no",
    	groups: [
    		"CSS Positioning"
    	],
    	initial: "auto",
    	appliesto: "positionedElements",
    	computed: "asSpecified",
    	order: "uniqueOrder",
    	stacking: true,
    	status: "standard",
    	mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
    },
    	zoom: zoom
    };

    var attachment = {
    	syntax: "scroll | fixed | local"
    };
    var box = {
    	syntax: "border-box | padding-box | content-box"
    };
    var color = {
    	syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
    };
    var combinator = {
    	syntax: "'>' | '+' | '~' | [ '||' ]"
    };
    var gradient = {
    	syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
    };
    var hue = {
    	syntax: "<number> | <angle>"
    };
    var image = {
    	syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
    };
    var nth$1 = {
    	syntax: "<an-plus-b> | even | odd"
    };
    var position = {
    	syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
    };
    var quote = {
    	syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
    };
    var shadow = {
    	syntax: "inset? && <length>{2,4} && <color>?"
    };
    var shape = {
    	syntax: "rect(<top>, <right>, <bottom>, <left>)"
    };
    var size = {
    	syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
    };
    var symbol = {
    	syntax: "<string> | <image> | <custom-ident>"
    };
    var target = {
    	syntax: "<target-counter()> | <target-counters()> | <target-text()>"
    };
    var require$$2 = {
    	"absolute-size": {
    	syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
    },
    	"alpha-value": {
    	syntax: "<number> | <percentage>"
    },
    	"angle-percentage": {
    	syntax: "<angle> | <percentage>"
    },
    	"angular-color-hint": {
    	syntax: "<angle-percentage>"
    },
    	"angular-color-stop": {
    	syntax: "<color> && <color-stop-angle>?"
    },
    	"angular-color-stop-list": {
    	syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
    },
    	"animateable-feature": {
    	syntax: "scroll-position | contents | <custom-ident>"
    },
    	attachment: attachment,
    	"attr()": {
    	syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
    },
    	"attr-matcher": {
    	syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
    },
    	"attr-modifier": {
    	syntax: "i | s"
    },
    	"attribute-selector": {
    	syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
    },
    	"auto-repeat": {
    	syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
    },
    	"auto-track-list": {
    	syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
    },
    	"baseline-position": {
    	syntax: "[ first | last ]? baseline"
    },
    	"basic-shape": {
    	syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
    },
    	"bg-image": {
    	syntax: "none | <image>"
    },
    	"bg-layer": {
    	syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
    },
    	"bg-position": {
    	syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
    },
    	"bg-size": {
    	syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
    },
    	"blur()": {
    	syntax: "blur( <length> )"
    },
    	"blend-mode": {
    	syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
    },
    	box: box,
    	"brightness()": {
    	syntax: "brightness( <number-percentage> )"
    },
    	"calc()": {
    	syntax: "calc( <calc-sum> )"
    },
    	"calc-sum": {
    	syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
    },
    	"calc-product": {
    	syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
    },
    	"calc-value": {
    	syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
    },
    	"cf-final-image": {
    	syntax: "<image> | <color>"
    },
    	"cf-mixing-image": {
    	syntax: "<percentage>? && <image>"
    },
    	"circle()": {
    	syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
    },
    	"clamp()": {
    	syntax: "clamp( <calc-sum>#{3} )"
    },
    	"class-selector": {
    	syntax: "'.' <ident-token>"
    },
    	"clip-source": {
    	syntax: "<url>"
    },
    	color: color,
    	"color-stop": {
    	syntax: "<color-stop-length> | <color-stop-angle>"
    },
    	"color-stop-angle": {
    	syntax: "<angle-percentage>{1,2}"
    },
    	"color-stop-length": {
    	syntax: "<length-percentage>{1,2}"
    },
    	"color-stop-list": {
    	syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
    },
    	combinator: combinator,
    	"common-lig-values": {
    	syntax: "[ common-ligatures | no-common-ligatures ]"
    },
    	"compat-auto": {
    	syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
    },
    	"composite-style": {
    	syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
    },
    	"compositing-operator": {
    	syntax: "add | subtract | intersect | exclude"
    },
    	"compound-selector": {
    	syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
    },
    	"compound-selector-list": {
    	syntax: "<compound-selector>#"
    },
    	"complex-selector": {
    	syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
    },
    	"complex-selector-list": {
    	syntax: "<complex-selector>#"
    },
    	"conic-gradient()": {
    	syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
    },
    	"contextual-alt-values": {
    	syntax: "[ contextual | no-contextual ]"
    },
    	"content-distribution": {
    	syntax: "space-between | space-around | space-evenly | stretch"
    },
    	"content-list": {
    	syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
    },
    	"content-position": {
    	syntax: "center | start | end | flex-start | flex-end"
    },
    	"content-replacement": {
    	syntax: "<image>"
    },
    	"contrast()": {
    	syntax: "contrast( [ <number-percentage> ] )"
    },
    	"counter()": {
    	syntax: "counter( <custom-ident>, <counter-style>? )"
    },
    	"counter-style": {
    	syntax: "<counter-style-name> | symbols()"
    },
    	"counter-style-name": {
    	syntax: "<custom-ident>"
    },
    	"counters()": {
    	syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
    },
    	"cross-fade()": {
    	syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
    },
    	"cubic-bezier-timing-function": {
    	syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
    },
    	"deprecated-system-color": {
    	syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
    },
    	"discretionary-lig-values": {
    	syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
    },
    	"display-box": {
    	syntax: "contents | none"
    },
    	"display-inside": {
    	syntax: "flow | flow-root | table | flex | grid | ruby"
    },
    	"display-internal": {
    	syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
    },
    	"display-legacy": {
    	syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
    },
    	"display-listitem": {
    	syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
    },
    	"display-outside": {
    	syntax: "block | inline | run-in"
    },
    	"drop-shadow()": {
    	syntax: "drop-shadow( <length>{2,3} <color>? )"
    },
    	"east-asian-variant-values": {
    	syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
    },
    	"east-asian-width-values": {
    	syntax: "[ full-width | proportional-width ]"
    },
    	"element()": {
    	syntax: "element( <id-selector> )"
    },
    	"ellipse()": {
    	syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
    },
    	"ending-shape": {
    	syntax: "circle | ellipse"
    },
    	"env()": {
    	syntax: "env( <custom-ident> , <declaration-value>? )"
    },
    	"explicit-track-list": {
    	syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
    },
    	"family-name": {
    	syntax: "<string> | <custom-ident>+"
    },
    	"feature-tag-value": {
    	syntax: "<string> [ <integer> | on | off ]?"
    },
    	"feature-type": {
    	syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
    },
    	"feature-value-block": {
    	syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
    },
    	"feature-value-block-list": {
    	syntax: "<feature-value-block>+"
    },
    	"feature-value-declaration": {
    	syntax: "<custom-ident>: <integer>+;"
    },
    	"feature-value-declaration-list": {
    	syntax: "<feature-value-declaration>"
    },
    	"feature-value-name": {
    	syntax: "<custom-ident>"
    },
    	"fill-rule": {
    	syntax: "nonzero | evenodd"
    },
    	"filter-function": {
    	syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
    },
    	"filter-function-list": {
    	syntax: "[ <filter-function> | <url> ]+"
    },
    	"final-bg-layer": {
    	syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
    },
    	"fit-content()": {
    	syntax: "fit-content( [ <length> | <percentage> ] )"
    },
    	"fixed-breadth": {
    	syntax: "<length-percentage>"
    },
    	"fixed-repeat": {
    	syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
    },
    	"fixed-size": {
    	syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
    },
    	"font-stretch-absolute": {
    	syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
    },
    	"font-variant-css21": {
    	syntax: "[ normal | small-caps ]"
    },
    	"font-weight-absolute": {
    	syntax: "normal | bold | <number [1,1000]>"
    },
    	"frequency-percentage": {
    	syntax: "<frequency> | <percentage>"
    },
    	"general-enclosed": {
    	syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
    },
    	"generic-family": {
    	syntax: "serif | sans-serif | cursive | fantasy | monospace"
    },
    	"generic-name": {
    	syntax: "serif | sans-serif | cursive | fantasy | monospace"
    },
    	"geometry-box": {
    	syntax: "<shape-box> | fill-box | stroke-box | view-box"
    },
    	gradient: gradient,
    	"grayscale()": {
    	syntax: "grayscale( <number-percentage> )"
    },
    	"grid-line": {
    	syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
    },
    	"historical-lig-values": {
    	syntax: "[ historical-ligatures | no-historical-ligatures ]"
    },
    	"hsl()": {
    	syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
    },
    	"hsla()": {
    	syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
    },
    	hue: hue,
    	"hue-rotate()": {
    	syntax: "hue-rotate( <angle> )"
    },
    	"id-selector": {
    	syntax: "<hash-token>"
    },
    	image: image,
    	"image()": {
    	syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
    },
    	"image-set()": {
    	syntax: "image-set( <image-set-option># )"
    },
    	"image-set-option": {
    	syntax: "[ <image> | <string> ] <resolution>"
    },
    	"image-src": {
    	syntax: "<url> | <string>"
    },
    	"image-tags": {
    	syntax: "ltr | rtl"
    },
    	"inflexible-breadth": {
    	syntax: "<length> | <percentage> | min-content | max-content | auto"
    },
    	"inset()": {
    	syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
    },
    	"invert()": {
    	syntax: "invert( <number-percentage> )"
    },
    	"keyframes-name": {
    	syntax: "<custom-ident> | <string>"
    },
    	"keyframe-block": {
    	syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
    },
    	"keyframe-block-list": {
    	syntax: "<keyframe-block>+"
    },
    	"keyframe-selector": {
    	syntax: "from | to | <percentage>"
    },
    	"leader()": {
    	syntax: "leader( <leader-type> )"
    },
    	"leader-type": {
    	syntax: "dotted | solid | space | <string>"
    },
    	"length-percentage": {
    	syntax: "<length> | <percentage>"
    },
    	"line-names": {
    	syntax: "'[' <custom-ident>* ']'"
    },
    	"line-name-list": {
    	syntax: "[ <line-names> | <name-repeat> ]+"
    },
    	"line-style": {
    	syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
    },
    	"line-width": {
    	syntax: "<length> | thin | medium | thick"
    },
    	"linear-color-hint": {
    	syntax: "<length-percentage>"
    },
    	"linear-color-stop": {
    	syntax: "<color> <color-stop-length>?"
    },
    	"linear-gradient()": {
    	syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
    },
    	"mask-layer": {
    	syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
    },
    	"mask-position": {
    	syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
    },
    	"mask-reference": {
    	syntax: "none | <image> | <mask-source>"
    },
    	"mask-source": {
    	syntax: "<url>"
    },
    	"masking-mode": {
    	syntax: "alpha | luminance | match-source"
    },
    	"matrix()": {
    	syntax: "matrix( <number>#{6} )"
    },
    	"matrix3d()": {
    	syntax: "matrix3d( <number>#{16} )"
    },
    	"max()": {
    	syntax: "max( <calc-sum># )"
    },
    	"media-and": {
    	syntax: "<media-in-parens> [ and <media-in-parens> ]+"
    },
    	"media-condition": {
    	syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
    },
    	"media-condition-without-or": {
    	syntax: "<media-not> | <media-and> | <media-in-parens>"
    },
    	"media-feature": {
    	syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
    },
    	"media-in-parens": {
    	syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
    },
    	"media-not": {
    	syntax: "not <media-in-parens>"
    },
    	"media-or": {
    	syntax: "<media-in-parens> [ or <media-in-parens> ]+"
    },
    	"media-query": {
    	syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
    },
    	"media-query-list": {
    	syntax: "<media-query>#"
    },
    	"media-type": {
    	syntax: "<ident>"
    },
    	"mf-boolean": {
    	syntax: "<mf-name>"
    },
    	"mf-name": {
    	syntax: "<ident>"
    },
    	"mf-plain": {
    	syntax: "<mf-name> : <mf-value>"
    },
    	"mf-range": {
    	syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
    },
    	"mf-value": {
    	syntax: "<number> | <dimension> | <ident> | <ratio>"
    },
    	"min()": {
    	syntax: "min( <calc-sum># )"
    },
    	"minmax()": {
    	syntax: "minmax( [ <length> | <percentage> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
    },
    	"named-color": {
    	syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
    },
    	"namespace-prefix": {
    	syntax: "<ident>"
    },
    	"ns-prefix": {
    	syntax: "[ <ident-token> | '*' ]? '|'"
    },
    	"number-percentage": {
    	syntax: "<number> | <percentage>"
    },
    	"numeric-figure-values": {
    	syntax: "[ lining-nums | oldstyle-nums ]"
    },
    	"numeric-fraction-values": {
    	syntax: "[ diagonal-fractions | stacked-fractions ]"
    },
    	"numeric-spacing-values": {
    	syntax: "[ proportional-nums | tabular-nums ]"
    },
    	nth: nth$1,
    	"opacity()": {
    	syntax: "opacity( [ <number-percentage> ] )"
    },
    	"overflow-position": {
    	syntax: "unsafe | safe"
    },
    	"outline-radius": {
    	syntax: "<length> | <percentage>"
    },
    	"page-body": {
    	syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
    },
    	"page-margin-box": {
    	syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
    },
    	"page-margin-box-type": {
    	syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
    },
    	"page-selector-list": {
    	syntax: "[ <page-selector># ]?"
    },
    	"page-selector": {
    	syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
    },
    	"path()": {
    	syntax: "path( [ <fill-rule>, ]? <string> )"
    },
    	"paint()": {
    	syntax: "paint( <ident>, <declaration-value>? )"
    },
    	"perspective()": {
    	syntax: "perspective( <length> )"
    },
    	"polygon()": {
    	syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
    },
    	position: position,
    	"pseudo-class-selector": {
    	syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
    },
    	"pseudo-element-selector": {
    	syntax: "':' <pseudo-class-selector>"
    },
    	"pseudo-page": {
    	syntax: ": [ left | right | first | blank ]"
    },
    	quote: quote,
    	"radial-gradient()": {
    	syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
    },
    	"relative-selector": {
    	syntax: "<combinator>? <complex-selector>"
    },
    	"relative-selector-list": {
    	syntax: "<relative-selector>#"
    },
    	"relative-size": {
    	syntax: "larger | smaller"
    },
    	"repeat-style": {
    	syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
    },
    	"repeating-linear-gradient()": {
    	syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
    },
    	"repeating-radial-gradient()": {
    	syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
    },
    	"rgb()": {
    	syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
    },
    	"rgba()": {
    	syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
    },
    	"rotate()": {
    	syntax: "rotate( [ <angle> | <zero> ] )"
    },
    	"rotate3d()": {
    	syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
    },
    	"rotateX()": {
    	syntax: "rotateX( [ <angle> | <zero> ] )"
    },
    	"rotateY()": {
    	syntax: "rotateY( [ <angle> | <zero> ] )"
    },
    	"rotateZ()": {
    	syntax: "rotateZ( [ <angle> | <zero> ] )"
    },
    	"saturate()": {
    	syntax: "saturate( <number-percentage> )"
    },
    	"scale()": {
    	syntax: "scale( <number> , <number>? )"
    },
    	"scale3d()": {
    	syntax: "scale3d( <number> , <number> , <number> )"
    },
    	"scaleX()": {
    	syntax: "scaleX( <number> )"
    },
    	"scaleY()": {
    	syntax: "scaleY( <number> )"
    },
    	"scaleZ()": {
    	syntax: "scaleZ( <number> )"
    },
    	"self-position": {
    	syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
    },
    	"shape-radius": {
    	syntax: "<length-percentage> | closest-side | farthest-side"
    },
    	"skew()": {
    	syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
    },
    	"skewX()": {
    	syntax: "skewX( [ <angle> | <zero> ] )"
    },
    	"skewY()": {
    	syntax: "skewY( [ <angle> | <zero> ] )"
    },
    	"sepia()": {
    	syntax: "sepia( <number-percentage> )"
    },
    	shadow: shadow,
    	"shadow-t": {
    	syntax: "[ <length>{2,3} && <color>? ]"
    },
    	shape: shape,
    	"shape-box": {
    	syntax: "<box> | margin-box"
    },
    	"side-or-corner": {
    	syntax: "[ left | right ] || [ top | bottom ]"
    },
    	"single-animation": {
    	syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
    },
    	"single-animation-direction": {
    	syntax: "normal | reverse | alternate | alternate-reverse"
    },
    	"single-animation-fill-mode": {
    	syntax: "none | forwards | backwards | both"
    },
    	"single-animation-iteration-count": {
    	syntax: "infinite | <number>"
    },
    	"single-animation-play-state": {
    	syntax: "running | paused"
    },
    	"single-transition": {
    	syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
    },
    	"single-transition-property": {
    	syntax: "all | <custom-ident>"
    },
    	size: size,
    	"step-position": {
    	syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
    },
    	"step-timing-function": {
    	syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
    },
    	"subclass-selector": {
    	syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
    },
    	"supports-condition": {
    	syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
    },
    	"supports-in-parens": {
    	syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
    },
    	"supports-feature": {
    	syntax: "<supports-decl> | <supports-selector-fn>"
    },
    	"supports-decl": {
    	syntax: "( <declaration> )"
    },
    	"supports-selector-fn": {
    	syntax: "selector( <complex-selector> )"
    },
    	symbol: symbol,
    	target: target,
    	"target-counter()": {
    	syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
    },
    	"target-counters()": {
    	syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
    },
    	"target-text()": {
    	syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
    },
    	"time-percentage": {
    	syntax: "<time> | <percentage>"
    },
    	"timing-function": {
    	syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
    },
    	"track-breadth": {
    	syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
    },
    	"track-list": {
    	syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
    },
    	"track-repeat": {
    	syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
    },
    	"track-size": {
    	syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
    },
    	"transform-function": {
    	syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
    },
    	"transform-list": {
    	syntax: "<transform-function>+"
    },
    	"translate()": {
    	syntax: "translate( <length-percentage> , <length-percentage>? )"
    },
    	"translate3d()": {
    	syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
    },
    	"translateX()": {
    	syntax: "translateX( <length-percentage> )"
    },
    	"translateY()": {
    	syntax: "translateY( <length-percentage> )"
    },
    	"translateZ()": {
    	syntax: "translateZ( <length> )"
    },
    	"type-or-unit": {
    	syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
    },
    	"type-selector": {
    	syntax: "<wq-name> | <ns-prefix>? '*'"
    },
    	"var()": {
    	syntax: "var( <custom-property-name> , <declaration-value>? )"
    },
    	"viewport-length": {
    	syntax: "auto | <length-percentage>"
    },
    	"wq-name": {
    	syntax: "<ns-prefix>? <ident-token>"
    }
    };

    var atrules = {
    	charset: {
    		prelude: "<string>"
    	},
    	"font-face": {
    		descriptors: {
    			"unicode-range": {
    				comment: "replaces <unicode-range>, an old production name",
    				syntax: "<urange>#"
    			}
    		}
    	}
    };
    var properties = {
    	"-moz-background-clip": {
    		comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
    		syntax: "padding | border"
    	},
    	"-moz-border-radius-bottomleft": {
    		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
    		syntax: "<'border-bottom-left-radius'>"
    	},
    	"-moz-border-radius-bottomright": {
    		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
    		syntax: "<'border-bottom-right-radius'>"
    	},
    	"-moz-border-radius-topleft": {
    		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
    		syntax: "<'border-top-left-radius'>"
    	},
    	"-moz-border-radius-topright": {
    		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
    		syntax: "<'border-bottom-right-radius'>"
    	},
    	"-moz-control-character-visibility": {
    		comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
    		syntax: "visible | hidden"
    	},
    	"-moz-osx-font-smoothing": {
    		comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
    		syntax: "auto | grayscale"
    	},
    	"-moz-user-select": {
    		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
    		syntax: "none | text | all | -moz-none"
    	},
    	"-ms-flex-align": {
    		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
    		syntax: "start | end | center | baseline | stretch"
    	},
    	"-ms-flex-item-align": {
    		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
    		syntax: "auto | start | end | center | baseline | stretch"
    	},
    	"-ms-flex-line-pack": {
    		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
    		syntax: "start | end | center | justify | distribute | stretch"
    	},
    	"-ms-flex-negative": {
    		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
    		syntax: "<'flex-shrink'>"
    	},
    	"-ms-flex-pack": {
    		comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
    		syntax: "start | end | center | justify | distribute"
    	},
    	"-ms-flex-order": {
    		comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
    		syntax: "<integer>"
    	},
    	"-ms-flex-positive": {
    		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
    		syntax: "<'flex-grow'>"
    	},
    	"-ms-flex-preferred-size": {
    		comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
    		syntax: "<'flex-basis'>"
    	},
    	"-ms-interpolation-mode": {
    		comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
    		syntax: "nearest-neighbor | bicubic"
    	},
    	"-ms-grid-column-align": {
    		comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
    		syntax: "start | end | center | stretch"
    	},
    	"-ms-grid-row-align": {
    		comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
    		syntax: "start | end | center | stretch"
    	},
    	"-ms-hyphenate-limit-last": {
    		comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
    		syntax: "none | always | column | page | spread"
    	},
    	"-webkit-appearance": {
    		comment: "webkit specific keywords",
    		references: [
    			"http://css-infos.net/property/-webkit-appearance"
    		],
    		syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"
    	},
    	"-webkit-background-clip": {
    		comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
    		syntax: "[ <box> | border | padding | content | text ]#"
    	},
    	"-webkit-column-break-after": {
    		comment: "added, http://help.dottoro.com/lcrthhhv.php",
    		syntax: "always | auto | avoid"
    	},
    	"-webkit-column-break-before": {
    		comment: "added, http://help.dottoro.com/lcxquvkf.php",
    		syntax: "always | auto | avoid"
    	},
    	"-webkit-column-break-inside": {
    		comment: "added, http://help.dottoro.com/lclhnthl.php",
    		syntax: "always | auto | avoid"
    	},
    	"-webkit-font-smoothing": {
    		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
    		syntax: "auto | none | antialiased | subpixel-antialiased"
    	},
    	"-webkit-mask-box-image": {
    		comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
    		syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
    	},
    	"-webkit-print-color-adjust": {
    		comment: "missed",
    		references: [
    			"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
    		],
    		syntax: "economy | exact"
    	},
    	"-webkit-text-security": {
    		comment: "missed; http://help.dottoro.com/lcbkewgt.php",
    		syntax: "none | circle | disc | square"
    	},
    	"-webkit-user-drag": {
    		comment: "missed; http://help.dottoro.com/lcbixvwm.php",
    		syntax: "none | element | auto"
    	},
    	"-webkit-user-select": {
    		comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
    		syntax: "auto | none | text | all"
    	},
    	"alignment-baseline": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
    		],
    		syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
    	},
    	"baseline-shift": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
    		],
    		syntax: "baseline | sub | super | <svg-length>"
    	},
    	behavior: {
    		comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
    		syntax: "<url>+"
    	},
    	"clip-rule": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
    		],
    		syntax: "nonzero | evenodd"
    	},
    	cue: {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "<'cue-before'> <'cue-after'>?"
    	},
    	"cue-after": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "<url> <decibel>? | none"
    	},
    	"cue-before": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "<url> <decibel>? | none"
    	},
    	cursor: {
    		comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
    		references: [
    			"https://www.sitepoint.com/css3-cursor-styles/"
    		],
    		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
    	},
    	display: {
    		comment: "extended with -ms-flexbox",
    		syntax: "| <-non-standard-display>"
    	},
    	position: {
    		comment: "extended with -webkit-sticky",
    		syntax: "| -webkit-sticky"
    	},
    	"dominant-baseline": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
    		],
    		syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
    	},
    	"image-rendering": {
    		comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
    		references: [
    			"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
    			"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
    		],
    		syntax: "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
    	},
    	fill: {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
    		],
    		syntax: "<paint>"
    	},
    	"fill-opacity": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
    		],
    		syntax: "<number-zero-one>"
    	},
    	"fill-rule": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#FillProperty"
    		],
    		syntax: "nonzero | evenodd"
    	},
    	filter: {
    		comment: "extend with IE legacy syntaxes",
    		syntax: "| <-ms-filter-function-list>"
    	},
    	"glyph-orientation-horizontal": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
    		],
    		syntax: "<angle>"
    	},
    	"glyph-orientation-vertical": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
    		],
    		syntax: "<angle>"
    	},
    	kerning: {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/text.html#KerningProperty"
    		],
    		syntax: "auto | <svg-length>"
    	},
    	"letter-spacing": {
    		comment: "fix syntax <length> -> <length-percentage>",
    		references: [
    			"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
    		],
    		syntax: "normal | <length-percentage>"
    	},
    	marker: {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
    		],
    		syntax: "none | <url>"
    	},
    	"marker-end": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
    		],
    		syntax: "none | <url>"
    	},
    	"marker-mid": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
    		],
    		syntax: "none | <url>"
    	},
    	"marker-start": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
    		],
    		syntax: "none | <url>"
    	},
    	"max-width": {
    		comment: "fix auto -> none (https://github.com/mdn/data/pull/431); extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
    		syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"
    	},
    	width: {
    		comment: "per spec fit-content should be a function, however browsers are supporting it as a keyword (https://github.com/csstree/stylelint-validator/issues/29)",
    		syntax: "| fit-content | -moz-fit-content | -webkit-fit-content"
    	},
    	"min-width": {
    		comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
    		syntax: "auto | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"
    	},
    	overflow: {
    		comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
    		syntax: "| <-non-standard-overflow>"
    	},
    	pause: {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "<'pause-before'> <'pause-after'>?"
    	},
    	"pause-after": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
    	},
    	"pause-before": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
    	},
    	rest: {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "<'rest-before'> <'rest-after'>?"
    	},
    	"rest-after": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
    	},
    	"rest-before": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
    	},
    	"shape-rendering": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
    		],
    		syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
    	},
    	src: {
    		comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
    		syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
    	},
    	speak: {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "auto | none | normal"
    	},
    	"speak-as": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
    	},
    	stroke: {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
    		],
    		syntax: "<paint>"
    	},
    	"stroke-dasharray": {
    		comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
    		],
    		syntax: "none | [ <svg-length>+ ]#"
    	},
    	"stroke-dashoffset": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
    		],
    		syntax: "<svg-length>"
    	},
    	"stroke-linecap": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
    		],
    		syntax: "butt | round | square"
    	},
    	"stroke-linejoin": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
    		],
    		syntax: "miter | round | bevel"
    	},
    	"stroke-miterlimit": {
    		comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
    		],
    		syntax: "<number-one-or-greater>"
    	},
    	"stroke-opacity": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
    		],
    		syntax: "<number-zero-one>"
    	},
    	"stroke-width": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
    		],
    		syntax: "<svg-length>"
    	},
    	"text-anchor": {
    		comment: "added SVG property",
    		references: [
    			"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
    		],
    		syntax: "start | middle | end"
    	},
    	"unicode-bidi": {
    		comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
    		syntax: "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"
    	},
    	"unicode-range": {
    		comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
    		syntax: "<urange>#"
    	},
    	"voice-balance": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "<number> | left | center | right | leftwards | rightwards"
    	},
    	"voice-duration": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "auto | <time>"
    	},
    	"voice-family": {
    		comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
    	},
    	"voice-pitch": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
    	},
    	"voice-range": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
    	},
    	"voice-rate": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
    	},
    	"voice-stress": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "normal | strong | moderate | none | reduced"
    	},
    	"voice-volume": {
    		comment: "https://www.w3.org/TR/css3-speech/#property-index",
    		syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
    	},
    	"writing-mode": {
    		comment: "extend with SVG keywords",
    		syntax: "| <svg-writing-mode>"
    	}
    };
    var syntaxes = {
    	"-legacy-gradient": {
    		comment: "added collection of legacy gradient syntaxes",
    		syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
    	},
    	"-legacy-linear-gradient": {
    		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
    		syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
    	},
    	"-legacy-repeating-linear-gradient": {
    		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
    		syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
    	},
    	"-legacy-linear-gradient-arguments": {
    		comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
    		syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
    	},
    	"-legacy-radial-gradient": {
    		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
    		syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
    	},
    	"-legacy-repeating-radial-gradient": {
    		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
    		syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
    	},
    	"-legacy-radial-gradient-arguments": {
    		comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
    		syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
    	},
    	"-legacy-radial-gradient-size": {
    		comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
    		syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
    	},
    	"-legacy-radial-gradient-shape": {
    		comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
    		syntax: "circle | ellipse"
    	},
    	"-non-standard-font": {
    		comment: "non standard fonts",
    		references: [
    			"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
    		],
    		syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
    	},
    	"-non-standard-color": {
    		comment: "non standard colors",
    		references: [
    			"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
    			"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
    		],
    		syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
    	},
    	"-non-standard-image-rendering": {
    		comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
    		syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
    	},
    	"-non-standard-overflow": {
    		comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
    		syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
    	},
    	"-non-standard-width": {
    		comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
    		syntax: "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
    	},
    	"-webkit-gradient()": {
    		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
    		syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
    	},
    	"-webkit-gradient-color-stop": {
    		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
    		syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
    	},
    	"-webkit-gradient-point": {
    		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
    		syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
    	},
    	"-webkit-gradient-radius": {
    		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
    		syntax: "<length> | <percentage>"
    	},
    	"-webkit-gradient-type": {
    		comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
    		syntax: "linear | radial"
    	},
    	"-webkit-mask-box-repeat": {
    		comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
    		syntax: "repeat | stretch | round"
    	},
    	"-webkit-mask-clip-style": {
    		comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
    		syntax: "border | border-box | padding | padding-box | content | content-box | text"
    	},
    	"-ms-filter-function-list": {
    		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
    		syntax: "<-ms-filter-function>+"
    	},
    	"-ms-filter-function": {
    		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
    		syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
    	},
    	"-ms-filter-function-progid": {
    		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
    		syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
    	},
    	"-ms-filter-function-legacy": {
    		comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
    		syntax: "<ident-token> | <function-token> <any-value>? )"
    	},
    	"-ms-filter": {
    		syntax: "<string>"
    	},
    	age: {
    		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
    		syntax: "child | young | old"
    	},
    	"attr-name": {
    		syntax: "<wq-name>"
    	},
    	"attr-fallback": {
    		syntax: "<any-value>"
    	},
    	"border-radius": {
    		comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
    		syntax: "<length-percentage>{1,2}"
    	},
    	bottom: {
    		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
    		syntax: "<length> | auto"
    	},
    	"content-list": {
    		comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
    		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
    	},
    	"element()": {
    		comment: "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
    		syntax: "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"
    	},
    	"generic-voice": {
    		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
    		syntax: "[ <age>? <gender> <integer>? ]"
    	},
    	gender: {
    		comment: "https://www.w3.org/TR/css3-speech/#voice-family",
    		syntax: "male | female | neutral"
    	},
    	"generic-family": {
    		comment: "added -apple-system",
    		references: [
    			"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
    		],
    		syntax: "| -apple-system"
    	},
    	gradient: {
    		comment: "added legacy syntaxes support",
    		syntax: "| <-legacy-gradient>"
    	},
    	left: {
    		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
    		syntax: "<length> | auto"
    	},
    	"mask-image": {
    		comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
    		syntax: "<mask-reference>#"
    	},
    	"name-repeat": {
    		comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
    		syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
    	},
    	"named-color": {
    		comment: "added non standard color names",
    		syntax: "| <-non-standard-color>"
    	},
    	paint: {
    		comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
    		syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
    	},
    	"page-size": {
    		comment: "https://www.w3.org/TR/css-page-3/#typedef-page-size-page-size",
    		syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
    	},
    	ratio: {
    		comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
    		syntax: "<integer> / <integer>"
    	},
    	right: {
    		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
    		syntax: "<length> | auto"
    	},
    	shape: {
    		comment: "missed spaces in function body and add backwards compatible syntax",
    		syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
    	},
    	"svg-length": {
    		comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
    		references: [
    			"https://www.w3.org/TR/SVG11/coords.html#Units"
    		],
    		syntax: "<percentage> | <length> | <number>"
    	},
    	"svg-writing-mode": {
    		comment: "SVG specific keywords (deprecated for CSS)",
    		references: [
    			"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
    			"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
    		],
    		syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
    	},
    	top: {
    		comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
    		syntax: "<length> | auto"
    	},
    	"track-group": {
    		comment: "used by old grid-columns and grid-rows syntax v0",
    		syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
    	},
    	"track-list-v0": {
    		comment: "used by old grid-columns and grid-rows syntax v0",
    		syntax: "[ <string>* <track-group> <string>* ]+ | none"
    	},
    	"track-minmax": {
    		comment: "used by old grid-columns and grid-rows syntax v0",
    		syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
    	},
    	x: {
    		comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
    		syntax: "<number>"
    	},
    	y: {
    		comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
    		syntax: "<number>"
    	},
    	declaration: {
    		comment: "missed, restored by https://drafts.csswg.org/css-syntax",
    		syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
    	},
    	"declaration-list": {
    		comment: "missed, restored by https://drafts.csswg.org/css-syntax",
    		syntax: "[ <declaration>? ';' ]* <declaration>?"
    	},
    	url: {
    		comment: "https://drafts.csswg.org/css-values-4/#urls",
    		syntax: "url( <string> <url-modifier>* ) | <url-token>"
    	},
    	"url-modifier": {
    		comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
    		syntax: "<ident> | <function-token> <any-value> )"
    	},
    	"number-zero-one": {
    		syntax: "<number [0,1]>"
    	},
    	"number-one-or-greater": {
    		syntax: "<number [1,]>"
    	},
    	"positive-integer": {
    		syntax: "<integer [0,]>"
    	},
    	"-non-standard-display": {
    		syntax: "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
    	}
    };
    var require$$3 = {
    	atrules: atrules,
    	properties: properties,
    	syntaxes: syntaxes
    };

    var data;
    var hasRequiredData;

    function requireData () {
    	if (hasRequiredData) return data;
    	hasRequiredData = 1;
    	const mdnAtrules = require$$0;
    	const mdnProperties = require$$1;
    	const mdnSyntaxes = require$$2;
    	const patch = require$$3;
    	const extendSyntax = /^\s*\|\s*/;

    	function preprocessAtrules(dict) {
    	    const result = Object.create(null);

    	    for (const atruleName in dict) {
    	        const atrule = dict[atruleName];
    	        let descriptors = null;

    	        if (atrule.descriptors) {
    	            descriptors = Object.create(null);

    	            for (const descriptor in atrule.descriptors) {
    	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
    	            }
    	        }

    	        result[atruleName.substr(1)] = {
    	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
    	            descriptors
    	        };
    	    }

    	    return result;
    	}

    	function patchDictionary(dict, patchDict) {
    	    const result = {};

    	    // copy all syntaxes for an original dict
    	    for (const key in dict) {
    	        result[key] = dict[key].syntax || dict[key];
    	    }

    	    // apply a patch
    	    for (const key in patchDict) {
    	        if (key in dict) {
    	            if (patchDict[key].syntax) {
    	                result[key] = extendSyntax.test(patchDict[key].syntax)
    	                    ? result[key] + ' ' + patchDict[key].syntax.trim()
    	                    : patchDict[key].syntax;
    	            } else {
    	                delete result[key];
    	            }
    	        } else {
    	            if (patchDict[key].syntax) {
    	                result[key] = patchDict[key].syntax.replace(extendSyntax, '');
    	            }
    	        }
    	    }

    	    return result;
    	}

    	function unpackSyntaxes(dict) {
    	    const result = {};

    	    for (const key in dict) {
    	        result[key] = dict[key].syntax;
    	    }

    	    return result;
    	}

    	function patchAtrules(dict, patchDict) {
    	    const result = {};

    	    // copy all syntaxes for an original dict
    	    for (const key in dict) {
    	        const patchDescriptors = (patchDict[key] && patchDict[key].descriptors) || null;

    	        result[key] = {
    	            prelude: key in patchDict && 'prelude' in patchDict[key]
    	                ? patchDict[key].prelude
    	                : dict[key].prelude || null,
    	            descriptors: dict[key].descriptors
    	                ? patchDictionary(dict[key].descriptors, patchDescriptors || {})
    	                : patchDescriptors && unpackSyntaxes(patchDescriptors)
    	        };
    	    }

    	    // apply a patch
    	    for (const key in patchDict) {
    	        if (!hasOwnProperty.call(dict, key)) {
    	            result[key] = {
    	                prelude: patchDict[key].prelude || null,
    	                descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)
    	            };
    	        }
    	    }

    	    return result;
    	}

    	data = {
    	    types: patchDictionary(mdnSyntaxes, patch.syntaxes),
    	    atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),
    	    properties: patchDictionary(mdnProperties, patch.properties)
    	};
    	return data;
    }

    var AnPlusB;
    var hasRequiredAnPlusB;

    function requireAnPlusB () {
    	if (hasRequiredAnPlusB) return AnPlusB;
    	hasRequiredAnPlusB = 1;
    	var cmpChar = requireTokenizer$1().cmpChar;
    	var isDigit = requireTokenizer$1().isDigit;
    	var TYPE = requireTokenizer$1().TYPE;

    	var WHITESPACE = TYPE.WhiteSpace;
    	var COMMENT = TYPE.Comment;
    	var IDENT = TYPE.Ident;
    	var NUMBER = TYPE.Number;
    	var DIMENSION = TYPE.Dimension;
    	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
    	var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
    	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
    	var DISALLOW_SIGN = true;
    	var ALLOW_SIGN = false;

    	function checkInteger(offset, disallowSign) {
    	    var pos = this.scanner.tokenStart + offset;
    	    var code = this.scanner.source.charCodeAt(pos);

    	    if (code === PLUSSIGN || code === HYPHENMINUS) {
    	        if (disallowSign) {
    	            this.error('Number sign is not allowed');
    	        }
    	        pos++;
    	    }

    	    for (; pos < this.scanner.tokenEnd; pos++) {
    	        if (!isDigit(this.scanner.source.charCodeAt(pos))) {
    	            this.error('Integer is expected', pos);
    	        }
    	    }
    	}

    	function checkTokenIsInteger(disallowSign) {
    	    return checkInteger.call(this, 0, disallowSign);
    	}

    	function expectCharCode(offset, code) {
    	    if (!cmpChar(this.scanner.source, this.scanner.tokenStart + offset, code)) {
    	        var msg = '';

    	        switch (code) {
    	            case N:
    	                msg = 'N is expected';
    	                break;
    	            case HYPHENMINUS:
    	                msg = 'HyphenMinus is expected';
    	                break;
    	        }

    	        this.error(msg, this.scanner.tokenStart + offset);
    	    }
    	}

    	// ... <signed-integer>
    	// ... ['+' | '-'] <signless-integer>
    	function consumeB() {
    	    var offset = 0;
    	    var sign = 0;
    	    var type = this.scanner.tokenType;

    	    while (type === WHITESPACE || type === COMMENT) {
    	        type = this.scanner.lookupType(++offset);
    	    }

    	    if (type !== NUMBER) {
    	        if (this.scanner.isDelim(PLUSSIGN, offset) ||
    	            this.scanner.isDelim(HYPHENMINUS, offset)) {
    	            sign = this.scanner.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;

    	            do {
    	                type = this.scanner.lookupType(++offset);
    	            } while (type === WHITESPACE || type === COMMENT);

    	            if (type !== NUMBER) {
    	                this.scanner.skip(offset);
    	                checkTokenIsInteger.call(this, DISALLOW_SIGN);
    	            }
    	        } else {
    	            return null;
    	        }
    	    }

    	    if (offset > 0) {
    	        this.scanner.skip(offset);
    	    }

    	    if (sign === 0) {
    	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
    	        if (type !== PLUSSIGN && type !== HYPHENMINUS) {
    	            this.error('Number sign is expected');
    	        }
    	    }

    	    checkTokenIsInteger.call(this, sign !== 0);
    	    return sign === HYPHENMINUS ? '-' + this.consume(NUMBER) : this.consume(NUMBER);
    	}

    	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
    	AnPlusB = {
    	    name: 'AnPlusB',
    	    structure: {
    	        a: [String, null],
    	        b: [String, null]
    	    },
    	    parse: function() {
    	        /* eslint-disable brace-style*/
    	        var start = this.scanner.tokenStart;
    	        var a = null;
    	        var b = null;

    	        // <integer>
    	        if (this.scanner.tokenType === NUMBER) {
    	            checkTokenIsInteger.call(this, ALLOW_SIGN);
    	            b = this.consume(NUMBER);
    	        }

    	        // -n
    	        // -n <signed-integer>
    	        // -n ['+' | '-'] <signless-integer>
    	        // -n- <signless-integer>
    	        // <dashndashdigit-ident>
    	        else if (this.scanner.tokenType === IDENT && cmpChar(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS)) {
    	            a = '-1';

    	            expectCharCode.call(this, 1, N);

    	            switch (this.scanner.getTokenLength()) {
    	                // -n
    	                // -n <signed-integer>
    	                // -n ['+' | '-'] <signless-integer>
    	                case 2:
    	                    this.scanner.next();
    	                    b = consumeB.call(this);
    	                    break;

    	                // -n- <signless-integer>
    	                case 3:
    	                    expectCharCode.call(this, 2, HYPHENMINUS);

    	                    this.scanner.next();
    	                    this.scanner.skipSC();

    	                    checkTokenIsInteger.call(this, DISALLOW_SIGN);

    	                    b = '-' + this.consume(NUMBER);
    	                    break;

    	                // <dashndashdigit-ident>
    	                default:
    	                    expectCharCode.call(this, 2, HYPHENMINUS);
    	                    checkInteger.call(this, 3, DISALLOW_SIGN);
    	                    this.scanner.next();

    	                    b = this.scanner.substrToCursor(start + 2);
    	            }
    	        }

    	        // '+'? n
    	        // '+'? n <signed-integer>
    	        // '+'? n ['+' | '-'] <signless-integer>
    	        // '+'? n- <signless-integer>
    	        // '+'? <ndashdigit-ident>
    	        else if (this.scanner.tokenType === IDENT || (this.scanner.isDelim(PLUSSIGN) && this.scanner.lookupType(1) === IDENT)) {
    	            var sign = 0;
    	            a = '1';

    	            // just ignore a plus
    	            if (this.scanner.isDelim(PLUSSIGN)) {
    	                sign = 1;
    	                this.scanner.next();
    	            }

    	            expectCharCode.call(this, 0, N);

    	            switch (this.scanner.getTokenLength()) {
    	                // '+'? n
    	                // '+'? n <signed-integer>
    	                // '+'? n ['+' | '-'] <signless-integer>
    	                case 1:
    	                    this.scanner.next();
    	                    b = consumeB.call(this);
    	                    break;

    	                // '+'? n- <signless-integer>
    	                case 2:
    	                    expectCharCode.call(this, 1, HYPHENMINUS);

    	                    this.scanner.next();
    	                    this.scanner.skipSC();

    	                    checkTokenIsInteger.call(this, DISALLOW_SIGN);

    	                    b = '-' + this.consume(NUMBER);
    	                    break;

    	                // '+'? <ndashdigit-ident>
    	                default:
    	                    expectCharCode.call(this, 1, HYPHENMINUS);
    	                    checkInteger.call(this, 2, DISALLOW_SIGN);
    	                    this.scanner.next();

    	                    b = this.scanner.substrToCursor(start + sign + 1);
    	            }
    	        }

    	        // <ndashdigit-dimension>
    	        // <ndash-dimension> <signless-integer>
    	        // <n-dimension>
    	        // <n-dimension> <signed-integer>
    	        // <n-dimension> ['+' | '-'] <signless-integer>
    	        else if (this.scanner.tokenType === DIMENSION) {
    	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
    	            var sign = code === PLUSSIGN || code === HYPHENMINUS;

    	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
    	                if (!isDigit(this.scanner.source.charCodeAt(i))) {
    	                    break;
    	                }
    	            }

    	            if (i === this.scanner.tokenStart + sign) {
    	                this.error('Integer is expected', this.scanner.tokenStart + sign);
    	            }

    	            expectCharCode.call(this, i - this.scanner.tokenStart, N);
    	            a = this.scanner.source.substring(start, i);

    	            // <n-dimension>
    	            // <n-dimension> <signed-integer>
    	            // <n-dimension> ['+' | '-'] <signless-integer>
    	            if (i + 1 === this.scanner.tokenEnd) {
    	                this.scanner.next();
    	                b = consumeB.call(this);
    	            } else {
    	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS);

    	                // <ndash-dimension> <signless-integer>
    	                if (i + 2 === this.scanner.tokenEnd) {
    	                    this.scanner.next();
    	                    this.scanner.skipSC();
    	                    checkTokenIsInteger.call(this, DISALLOW_SIGN);
    	                    b = '-' + this.consume(NUMBER);
    	                }
    	                // <ndashdigit-dimension>
    	                else {
    	                    checkInteger.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN);
    	                    this.scanner.next();
    	                    b = this.scanner.substrToCursor(i + 1);
    	                }
    	            }
    	        } else {
    	            this.error();
    	        }

    	        if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
    	            a = a.substr(1);
    	        }

    	        if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
    	            b = b.substr(1);
    	        }

    	        return {
    	            type: 'AnPlusB',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            a: a,
    	            b: b
    	        };
    	    },
    	    generate: function(node) {
    	        var a = node.a !== null && node.a !== undefined;
    	        var b = node.b !== null && node.b !== undefined;

    	        if (a) {
    	            this.chunk(
    	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
    	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
    	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
    	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
    	            );

    	            if (b) {
    	                b = String(node.b);
    	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
    	                    this.chunk(b.charAt(0));
    	                    this.chunk(b.substr(1));
    	                } else {
    	                    this.chunk('+');
    	                    this.chunk(b);
    	                }
    	            }
    	        } else {
    	            this.chunk(String(node.b));
    	        }
    	    }
    	};
    	return AnPlusB;
    }

    var Raw;
    var hasRequiredRaw;

    function requireRaw () {
    	if (hasRequiredRaw) return Raw;
    	hasRequiredRaw = 1;
    	var tokenizer = requireTokenizer$1();
    	var TYPE = tokenizer.TYPE;

    	var WhiteSpace = TYPE.WhiteSpace;
    	var Semicolon = TYPE.Semicolon;
    	var LeftCurlyBracket = TYPE.LeftCurlyBracket;
    	var Delim = TYPE.Delim;
    	var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

    	function getOffsetExcludeWS() {
    	    if (this.scanner.tokenIndex > 0) {
    	        if (this.scanner.lookupType(-1) === WhiteSpace) {
    	            return this.scanner.tokenIndex > 1
    	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
    	                : this.scanner.firstCharOffset;
    	        }
    	    }

    	    return this.scanner.tokenStart;
    	}

    	// 0, 0, false
    	function balanceEnd() {
    	    return 0;
    	}

    	// LEFTCURLYBRACKET, 0, false
    	function leftCurlyBracket(tokenType) {
    	    return tokenType === LeftCurlyBracket ? 1 : 0;
    	}

    	// LEFTCURLYBRACKET, SEMICOLON, false
    	function leftCurlyBracketOrSemicolon(tokenType) {
    	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
    	}

    	// EXCLAMATIONMARK, SEMICOLON, false
    	function exclamationMarkOrSemicolon(tokenType, source, offset) {
    	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK) {
    	        return 1;
    	    }

    	    return tokenType === Semicolon ? 1 : 0;
    	}

    	// 0, SEMICOLON, true
    	function semicolonIncluded(tokenType) {
    	    return tokenType === Semicolon ? 2 : 0;
    	}

    	Raw = {
    	    name: 'Raw',
    	    structure: {
    	        value: String
    	    },
    	    parse: function(startToken, mode, excludeWhiteSpace) {
    	        var startOffset = this.scanner.getTokenStart(startToken);
    	        var endOffset;

    	        this.scanner.skip(
    	            this.scanner.getRawLength(startToken, mode || balanceEnd)
    	        );

    	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
    	            endOffset = getOffsetExcludeWS.call(this);
    	        } else {
    	            endOffset = this.scanner.tokenStart;
    	        }

    	        return {
    	            type: 'Raw',
    	            loc: this.getLocation(startOffset, endOffset),
    	            value: this.scanner.source.substring(startOffset, endOffset)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.value);
    	    },

    	    mode: {
    	        default: balanceEnd,
    	        leftCurlyBracket: leftCurlyBracket,
    	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
    	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
    	        semicolonIncluded: semicolonIncluded
    	    }
    	};
    	return Raw;
    }

    var Atrule;
    var hasRequiredAtrule$1;

    function requireAtrule$1 () {
    	if (hasRequiredAtrule$1) return Atrule;
    	hasRequiredAtrule$1 = 1;
    	var TYPE = requireTokenizer$1().TYPE;
    	var rawMode = requireRaw().mode;

    	var ATKEYWORD = TYPE.AtKeyword;
    	var SEMICOLON = TYPE.Semicolon;
    	var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
    	var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

    	function consumeRaw(startToken) {
    	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
    	}

    	function isDeclarationBlockAtrule() {
    	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
    	        if (type === RIGHTCURLYBRACKET) {
    	            return true;
    	        }

    	        if (type === LEFTCURLYBRACKET ||
    	            type === ATKEYWORD) {
    	            return false;
    	        }
    	    }

    	    return false;
    	}

    	Atrule = {
    	    name: 'Atrule',
    	    structure: {
    	        name: String,
    	        prelude: ['AtrulePrelude', 'Raw', null],
    	        block: ['Block', null]
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var name;
    	        var nameLowerCase;
    	        var prelude = null;
    	        var block = null;

    	        this.eat(ATKEYWORD);

    	        name = this.scanner.substrToCursor(start + 1);
    	        nameLowerCase = name.toLowerCase();
    	        this.scanner.skipSC();

    	        // parse prelude
    	        if (this.scanner.eof === false &&
    	            this.scanner.tokenType !== LEFTCURLYBRACKET &&
    	            this.scanner.tokenType !== SEMICOLON) {
    	            if (this.parseAtrulePrelude) {
    	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

    	                // turn empty AtrulePrelude into null
    	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
    	                    prelude = null;
    	                }
    	            } else {
    	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
    	            }

    	            this.scanner.skipSC();
    	        }

    	        switch (this.scanner.tokenType) {
    	            case SEMICOLON:
    	                this.scanner.next();
    	                break;

    	            case LEFTCURLYBRACKET:
    	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
    	                    typeof this.atrule[nameLowerCase].block === 'function') {
    	                    block = this.atrule[nameLowerCase].block.call(this);
    	                } else {
    	                    // TODO: should consume block content as Raw?
    	                    block = this.Block(isDeclarationBlockAtrule.call(this));
    	                }

    	                break;
    	        }

    	        return {
    	            type: 'Atrule',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            name: name,
    	            prelude: prelude,
    	            block: block
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk('@');
    	        this.chunk(node.name);

    	        if (node.prelude !== null) {
    	            this.chunk(' ');
    	            this.node(node.prelude);
    	        }

    	        if (node.block) {
    	            this.node(node.block);
    	        } else {
    	            this.chunk(';');
    	        }
    	    },
    	    walkContext: 'atrule'
    	};
    	return Atrule;
    }

    var AtrulePrelude;
    var hasRequiredAtrulePrelude$1;

    function requireAtrulePrelude$1 () {
    	if (hasRequiredAtrulePrelude$1) return AtrulePrelude;
    	hasRequiredAtrulePrelude$1 = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var SEMICOLON = TYPE.Semicolon;
    	var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

    	AtrulePrelude = {
    	    name: 'AtrulePrelude',
    	    structure: {
    	        children: [[]]
    	    },
    	    parse: function(name) {
    	        var children = null;

    	        if (name !== null) {
    	            name = name.toLowerCase();
    	        }

    	        this.scanner.skipSC();

    	        if (this.atrule.hasOwnProperty(name) &&
    	            typeof this.atrule[name].prelude === 'function') {
    	            // custom consumer
    	            children = this.atrule[name].prelude.call(this);
    	        } else {
    	            // default consumer
    	            children = this.readSequence(this.scope.AtrulePrelude);
    	        }

    	        this.scanner.skipSC();

    	        if (this.scanner.eof !== true &&
    	            this.scanner.tokenType !== LEFTCURLYBRACKET &&
    	            this.scanner.tokenType !== SEMICOLON) {
    	            this.error('Semicolon or block is expected');
    	        }

    	        if (children === null) {
    	            children = this.createList();
    	        }

    	        return {
    	            type: 'AtrulePrelude',
    	            loc: this.getLocationFromList(children),
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.children(node);
    	    },
    	    walkContext: 'atrulePrelude'
    	};
    	return AtrulePrelude;
    }

    var AttributeSelector;
    var hasRequiredAttributeSelector;

    function requireAttributeSelector () {
    	if (hasRequiredAttributeSelector) return AttributeSelector;
    	hasRequiredAttributeSelector = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var IDENT = TYPE.Ident;
    	var STRING = TYPE.String;
    	var COLON = TYPE.Colon;
    	var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
    	var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
    	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
    	var ASTERISK = 0x002A;         // U+002A ASTERISK (*)
    	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
    	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
    	var VERTICALLINE = 0x007C;     // U+007C VERTICAL LINE (|)
    	var TILDE = 0x007E;            // U+007E TILDE (~)

    	function getAttributeName() {
    	    if (this.scanner.eof) {
    	        this.error('Unexpected end of input');
    	    }

    	    var start = this.scanner.tokenStart;
    	    var expectIdent = false;
    	    var checkColon = true;

    	    if (this.scanner.isDelim(ASTERISK)) {
    	        expectIdent = true;
    	        checkColon = false;
    	        this.scanner.next();
    	    } else if (!this.scanner.isDelim(VERTICALLINE)) {
    	        this.eat(IDENT);
    	    }

    	    if (this.scanner.isDelim(VERTICALLINE)) {
    	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
    	            this.scanner.next();
    	            this.eat(IDENT);
    	        } else if (expectIdent) {
    	            this.error('Identifier is expected', this.scanner.tokenEnd);
    	        }
    	    } else if (expectIdent) {
    	        this.error('Vertical line is expected');
    	    }

    	    if (checkColon && this.scanner.tokenType === COLON) {
    	        this.scanner.next();
    	        this.eat(IDENT);
    	    }

    	    return {
    	        type: 'Identifier',
    	        loc: this.getLocation(start, this.scanner.tokenStart),
    	        name: this.scanner.substrToCursor(start)
    	    };
    	}

    	function getOperator() {
    	    var start = this.scanner.tokenStart;
    	    var code = this.scanner.source.charCodeAt(start);

    	    if (code !== EQUALSSIGN &&        // =
    	        code !== TILDE &&             // ~=
    	        code !== CIRCUMFLEXACCENT &&  // ^=
    	        code !== DOLLARSIGN &&        // $=
    	        code !== ASTERISK &&          // *=
    	        code !== VERTICALLINE         // |=
    	    ) {
    	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
    	    }

    	    this.scanner.next();

    	    if (code !== EQUALSSIGN) {
    	        if (!this.scanner.isDelim(EQUALSSIGN)) {
    	            this.error('Equal sign is expected');
    	        }

    	        this.scanner.next();
    	    }

    	    return this.scanner.substrToCursor(start);
    	}

    	// '[' <wq-name> ']'
    	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
    	AttributeSelector = {
    	    name: 'AttributeSelector',
    	    structure: {
    	        name: 'Identifier',
    	        matcher: [String, null],
    	        value: ['String', 'Identifier', null],
    	        flags: [String, null]
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var name;
    	        var matcher = null;
    	        var value = null;
    	        var flags = null;

    	        this.eat(LEFTSQUAREBRACKET);
    	        this.scanner.skipSC();

    	        name = getAttributeName.call(this);
    	        this.scanner.skipSC();

    	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
    	            // avoid case `[name i]`
    	            if (this.scanner.tokenType !== IDENT) {
    	                matcher = getOperator.call(this);

    	                this.scanner.skipSC();

    	                value = this.scanner.tokenType === STRING
    	                    ? this.String()
    	                    : this.Identifier();

    	                this.scanner.skipSC();
    	            }

    	            // attribute flags
    	            if (this.scanner.tokenType === IDENT) {
    	                flags = this.scanner.getTokenValue();
    	                this.scanner.next();

    	                this.scanner.skipSC();
    	            }
    	        }

    	        this.eat(RIGHTSQUAREBRACKET);

    	        return {
    	            type: 'AttributeSelector',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            name: name,
    	            matcher: matcher,
    	            value: value,
    	            flags: flags
    	        };
    	    },
    	    generate: function(node) {
    	        var flagsPrefix = ' ';

    	        this.chunk('[');
    	        this.node(node.name);

    	        if (node.matcher !== null) {
    	            this.chunk(node.matcher);

    	            if (node.value !== null) {
    	                this.node(node.value);

    	                // space between string and flags is not required
    	                if (node.value.type === 'String') {
    	                    flagsPrefix = '';
    	                }
    	            }
    	        }

    	        if (node.flags !== null) {
    	            this.chunk(flagsPrefix);
    	            this.chunk(node.flags);
    	        }

    	        this.chunk(']');
    	    }
    	};
    	return AttributeSelector;
    }

    var Block;
    var hasRequiredBlock;

    function requireBlock () {
    	if (hasRequiredBlock) return Block;
    	hasRequiredBlock = 1;
    	var TYPE = requireTokenizer$1().TYPE;
    	var rawMode = requireRaw().mode;

    	var WHITESPACE = TYPE.WhiteSpace;
    	var COMMENT = TYPE.Comment;
    	var SEMICOLON = TYPE.Semicolon;
    	var ATKEYWORD = TYPE.AtKeyword;
    	var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
    	var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

    	function consumeRaw(startToken) {
    	    return this.Raw(startToken, null, true);
    	}
    	function consumeRule() {
    	    return this.parseWithFallback(this.Rule, consumeRaw);
    	}
    	function consumeRawDeclaration(startToken) {
    	    return this.Raw(startToken, rawMode.semicolonIncluded, true);
    	}
    	function consumeDeclaration() {
    	    if (this.scanner.tokenType === SEMICOLON) {
    	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
    	    }

    	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

    	    if (this.scanner.tokenType === SEMICOLON) {
    	        this.scanner.next();
    	    }

    	    return node;
    	}

    	Block = {
    	    name: 'Block',
    	    structure: {
    	        children: [[
    	            'Atrule',
    	            'Rule',
    	            'Declaration'
    	        ]]
    	    },
    	    parse: function(isDeclaration) {
    	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

    	        var start = this.scanner.tokenStart;
    	        var children = this.createList();

    	        this.eat(LEFTCURLYBRACKET);

    	        scan:
    	        while (!this.scanner.eof) {
    	            switch (this.scanner.tokenType) {
    	                case RIGHTCURLYBRACKET:
    	                    break scan;

    	                case WHITESPACE:
    	                case COMMENT:
    	                    this.scanner.next();
    	                    break;

    	                case ATKEYWORD:
    	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw));
    	                    break;

    	                default:
    	                    children.push(consumer.call(this));
    	            }
    	        }

    	        if (!this.scanner.eof) {
    	            this.eat(RIGHTCURLYBRACKET);
    	        }

    	        return {
    	            type: 'Block',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk('{');
    	        this.children(node, function(prev) {
    	            if (prev.type === 'Declaration') {
    	                this.chunk(';');
    	            }
    	        });
    	        this.chunk('}');
    	    },
    	    walkContext: 'block'
    	};
    	return Block;
    }

    var Brackets;
    var hasRequiredBrackets;

    function requireBrackets () {
    	if (hasRequiredBrackets) return Brackets;
    	hasRequiredBrackets = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
    	var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;

    	Brackets = {
    	    name: 'Brackets',
    	    structure: {
    	        children: [[]]
    	    },
    	    parse: function(readSequence, recognizer) {
    	        var start = this.scanner.tokenStart;
    	        var children = null;

    	        this.eat(LEFTSQUAREBRACKET);

    	        children = readSequence.call(this, recognizer);

    	        if (!this.scanner.eof) {
    	            this.eat(RIGHTSQUAREBRACKET);
    	        }

    	        return {
    	            type: 'Brackets',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk('[');
    	        this.children(node);
    	        this.chunk(']');
    	    }
    	};
    	return Brackets;
    }

    var CDC_1;
    var hasRequiredCDC;

    function requireCDC () {
    	if (hasRequiredCDC) return CDC_1;
    	hasRequiredCDC = 1;
    	var CDC = requireTokenizer$1().TYPE.CDC;

    	CDC_1 = {
    	    name: 'CDC',
    	    structure: [],
    	    parse: function() {
    	        var start = this.scanner.tokenStart;

    	        this.eat(CDC); // -->

    	        return {
    	            type: 'CDC',
    	            loc: this.getLocation(start, this.scanner.tokenStart)
    	        };
    	    },
    	    generate: function() {
    	        this.chunk('-->');
    	    }
    	};
    	return CDC_1;
    }

    var CDO_1;
    var hasRequiredCDO;

    function requireCDO () {
    	if (hasRequiredCDO) return CDO_1;
    	hasRequiredCDO = 1;
    	var CDO = requireTokenizer$1().TYPE.CDO;

    	CDO_1 = {
    	    name: 'CDO',
    	    structure: [],
    	    parse: function() {
    	        var start = this.scanner.tokenStart;

    	        this.eat(CDO); // <!--

    	        return {
    	            type: 'CDO',
    	            loc: this.getLocation(start, this.scanner.tokenStart)
    	        };
    	    },
    	    generate: function() {
    	        this.chunk('<!--');
    	    }
    	};
    	return CDO_1;
    }

    var ClassSelector;
    var hasRequiredClassSelector;

    function requireClassSelector () {
    	if (hasRequiredClassSelector) return ClassSelector;
    	hasRequiredClassSelector = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var IDENT = TYPE.Ident;
    	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

    	// '.' ident
    	ClassSelector = {
    	    name: 'ClassSelector',
    	    structure: {
    	        name: String
    	    },
    	    parse: function() {
    	        if (!this.scanner.isDelim(FULLSTOP)) {
    	            this.error('Full stop is expected');
    	        }

    	        this.scanner.next();

    	        return {
    	            type: 'ClassSelector',
    	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
    	            name: this.consume(IDENT)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk('.');
    	        this.chunk(node.name);
    	    }
    	};
    	return ClassSelector;
    }

    var Combinator;
    var hasRequiredCombinator;

    function requireCombinator () {
    	if (hasRequiredCombinator) return Combinator;
    	hasRequiredCombinator = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var IDENT = TYPE.Ident;
    	var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
    	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
    	var GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
    	var TILDE = 0x007E;           // U+007E TILDE (~)

    	// + | > | ~ | /deep/
    	Combinator = {
    	    name: 'Combinator',
    	    structure: {
    	        name: String
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

    	        switch (code) {
    	            case GREATERTHANSIGN:
    	            case PLUSSIGN:
    	            case TILDE:
    	                this.scanner.next();
    	                break;

    	            case SOLIDUS:
    	                this.scanner.next();

    	                if (this.scanner.tokenType !== IDENT || this.scanner.lookupValue(0, 'deep') === false) {
    	                    this.error('Identifier `deep` is expected');
    	                }

    	                this.scanner.next();

    	                if (!this.scanner.isDelim(SOLIDUS)) {
    	                    this.error('Solidus is expected');
    	                }

    	                this.scanner.next();
    	                break;

    	            default:
    	                this.error('Combinator is expected');
    	        }

    	        return {
    	            type: 'Combinator',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            name: this.scanner.substrToCursor(start)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.name);
    	    }
    	};
    	return Combinator;
    }

    var Comment;
    var hasRequiredComment;

    function requireComment () {
    	if (hasRequiredComment) return Comment;
    	hasRequiredComment = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var COMMENT = TYPE.Comment;
    	var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
    	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)

    	// '/*' .* '*/'
    	Comment = {
    	    name: 'Comment',
    	    structure: {
    	        value: String
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var end = this.scanner.tokenEnd;

    	        this.eat(COMMENT);

    	        if ((end - start + 2) >= 2 &&
    	            this.scanner.source.charCodeAt(end - 2) === ASTERISK &&
    	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS) {
    	            end -= 2;
    	        }

    	        return {
    	            type: 'Comment',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            value: this.scanner.source.substring(start + 2, end)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk('/*');
    	        this.chunk(node.value);
    	        this.chunk('*/');
    	    }
    	};
    	return Comment;
    }

    var Declaration;
    var hasRequiredDeclaration;

    function requireDeclaration () {
    	if (hasRequiredDeclaration) return Declaration;
    	hasRequiredDeclaration = 1;
    	var isCustomProperty = requireNames().isCustomProperty;
    	var TYPE = requireTokenizer$1().TYPE;
    	var rawMode = requireRaw().mode;

    	var IDENT = TYPE.Ident;
    	var HASH = TYPE.Hash;
    	var COLON = TYPE.Colon;
    	var SEMICOLON = TYPE.Semicolon;
    	var DELIM = TYPE.Delim;
    	var WHITESPACE = TYPE.WhiteSpace;
    	var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)
    	var NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
    	var DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)
    	var AMPERSAND = 0x0026;       // U+0026 ANPERSAND (&)
    	var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
    	var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
    	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)

    	function consumeValueRaw(startToken) {
    	    return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, true);
    	}

    	function consumeCustomPropertyRaw(startToken) {
    	    return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, false);
    	}

    	function consumeValue() {
    	    var startValueToken = this.scanner.tokenIndex;
    	    var value = this.Value();

    	    if (value.type !== 'Raw' &&
    	        this.scanner.eof === false &&
    	        this.scanner.tokenType !== SEMICOLON &&
    	        this.scanner.isDelim(EXCLAMATIONMARK) === false &&
    	        this.scanner.isBalanceEdge(startValueToken) === false) {
    	        this.error();
    	    }

    	    return value;
    	}

    	Declaration = {
    	    name: 'Declaration',
    	    structure: {
    	        important: [Boolean, String],
    	        property: String,
    	        value: ['Value', 'Raw']
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var startToken = this.scanner.tokenIndex;
    	        var property = readProperty.call(this);
    	        var customProperty = isCustomProperty(property);
    	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
    	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
    	        var important = false;
    	        var value;

    	        this.scanner.skipSC();
    	        this.eat(COLON);

    	        const valueStart = this.scanner.tokenIndex;

    	        if (!customProperty) {
    	            this.scanner.skipSC();
    	        }

    	        if (parseValue) {
    	            value = this.parseWithFallback(consumeValue, consumeRaw);
    	        } else {
    	            value = consumeRaw.call(this, this.scanner.tokenIndex);
    	        }

    	        if (customProperty && value.type === 'Value' && value.children.isEmpty()) {
    	            for (let offset = valueStart - this.scanner.tokenIndex; offset <= 0; offset++) {
    	                if (this.scanner.lookupType(offset) === WHITESPACE) {
    	                    value.children.appendData({
    	                        type: 'WhiteSpace',
    	                        loc: null,
    	                        value: ' '
    	                    });
    	                    break;
    	                }
    	            }
    	        }

    	        if (this.scanner.isDelim(EXCLAMATIONMARK)) {
    	            important = getImportant.call(this);
    	            this.scanner.skipSC();
    	        }

    	        // Do not include semicolon to range per spec
    	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

    	        if (this.scanner.eof === false &&
    	            this.scanner.tokenType !== SEMICOLON &&
    	            this.scanner.isBalanceEdge(startToken) === false) {
    	            this.error();
    	        }

    	        return {
    	            type: 'Declaration',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            important: important,
    	            property: property,
    	            value: value
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.property);
    	        this.chunk(':');
    	        this.node(node.value);

    	        if (node.important) {
    	            this.chunk(node.important === true ? '!important' : '!' + node.important);
    	        }
    	    },
    	    walkContext: 'declaration'
    	};

    	function readProperty() {
    	    var start = this.scanner.tokenStart;

    	    // hacks
    	    if (this.scanner.tokenType === DELIM) {
    	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
    	            case ASTERISK:
    	            case DOLLARSIGN:
    	            case PLUSSIGN:
    	            case NUMBERSIGN:
    	            case AMPERSAND:
    	                this.scanner.next();
    	                break;

    	            // TODO: not sure we should support this hack
    	            case SOLIDUS:
    	                this.scanner.next();
    	                if (this.scanner.isDelim(SOLIDUS)) {
    	                    this.scanner.next();
    	                }
    	                break;
    	        }
    	    }

    	    if (this.scanner.tokenType === HASH) {
    	        this.eat(HASH);
    	    } else {
    	        this.eat(IDENT);
    	    }

    	    return this.scanner.substrToCursor(start);
    	}

    	// ! ws* important
    	function getImportant() {
    	    this.eat(DELIM);
    	    this.scanner.skipSC();

    	    var important = this.consume(IDENT);

    	    // store original value in case it differ from `important`
    	    // for better original source restoring and hacks like `!ie` support
    	    return important === 'important' ? true : important;
    	}
    	return Declaration;
    }

    var DeclarationList;
    var hasRequiredDeclarationList;

    function requireDeclarationList () {
    	if (hasRequiredDeclarationList) return DeclarationList;
    	hasRequiredDeclarationList = 1;
    	var TYPE = requireTokenizer$1().TYPE;
    	var rawMode = requireRaw().mode;

    	var WHITESPACE = TYPE.WhiteSpace;
    	var COMMENT = TYPE.Comment;
    	var SEMICOLON = TYPE.Semicolon;

    	function consumeRaw(startToken) {
    	    return this.Raw(startToken, rawMode.semicolonIncluded, true);
    	}

    	DeclarationList = {
    	    name: 'DeclarationList',
    	    structure: {
    	        children: [[
    	            'Declaration'
    	        ]]
    	    },
    	    parse: function() {
    	        var children = this.createList();

    	        while (!this.scanner.eof) {
    	            switch (this.scanner.tokenType) {
    	                case WHITESPACE:
    	                case COMMENT:
    	                case SEMICOLON:
    	                    this.scanner.next();
    	                    break;

    	                default:
    	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw));
    	            }
    	        }

    	        return {
    	            type: 'DeclarationList',
    	            loc: this.getLocationFromList(children),
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.children(node, function(prev) {
    	            if (prev.type === 'Declaration') {
    	                this.chunk(';');
    	            }
    	        });
    	    }
    	};
    	return DeclarationList;
    }

    var Dimension;
    var hasRequiredDimension;

    function requireDimension () {
    	if (hasRequiredDimension) return Dimension;
    	hasRequiredDimension = 1;
    	var consumeNumber = requireUtils().consumeNumber;
    	var TYPE = requireTokenizer$1().TYPE;

    	var DIMENSION = TYPE.Dimension;

    	Dimension = {
    	    name: 'Dimension',
    	    structure: {
    	        value: String,
    	        unit: String
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var numberEnd = consumeNumber(this.scanner.source, start);

    	        this.eat(DIMENSION);

    	        return {
    	            type: 'Dimension',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            value: this.scanner.source.substring(start, numberEnd),
    	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.value);
    	        this.chunk(node.unit);
    	    }
    	};
    	return Dimension;
    }

    var _Function;
    var hasRequired_Function;

    function require_Function () {
    	if (hasRequired_Function) return _Function;
    	hasRequired_Function = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var RIGHTPARENTHESIS = TYPE.RightParenthesis;

    	// <function-token> <sequence> )
    	_Function = {
    	    name: 'Function',
    	    structure: {
    	        name: String,
    	        children: [[]]
    	    },
    	    parse: function(readSequence, recognizer) {
    	        var start = this.scanner.tokenStart;
    	        var name = this.consumeFunctionName();
    	        var nameLowerCase = name.toLowerCase();
    	        var children;

    	        children = recognizer.hasOwnProperty(nameLowerCase)
    	            ? recognizer[nameLowerCase].call(this, recognizer)
    	            : readSequence.call(this, recognizer);

    	        if (!this.scanner.eof) {
    	            this.eat(RIGHTPARENTHESIS);
    	        }

    	        return {
    	            type: 'Function',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            name: name,
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.name);
    	        this.chunk('(');
    	        this.children(node);
    	        this.chunk(')');
    	    },
    	    walkContext: 'function'
    	};
    	return _Function;
    }

    var Hash;
    var hasRequiredHash;

    function requireHash () {
    	if (hasRequiredHash) return Hash;
    	hasRequiredHash = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var HASH = TYPE.Hash;

    	// '#' ident
    	Hash = {
    	    name: 'Hash',
    	    structure: {
    	        value: String
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;

    	        this.eat(HASH);

    	        return {
    	            type: 'Hash',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            value: this.scanner.substrToCursor(start + 1)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk('#');
    	        this.chunk(node.value);
    	    }
    	};
    	return Hash;
    }

    var Identifier;
    var hasRequiredIdentifier;

    function requireIdentifier () {
    	if (hasRequiredIdentifier) return Identifier;
    	hasRequiredIdentifier = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var IDENT = TYPE.Ident;

    	Identifier = {
    	    name: 'Identifier',
    	    structure: {
    	        name: String
    	    },
    	    parse: function() {
    	        return {
    	            type: 'Identifier',
    	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
    	            name: this.consume(IDENT)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.name);
    	    }
    	};
    	return Identifier;
    }

    var IdSelector;
    var hasRequiredIdSelector;

    function requireIdSelector () {
    	if (hasRequiredIdSelector) return IdSelector;
    	hasRequiredIdSelector = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var HASH = TYPE.Hash;

    	// <hash-token>
    	IdSelector = {
    	    name: 'IdSelector',
    	    structure: {
    	        name: String
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;

    	        // TODO: check value is an ident
    	        this.eat(HASH);

    	        return {
    	            type: 'IdSelector',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            name: this.scanner.substrToCursor(start + 1)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk('#');
    	        this.chunk(node.name);
    	    }
    	};
    	return IdSelector;
    }

    var MediaFeature;
    var hasRequiredMediaFeature;

    function requireMediaFeature () {
    	if (hasRequiredMediaFeature) return MediaFeature;
    	hasRequiredMediaFeature = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var IDENT = TYPE.Ident;
    	var NUMBER = TYPE.Number;
    	var DIMENSION = TYPE.Dimension;
    	var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    	var RIGHTPARENTHESIS = TYPE.RightParenthesis;
    	var COLON = TYPE.Colon;
    	var DELIM = TYPE.Delim;

    	MediaFeature = {
    	    name: 'MediaFeature',
    	    structure: {
    	        name: String,
    	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var name;
    	        var value = null;

    	        this.eat(LEFTPARENTHESIS);
    	        this.scanner.skipSC();

    	        name = this.consume(IDENT);
    	        this.scanner.skipSC();

    	        if (this.scanner.tokenType !== RIGHTPARENTHESIS) {
    	            this.eat(COLON);
    	            this.scanner.skipSC();

    	            switch (this.scanner.tokenType) {
    	                case NUMBER:
    	                    if (this.lookupNonWSType(1) === DELIM) {
    	                        value = this.Ratio();
    	                    } else {
    	                        value = this.Number();
    	                    }

    	                    break;

    	                case DIMENSION:
    	                    value = this.Dimension();
    	                    break;

    	                case IDENT:
    	                    value = this.Identifier();

    	                    break;

    	                default:
    	                    this.error('Number, dimension, ratio or identifier is expected');
    	            }

    	            this.scanner.skipSC();
    	        }

    	        this.eat(RIGHTPARENTHESIS);

    	        return {
    	            type: 'MediaFeature',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            name: name,
    	            value: value
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk('(');
    	        this.chunk(node.name);
    	        if (node.value !== null) {
    	            this.chunk(':');
    	            this.node(node.value);
    	        }
    	        this.chunk(')');
    	    }
    	};
    	return MediaFeature;
    }

    var MediaQuery;
    var hasRequiredMediaQuery;

    function requireMediaQuery () {
    	if (hasRequiredMediaQuery) return MediaQuery;
    	hasRequiredMediaQuery = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var WHITESPACE = TYPE.WhiteSpace;
    	var COMMENT = TYPE.Comment;
    	var IDENT = TYPE.Ident;
    	var LEFTPARENTHESIS = TYPE.LeftParenthesis;

    	MediaQuery = {
    	    name: 'MediaQuery',
    	    structure: {
    	        children: [[
    	            'Identifier',
    	            'MediaFeature',
    	            'WhiteSpace'
    	        ]]
    	    },
    	    parse: function() {
    	        this.scanner.skipSC();

    	        var children = this.createList();
    	        var child = null;
    	        var space = null;

    	        scan:
    	        while (!this.scanner.eof) {
    	            switch (this.scanner.tokenType) {
    	                case COMMENT:
    	                    this.scanner.next();
    	                    continue;

    	                case WHITESPACE:
    	                    space = this.WhiteSpace();
    	                    continue;

    	                case IDENT:
    	                    child = this.Identifier();
    	                    break;

    	                case LEFTPARENTHESIS:
    	                    child = this.MediaFeature();
    	                    break;

    	                default:
    	                    break scan;
    	            }

    	            if (space !== null) {
    	                children.push(space);
    	                space = null;
    	            }

    	            children.push(child);
    	        }

    	        if (child === null) {
    	            this.error('Identifier or parenthesis is expected');
    	        }

    	        return {
    	            type: 'MediaQuery',
    	            loc: this.getLocationFromList(children),
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.children(node);
    	    }
    	};
    	return MediaQuery;
    }

    var MediaQueryList;
    var hasRequiredMediaQueryList;

    function requireMediaQueryList () {
    	if (hasRequiredMediaQueryList) return MediaQueryList;
    	hasRequiredMediaQueryList = 1;
    	var COMMA = requireTokenizer$1().TYPE.Comma;

    	MediaQueryList = {
    	    name: 'MediaQueryList',
    	    structure: {
    	        children: [[
    	            'MediaQuery'
    	        ]]
    	    },
    	    parse: function(relative) {
    	        var children = this.createList();

    	        this.scanner.skipSC();

    	        while (!this.scanner.eof) {
    	            children.push(this.MediaQuery(relative));

    	            if (this.scanner.tokenType !== COMMA) {
    	                break;
    	            }

    	            this.scanner.next();
    	        }

    	        return {
    	            type: 'MediaQueryList',
    	            loc: this.getLocationFromList(children),
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.children(node, function() {
    	            this.chunk(',');
    	        });
    	    }
    	};
    	return MediaQueryList;
    }

    var Nth;
    var hasRequiredNth$1;

    function requireNth$1 () {
    	if (hasRequiredNth$1) return Nth;
    	hasRequiredNth$1 = 1;
    	Nth = {
    	    name: 'Nth',
    	    structure: {
    	        nth: ['AnPlusB', 'Identifier'],
    	        selector: ['SelectorList', null]
    	    },
    	    parse: function(allowOfClause) {
    	        this.scanner.skipSC();

    	        var start = this.scanner.tokenStart;
    	        var end = start;
    	        var selector = null;
    	        var query;

    	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
    	            query = this.Identifier();
    	        } else {
    	            query = this.AnPlusB();
    	        }

    	        this.scanner.skipSC();

    	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
    	            this.scanner.next();

    	            selector = this.SelectorList();

    	            if (this.needPositions) {
    	                end = this.getLastListNode(selector.children).loc.end.offset;
    	            }
    	        } else {
    	            if (this.needPositions) {
    	                end = query.loc.end.offset;
    	            }
    	        }

    	        return {
    	            type: 'Nth',
    	            loc: this.getLocation(start, end),
    	            nth: query,
    	            selector: selector
    	        };
    	    },
    	    generate: function(node) {
    	        this.node(node.nth);
    	        if (node.selector !== null) {
    	            this.chunk(' of ');
    	            this.node(node.selector);
    	        }
    	    }
    	};
    	return Nth;
    }

    var _Number;
    var hasRequired_Number;

    function require_Number () {
    	if (hasRequired_Number) return _Number;
    	hasRequired_Number = 1;
    	var NUMBER = requireTokenizer$1().TYPE.Number;

    	_Number = {
    	    name: 'Number',
    	    structure: {
    	        value: String
    	    },
    	    parse: function() {
    	        return {
    	            type: 'Number',
    	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
    	            value: this.consume(NUMBER)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.value);
    	    }
    	};
    	return _Number;
    }

    var Operator;
    var hasRequiredOperator;

    function requireOperator () {
    	if (hasRequiredOperator) return Operator;
    	hasRequiredOperator = 1;
    	// '/' | '*' | ',' | ':' | '+' | '-'
    	Operator = {
    	    name: 'Operator',
    	    structure: {
    	        value: String
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;

    	        this.scanner.next();

    	        return {
    	            type: 'Operator',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            value: this.scanner.substrToCursor(start)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.value);
    	    }
    	};
    	return Operator;
    }

    var Parentheses;
    var hasRequiredParentheses;

    function requireParentheses () {
    	if (hasRequiredParentheses) return Parentheses;
    	hasRequiredParentheses = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    	var RIGHTPARENTHESIS = TYPE.RightParenthesis;

    	Parentheses = {
    	    name: 'Parentheses',
    	    structure: {
    	        children: [[]]
    	    },
    	    parse: function(readSequence, recognizer) {
    	        var start = this.scanner.tokenStart;
    	        var children = null;

    	        this.eat(LEFTPARENTHESIS);

    	        children = readSequence.call(this, recognizer);

    	        if (!this.scanner.eof) {
    	            this.eat(RIGHTPARENTHESIS);
    	        }

    	        return {
    	            type: 'Parentheses',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk('(');
    	        this.children(node);
    	        this.chunk(')');
    	    }
    	};
    	return Parentheses;
    }

    var Percentage;
    var hasRequiredPercentage;

    function requirePercentage () {
    	if (hasRequiredPercentage) return Percentage;
    	hasRequiredPercentage = 1;
    	var consumeNumber = requireUtils().consumeNumber;
    	var TYPE = requireTokenizer$1().TYPE;

    	var PERCENTAGE = TYPE.Percentage;

    	Percentage = {
    	    name: 'Percentage',
    	    structure: {
    	        value: String
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var numberEnd = consumeNumber(this.scanner.source, start);

    	        this.eat(PERCENTAGE);

    	        return {
    	            type: 'Percentage',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            value: this.scanner.source.substring(start, numberEnd)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.value);
    	        this.chunk('%');
    	    }
    	};
    	return Percentage;
    }

    var PseudoClassSelector;
    var hasRequiredPseudoClassSelector;

    function requirePseudoClassSelector () {
    	if (hasRequiredPseudoClassSelector) return PseudoClassSelector;
    	hasRequiredPseudoClassSelector = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var IDENT = TYPE.Ident;
    	var FUNCTION = TYPE.Function;
    	var COLON = TYPE.Colon;
    	var RIGHTPARENTHESIS = TYPE.RightParenthesis;

    	// : [ <ident> | <function-token> <any-value>? ) ]
    	PseudoClassSelector = {
    	    name: 'PseudoClassSelector',
    	    structure: {
    	        name: String,
    	        children: [['Raw'], null]
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var children = null;
    	        var name;
    	        var nameLowerCase;

    	        this.eat(COLON);

    	        if (this.scanner.tokenType === FUNCTION) {
    	            name = this.consumeFunctionName();
    	            nameLowerCase = name.toLowerCase();

    	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
    	                this.scanner.skipSC();
    	                children = this.pseudo[nameLowerCase].call(this);
    	                this.scanner.skipSC();
    	            } else {
    	                children = this.createList();
    	                children.push(
    	                    this.Raw(this.scanner.tokenIndex, null, false)
    	                );
    	            }

    	            this.eat(RIGHTPARENTHESIS);
    	        } else {
    	            name = this.consume(IDENT);
    	        }

    	        return {
    	            type: 'PseudoClassSelector',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            name: name,
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(':');
    	        this.chunk(node.name);

    	        if (node.children !== null) {
    	            this.chunk('(');
    	            this.children(node);
    	            this.chunk(')');
    	        }
    	    },
    	    walkContext: 'function'
    	};
    	return PseudoClassSelector;
    }

    var PseudoElementSelector;
    var hasRequiredPseudoElementSelector;

    function requirePseudoElementSelector () {
    	if (hasRequiredPseudoElementSelector) return PseudoElementSelector;
    	hasRequiredPseudoElementSelector = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var IDENT = TYPE.Ident;
    	var FUNCTION = TYPE.Function;
    	var COLON = TYPE.Colon;
    	var RIGHTPARENTHESIS = TYPE.RightParenthesis;

    	// :: [ <ident> | <function-token> <any-value>? ) ]
    	PseudoElementSelector = {
    	    name: 'PseudoElementSelector',
    	    structure: {
    	        name: String,
    	        children: [['Raw'], null]
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var children = null;
    	        var name;
    	        var nameLowerCase;

    	        this.eat(COLON);
    	        this.eat(COLON);

    	        if (this.scanner.tokenType === FUNCTION) {
    	            name = this.consumeFunctionName();
    	            nameLowerCase = name.toLowerCase();

    	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
    	                this.scanner.skipSC();
    	                children = this.pseudo[nameLowerCase].call(this);
    	                this.scanner.skipSC();
    	            } else {
    	                children = this.createList();
    	                children.push(
    	                    this.Raw(this.scanner.tokenIndex, null, false)
    	                );
    	            }

    	            this.eat(RIGHTPARENTHESIS);
    	        } else {
    	            name = this.consume(IDENT);
    	        }

    	        return {
    	            type: 'PseudoElementSelector',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            name: name,
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk('::');
    	        this.chunk(node.name);

    	        if (node.children !== null) {
    	            this.chunk('(');
    	            this.children(node);
    	            this.chunk(')');
    	        }
    	    },
    	    walkContext: 'function'
    	};
    	return PseudoElementSelector;
    }

    var Ratio;
    var hasRequiredRatio;

    function requireRatio () {
    	if (hasRequiredRatio) return Ratio;
    	hasRequiredRatio = 1;
    	var isDigit = requireTokenizer$1().isDigit;
    	var TYPE = requireTokenizer$1().TYPE;

    	var NUMBER = TYPE.Number;
    	var DELIM = TYPE.Delim;
    	var SOLIDUS = 0x002F;  // U+002F SOLIDUS (/)
    	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

    	// Terms of <ratio> should be a positive numbers (not zero or negative)
    	// (see https://drafts.csswg.org/mediaqueries-3/#values)
    	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
    	// and this is using by various sites. Therefore we relax checking on parse
    	// to test a term is unsigned number without an exponent part.
    	// Additional checking may be applied on lexer validation.
    	function consumeNumber() {
    	    this.scanner.skipWS();

    	    var value = this.consume(NUMBER);

    	    for (var i = 0; i < value.length; i++) {
    	        var code = value.charCodeAt(i);
    	        if (!isDigit(code) && code !== FULLSTOP) {
    	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
    	        }
    	    }

    	    if (Number(value) === 0) {
    	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
    	    }

    	    return value;
    	}

    	// <positive-integer> S* '/' S* <positive-integer>
    	Ratio = {
    	    name: 'Ratio',
    	    structure: {
    	        left: String,
    	        right: String
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var left = consumeNumber.call(this);
    	        var right;

    	        this.scanner.skipWS();

    	        if (!this.scanner.isDelim(SOLIDUS)) {
    	            this.error('Solidus is expected');
    	        }
    	        this.eat(DELIM);
    	        right = consumeNumber.call(this);

    	        return {
    	            type: 'Ratio',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            left: left,
    	            right: right
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.left);
    	        this.chunk('/');
    	        this.chunk(node.right);
    	    }
    	};
    	return Ratio;
    }

    var Rule;
    var hasRequiredRule;

    function requireRule () {
    	if (hasRequiredRule) return Rule;
    	hasRequiredRule = 1;
    	var TYPE = requireTokenizer$1().TYPE;
    	var rawMode = requireRaw().mode;

    	var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

    	function consumeRaw(startToken) {
    	    return this.Raw(startToken, rawMode.leftCurlyBracket, true);
    	}

    	function consumePrelude() {
    	    var prelude = this.SelectorList();

    	    if (prelude.type !== 'Raw' &&
    	        this.scanner.eof === false &&
    	        this.scanner.tokenType !== LEFTCURLYBRACKET) {
    	        this.error();
    	    }

    	    return prelude;
    	}

    	Rule = {
    	    name: 'Rule',
    	    structure: {
    	        prelude: ['SelectorList', 'Raw'],
    	        block: ['Block']
    	    },
    	    parse: function() {
    	        var startToken = this.scanner.tokenIndex;
    	        var startOffset = this.scanner.tokenStart;
    	        var prelude;
    	        var block;

    	        if (this.parseRulePrelude) {
    	            prelude = this.parseWithFallback(consumePrelude, consumeRaw);
    	        } else {
    	            prelude = consumeRaw.call(this, startToken);
    	        }

    	        block = this.Block(true);

    	        return {
    	            type: 'Rule',
    	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
    	            prelude: prelude,
    	            block: block
    	        };
    	    },
    	    generate: function(node) {
    	        this.node(node.prelude);
    	        this.node(node.block);
    	    },
    	    walkContext: 'rule'
    	};
    	return Rule;
    }

    var Selector;
    var hasRequiredSelector$1;

    function requireSelector$1 () {
    	if (hasRequiredSelector$1) return Selector;
    	hasRequiredSelector$1 = 1;
    	Selector = {
    	    name: 'Selector',
    	    structure: {
    	        children: [[
    	            'TypeSelector',
    	            'IdSelector',
    	            'ClassSelector',
    	            'AttributeSelector',
    	            'PseudoClassSelector',
    	            'PseudoElementSelector',
    	            'Combinator',
    	            'WhiteSpace'
    	        ]]
    	    },
    	    parse: function() {
    	        var children = this.readSequence(this.scope.Selector);

    	        // nothing were consumed
    	        if (this.getFirstListNode(children) === null) {
    	            this.error('Selector is expected');
    	        }

    	        return {
    	            type: 'Selector',
    	            loc: this.getLocationFromList(children),
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.children(node);
    	    }
    	};
    	return Selector;
    }

    var SelectorList;
    var hasRequiredSelectorList$1;

    function requireSelectorList$1 () {
    	if (hasRequiredSelectorList$1) return SelectorList;
    	hasRequiredSelectorList$1 = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var COMMA = TYPE.Comma;

    	SelectorList = {
    	    name: 'SelectorList',
    	    structure: {
    	        children: [[
    	            'Selector',
    	            'Raw'
    	        ]]
    	    },
    	    parse: function() {
    	        var children = this.createList();

    	        while (!this.scanner.eof) {
    	            children.push(this.Selector());

    	            if (this.scanner.tokenType === COMMA) {
    	                this.scanner.next();
    	                continue;
    	            }

    	            break;
    	        }

    	        return {
    	            type: 'SelectorList',
    	            loc: this.getLocationFromList(children),
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.children(node, function() {
    	            this.chunk(',');
    	        });
    	    },
    	    walkContext: 'selector'
    	};
    	return SelectorList;
    }

    var _String;
    var hasRequired_String;

    function require_String () {
    	if (hasRequired_String) return _String;
    	hasRequired_String = 1;
    	var STRING = requireTokenizer$1().TYPE.String;

    	_String = {
    	    name: 'String',
    	    structure: {
    	        value: String
    	    },
    	    parse: function() {
    	        return {
    	            type: 'String',
    	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
    	            value: this.consume(STRING)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.value);
    	    }
    	};
    	return _String;
    }

    var StyleSheet;
    var hasRequiredStyleSheet;

    function requireStyleSheet () {
    	if (hasRequiredStyleSheet) return StyleSheet;
    	hasRequiredStyleSheet = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var WHITESPACE = TYPE.WhiteSpace;
    	var COMMENT = TYPE.Comment;
    	var ATKEYWORD = TYPE.AtKeyword;
    	var CDO = TYPE.CDO;
    	var CDC = TYPE.CDC;
    	var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

    	function consumeRaw(startToken) {
    	    return this.Raw(startToken, null, false);
    	}

    	StyleSheet = {
    	    name: 'StyleSheet',
    	    structure: {
    	        children: [[
    	            'Comment',
    	            'CDO',
    	            'CDC',
    	            'Atrule',
    	            'Rule',
    	            'Raw'
    	        ]]
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var children = this.createList();
    	        var child;

    	        while (!this.scanner.eof) {
    	            switch (this.scanner.tokenType) {
    	                case WHITESPACE:
    	                    this.scanner.next();
    	                    continue;

    	                case COMMENT:
    	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
    	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {
    	                        this.scanner.next();
    	                        continue;
    	                    }

    	                    child = this.Comment();
    	                    break;

    	                case CDO: // <!--
    	                    child = this.CDO();
    	                    break;

    	                case CDC: // -->
    	                    child = this.CDC();
    	                    break;

    	                // CSS Syntax Module Level 3
    	                // 2.2 Error handling
    	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
    	                case ATKEYWORD:
    	                    child = this.parseWithFallback(this.Atrule, consumeRaw);
    	                    break;

    	                // Anything else starts a qualified rule ...
    	                default:
    	                    child = this.parseWithFallback(this.Rule, consumeRaw);
    	            }

    	            children.push(child);
    	        }

    	        return {
    	            type: 'StyleSheet',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.children(node);
    	    },
    	    walkContext: 'stylesheet'
    	};
    	return StyleSheet;
    }

    var TypeSelector;
    var hasRequiredTypeSelector;

    function requireTypeSelector () {
    	if (hasRequiredTypeSelector) return TypeSelector;
    	hasRequiredTypeSelector = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var IDENT = TYPE.Ident;
    	var ASTERISK = 0x002A;     // U+002A ASTERISK (*)
    	var VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)

    	function eatIdentifierOrAsterisk() {
    	    if (this.scanner.tokenType !== IDENT &&
    	        this.scanner.isDelim(ASTERISK) === false) {
    	        this.error('Identifier or asterisk is expected');
    	    }

    	    this.scanner.next();
    	}

    	// ident
    	// ident|ident
    	// ident|*
    	// *
    	// *|ident
    	// *|*
    	// |ident
    	// |*
    	TypeSelector = {
    	    name: 'TypeSelector',
    	    structure: {
    	        name: String
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;

    	        if (this.scanner.isDelim(VERTICALLINE)) {
    	            this.scanner.next();
    	            eatIdentifierOrAsterisk.call(this);
    	        } else {
    	            eatIdentifierOrAsterisk.call(this);

    	            if (this.scanner.isDelim(VERTICALLINE)) {
    	                this.scanner.next();
    	                eatIdentifierOrAsterisk.call(this);
    	            }
    	        }

    	        return {
    	            type: 'TypeSelector',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            name: this.scanner.substrToCursor(start)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.name);
    	    }
    	};
    	return TypeSelector;
    }

    var UnicodeRange;
    var hasRequiredUnicodeRange;

    function requireUnicodeRange () {
    	if (hasRequiredUnicodeRange) return UnicodeRange;
    	hasRequiredUnicodeRange = 1;
    	var isHexDigit = requireTokenizer$1().isHexDigit;
    	var cmpChar = requireTokenizer$1().cmpChar;
    	var TYPE = requireTokenizer$1().TYPE;
    	var NAME = requireTokenizer$1().NAME;

    	var IDENT = TYPE.Ident;
    	var NUMBER = TYPE.Number;
    	var DIMENSION = TYPE.Dimension;
    	var PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)
    	var HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)
    	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
    	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

    	function eatHexSequence(offset, allowDash) {
    	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
    	        var code = this.scanner.source.charCodeAt(pos);

    	        if (code === HYPHENMINUS && allowDash && len !== 0) {
    	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
    	                this.error();
    	            }

    	            return -1;
    	        }

    	        if (!isHexDigit(code)) {
    	            this.error(
    	                allowDash && len !== 0
    	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
    	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
    	                pos
    	            );
    	        }

    	        if (++len > 6) {
    	            this.error('Too many hex digits', pos);
    	        }	    }

    	    this.scanner.next();
    	    return len;
    	}

    	function eatQuestionMarkSequence(max) {
    	    var count = 0;

    	    while (this.scanner.isDelim(QUESTIONMARK)) {
    	        if (++count > max) {
    	            this.error('Too many question marks');
    	        }

    	        this.scanner.next();
    	    }
    	}

    	function startsWith(code) {
    	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
    	        this.error(NAME[code] + ' is expected');
    	    }
    	}

    	// https://drafts.csswg.org/css-syntax/#urange
    	// Informally, the <urange> production has three forms:
    	// U+0001
    	//      Defines a range consisting of a single code point, in this case the code point "1".
    	// U+0001-00ff
    	//      Defines a range of codepoints between the first and the second value, in this case
    	//      the range between "1" and "ff" (255 in decimal) inclusive.
    	// U+00??
    	//      Defines a range of codepoints where the "?" characters range over all hex digits,
    	//      in this case defining the same as the value U+0000-00ff.
    	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
    	//
    	// <urange> =
    	//   u '+' <ident-token> '?'* |
    	//   u <dimension-token> '?'* |
    	//   u <number-token> '?'* |
    	//   u <number-token> <dimension-token> |
    	//   u <number-token> <number-token> |
    	//   u '+' '?'+
    	function scanUnicodeRange() {
    	    var hexLength = 0;

    	    // u '+' <ident-token> '?'*
    	    // u '+' '?'+
    	    if (this.scanner.isDelim(PLUSSIGN)) {
    	        this.scanner.next();

    	        if (this.scanner.tokenType === IDENT) {
    	            hexLength = eatHexSequence.call(this, 0, true);
    	            if (hexLength > 0) {
    	                eatQuestionMarkSequence.call(this, 6 - hexLength);
    	            }
    	            return;
    	        }

    	        if (this.scanner.isDelim(QUESTIONMARK)) {
    	            this.scanner.next();
    	            eatQuestionMarkSequence.call(this, 5);
    	            return;
    	        }

    	        this.error('Hex digit or question mark is expected');
    	        return;
    	    }

    	    // u <number-token> '?'*
    	    // u <number-token> <dimension-token>
    	    // u <number-token> <number-token>
    	    if (this.scanner.tokenType === NUMBER) {
    	        startsWith.call(this, PLUSSIGN);
    	        hexLength = eatHexSequence.call(this, 1, true);

    	        if (this.scanner.isDelim(QUESTIONMARK)) {
    	            eatQuestionMarkSequence.call(this, 6 - hexLength);
    	            return;
    	        }

    	        if (this.scanner.tokenType === DIMENSION ||
    	            this.scanner.tokenType === NUMBER) {
    	            startsWith.call(this, HYPHENMINUS);
    	            eatHexSequence.call(this, 1, false);
    	            return;
    	        }

    	        return;
    	    }

    	    // u <dimension-token> '?'*
    	    if (this.scanner.tokenType === DIMENSION) {
    	        startsWith.call(this, PLUSSIGN);
    	        hexLength = eatHexSequence.call(this, 1, true);

    	        if (hexLength > 0) {
    	            eatQuestionMarkSequence.call(this, 6 - hexLength);
    	        }

    	        return;
    	    }

    	    this.error();
    	}

    	UnicodeRange = {
    	    name: 'UnicodeRange',
    	    structure: {
    	        value: String
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;

    	        // U or u
    	        if (!cmpChar(this.scanner.source, start, U)) {
    	            this.error('U is expected');
    	        }

    	        if (!cmpChar(this.scanner.source, start + 1, PLUSSIGN)) {
    	            this.error('Plus sign is expected');
    	        }

    	        this.scanner.next();
    	        scanUnicodeRange.call(this);

    	        return {
    	            type: 'UnicodeRange',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            value: this.scanner.substrToCursor(start)
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.value);
    	    }
    	};
    	return UnicodeRange;
    }

    var Url;
    var hasRequiredUrl;

    function requireUrl () {
    	if (hasRequiredUrl) return Url;
    	hasRequiredUrl = 1;
    	var isWhiteSpace = requireTokenizer$1().isWhiteSpace;
    	var cmpStr = requireTokenizer$1().cmpStr;
    	var TYPE = requireTokenizer$1().TYPE;

    	var FUNCTION = TYPE.Function;
    	var URL = TYPE.Url;
    	var RIGHTPARENTHESIS = TYPE.RightParenthesis;

    	// <url-token> | <function-token> <string> )
    	Url = {
    	    name: 'Url',
    	    structure: {
    	        value: ['String', 'Raw']
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var value;

    	        switch (this.scanner.tokenType) {
    	            case URL:
    	                var rawStart = start + 4;
    	                var rawEnd = this.scanner.tokenEnd - 1;

    	                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawStart))) {
    	                    rawStart++;
    	                }

    	                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawEnd - 1))) {
    	                    rawEnd--;
    	                }

    	                value = {
    	                    type: 'Raw',
    	                    loc: this.getLocation(rawStart, rawEnd),
    	                    value: this.scanner.source.substring(rawStart, rawEnd)
    	                };

    	                this.eat(URL);
    	                break;

    	            case FUNCTION:
    	                if (!cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
    	                    this.error('Function name must be `url`');
    	                }

    	                this.eat(FUNCTION);
    	                this.scanner.skipSC();
    	                value = this.String();
    	                this.scanner.skipSC();
    	                this.eat(RIGHTPARENTHESIS);
    	                break;

    	            default:
    	                this.error('Url or Function is expected');
    	        }

    	        return {
    	            type: 'Url',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            value: value
    	        };
    	    },
    	    generate: function(node) {
    	        this.chunk('url');
    	        this.chunk('(');
    	        this.node(node.value);
    	        this.chunk(')');
    	    }
    	};
    	return Url;
    }

    var Value;
    var hasRequiredValue$1;

    function requireValue$1 () {
    	if (hasRequiredValue$1) return Value;
    	hasRequiredValue$1 = 1;
    	Value = {
    	    name: 'Value',
    	    structure: {
    	        children: [[]]
    	    },
    	    parse: function() {
    	        var start = this.scanner.tokenStart;
    	        var children = this.readSequence(this.scope.Value);

    	        return {
    	            type: 'Value',
    	            loc: this.getLocation(start, this.scanner.tokenStart),
    	            children: children
    	        };
    	    },
    	    generate: function(node) {
    	        this.children(node);
    	    }
    	};
    	return Value;
    }

    var WhiteSpace;
    var hasRequiredWhiteSpace;

    function requireWhiteSpace () {
    	if (hasRequiredWhiteSpace) return WhiteSpace;
    	hasRequiredWhiteSpace = 1;
    	var WHITESPACE = requireTokenizer$1().TYPE.WhiteSpace;
    	var SPACE = Object.freeze({
    	    type: 'WhiteSpace',
    	    loc: null,
    	    value: ' '
    	});

    	WhiteSpace = {
    	    name: 'WhiteSpace',
    	    structure: {
    	        value: String
    	    },
    	    parse: function() {
    	        this.eat(WHITESPACE);
    	        return SPACE;

    	        // return {
    	        //     type: 'WhiteSpace',
    	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
    	        //     value: this.consume(WHITESPACE)
    	        // };
    	    },
    	    generate: function(node) {
    	        this.chunk(node.value);
    	    }
    	};
    	return WhiteSpace;
    }

    var node;
    var hasRequiredNode;

    function requireNode () {
    	if (hasRequiredNode) return node;
    	hasRequiredNode = 1;
    	node = {
    	    AnPlusB: requireAnPlusB(),
    	    Atrule: requireAtrule$1(),
    	    AtrulePrelude: requireAtrulePrelude$1(),
    	    AttributeSelector: requireAttributeSelector(),
    	    Block: requireBlock(),
    	    Brackets: requireBrackets(),
    	    CDC: requireCDC(),
    	    CDO: requireCDO(),
    	    ClassSelector: requireClassSelector(),
    	    Combinator: requireCombinator(),
    	    Comment: requireComment(),
    	    Declaration: requireDeclaration(),
    	    DeclarationList: requireDeclarationList(),
    	    Dimension: requireDimension(),
    	    Function: require_Function(),
    	    Hash: requireHash(),
    	    Identifier: requireIdentifier(),
    	    IdSelector: requireIdSelector(),
    	    MediaFeature: requireMediaFeature(),
    	    MediaQuery: requireMediaQuery(),
    	    MediaQueryList: requireMediaQueryList(),
    	    Nth: requireNth$1(),
    	    Number: require_Number(),
    	    Operator: requireOperator(),
    	    Parentheses: requireParentheses(),
    	    Percentage: requirePercentage(),
    	    PseudoClassSelector: requirePseudoClassSelector(),
    	    PseudoElementSelector: requirePseudoElementSelector(),
    	    Ratio: requireRatio(),
    	    Raw: requireRaw(),
    	    Rule: requireRule(),
    	    Selector: requireSelector$1(),
    	    SelectorList: requireSelectorList$1(),
    	    String: require_String(),
    	    StyleSheet: requireStyleSheet(),
    	    TypeSelector: requireTypeSelector(),
    	    UnicodeRange: requireUnicodeRange(),
    	    Url: requireUrl(),
    	    Value: requireValue$1(),
    	    WhiteSpace: requireWhiteSpace()
    	};
    	return node;
    }

    var lexer;
    var hasRequiredLexer;

    function requireLexer () {
    	if (hasRequiredLexer) return lexer;
    	hasRequiredLexer = 1;
    	var data = requireData();

    	lexer = {
    	    generic: true,
    	    types: data.types,
    	    atrules: data.atrules,
    	    properties: data.properties,
    	    node: requireNode()
    	};
    	return lexer;
    }

    var _default;
    var hasRequired_default;

    function require_default () {
    	if (hasRequired_default) return _default;
    	hasRequired_default = 1;
    	var cmpChar = requireTokenizer$1().cmpChar;
    	var cmpStr = requireTokenizer$1().cmpStr;
    	var TYPE = requireTokenizer$1().TYPE;

    	var IDENT = TYPE.Ident;
    	var STRING = TYPE.String;
    	var NUMBER = TYPE.Number;
    	var FUNCTION = TYPE.Function;
    	var URL = TYPE.Url;
    	var HASH = TYPE.Hash;
    	var DIMENSION = TYPE.Dimension;
    	var PERCENTAGE = TYPE.Percentage;
    	var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    	var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
    	var COMMA = TYPE.Comma;
    	var DELIM = TYPE.Delim;
    	var NUMBERSIGN = 0x0023;  // U+0023 NUMBER SIGN (#)
    	var ASTERISK = 0x002A;    // U+002A ASTERISK (*)
    	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
    	var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
    	var SOLIDUS = 0x002F;     // U+002F SOLIDUS (/)
    	var U = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

    	_default = function defaultRecognizer(context) {
    	    switch (this.scanner.tokenType) {
    	        case HASH:
    	            return this.Hash();

    	        case COMMA:
    	            context.space = null;
    	            context.ignoreWSAfter = true;
    	            return this.Operator();

    	        case LEFTPARENTHESIS:
    	            return this.Parentheses(this.readSequence, context.recognizer);

    	        case LEFTSQUAREBRACKET:
    	            return this.Brackets(this.readSequence, context.recognizer);

    	        case STRING:
    	            return this.String();

    	        case DIMENSION:
    	            return this.Dimension();

    	        case PERCENTAGE:
    	            return this.Percentage();

    	        case NUMBER:
    	            return this.Number();

    	        case FUNCTION:
    	            return cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
    	                ? this.Url()
    	                : this.Function(this.readSequence, context.recognizer);

    	        case URL:
    	            return this.Url();

    	        case IDENT:
    	            // check for unicode range, it should start with u+ or U+
    	            if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) &&
    	                cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {
    	                return this.UnicodeRange();
    	            } else {
    	                return this.Identifier();
    	            }

    	        case DELIM:
    	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

    	            if (code === SOLIDUS ||
    	                code === ASTERISK ||
    	                code === PLUSSIGN ||
    	                code === HYPHENMINUS) {
    	                return this.Operator(); // TODO: replace with Delim
    	            }

    	            // TODO: produce a node with Delim node type

    	            if (code === NUMBERSIGN) {
    	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
    	            }

    	            break;
    	    }
    	};
    	return _default;
    }

    var atrulePrelude;
    var hasRequiredAtrulePrelude;

    function requireAtrulePrelude () {
    	if (hasRequiredAtrulePrelude) return atrulePrelude;
    	hasRequiredAtrulePrelude = 1;
    	atrulePrelude = {
    	    getNode: require_default()
    	};
    	return atrulePrelude;
    }

    var selector;
    var hasRequiredSelector;

    function requireSelector () {
    	if (hasRequiredSelector) return selector;
    	hasRequiredSelector = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var DELIM = TYPE.Delim;
    	var IDENT = TYPE.Ident;
    	var DIMENSION = TYPE.Dimension;
    	var PERCENTAGE = TYPE.Percentage;
    	var NUMBER = TYPE.Number;
    	var HASH = TYPE.Hash;
    	var COLON = TYPE.Colon;
    	var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
    	var NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
    	var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
    	var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
    	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
    	var FULLSTOP = 0x002E;        // U+002E FULL STOP (.)
    	var GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
    	var VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)
    	var TILDE = 0x007E;           // U+007E TILDE (~)

    	function getNode(context) {
    	    switch (this.scanner.tokenType) {
    	        case LEFTSQUAREBRACKET:
    	            return this.AttributeSelector();

    	        case HASH:
    	            return this.IdSelector();

    	        case COLON:
    	            if (this.scanner.lookupType(1) === COLON) {
    	                return this.PseudoElementSelector();
    	            } else {
    	                return this.PseudoClassSelector();
    	            }

    	        case IDENT:
    	            return this.TypeSelector();

    	        case NUMBER:
    	        case PERCENTAGE:
    	            return this.Percentage();

    	        case DIMENSION:
    	            // throws when .123ident
    	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP) {
    	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
    	            }
    	            break;

    	        case DELIM:
    	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

    	            switch (code) {
    	                case PLUSSIGN:
    	                case GREATERTHANSIGN:
    	                case TILDE:
    	                    context.space = null;
    	                    context.ignoreWSAfter = true;
    	                    return this.Combinator();

    	                case SOLIDUS:  // /deep/
    	                    return this.Combinator();

    	                case FULLSTOP:
    	                    return this.ClassSelector();

    	                case ASTERISK:
    	                case VERTICALLINE:
    	                    return this.TypeSelector();

    	                case NUMBERSIGN:
    	                    return this.IdSelector();
    	            }

    	            break;
    	    }
    	}
    	selector = {
    	    getNode: getNode
    	};
    	return selector;
    }

    var expression;
    var hasRequiredExpression;

    function requireExpression () {
    	if (hasRequiredExpression) return expression;
    	hasRequiredExpression = 1;
    	// legacy IE function
    	// expression( <any-value> )
    	expression = function() {
    	    return this.createSingleNodeList(
    	        this.Raw(this.scanner.tokenIndex, null, false)
    	    );
    	};
    	return expression;
    }

    var _var;
    var hasRequired_var;

    function require_var () {
    	if (hasRequired_var) return _var;
    	hasRequired_var = 1;
    	var TYPE = requireTokenizer$1().TYPE;
    	var rawMode = requireRaw().mode;

    	var COMMA = TYPE.Comma;
    	var WHITESPACE = TYPE.WhiteSpace;

    	// var( <ident> , <value>? )
    	_var = function() {
    	    var children = this.createList();

    	    this.scanner.skipSC();

    	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
    	    children.push(this.Identifier());

    	    this.scanner.skipSC();

    	    if (this.scanner.tokenType === COMMA) {
    	        children.push(this.Operator());

    	        const startIndex = this.scanner.tokenIndex;
    	        const value = this.parseCustomProperty
    	            ? this.Value(null)
    	            : this.Raw(this.scanner.tokenIndex, rawMode.exclamationMarkOrSemicolon, false);

    	        if (value.type === 'Value' && value.children.isEmpty()) {
    	            for (let offset = startIndex - this.scanner.tokenIndex; offset <= 0; offset++) {
    	                if (this.scanner.lookupType(offset) === WHITESPACE) {
    	                    value.children.appendData({
    	                        type: 'WhiteSpace',
    	                        loc: null,
    	                        value: ' '
    	                    });
    	                    break;
    	                }
    	            }
    	        }

    	        children.push(value);
    	    }

    	    return children;
    	};
    	return _var;
    }

    var value;
    var hasRequiredValue;

    function requireValue () {
    	if (hasRequiredValue) return value;
    	hasRequiredValue = 1;
    	value = {
    	    getNode: require_default(),
    	    'expression': requireExpression(),
    	    'var': require_var()
    	};
    	return value;
    }

    var scope;
    var hasRequiredScope;

    function requireScope () {
    	if (hasRequiredScope) return scope;
    	hasRequiredScope = 1;
    	scope = {
    	    AtrulePrelude: requireAtrulePrelude(),
    	    Selector: requireSelector(),
    	    Value: requireValue()
    	};
    	return scope;
    }

    var fontFace;
    var hasRequiredFontFace;

    function requireFontFace () {
    	if (hasRequiredFontFace) return fontFace;
    	hasRequiredFontFace = 1;
    	fontFace = {
    	    parse: {
    	        prelude: null,
    	        block: function() {
    	            return this.Block(true);
    	        }
    	    }
    	};
    	return fontFace;
    }

    var _import;
    var hasRequired_import;

    function require_import () {
    	if (hasRequired_import) return _import;
    	hasRequired_import = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var STRING = TYPE.String;
    	var IDENT = TYPE.Ident;
    	var URL = TYPE.Url;
    	var FUNCTION = TYPE.Function;
    	var LEFTPARENTHESIS = TYPE.LeftParenthesis;

    	_import = {
    	    parse: {
    	        prelude: function() {
    	            var children = this.createList();

    	            this.scanner.skipSC();

    	            switch (this.scanner.tokenType) {
    	                case STRING:
    	                    children.push(this.String());
    	                    break;

    	                case URL:
    	                case FUNCTION:
    	                    children.push(this.Url());
    	                    break;

    	                default:
    	                    this.error('String or url() is expected');
    	            }

    	            if (this.lookupNonWSType(0) === IDENT ||
    	                this.lookupNonWSType(0) === LEFTPARENTHESIS) {
    	                children.push(this.WhiteSpace());
    	                children.push(this.MediaQueryList());
    	            }

    	            return children;
    	        },
    	        block: null
    	    }
    	};
    	return _import;
    }

    var media;
    var hasRequiredMedia;

    function requireMedia () {
    	if (hasRequiredMedia) return media;
    	hasRequiredMedia = 1;
    	media = {
    	    parse: {
    	        prelude: function() {
    	            return this.createSingleNodeList(
    	                this.MediaQueryList()
    	            );
    	        },
    	        block: function() {
    	            return this.Block(false);
    	        }
    	    }
    	};
    	return media;
    }

    var page;
    var hasRequiredPage;

    function requirePage () {
    	if (hasRequiredPage) return page;
    	hasRequiredPage = 1;
    	page = {
    	    parse: {
    	        prelude: function() {
    	            return this.createSingleNodeList(
    	                this.SelectorList()
    	            );
    	        },
    	        block: function() {
    	            return this.Block(true);
    	        }
    	    }
    	};
    	return page;
    }

    var supports;
    var hasRequiredSupports;

    function requireSupports () {
    	if (hasRequiredSupports) return supports;
    	hasRequiredSupports = 1;
    	var TYPE = requireTokenizer$1().TYPE;

    	var WHITESPACE = TYPE.WhiteSpace;
    	var COMMENT = TYPE.Comment;
    	var IDENT = TYPE.Ident;
    	var FUNCTION = TYPE.Function;
    	var COLON = TYPE.Colon;
    	var LEFTPARENTHESIS = TYPE.LeftParenthesis;

    	function consumeRaw() {
    	    return this.createSingleNodeList(
    	        this.Raw(this.scanner.tokenIndex, null, false)
    	    );
    	}

    	function parentheses() {
    	    this.scanner.skipSC();

    	    if (this.scanner.tokenType === IDENT &&
    	        this.lookupNonWSType(1) === COLON) {
    	        return this.createSingleNodeList(
    	            this.Declaration()
    	        );
    	    }

    	    return readSequence.call(this);
    	}

    	function readSequence() {
    	    var children = this.createList();
    	    var space = null;
    	    var child;

    	    this.scanner.skipSC();

    	    scan:
    	    while (!this.scanner.eof) {
    	        switch (this.scanner.tokenType) {
    	            case WHITESPACE:
    	                space = this.WhiteSpace();
    	                continue;

    	            case COMMENT:
    	                this.scanner.next();
    	                continue;

    	            case FUNCTION:
    	                child = this.Function(consumeRaw, this.scope.AtrulePrelude);
    	                break;

    	            case IDENT:
    	                child = this.Identifier();
    	                break;

    	            case LEFTPARENTHESIS:
    	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
    	                break;

    	            default:
    	                break scan;
    	        }

    	        if (space !== null) {
    	            children.push(space);
    	            space = null;
    	        }

    	        children.push(child);
    	    }

    	    return children;
    	}

    	supports = {
    	    parse: {
    	        prelude: function() {
    	            var children = readSequence.call(this);

    	            if (this.getFirstListNode(children) === null) {
    	                this.error('Condition is expected');
    	            }

    	            return children;
    	        },
    	        block: function() {
    	            return this.Block(false);
    	        }
    	    }
    	};
    	return supports;
    }

    var atrule;
    var hasRequiredAtrule;

    function requireAtrule () {
    	if (hasRequiredAtrule) return atrule;
    	hasRequiredAtrule = 1;
    	atrule = {
    	    'font-face': requireFontFace(),
    	    'import': require_import(),
    	    'media': requireMedia(),
    	    'page': requirePage(),
    	    'supports': requireSupports()
    	};
    	return atrule;
    }

    var dir;
    var hasRequiredDir;

    function requireDir () {
    	if (hasRequiredDir) return dir;
    	hasRequiredDir = 1;
    	dir = {
    	    parse: function() {
    	        return this.createSingleNodeList(
    	            this.Identifier()
    	        );
    	    }
    	};
    	return dir;
    }

    var has;
    var hasRequiredHas;

    function requireHas () {
    	if (hasRequiredHas) return has;
    	hasRequiredHas = 1;
    	has = {
    	    parse: function() {
    	        return this.createSingleNodeList(
    	            this.SelectorList()
    	        );
    	    }
    	};
    	return has;
    }

    var lang;
    var hasRequiredLang;

    function requireLang () {
    	if (hasRequiredLang) return lang;
    	hasRequiredLang = 1;
    	lang = {
    	    parse: function() {
    	        return this.createSingleNodeList(
    	            this.Identifier()
    	        );
    	    }
    	};
    	return lang;
    }

    var selectorList;
    var hasRequiredSelectorList;

    function requireSelectorList () {
    	if (hasRequiredSelectorList) return selectorList;
    	hasRequiredSelectorList = 1;
    	selectorList = {
    	    parse: function selectorList() {
    	        return this.createSingleNodeList(
    	            this.SelectorList()
    	        );
    	    }
    	};
    	return selectorList;
    }

    var matches;
    var hasRequiredMatches;

    function requireMatches () {
    	if (hasRequiredMatches) return matches;
    	hasRequiredMatches = 1;
    	matches = requireSelectorList();
    	return matches;
    }

    var not;
    var hasRequiredNot;

    function requireNot () {
    	if (hasRequiredNot) return not;
    	hasRequiredNot = 1;
    	not = requireSelectorList();
    	return not;
    }

    var nthWithOfClause;
    var hasRequiredNthWithOfClause;

    function requireNthWithOfClause () {
    	if (hasRequiredNthWithOfClause) return nthWithOfClause;
    	hasRequiredNthWithOfClause = 1;
    	var ALLOW_OF_CLAUSE = true;

    	nthWithOfClause = {
    	    parse: function nthWithOfClause() {
    	        return this.createSingleNodeList(
    	            this.Nth(ALLOW_OF_CLAUSE)
    	        );
    	    }
    	};
    	return nthWithOfClause;
    }

    var nthChild;
    var hasRequiredNthChild;

    function requireNthChild () {
    	if (hasRequiredNthChild) return nthChild;
    	hasRequiredNthChild = 1;
    	nthChild = requireNthWithOfClause();
    	return nthChild;
    }

    var nthLastChild;
    var hasRequiredNthLastChild;

    function requireNthLastChild () {
    	if (hasRequiredNthLastChild) return nthLastChild;
    	hasRequiredNthLastChild = 1;
    	nthLastChild = requireNthWithOfClause();
    	return nthLastChild;
    }

    var nth;
    var hasRequiredNth;

    function requireNth () {
    	if (hasRequiredNth) return nth;
    	hasRequiredNth = 1;
    	var DISALLOW_OF_CLAUSE = false;

    	nth = {
    	    parse: function nth() {
    	        return this.createSingleNodeList(
    	            this.Nth(DISALLOW_OF_CLAUSE)
    	        );
    	    }
    	};
    	return nth;
    }

    var nthLastOfType;
    var hasRequiredNthLastOfType;

    function requireNthLastOfType () {
    	if (hasRequiredNthLastOfType) return nthLastOfType;
    	hasRequiredNthLastOfType = 1;
    	nthLastOfType = requireNth();
    	return nthLastOfType;
    }

    var nthOfType;
    var hasRequiredNthOfType;

    function requireNthOfType () {
    	if (hasRequiredNthOfType) return nthOfType;
    	hasRequiredNthOfType = 1;
    	nthOfType = requireNth();
    	return nthOfType;
    }

    var slotted;
    var hasRequiredSlotted;

    function requireSlotted () {
    	if (hasRequiredSlotted) return slotted;
    	hasRequiredSlotted = 1;
    	slotted = {
    	    parse: function compoundSelector() {
    	        return this.createSingleNodeList(
    	            this.Selector()
    	        );
    	    }
    	};
    	return slotted;
    }

    var pseudo;
    var hasRequiredPseudo;

    function requirePseudo () {
    	if (hasRequiredPseudo) return pseudo;
    	hasRequiredPseudo = 1;
    	pseudo = {
    	    'dir': requireDir(),
    	    'has': requireHas(),
    	    'lang': requireLang(),
    	    'matches': requireMatches(),
    	    'not': requireNot(),
    	    'nth-child': requireNthChild(),
    	    'nth-last-child': requireNthLastChild(),
    	    'nth-last-of-type': requireNthLastOfType(),
    	    'nth-of-type': requireNthOfType(),
    	    'slotted': requireSlotted()
    	};
    	return pseudo;
    }

    var parser;
    var hasRequiredParser;

    function requireParser () {
    	if (hasRequiredParser) return parser;
    	hasRequiredParser = 1;
    	parser = {
    	    parseContext: {
    	        default: 'StyleSheet',
    	        stylesheet: 'StyleSheet',
    	        atrule: 'Atrule',
    	        atrulePrelude: function(options) {
    	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
    	        },
    	        mediaQueryList: 'MediaQueryList',
    	        mediaQuery: 'MediaQuery',
    	        rule: 'Rule',
    	        selectorList: 'SelectorList',
    	        selector: 'Selector',
    	        block: function() {
    	            return this.Block(true);
    	        },
    	        declarationList: 'DeclarationList',
    	        declaration: 'Declaration',
    	        value: 'Value'
    	    },
    	    scope: requireScope(),
    	    atrule: requireAtrule(),
    	    pseudo: requirePseudo(),
    	    node: requireNode()
    	};
    	return parser;
    }

    var walker;
    var hasRequiredWalker;

    function requireWalker () {
    	if (hasRequiredWalker) return walker;
    	hasRequiredWalker = 1;
    	walker = {
    	    node: requireNode()
    	};
    	return walker;
    }

    var version$1 = "1.1.3";
    var require$$4 = {
    	version: version$1};

    var hasRequiredSyntax;

    function requireSyntax () {
    	if (hasRequiredSyntax) return syntax.exports;
    	hasRequiredSyntax = 1;
    	function merge() {
    	    var dest = {};

    	    for (var i = 0; i < arguments.length; i++) {
    	        var src = arguments[i];
    	        for (var key in src) {
    	            dest[key] = src[key];
    	        }
    	    }

    	    return dest;
    	}

    	syntax.exports = requireCreate().create(
    	    merge(
    	        requireLexer(),
    	        requireParser(),
    	        requireWalker()
    	    )
    	);
    	syntax.exports.version = require$$4.version;
    	return syntax.exports;
    }

    var lib;
    var hasRequiredLib;

    function requireLib () {
    	if (hasRequiredLib) return lib;
    	hasRequiredLib = 1;
    	lib = requireSyntax();
    	return lib;
    }

    var libExports = requireLib();
    var csstree = /*@__PURE__*/getDefaultExportFromCjs(libExports);

    class Sheet {
    	constructor(url, hooks) {

    		if (hooks) {
    			this.hooks = hooks;
    		} else {
    			this.hooks = {};
    			this.hooks.onUrl = new Hook(this);
    			this.hooks.onAtPage = new Hook(this);
    			this.hooks.onAtMedia = new Hook(this);
    			this.hooks.onRule = new Hook(this);
    			this.hooks.onDeclaration = new Hook(this);
    			this.hooks.onSelector = new Hook(this);
    			this.hooks.onPseudoSelector = new Hook(this);

    			this.hooks.onContent = new Hook(this);
    			this.hooks.onImport = new Hook(this);

    			this.hooks.beforeTreeParse = new Hook(this);
    			this.hooks.beforeTreeWalk = new Hook(this);
    			this.hooks.afterTreeWalk = new Hook(this);
    		}

    		try {
    			this.url = new URL(url, window.location.href);
    		} catch (e) {
    			this.url = new URL(window.location.href);
    		}
    	}



    	// parse
    	async parse(text) {
    		this.text = text;

    		await this.hooks.beforeTreeParse.trigger(this.text, this);

    		// send to csstree
    		this.ast = csstree.parse(this._text);

    		await this.hooks.beforeTreeWalk.trigger(this.ast);

    		// Replace urls
    		this.replaceUrls(this.ast);

    		// Scope
    		this.id = UUID();
    		// this.addScope(this.ast, this.uuid);

    		// Replace IDs with data-id
    		this.replaceIds(this.ast);

    		this.imported = [];

    		// Trigger Hooks
    		this.urls(this.ast);
    		this.rules(this.ast);
    		this.atrules(this.ast);

    		await this.hooks.afterTreeWalk.trigger(this.ast, this);

    		// return ast
    		return this.ast;
    	}



    	insertRule(rule) {
    		let inserted = this.ast.children.appendData(rule);

    		this.declarations(rule);

    		return inserted;
    	}

    	urls(ast) {
    		csstree.walk(ast, {
    			visit: "Url",
    			enter: (node, item, list) => {
    				this.hooks.onUrl.trigger(node, item, list);
    			}
    		});
    	}

    	atrules(ast) {
    		csstree.walk(ast, {
    			visit: "Atrule",
    			enter: (node, item, list) => {
    				const basename = csstree.keyword(node.name).basename;

    				if (basename === "page") {
    					this.hooks.onAtPage.trigger(node, item, list);
    					this.declarations(node, item, list);
    				}

    				if (basename === "media") {
    					this.hooks.onAtMedia.trigger(node, item, list);
    					this.declarations(node, item, list);
    				}

    				if (basename === "import") {
    					this.hooks.onImport.trigger(node, item, list);
    					this.imports(node, item, list);
    				}
    			}
    		});
    	}


    	rules(ast) {
    		csstree.walk(ast, {
    			visit: "Rule",
    			enter: (ruleNode, ruleItem, rulelist) => {

    				this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
    				this.declarations(ruleNode, ruleItem, rulelist);
    				this.onSelector(ruleNode, ruleItem, rulelist);

    			}
    		});
    	}

    	declarations(ruleNode, ruleItem, rulelist) {
    		csstree.walk(ruleNode, {
    			visit: "Declaration",
    			enter: (declarationNode, dItem, dList) => {

    				this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

    				if (declarationNode.property === "content") {
    					csstree.walk(declarationNode, {
    						visit: "Function",
    						enter: (funcNode, fItem, fList) => {
    							this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
    						}
    					});
    				}

    			}
    		});
    	}

    	// add pseudo elements to parser
    	onSelector(ruleNode, ruleItem, rulelist) {
    		csstree.walk(ruleNode, {
    			visit: "Selector",
    			enter: (selectNode, selectItem, selectList) => {
    				this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

    				if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
    					csstree.walk(node, {
    						visit: "PseudoElementSelector",
    						enter: (pseudoNode, pItem, pList) => {
    							this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
    						}
    					});
    				}}));
    			}
    		});
    	}

    	replaceUrls(ast) {
    		csstree.walk(ast, {
    			visit: "Url",
    			enter: (node, item, list) => {
    				let content = node.value.value;
    				if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
    					let href = content.replace(/["']/g, "");
    					let url = new URL(href, this.url);
    					node.value.value = url.toString();
    				}
    			}
    		});
    	}

    	addScope(ast, id) {
    		// Get all selector lists
    		// add an id
    		csstree.walk(ast, {
    			visit: "Selector",
    			enter: (node, item, list) => {
    				let children = node.children;
    				children.prepend(children.createItem({
    					type: "WhiteSpace",
    					value: " "
    				}));
    				children.prepend(children.createItem({
    					type: "IdSelector",
    					name: id,
    					loc: null,
    					children: null
    				}));
    			}
    		});
    	}

    	getNamedPageSelectors(ast) {
    		let namedPageSelectors = {};
    		csstree.walk(ast, {
    			visit: "Rule",
    			enter: (node, item, list) => {
    				csstree.walk(node, {
    					visit: "Declaration",
    					enter: (declaration, dItem, dList) => {
    						if (declaration.property === "page") {
    							let value = declaration.value.children.first();
    							let name = value.name;
    							let selector = csstree.generate(node.prelude);
    							namedPageSelectors[name] = {
    								name: name,
    								selector: selector
    							};

    							// dList.remove(dItem);

    							// Add in page break
    							declaration.property = "break-before";
    							value.type = "Identifier";
    							value.name = "always";

    						}
    					}
    				});
    			}
    		});
    		return namedPageSelectors;
    	}

    	replaceIds(ast) {
    		csstree.walk(ast, {
    			visit: "Rule",
    			enter: (node, item, list) => {

    				csstree.walk(node, {
    					visit: "IdSelector",
    					enter: (idNode, idItem, idList) => {
    						let name = idNode.name;
    						idNode.flags = null;
    						idNode.matcher = "=";
    						idNode.name = {type: "Identifier", loc: null, name: "data-id"};
    						idNode.type = "AttributeSelector";
    						idNode.value = {type: "String", loc: null, value: `"${name}"`};
    					}
    				});
    			}
    		});
    	}

    	imports(node, item, list) {
    		// console.log("import", node, item, list);
    		let queries = [];
    		csstree.walk(node, {
    			visit: "MediaQuery",
    			enter: (mqNode, mqItem, mqList) => {
    				csstree.walk(mqNode, {
    					visit: "Identifier",
    					enter: (identNode, identItem, identList) => {
    						queries.push(identNode.name);
    					}
    				});
    			}
    		});

    		// Just basic media query support for now
    		let shouldNotApply = queries.some((query, index) => {
    			let q = query;
    			if (q === "not") {
    				q = queries[index + 1];
    				return !(q === "screen" || q === "speech");
    			} else {
    				return (q === "screen" || q === "speech");
    			}
    		});

    		if (shouldNotApply) {
    			return;
    		}

    		csstree.walk(node, {
    			visit: "String",
    			enter: (urlNode, urlItem, urlList) => {
    				let href = urlNode.value.replace(/["']/g, "");
    				let url = new URL(href, this.url);
    				let value = url.toString();

    				this.imported.push(value);

    				// Remove the original
    				list.remove(item);
    			}
    		});
    	}

    	set text(t) {
    		this._text = t;
    	}

    	get text() {
    		return this._text;
    	}

    	// generate string
    	toString(ast) {
    		return csstree.generate(ast || this.ast);
    	}
    }

    var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-footnotes-height: 0mm;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-shadow: white;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
	--pagedjs-footnotes-count: 0;
	--pagedjs-column-gap-offset: 1000px;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
	box-shadow: 1px 0px 0px 0px var(--pagedjs-crop-shadow);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
	box-shadow: -1px 0px 0px 0px var(--pagedjs-crop-shadow);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
	box-shadow: 0px 1px 0px 0px var(--pagedjs-crop-shadow);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
	box-shadow: 0px -1px 0px 0px var(--pagedjs-crop-shadow);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: calc(100% - var(--pagedjs-footnotes-height));
	position: relative;
	column-fill: auto;
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content > div {
	height: inherit;
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_footnote_area {
	position: relative;
	overflow: hidden;
	height: var(--pagedjs-footnotes-height);
	display: flex;
    justify-content: flex-end;
    flex-flow: column;
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_footnote_area > .pagedjs_footnote_content {
	overflow: hidden;
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_footnote_area > .pagedjs_footnote_inner_content {
	overflow: hidden;
}

.pagedjs_area [data-footnote-call] {
	all: unset;
	counter-increment: footnote;
}

.pagedjs_area [data-split-from] {
	counter-increment: unset;
	counter-reset: unset;
}

[data-footnote-call]::after {
	vertical-align: super;
	font-size: 65%;
	line-height: normal;
	content: counter(footnote);
}

@supports ( font-variant-position: super ) {
	[data-footnote-call]::after {
		vertical-align: baseline;
		font-size: 100%;
		line-height: inherit;
		font-variant-position: super;
	}
}

.pagedjs_footnote_empty {
	display: none;
}

.pagedjs_area [data-split-from] {
	counter-increment: unset;
	counter-reset: unset;
}

[data-footnote-marker] {
	text-indent: 0;
	display: list-item;
	list-style-position: inside;
}

[data-footnote-marker][data-split-from] {
	list-style: none;
}

[data-footnote-marker]:not([data-split-from]) {
	counter-increment: footnote-marker;
}

[data-footnote-marker]::marker {
	content: counter(footnote-marker) ". ";
}

[data-footnote-marker][data-split-from]::marker {
	content: unset;
}

.pagedjs_area .pagedjs_footnote_inner_content [data-note-display="inline"] {
 	display: inline;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count) footnote var(--pagedjs-footnotes-count) footnote-marker var(--pagedjs-footnotes-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:not([data-footnote-call]):after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:not([data-footnote-call])::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:not([data-footnote-call]):before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:not([data-footnote-call])::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
		-webkit-print-color-adjust: exact;
		print-color-adjust: exact;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

    async function request(url, options={}) {
    	return new Promise(function(resolve, reject) {
    		let request = new XMLHttpRequest();

    		request.open(options.method || "get", url, true);

    		for (let i in options.headers) {
    			request.setRequestHeader(i, options.headers[i]);
    		}

    		request.withCredentials = options.credentials === "include";

    		request.onload = () => {
    			// Chrome returns a status code of 0 for local files
    			const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
    			resolve(new Response(request.responseText, {status}));
    		};

    		request.onerror = reject;

    		request.send(options.body || null);
    	});
    }

    class Polisher {
    	constructor(setup) {
    		this.sheets = [];
    		this.inserted = [];

    		this.hooks = {};
    		this.hooks.onUrl = new Hook(this);
    		this.hooks.onAtPage = new Hook(this);
    		this.hooks.onAtMedia = new Hook(this);
    		this.hooks.onRule = new Hook(this);
    		this.hooks.onDeclaration = new Hook(this);
    		this.hooks.onContent = new Hook(this);
    		this.hooks.onSelector = new Hook(this);
    		this.hooks.onPseudoSelector = new Hook(this);

    		this.hooks.onImport = new Hook(this);

    		this.hooks.beforeTreeParse = new Hook(this);
    		this.hooks.beforeTreeWalk = new Hook(this);
    		this.hooks.afterTreeWalk = new Hook(this);

    		if (setup !== false) {
    			this.setup();
    		}
    	}

    	setup() {
    		this.base = this.insert(baseStyles);
    		this.styleEl = document.createElement("style");
    		document.head.appendChild(this.styleEl);
    		this.styleSheet = this.styleEl.sheet;
    		return this.styleSheet;
    	}

    	async add() {
    		let fetched = [];
    		let urls = [];

    		for (var i = 0; i < arguments.length; i++) {
    			let f;

    			if (typeof arguments[i] === "object") {
    				for (let url in arguments[i]) {
    					let obj = arguments[i];
    					f = new Promise(function(resolve, reject) {
    						urls.push(url);
    						resolve(obj[url]);
    					});
    				}
    			} else {
    				urls.push(arguments[i]);
    				f = request(arguments[i]).then((response) => {
    					return response.text();
    				});
    			}


    			fetched.push(f);
    		}

    		return await Promise.all(fetched)
    			.then(async (originals) => {
    				let text = "";
    				for (let index = 0; index < originals.length; index++) {
    					text = await this.convertViaSheet(originals[index], urls[index]);
    					this.insert(text);
    				}
    				return text;
    			});
    	}

    	async convertViaSheet(cssStr, href) {
    		let sheet = new Sheet(href, this.hooks);
    		await sheet.parse(cssStr);

    		// Insert the imported sheets first
    		for (let url of sheet.imported) {
    			let str = await request(url).then((response) => {
    				return response.text();
    			});
    			let text = await this.convertViaSheet(str, url);
    			this.insert(text);
    		}

    		this.sheets.push(sheet);

    		if (typeof sheet.width !== "undefined") {
    			this.width = sheet.width;
    		}
    		if (typeof sheet.height !== "undefined") {
    			this.height = sheet.height;
    		}
    		if (typeof sheet.orientation !== "undefined") {
    			this.orientation = sheet.orientation;
    		}
    		return sheet.toString();
    	}

    	insert(text){
    		let head = document.querySelector("head");
    		let style = document.createElement("style");
    		style.setAttribute("data-pagedjs-inserted-styles", "true");

    		style.appendChild(document.createTextNode(text));

    		head.appendChild(style);

    		this.inserted.push(style);
    		return style;
    	}

    	destroy() {
    		this.styleEl.remove();
    		this.inserted.forEach((s) => {
    			s.remove();
    		});
    		this.sheets = [];
    	}
    }

    class Handler {
    	constructor(chunker, polisher, caller) {
    		let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
    		this.chunker = chunker;
    		this.polisher = polisher;
    		this.caller = caller;

    		for (let name in hooks) {
    			if (name in this) {
    				let hook = hooks[name];
    				hook.register(this[name].bind(this));
    			}
    		}
    	}
    }

    EventEmitter(Handler.prototype);

    // https://www.w3.org/TR/css3-page/#page-size-prop

    var pageSizes = {
    	"A0": {
    		width: {
    			value: 841,
    			unit: "mm"
    		},
    		height: {
    			value: 1189,
    			unit: "mm"
    		}
    	},
    	"A1": {
    		width: {
    			value: 594,
    			unit: "mm"
    		},
    		height: {
    			value: 841,
    			unit: "mm"
    		}
    	},
    	"A2": {
    		width: {
    			value: 420,
    			unit: "mm"
    		},
    		height: {
    			value: 594,
    			unit: "mm"
    		}
    	},
    	"A3": {
    		width: {
    			value: 297,
    			unit: "mm"
    		},
    		height: {
    			value: 420,
    			unit: "mm"
    		}
    	},
    	"A4": {
    		width: {
    			value: 210,
    			unit: "mm"
    		},
    		height: {
    			value: 297,
    			unit: "mm"
    		}
    	},
    	"A5": {
    		width: {
    			value: 148,
    			unit: "mm"
    		},
    		height: {
    			value: 210,
    			unit: "mm"
    		}
    	},
    	"A6": {
    		width: {
    			value: 105,
    			unit: "mm"
    		},
    		height: {
    			value: 148,
    			unit: "mm"
    		}
    	},
    	"A7": {
    		width: {
    			value: 74,
    			unit: "mm"
    		},
    		height: {
    			value: 105,
    			unit: "mm"
    		}
    	},
    	"A8": {
    		width: {
    			value: 52,
    			unit: "mm"
    		},
    		height: {
    			value: 74,
    			unit: "mm"
    		}
    	},
    	"A9": {
    		width: {
    			value: 37,
    			unit: "mm"
    		},
    		height: {
    			value: 52,
    			unit: "mm"
    		}
    	},
    	"A10": {
    		width: {
    			value: 26,
    			unit: "mm"
    		},
    		height: {
    			value: 37,
    			unit: "mm"
    		}
    	},
    	"B4": {
    		width: {
    			value: 250,
    			unit: "mm"
    		},
    		height: {
    			value: 353,
    			unit: "mm"
    		}
    	},
    	"B5": {
    		width: {
    			value: 176,
    			unit: "mm"
    		},
    		height: {
    			value: 250,
    			unit: "mm"
    		}
    	},
    	"letter": {
    		width: {
    			value: 8.5,
    			unit: "in"
    		},
    		height: {
    			value: 11,
    			unit: "in"
    		}
    	},
    	"legal": {
    		width: {
    			value: 8.5,
    			unit: "in"
    		},
    		height: {
    			value: 14,
    			unit: "in"
    		}
    	},
    	"ledger": {
    		width: {
    			value: 11,
    			unit: "in"
    		},
    		height: {
    			value: 17,
    			unit: "in"
    		}
    	}
    };

    class AtPage extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);

    		this.pages = {};

    		this.width = undefined;
    		this.height = undefined;
    		this.orientation = undefined;
    		this.marginalia = {};
    	}

    	pageModel(selector) {
    		return {
    			selector: selector,
    			name: undefined,
    			psuedo: undefined,
    			nth: undefined,
    			marginalia: {},
    			width: undefined,
    			height: undefined,
    			orientation: undefined,
    			margin: {
    				top: {},
    				right: {},
    				left: {},
    				bottom: {}
    			},
    			padding: {
    				top: {},
    				right: {},
    				left: {},
    				bottom: {}
    			},
    			border: {
    				top: {},
    				right: {},
    				left: {},
    				bottom: {}
    			},
    			backgroundOrigin: undefined,
    			block: {},
    			marks: undefined,
    			notes: undefined,
    			added: false
    		};
    	}

    	// Find and Remove @page rules
    	onAtPage(node, item, list) {
    		let page, marginalia;
    		let selector = "";
    		let named, psuedo, nth;
    		let needsMerge = false;

    		if (node.prelude) {
    			named = this.getTypeSelector(node);
    			psuedo = this.getPsuedoSelector(node);
    			nth = this.getNthSelector(node);
    			selector = csstree.generate(node.prelude);
    		} else {
    			selector = "*";
    		}

    		if (selector in this.pages) {
    			// this.pages[selector] = Object.assign(this.pages[selector], page);
    			// console.log("after", selector, this.pages[selector]);

    			// this.pages[selector].added = false;
    			page = this.pages[selector];
    			marginalia = this.replaceMarginalia(node);
    			needsMerge = true;
    			// Mark page for getting classes added again
    			page.added = false;
    		} else {
    			page = this.pageModel(selector);
    			marginalia = this.replaceMarginalia(node);
    			this.pages[selector] = page;
    		}

    		page.name = named;
    		page.psuedo = psuedo;
    		page.nth = nth;

    		if (needsMerge) {
    			page.marginalia = Object.assign(page.marginalia, marginalia);
    		} else {
    			page.marginalia = marginalia;
    		}

    		let notes = this.replaceNotes(node);
    		page.notes = notes;

    		let declarations = this.replaceDeclarations(node);

    		if (declarations.size) {
    			page.size = declarations.size;
    			page.width = declarations.size.width;
    			page.height = declarations.size.height;
    			page.orientation = declarations.size.orientation;
    			page.format = declarations.size.format;
    		}

    		if (declarations.bleed && declarations.bleed[0] != "auto") {
    			switch (declarations.bleed.length) {
    				case 4: // top right bottom left
    					page.bleed = {
    						top: declarations.bleed[0],
    						right: declarations.bleed[1],
    						bottom: declarations.bleed[2],
    						left: declarations.bleed[3]
    					};
    					break;
    				case 3: // top right bottom right
    					page.bleed = {
    						top: declarations.bleed[0],
    						right: declarations.bleed[1],
    						bottom: declarations.bleed[2],
    						left: declarations.bleed[1]
    					};
    					break;
    				case 2: // top right top right
    					page.bleed = {
    						top: declarations.bleed[0],
    						right: declarations.bleed[1],
    						bottom: declarations.bleed[0],
    						left: declarations.bleed[1]
    					};
    					break;
    				default:
    					page.bleed = {
    						top: declarations.bleed[0],
    						right: declarations.bleed[0],
    						bottom: declarations.bleed[0],
    						left: declarations.bleed[0]
    					};
    			}
    		}

    		if (declarations.marks) {
    			if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
    				// Spec say 6pt, but needs more space for marks
    				page.bleed = {
    					top: { value: 6, unit: "mm" },
    					right: { value: 6, unit: "mm" },
    					bottom: { value: 6, unit: "mm" },
    					left: { value: 6, unit: "mm" }
    				};
    			}

    			page.marks = declarations.marks;
    		}

    		if (declarations.margin) {
    			page.margin = declarations.margin;
    		}
    		if (declarations.padding) {
    			page.padding = declarations.padding;
    		}

    		if (declarations.border) {
    			page.border = declarations.border;
    		}

    		if (declarations.marks) {
    			page.marks = declarations.marks;
    		}

    		if (needsMerge) {
    			page.block.children.appendList(node.block.children);
    		} else {
    			page.block = node.block;
    		}

    		// Remove the rule
    		list.remove(item);
    	}

    	/* Handled in breaks */
    	/*
    	afterParsed(parsed) {
    		for (let b in this.named) {
    			// Find elements
    			let elements = parsed.querySelectorAll(b);
    			// Add break data
    			for (var i = 0; i < elements.length; i++) {
    				elements[i].setAttribute("data-page", this.named[b]);
    			}
    		}
    	}
    	*/

    	afterTreeWalk(ast, sheet) {
    		let dirtyPage = "*" in this.pages && this.pages["*"].added === false;

    		this.addPageClasses(this.pages, ast, sheet);

    		if (dirtyPage) {
    			let width = this.pages["*"].width;
    			let height = this.pages["*"].height;
    			let format = this.pages["*"].format;
    			let orientation = this.pages["*"].orientation;
    			let bleed = this.pages["*"].bleed;
    			let marks = this.pages["*"].marks;
    			let bleedverso = undefined;
    			let bleedrecto = undefined;

    			if (":left" in this.pages) {
    				bleedverso = this.pages[":left"].bleed;
    			}

    			if (":right" in this.pages) {
    				bleedrecto = this.pages[":right"].bleed;
    			}

    			if ((width && height) &&
    				(this.width !== width || this.height !== height)) {
    				this.width = width;
    				this.height = height;
    				this.format = format;
    				this.orientation = orientation;

    				this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
    				this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

    				this.emit("size", { width, height, orientation, format, bleed });
    				this.emit("atpages", this.pages);
    			}

    		}
    	}

    	getTypeSelector(ast) {
    		// Find page name
    		let name;

    		csstree.walk(ast, {
    			visit: "TypeSelector",
    			enter: (node, item, list) => {
    				name = node.name;
    			}
    		});

    		return name;
    	}

    	getPsuedoSelector(ast) {
    		// Find if it has :left & :right & :black & :first
    		let name;
    		csstree.walk(ast, {
    			visit: "PseudoClassSelector",
    			enter: (node, item, list) => {
    				if (node.name !== "nth") {
    					name = node.name;
    				}
    			}
    		});

    		return name;
    	}

    	getNthSelector(ast) {
    		// Find if it has :nth
    		let nth;
    		csstree.walk(ast, {
    			visit: "PseudoClassSelector",
    			enter: (node, item, list) => {
    				if (node.name === "nth" && node.children) {
    					let raw = node.children.first();
    					nth = raw.value;
    				}
    			}
    		});

    		return nth;
    	}

    	replaceMarginalia(ast) {
    		let parsed = {};
    		const MARGINS = [
    			"top-left-corner", "top-left", "top", "top-center", "top-right", "top-right-corner",
    			"bottom-left-corner", "bottom-left", "bottom", "bottom-center", "bottom-right", "bottom-right-corner",
    			"left-top", "left-middle", "left", "left-bottom", "top-right-corner",
    			"right-top", "right-middle", "right", "right-bottom", "right-right-corner"
    		];
    		csstree.walk(ast.block, {
    			visit: "Atrule",
    			enter: (node, item, list) => {
    				let name = node.name;
    				if (MARGINS.includes(name)) {
    					if (name === "top") {
    						name = "top-center";
    					}
    					if (name === "right") {
    						name = "right-middle";
    					}
    					if (name === "left") {
    						name = "left-middle";
    					}
    					if (name === "bottom") {
    						name = "bottom-center";
    					}
    					parsed[name] = node.block;
    					list.remove(item);
    				}
    			}
    		});

    		return parsed;
    	}

    	replaceNotes(ast) {
    		let parsed = {};

    		csstree.walk(ast.block, {
    			visit: "Atrule",
    			enter: (node, item, list) => {
    				let name = node.name;
    				if (name === "footnote") {
    					parsed[name] = node.block;
    					list.remove(item);
    				}
    			}
    		});

    		return parsed;
    	}

    	replaceDeclarations(ast) {
    		let parsed = {};

    		csstree.walk(ast.block, {
    			visit: "Declaration",
    			enter: (declaration, dItem, dList) => {
    				let prop = csstree.property(declaration.property).name;
    				// let value = declaration.value;

    				if (prop === "marks") {
    					parsed.marks = [];
    					csstree.walk(declaration, {
    						visit: "Identifier",
    						enter: (ident) => {
    							parsed.marks.push(ident.name);
    						}
    					});
    					dList.remove(dItem);
    				} else if (prop === "margin") {
    					parsed.margin = this.getMargins(declaration);
    					dList.remove(dItem);

    				} else if (prop.indexOf("margin-") === 0) {
    					let m = prop.substring("margin-".length);
    					if (!parsed.margin) {
    						parsed.margin = {
    							top: {},
    							right: {},
    							left: {},
    							bottom: {}
    						};
    					}
    					parsed.margin[m] = declaration.value.children.first();
    					dList.remove(dItem);

    				} else if (prop === "padding") {
    					parsed.padding = this.getPaddings(declaration.value);
    					dList.remove(dItem);

    				} else if (prop.indexOf("padding-") === 0) {
    					let p = prop.substring("padding-".length);
    					if (!parsed.padding) {
    						parsed.padding = {
    							top: {},
    							right: {},
    							left: {},
    							bottom: {}
    						};
    					}
    					parsed.padding[p] = declaration.value.children.first();
    					dList.remove(dItem);
    				}

    				else if (prop === "border") {
    					if (!parsed.border) {
    						parsed.border = {
    							top: {},
    							right: {},
    							left: {},
    							bottom: {}
    						};
    					}
    					parsed.border.top = csstree.generate(declaration.value);
    					parsed.border.right = csstree.generate(declaration.value);
    					parsed.border.left = csstree.generate(declaration.value);
    					parsed.border.bottom = csstree.generate(declaration.value);

    					dList.remove(dItem);

    				}

    				else if (prop.indexOf("border-") === 0) {
    					if (!parsed.border) {
    						parsed.border = {
    							top: {},
    							right: {},
    							left: {},
    							bottom: {}
    						};
    					}
    					let p = prop.substring("border-".length);

    					parsed.border[p] = csstree.generate(declaration.value);
    					dList.remove(dItem);

    				}

    				else if (prop === "size") {
    					parsed.size = this.getSize(declaration);
    					dList.remove(dItem);
    				} else if (prop === "bleed") {
    					parsed.bleed = [];

    					csstree.walk(declaration, {
    						enter: (subNode) => {
    							switch (subNode.type) {
    								case "String": // bleed: "auto"
    									if (subNode.value.indexOf("auto") > -1) {
    										parsed.bleed.push("auto");
    									}
    									break;
    								case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
    									parsed.bleed.push({
    										value: subNode.value,
    										unit: subNode.unit
    									});
    									break;
    								case "Number":
    									parsed.bleed.push({
    										value: subNode.value,
    										unit: "px"
    									});
    									break;
    								// ignore
    							}

    						}
    					});

    					dList.remove(dItem);
    				}

    			}
    		});

    		return parsed;

    	}
    	getSize(declaration) {
    		let width, height, orientation, format;

    		// Get size: Xmm Ymm
    		csstree.walk(declaration, {
    			visit: "Dimension",
    			enter: (node, item, list) => {
    				let { value, unit } = node;
    				if (typeof width === "undefined") {
    					width = { value, unit };
    				} else if (typeof height === "undefined") {
    					height = { value, unit };
    				}
    			}
    		});

    		// Get size: "A4"
    		csstree.walk(declaration, {
    			visit: "String",
    			enter: (node, item, list) => {
    				let name = node.value.replace(/["|']/g, "");
    				let s = pageSizes[name];
    				if (s) {
    					width = s.width;
    					height = s.height;
    				}
    			}
    		});

    		// Get Format or Landscape or Portrait
    		csstree.walk(declaration, {
    			visit: "Identifier",
    			enter: (node, item, list) => {
    				let name = node.name;
    				if (name === "landscape" || name === "portrait") {
    					orientation = node.name;
    				} else if (name !== "auto") {
    					let s = pageSizes[name];
    					if (s) {
    						width = s.width;
    						height = s.height;
    					}
    					format = name;
    				}
    			}
    		});

    		return {
    			width,
    			height,
    			orientation,
    			format
    		};
    	}

    	getMargins(declaration) {
    		let margins = [];
    		let margin = {
    			top: {},
    			right: {},
    			left: {},
    			bottom: {}
    		};

    		csstree.walk(declaration, {
    			enter: (node) => {
    				switch (node.type) {
    					case "Dimension": // margin: 1in 2in, margin: 20px, etc...
    						margins.push(node);
    						break;
    					case "Number": // margin: 0
    						margins.push({value: node.value, unit: "px"});
    						break;
    					// ignore
    				}
    			}
    		});

    		if (margins.length === 1) {
    			for (let m in margin) {
    				margin[m] = margins[0];
    			}
    		} else if (margins.length === 2) {
    			margin.top = margins[0];
    			margin.right = margins[1];
    			margin.bottom = margins[0];
    			margin.left = margins[1];
    		} else if (margins.length === 3) {
    			margin.top = margins[0];
    			margin.right = margins[1];
    			margin.bottom = margins[2];
    			margin.left = margins[1];
    		} else if (margins.length === 4) {
    			margin.top = margins[0];
    			margin.right = margins[1];
    			margin.bottom = margins[2];
    			margin.left = margins[3];
    		}

    		return margin;
    	}

    	getPaddings(declaration) {
    		let paddings = [];
    		let padding = {
    			top: {},
    			right: {},
    			left: {},
    			bottom: {}
    		};

    		csstree.walk(declaration, {
    			enter: (node) => {
    				switch (node.type) {
    					case "Dimension": // padding: 1in 2in, padding: 20px, etc...
    						paddings.push(node);
    						break;
    					case "Number": // padding: 0
    						paddings.push({value: node.value, unit: "px"});
    						break;
    					// ignore
    				}
    			}
    		});
    		if (paddings.length === 1) {
    			for (let p in padding) {
    				padding[p] = paddings[0];
    			}
    		} else if (paddings.length === 2) {

    			padding.top = paddings[0];
    			padding.right = paddings[1];
    			padding.bottom = paddings[0];
    			padding.left = paddings[1];
    		} else if (paddings.length === 3) {

    			padding.top = paddings[0];
    			padding.right = paddings[1];
    			padding.bottom = paddings[2];
    			padding.left = paddings[1];
    		} else if (paddings.length === 4) {

    			padding.top = paddings[0];
    			padding.right = paddings[1];
    			padding.bottom = paddings[2];
    			padding.left = paddings[3];
    		}
    		return padding;
    	}

    	// get values for the border on the @page to pass them to the element with the .pagedjs_area class
    	getBorders(declaration) {
    		let border = {
    			top: {},
    			right: {},
    			left: {},
    			bottom: {}
    		};

    		if (declaration.prop == "border") {
    			border.top = csstree.generate(declaration.value);
    			border.right = csstree.generate(declaration.value);
    			border.bottom = csstree.generate(declaration.value);
    			border.left = csstree.generate(declaration.value);

    		}
    		else if (declaration.prop == "border-top") {
    			border.top = csstree.generate(declaration.value);
    		}
    		else if (declaration.prop == "border-right") {
    			border.right = csstree.generate(declaration.value);

    		}
    		else if (declaration.prop == "border-bottom") {
    			border.bottom = csstree.generate(declaration.value);

    		}
    		else if (declaration.prop == "border-left") {
    			border.left = csstree.generate(declaration.value);
    		}

    		return border;
    	}


    	addPageClasses(pages, ast, sheet) {
    		// First add * page
    		if ("*" in pages && pages["*"].added === false) {
    			let p = this.createPage(pages["*"], ast.children, sheet);
    			sheet.insertRule(p);
    			pages["*"].added = true;
    		}
    		// Add :left & :right
    		if (":left" in pages && pages[":left"].added === false) {
    			let left = this.createPage(pages[":left"], ast.children, sheet);
    			sheet.insertRule(left);
    			pages[":left"].added = true;
    		}
    		if (":right" in pages && pages[":right"].added === false) {
    			let right = this.createPage(pages[":right"], ast.children, sheet);
    			sheet.insertRule(right);
    			pages[":right"].added = true;
    		}
    		// Add :first & :blank
    		if (":first" in pages && pages[":first"].added === false) {
    			let first = this.createPage(pages[":first"], ast.children, sheet);
    			sheet.insertRule(first);
    			pages[":first"].added = true;
    		}
    		if (":blank" in pages && pages[":blank"].added === false) {
    			let blank = this.createPage(pages[":blank"], ast.children, sheet);
    			sheet.insertRule(blank);
    			pages[":blank"].added = true;
    		}
    		// Add nth pages
    		for (let pg in pages) {
    			if (pages[pg].nth && pages[pg].added === false) {
    				let nth = this.createPage(pages[pg], ast.children, sheet);
    				sheet.insertRule(nth);
    				pages[pg].added = true;
    			}
    		}

    		// Add named pages
    		for (let pg in pages) {
    			if (pages[pg].name && pages[pg].added === false) {
    				let named = this.createPage(pages[pg], ast.children, sheet);
    				sheet.insertRule(named);
    				pages[pg].added = true;
    			}
    		}

    	}

    	createPage(page, ruleList, sheet) {

    		let selectors = this.selectorsForPage(page);
    		let children = page.block.children.copy();
    		let block = {
    			type: "Block",
    			loc: 0,
    			children: children
    		};


    		let rule = this.createRule(selectors, block);

    		this.addMarginVars(page.margin, children, children.first());
    		this.addPaddingVars(page.padding, children, children.first());
    		this.addBorderVars(page.border, children, children.first());


    		if (page.width) {
    			this.addDimensions(page.width, page.height, page.orientation, children, children.first());
    		}

    		if (page.marginalia) {
    			this.addMarginaliaStyles(page, ruleList, rule, sheet);
    			this.addMarginaliaContent(page, ruleList, rule, sheet);
    		}

    		if(page.notes) {
    			this.addNotesStyles(page.notes, page, ruleList, rule, sheet);
    		}

    		return rule;
    	}

    	addMarginVars(margin, list, item) {
    		// variables for margins
    		for (let m in margin) {
    			if (typeof margin[m].value !== "undefined") {
    				let value = margin[m].value + (margin[m].unit || "");
    				let mVar = list.createItem({
    					type: "Declaration",
    					property: "--pagedjs-margin-" + m,
    					value: {
    						type: "Raw",
    						value: value
    					}
    				});
    				list.append(mVar, item);

    			}
    		}
    	}

    	addPaddingVars(padding, list, item) {
    		// variables for padding
    		for (let p in padding) {

    			if (typeof padding[p].value !== "undefined") {
    				let value = padding[p].value + (padding[p].unit || "");
    				let pVar = list.createItem({
    					type: "Declaration",
    					property: "--pagedjs-padding-" + p,
    					value: {
    						type: "Raw",
    						value: value
    					}
    				});

    				list.append(pVar, item);
    			}

    		}
    	}

    	addBorderVars(border, list, item) {
    		// variables for borders
    		for (const name of Object.keys(border)) {
    			const value = border[name];
    			// value is an empty object when undefined
    			if (typeof value === "string") {
    				const borderItem = list.createItem({
    					type: "Declaration",
    					property: "--pagedjs-border-" + name,
    					value: {
    						type: "Raw",
    						value: value
    					}
    				});
    				list.append(borderItem, item);
    			}
    		}
    	}

    	addDimensions(width, height, orientation, list, item) {
    		let widthString, heightString;

    		widthString = CSSValueToString(width);
    		heightString = CSSValueToString(height);

    		if (orientation && orientation !== "portrait") {
    			// reverse for orientation
    			[widthString, heightString] = [heightString, widthString];
    		}

    		// width variable
    		let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
    		list.appendData(wVar);

    		// height variable
    		let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
    		list.appendData(hVar);

    		// let w = this.createDimension("width", width);
    		// let h = this.createDimension("height", height);
    		// list.appendData(w);
    		// list.appendData(h);
    	}

    	addMarginaliaStyles(page, list, item, sheet) {
    		for (let loc in page.marginalia) {
    			let block = csstree.clone(page.marginalia[loc]);
    			let hasContent = false;

    			if (block.children.isEmpty()) {
    				continue;
    			}

    			csstree.walk(block, {
    				visit: "Declaration",
    				enter: (node, item, list) => {
    					if (node.property === "content") {
    						if (node.value.children && node.value.children.first().name === "none") {
    							hasContent = false;
    						} else {
    							hasContent = true;
    						}
    						list.remove(item);
    					}
    					if (node.property === "vertical-align") {
    						csstree.walk(node, {
    							visit: "Identifier",
    							enter: (identNode, identItem, identlist) => {
    								let name = identNode.name;
    								if (name === "top") {
    									identNode.name = "flex-start";
    								} else if (name === "middle") {
    									identNode.name = "center";
    								} else if (name === "bottom") {
    									identNode.name = "flex-end";
    								}
    							}
    						});
    						node.property = "align-items";
    					}

    					if (node.property === "width" &&
    						(loc === "top-left" ||
    							loc === "top-center" ||
    							loc === "top-right" ||
    							loc === "bottom-left" ||
    							loc === "bottom-center" ||
    							loc === "bottom-right")) {
    						let c = csstree.clone(node);
    						c.property = "max-width";
    						list.appendData(c);
    					}

    					if (node.property === "height" &&
    						(loc === "left-top" ||
    							loc === "left-middle" ||
    							loc === "left-bottom" ||
    							loc === "right-top" ||
    							loc === "right-middle" ||
    							loc === "right-bottom")) {
    						let c = csstree.clone(node);
    						c.property = "max-height";
    						list.appendData(c);
    					}
    				}
    			});

    			let marginSelectors = this.selectorsForPageMargin(page, loc);
    			let marginRule = this.createRule(marginSelectors, block);

    			list.appendData(marginRule);

    			let sel = csstree.generate({
    				type: "Selector",
    				children: marginSelectors
    			});

    			this.marginalia[sel] = {
    				page: page,
    				selector: sel,
    				block: page.marginalia[loc],
    				hasContent: hasContent
    			};

    		}
    	}

    	addMarginaliaContent(page, list, item, sheet) {
    		let displayNone;
    		// Just content
    		for (let loc in page.marginalia) {
    			let content = csstree.clone(page.marginalia[loc]);
    			csstree.walk(content, {
    				visit: "Declaration",
    				enter: (node, item, list) => {
    					if (node.property !== "content") {
    						list.remove(item);
    					}

    					if (node.value.children && node.value.children.first().name === "none") {
    						displayNone = true;
    					}
    				}
    			});

    			if (content.children.isEmpty()) {
    				continue;
    			}

    			let displaySelectors = this.selectorsForPageMargin(page, loc);
    			let displayDeclaration;

    			displaySelectors.insertData({
    				type: "Combinator",
    				name: ">"
    			});

    			displaySelectors.insertData({
    				type: "ClassSelector",
    				name: "pagedjs_margin-content"
    			});

    			displaySelectors.insertData({
    				type: "Combinator",
    				name: ">"
    			});

    			displaySelectors.insertData({
    				type: "TypeSelector",
    				name: "*"
    			});

    			if (displayNone) {
    				displayDeclaration = this.createDeclaration("display", "none");
    			} else {
    				displayDeclaration = this.createDeclaration("display", "block");
    			}

    			let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
    			sheet.insertRule(displayRule);

    			// insert content rule
    			let contentSelectors = this.selectorsForPageMargin(page, loc);

    			contentSelectors.insertData({
    				type: "Combinator",
    				name: ">"
    			});

    			contentSelectors.insertData({
    				type: "ClassSelector",
    				name: "pagedjs_margin-content"
    			});

    			contentSelectors.insertData({
    				type: "PseudoElementSelector",
    				name: "after",
    				children: null
    			});

    			let contentRule = this.createRule(contentSelectors, content);
    			sheet.insertRule(contentRule);
    		}
    	}

    	addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
    		let rules = [];
    		let selectors = new csstree.List();
    		selectors.insertData({
    			type: "PseudoClassSelector",
    			name: "root",
    			children: null
    		});

    		let widthString, heightString;
    		let widthStringRight, heightStringRight;
    		let widthStringLeft, heightStringLeft;

    		if (!bleed) {
    			widthString = CSSValueToString(width);
    			heightString = CSSValueToString(height);
    			widthStringRight = CSSValueToString(width);
    			heightStringRight = CSSValueToString(height);
    			widthStringLeft = CSSValueToString(width);
    			heightStringLeft = CSSValueToString(height);
    		} else {
    			widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
    			heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

    			widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
    			heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

    			widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
    			heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

    			let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
    			let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
    			let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
    			let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

    			let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
    			let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
    			let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
    			let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

    			let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
    			let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
    			let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
    			let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

    			if (bleedrecto) {
    				bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
    				bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
    				bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
    				bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

    				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
    				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
    			}
    			if (bleedverso) {
    				bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
    				bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
    				bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
    				bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

    				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
    				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
    			}

    			let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
    			let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

    			rules.push(
    				bleedTop,
    				bleedRight,
    				bleedBottom,
    				bleedLeft,
    				bleedTopRecto,
    				bleedRightRecto,
    				bleedBottomRecto,
    				bleedLeftRecto,
    				bleedTopVerso,
    				bleedRightVerso,
    				bleedBottomVerso,
    				bleedLeftVerso,
    				pageWidthVar,
    				pageHeightVar
    			);
    		}

    		if (marks) {
    			marks.forEach((mark) => {
    				let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
    				rules.push(markDisplay);
    			});
    		}

    		// orientation variable
    		if (orientation) {
    			let oVar = this.createVariable("--pagedjs-orientation", orientation);
    			rules.push(oVar);

    			if (orientation !== "portrait") {
    				// reverse for orientation
    				[widthString, heightString] = [heightString, widthString];
    				[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
    				[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
    			}
    		}

    		let wVar = this.createVariable("--pagedjs-width", widthString);
    		let hVar = this.createVariable("--pagedjs-height", heightString);

    		let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
    		let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

    		let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
    		let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

    		rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

    		let rule = this.createRule(selectors, rules);

    		ast.children.appendData(rule);
    	}


    	addNotesStyles(notes, page, list, item, sheet) {

    		for (const note in notes) {
    			let selectors = this.selectorsForPage(page);

    			selectors.insertData({
    				type: "Combinator",
    				name: " "
    			});

    			selectors.insertData({
    				type: "ClassSelector",
    				name: "pagedjs_" + note + "_content"
    			});

    			let notesRule = this.createRule(selectors, notes[note]);

    			list.appendData(notesRule);
    		}

    	}

    	/*
    	@page {
    		size: var(--pagedjs-width) var(--pagedjs-height);
    		margin: 0;
    		padding: 0;
    	}
    	*/
    	addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
    		let { width, height, orientation, format } = size;
    		let children = new csstree.List();
    		let childrenLeft = new csstree.List();
    		let childrenRight = new csstree.List();
    		let dimensions = new csstree.List();
    		let dimensionsLeft = new csstree.List();
    		let dimensionsRight = new csstree.List();

    		if (bleed) {
    			let widthCalculations = new csstree.List();
    			let heightCalculations = new csstree.List();

    			// width
    			widthCalculations.appendData({
    				type: "Dimension",
    				unit: width.unit,
    				value: width.value
    			});

    			widthCalculations.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			widthCalculations.appendData({
    				type: "Operator",
    				value: "+"
    			});

    			widthCalculations.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			widthCalculations.appendData({
    				type: "Dimension",
    				unit: bleed.left.unit,
    				value: bleed.left.value
    			});

    			widthCalculations.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			widthCalculations.appendData({
    				type: "Operator",
    				value: "+"
    			});

    			widthCalculations.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			widthCalculations.appendData({
    				type: "Dimension",
    				unit: bleed.right.unit,
    				value: bleed.right.value
    			});

    			// height
    			heightCalculations.appendData({
    				type: "Dimension",
    				unit: height.unit,
    				value: height.value
    			});

    			heightCalculations.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			heightCalculations.appendData({
    				type: "Operator",
    				value: "+"
    			});

    			heightCalculations.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			heightCalculations.appendData({
    				type: "Dimension",
    				unit: bleed.top.unit,
    				value: bleed.top.value
    			});

    			heightCalculations.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			heightCalculations.appendData({
    				type: "Operator",
    				value: "+"
    			});

    			heightCalculations.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			heightCalculations.appendData({
    				type: "Dimension",
    				unit: bleed.bottom.unit,
    				value: bleed.bottom.value
    			});

    			dimensions.appendData({
    				type: "Function",
    				name: "calc",
    				children: widthCalculations
    			});

    			dimensions.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			dimensions.appendData({
    				type: "Function",
    				name: "calc",
    				children: heightCalculations
    			});

    		} else if (format) {
    			dimensions.appendData({
    				type: "Identifier",
    				name: format
    			});

    			if (orientation) {
    				dimensions.appendData({
    					type: "WhiteSpace",
    					value: " "
    				});

    				dimensions.appendData({
    					type: "Identifier",
    					name: orientation
    				});
    			}
    		} else {
    			dimensions.appendData({
    				type: "Dimension",
    				unit: width.unit,
    				value: width.value
    			});

    			dimensions.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			dimensions.appendData({
    				type: "Dimension",
    				unit: height.unit,
    				value: height.value
    			});
    		}

    		children.appendData({
    			type: "Declaration",
    			property: "size",
    			loc: null,
    			value: {
    				type: "Value",
    				children: dimensions
    			}
    		});

    		children.appendData({
    			type: "Declaration",
    			property: "margin",
    			loc: null,
    			value: {
    				type: "Value",
    				children: [{
    					type: "Dimension",
    					unit: "px",
    					value: 0
    				}]
    			}
    		});

    		children.appendData({
    			type: "Declaration",
    			property: "padding",
    			loc: null,
    			value: {
    				type: "Value",
    				children: [{
    					type: "Dimension",
    					unit: "px",
    					value: 0
    				}]
    			}
    		});

    		children.appendData({
    			type: "Declaration",
    			property: "padding",
    			loc: null,
    			value: {
    				type: "Value",
    				children: [{
    					type: "Dimension",
    					unit: "px",
    					value: 0
    				}]
    			}
    		});

    		let rule = ast.children.createItem({
    			type: "Atrule",
    			prelude: null,
    			name: "page",
    			block: {
    				type: "Block",
    				loc: null,
    				children: children
    			}
    		});

    		ast.children.append(rule);

    		if (bleedverso) {
    			let widthCalculationsLeft = new csstree.List();
    			let heightCalculationsLeft = new csstree.List();

    			// width
    			widthCalculationsLeft.appendData({
    				type: "Dimension",
    				unit: width.unit,
    				value: width.value
    			});

    			widthCalculationsLeft.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			widthCalculationsLeft.appendData({
    				type: "Operator",
    				value: "+"
    			});

    			widthCalculationsLeft.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			widthCalculationsLeft.appendData({
    				type: "Dimension",
    				unit: bleedverso.left.unit,
    				value: bleedverso.left.value
    			});

    			widthCalculationsLeft.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			widthCalculationsLeft.appendData({
    				type: "Operator",
    				value: "+"
    			});

    			widthCalculationsLeft.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			widthCalculationsLeft.appendData({
    				type: "Dimension",
    				unit: bleedverso.right.unit,
    				value: bleedverso.right.value
    			});

    			// height
    			heightCalculationsLeft.appendData({
    				type: "Dimension",
    				unit: height.unit,
    				value: height.value
    			});

    			heightCalculationsLeft.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			heightCalculationsLeft.appendData({
    				type: "Operator",
    				value: "+"
    			});

    			heightCalculationsLeft.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			heightCalculationsLeft.appendData({
    				type: "Dimension",
    				unit: bleedverso.top.unit,
    				value: bleedverso.top.value
    			});

    			heightCalculationsLeft.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			heightCalculationsLeft.appendData({
    				type: "Operator",
    				value: "+"
    			});

    			heightCalculationsLeft.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			heightCalculationsLeft.appendData({
    				type: "Dimension",
    				unit: bleedverso.bottom.unit,
    				value: bleedverso.bottom.value
    			});

    			dimensionsLeft.appendData({
    				type: "Function",
    				name: "calc",
    				children: widthCalculationsLeft
    			});

    			dimensionsLeft.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			dimensionsLeft.appendData({
    				type: "Function",
    				name: "calc",
    				children: heightCalculationsLeft
    			});

    			childrenLeft.appendData({
    				type: "Declaration",
    				property: "size",
    				loc: null,
    				value: {
    					type: "Value",
    					children: dimensionsLeft
    				}
    			});

    			let ruleLeft = ast.children.createItem({
    				type: "Atrule",
    				prelude: null,
    				name: "page :left",
    				block: {
    					type: "Block",
    					loc: null,
    					children: childrenLeft
    				}
    			});

    			ast.children.append(ruleLeft);

    		}

    		if (bleedrecto) {
    			let widthCalculationsRight = new csstree.List();
    			let heightCalculationsRight = new csstree.List();

    			// width
    			widthCalculationsRight.appendData({
    				type: "Dimension",
    				unit: width.unit,
    				value: width.value
    			});

    			widthCalculationsRight.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			widthCalculationsRight.appendData({
    				type: "Operator",
    				value: "+"
    			});

    			widthCalculationsRight.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			widthCalculationsRight.appendData({
    				type: "Dimension",
    				unit: bleedrecto.left.unit,
    				value: bleedrecto.left.value
    			});

    			widthCalculationsRight.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			widthCalculationsRight.appendData({
    				type: "Operator",
    				value: "+"
    			});

    			widthCalculationsRight.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			widthCalculationsRight.appendData({
    				type: "Dimension",
    				unit: bleedrecto.right.unit,
    				value: bleedrecto.right.value
    			});

    			// height
    			heightCalculationsRight.appendData({
    				type: "Dimension",
    				unit: height.unit,
    				value: height.value
    			});

    			heightCalculationsRight.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			heightCalculationsRight.appendData({
    				type: "Operator",
    				value: "+"
    			});

    			heightCalculationsRight.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			heightCalculationsRight.appendData({
    				type: "Dimension",
    				unit: bleedrecto.top.unit,
    				value: bleedrecto.top.value
    			});

    			heightCalculationsRight.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			heightCalculationsRight.appendData({
    				type: "Operator",
    				value: "+"
    			});

    			heightCalculationsRight.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			heightCalculationsRight.appendData({
    				type: "Dimension",
    				unit: bleedrecto.bottom.unit,
    				value: bleedrecto.bottom.value
    			});

    			dimensionsRight.appendData({
    				type: "Function",
    				name: "calc",
    				children: widthCalculationsRight
    			});

    			dimensionsRight.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			dimensionsRight.appendData({
    				type: "Function",
    				name: "calc",
    				children: heightCalculationsRight
    			});

    			childrenRight.appendData({
    				type: "Declaration",
    				property: "size",
    				loc: null,
    				value: {
    					type: "Value",
    					children: dimensionsRight
    				}
    			});

    			let ruleRight = ast.children.createItem({
    				type: "Atrule",
    				prelude: null,
    				name: "page :right",
    				block: {
    					type: "Block",
    					loc: null,
    					children: childrenRight
    				}
    			});

    			ast.children.append(ruleRight);

    		}
    	}

    	getNth(nth) {
    		let n = nth.indexOf("n");
    		let plus = nth.indexOf("+");
    		let splitN = nth.split("n");
    		let splitP = nth.split("+");
    		let a = null;
    		let b = null;
    		if (n > -1) {
    			a = splitN[0];
    			if (plus > -1) {
    				b = splitP[1];
    			}
    		} else {
    			b = nth;
    		}

    		return {
    			type: "Nth",
    			loc: null,
    			selector: null,
    			nth: {
    				type: "AnPlusB",
    				loc: null,
    				a: a,
    				b: b
    			}
    		};
    	}

    	addPageAttributes(page, start, pages) {
    		let namedPages = [start.dataset.page];

    		if (namedPages && namedPages.length) {
    			for (const named of namedPages) {
    				if (!named) {
    					continue;
    				}
    				page.name = named;
    				page.element.classList.add("pagedjs_named_page");
    				page.element.classList.add("pagedjs_" + named + "_page");

    				if (!start.dataset.splitFrom) {
    					page.element.classList.add("pagedjs_" + named + "_first_page");
    				}
    			}
    		}
    	}

    	getStartElement(content, breakToken) {
    		let node = breakToken && breakToken.node;

    		if (!content && !breakToken) {
    			return;
    		}

    		// No break
    		if (!node) {
    			return content.children[0];
    		}

    		// Top level element
    		if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
    			return node;
    		}

    		// Named page
    		if (node.nodeType === 1 && node.dataset.page) {
    			return node;
    		}

    		// Get top level Named parent
    		let fragment = rebuildAncestors(node);
    		let pages = fragment.querySelectorAll("[data-page]");

    		if (pages.length) {
    			return pages[pages.length - 1];
    		} else {
    			return fragment.children[0];
    		}
    	}

    	beforePageLayout(page, contents, breakToken, chunker) {
    		let start = this.getStartElement(contents, breakToken);
    		if (start) {
    			this.addPageAttributes(page, start, chunker.pages);
    		}
    		// page.element.querySelector('.paged_area').style.color = red;
    	}

    	finalizePage(fragment, page, breakToken, chunker) {
    		for (let m in this.marginalia) {
    			let margin = this.marginalia[m];
    			let sels = m.split(" ");

    			let content;
    			if (page.element.matches(sels[0]) && margin.hasContent) {
    				content = page.element.querySelector(sels[1]);
    				content.classList.add("hasContent");
    			}
    		}

    		// check center
    		["top", "bottom"].forEach((loc) => {
    			let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
    			let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
    			let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
    			let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

    			let centerContent = center.classList.contains("hasContent");
    			let leftContent = left.classList.contains("hasContent");
    			let rightContent = right.classList.contains("hasContent");
    			let centerWidth, leftWidth, rightWidth;

    			if (leftContent) {
    				leftWidth = window.getComputedStyle(left)["max-width"];
    			}

    			if (rightContent) {
    				rightWidth = window.getComputedStyle(right)["max-width"];
    			}


    			if (centerContent) {
    				centerWidth = window.getComputedStyle(center)["max-width"];

    				if (centerWidth === "none" || centerWidth === "auto") {
    					if (!leftContent && !rightContent) {
    						marginGroup.style["grid-template-columns"] = "0 1fr 0";
    					} else if (leftContent) {
    						if (!rightContent) {
    							if (leftWidth !== "none" && leftWidth !== "auto") {
    								marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
    							} else {
    								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
    								left.style["white-space"] = "nowrap";
    								center.style["white-space"] = "nowrap";
    								let leftOuterWidth = left.offsetWidth;
    								let centerOuterWidth = center.offsetWidth;
    								let outerwidths = leftOuterWidth + centerOuterWidth;
    								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
    								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
    								left.style["white-space"] = "normal";
    								center.style["white-space"] = "normal";
    							}
    						} else {
    							if (leftWidth !== "none" && leftWidth !== "auto") {
    								if (rightWidth !== "none" && rightWidth !== "auto") {
    									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
    								} else {
    									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
    								}
    							} else {
    								if (rightWidth !== "none" && rightWidth !== "auto") {
    									marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
    								} else {
    									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
    									left.style["white-space"] = "nowrap";
    									center.style["white-space"] = "nowrap";
    									right.style["white-space"] = "nowrap";
    									let leftOuterWidth = left.offsetWidth;
    									let centerOuterWidth = center.offsetWidth;
    									let rightOuterWidth = right.offsetWidth;
    									let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
    									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
    									if (newcenterWidth > 40) {
    										marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
    									} else {
    										marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
    									}
    									left.style["white-space"] = "normal";
    									center.style["white-space"] = "normal";
    									right.style["white-space"] = "normal";
    								}
    							}
    						}
    					} else {
    						if (rightWidth !== "none" && rightWidth !== "auto") {
    							marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
    						} else {
    							marginGroup.style["grid-template-columns"] = "auto auto 1fr";
    							right.style["white-space"] = "nowrap";
    							center.style["white-space"] = "nowrap";
    							let rightOuterWidth = right.offsetWidth;
    							let centerOuterWidth = center.offsetWidth;
    							let outerwidths = rightOuterWidth + centerOuterWidth;
    							let newcenterWidth = centerOuterWidth * 100 / outerwidths;
    							marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
    							right.style["white-space"] = "normal";
    							center.style["white-space"] = "normal";
    						}
    					}
    				} else if (centerWidth !== "none" && centerWidth !== "auto") {
    					if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
    						marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
    					} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
    						marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
    					} else {
    						marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
    					}

    				}

    			} else {
    				if (leftContent) {
    					if (!rightContent) {
    						marginGroup.style["grid-template-columns"] = "1fr 0 0";
    					} else {
    						if (leftWidth !== "none" && leftWidth !== "auto") {
    							if (rightWidth !== "none" && rightWidth !== "auto") {
    								marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
    							} else {
    								marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
    							}
    						} else {
    							if (rightWidth !== "none" && rightWidth !== "auto") {
    								marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
    							} else {
    								marginGroup.style["grid-template-columns"] = "auto 1fr auto";
    								left.style["white-space"] = "nowrap";
    								right.style["white-space"] = "nowrap";
    								let leftOuterWidth = left.offsetWidth;
    								let rightOuterWidth = right.offsetWidth;
    								let outerwidths = leftOuterWidth + rightOuterWidth;
    								let newLeftWidth = leftOuterWidth * 100 / outerwidths;
    								marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
    								left.style["white-space"] = "normal";
    								right.style["white-space"] = "normal";
    							}
    						}
    					}
    				} else {
    					if (rightWidth !== "none" && rightWidth !== "auto") {
    						marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
    					} else {
    						marginGroup.style["grid-template-columns"] = "0 0 1fr";
    					}
    				}
    			}
    		});

    		// check middle
    		["left", "right"].forEach((loc) => {
    			let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
    			let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
    			let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
    			let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
    			let topContent = top.classList.contains("hasContent");
    			let bottomContent = bottom.classList.contains("hasContent");
    			let middleHeight, topHeight, bottomHeight;

    			if (topContent) {
    				topHeight = window.getComputedStyle(top)["max-height"];
    			}

    			if (bottomContent) {
    				bottomHeight = window.getComputedStyle(bottom)["max-height"];
    			}

    			if (middle) {
    				middleHeight = window.getComputedStyle(middle)["max-height"];

    				if (middleHeight === "none" || middleHeight === "auto") {
    					if (!topContent && !bottomContent) {
    						marginGroup.style["grid-template-rows"] = "0 1fr 0";
    					} else if (topContent) {
    						if (!bottomContent) {
    							if (topHeight !== "none" && topHeight !== "auto") {
    								marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
    							}
    						} else {
    							if (topHeight !== "none" && topHeight !== "auto") {
    								if (bottomHeight !== "none" && bottomHeight !== "auto") {
    									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
    								} else {
    									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
    								}
    							} else {
    								if (bottomHeight !== "none" && bottomHeight !== "auto") {
    									marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
    								}
    							}
    						}
    					} else {
    						if (bottomHeight !== "none" && bottomHeight !== "auto") {
    							marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
    						}
    					}
    				} else {
    					if (topContent && topHeight !== "none" && topHeight !== "auto") {
    						marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
    					} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
    						marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
    					} else {
    						marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
    					}

    				}

    			} else {
    				if (topContent) {
    					if (!bottomContent) {
    						marginGroup.style["grid-template-rows"] = "1fr 0 0";
    					} else {
    						if (topHeight !== "none" && topHeight !== "auto") {
    							if (bottomHeight !== "none" && bottomHeight !== "auto") {
    								marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
    							} else {
    								marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
    							}
    						} else {
    							if (bottomHeight !== "none" && bottomHeight !== "auto") {
    								marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
    							} else {
    								marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
    							}
    						}
    					}
    				} else {
    					if (bottomHeight !== "none" && bottomHeight !== "auto") {
    						marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
    					} else {
    						marginGroup.style["grid-template-rows"] = "0 0 1fr";
    					}
    				}
    			}



    		});

    	}

    	// CSS Tree Helpers

    	selectorsForPage(page) {
    		let nthlist;
    		let nth;

    		let selectors = new csstree.List();

    		selectors.insertData({
    			type: "ClassSelector",
    			name: "pagedjs_page"
    		});

    		// Named page
    		if (page.name) {
    			selectors.insertData({
    				type: "ClassSelector",
    				name: "pagedjs_named_page"
    			});

    			selectors.insertData({
    				type: "ClassSelector",
    				name: "pagedjs_" + page.name + "_page"
    			});
    		}

    		// PsuedoSelector
    		if (page.psuedo && !(page.name && page.psuedo === "first")) {
    			selectors.insertData({
    				type: "ClassSelector",
    				name: "pagedjs_" + page.psuedo + "_page"
    			});
    		}

    		if (page.name && page.psuedo === "first") {
    			selectors.insertData({
    				type: "ClassSelector",
    				name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
    			});
    		}

    		// Nth
    		if (page.nth) {
    			nthlist = new csstree.List();
    			nth = this.getNth(page.nth);

    			nthlist.insertData(nth);

    			selectors.insertData({
    				type: "PseudoClassSelector",
    				name: "nth-of-type",
    				children: nthlist
    			});
    		}

    		return selectors;
    	}

    	selectorsForPageMargin(page, margin) {
    		let selectors = this.selectorsForPage(page);

    		selectors.insertData({
    			type: "Combinator",
    			name: " "
    		});

    		selectors.insertData({
    			type: "ClassSelector",
    			name: "pagedjs_margin-" + margin
    		});

    		return selectors;
    	}

    	createDeclaration(property, value, important) {
    		let children = new csstree.List();

    		children.insertData({
    			type: "Identifier",
    			loc: null,
    			name: value
    		});

    		return {
    			type: "Declaration",
    			loc: null,
    			important: important,
    			property: property,
    			value: {
    				type: "Value",
    				loc: null,
    				children: children
    			}
    		};
    	}

    	createVariable(property, value) {
    		return {
    			type: "Declaration",
    			loc: null,
    			property: property,
    			value: {
    				type: "Raw",
    				value: value
    			}
    		};
    	}

    	createCalculatedDimension(property, items, important, operator = "+") {
    		let children = new csstree.List();
    		let calculations = new csstree.List();

    		items.forEach((item, index) => {
    			calculations.appendData({
    				type: "Dimension",
    				unit: item.unit,
    				value: item.value
    			});

    			calculations.appendData({
    				type: "WhiteSpace",
    				value: " "
    			});

    			if (index + 1 < items.length) {
    				calculations.appendData({
    					type: "Operator",
    					value: operator
    				});

    				calculations.appendData({
    					type: "WhiteSpace",
    					value: " "
    				});
    			}
    		});

    		children.insertData({
    			type: "Function",
    			loc: null,
    			name: "calc",
    			children: calculations
    		});

    		return {
    			type: "Declaration",
    			loc: null,
    			important: important,
    			property: property,
    			value: {
    				type: "Value",
    				loc: null,
    				children: children
    			}
    		};
    	}

    	createDimension(property, cssValue, important) {
    		let children = new csstree.List();

    		children.insertData({
    			type: "Dimension",
    			loc: null,
    			value: cssValue.value,
    			unit: cssValue.unit
    		});

    		return {
    			type: "Declaration",
    			loc: null,
    			important: important,
    			property: property,
    			value: {
    				type: "Value",
    				loc: null,
    				children: children
    			}
    		};
    	}

    	createBlock(declarations) {
    		let block = new csstree.List();

    		declarations.forEach((declaration) => {
    			block.insertData(declaration);
    		});

    		return {
    			type: "Block",
    			loc: null,
    			children: block
    		};
    	}

    	createRule(selectors, block) {
    		let selectorList = new csstree.List();
    		selectorList.insertData({
    			type: "Selector",
    			children: selectors
    		});

    		if (Array.isArray(block)) {
    			block = this.createBlock(block);
    		}

    		return {
    			type: "Rule",
    			prelude: {
    				type: "SelectorList",
    				children: selectorList
    			},
    			block: block
    		};
    	}

    }

    class Breaks extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);

    		this.breaks = {};
    	}

    	onDeclaration(declaration, dItem, dList, rule) {
    		let property = declaration.property;

    		if (property === "page") {
    			let children = declaration.value.children.first();
    			let value = children.name;
    			let selector = csstree.generate(rule.ruleNode.prelude);
    			let name = value;

    			let breaker = {
    				property: property,
    				value: value,
    				selector: selector,
    				name: name
    			};

    			selector.split(",").forEach((s) => {
    				if (!this.breaks[s]) {
    					this.breaks[s] = [breaker];
    				} else {
    					this.breaks[s].push(breaker);
    				}
    			});

    			dList.remove(dItem);
    		}

    		if (property === "break-before" ||
    				property === "break-after" ||
    				property === "page-break-before" ||
    				property === "page-break-after"
    		) {
    			let child = declaration.value.children.first();
    			let value = child.name;
    			let selector = csstree.generate(rule.ruleNode.prelude);

    			if (property === "page-break-before") {
    				property = "break-before";
    			} else if (property === "page-break-after") {
    				property = "break-after";
    			}

    			let breaker = {
    				property: property,
    				value: value,
    				selector: selector
    			};

    			selector.split(",").forEach((s) => {
    				if (!this.breaks[s]) {
    					this.breaks[s] = [breaker];
    				} else {
    					this.breaks[s].push(breaker);
    				}
    			});

    			// Remove from CSS -- handle right / left in module
    			dList.remove(dItem);
    		}
    	}

    	afterParsed(parsed) {
    		this.processBreaks(parsed, this.breaks);
    	}

    	processBreaks(parsed, breaks) {
    		for (let b in breaks) {
    			// Find elements
    			let elements = parsed.querySelectorAll(b);
    			// Add break data
    			for (var i = 0; i < elements.length; i++) {
    				for (let prop of breaks[b]) {

    					if (prop.property === "break-after") {
    						let nodeAfter = displayedElementAfter(elements[i], parsed);

    						elements[i].setAttribute("data-break-after", prop.value);

    						if (nodeAfter) {
    							nodeAfter.setAttribute("data-previous-break-after", prop.value);
    						}
    					} else if (prop.property === "break-before") {
    						let nodeBefore = displayedElementBefore(elements[i], parsed);

    						// Breaks are only allowed between siblings, not between a box and its container.
    						// If we cannot find a node before we should not break!
    						// https://drafts.csswg.org/css-break-3/#break-propagation
    						if (nodeBefore) {
    							if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
    								// we ignore this explicit page break because an implicit page break is already needed
    								continue;
    							}
    							elements[i].setAttribute("data-break-before", prop.value);
    							nodeBefore.setAttribute("data-next-break-before", prop.value);
    						}
    					} else if (prop.property === "page") {
    						elements[i].setAttribute("data-page", prop.value);

    						let nodeAfter = displayedElementAfter(elements[i], parsed);

    						if (nodeAfter) {
    							nodeAfter.setAttribute("data-after-page", prop.value);
    						}
    					} else {
    						elements[i].setAttribute("data-" + prop.property, prop.value);
    					}
    				}
    			}
    		}
    	}

    	mergeBreaks(pageBreaks, newBreaks) {
    		for (let b in newBreaks) {
    			if (b in pageBreaks) {
    				pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
    			} else {
    				pageBreaks[b] = newBreaks[b];
    			}
    		}
    		return pageBreaks;
    	}

    	addBreakAttributes(pageElement, page) {
    		let before = pageElement.querySelector("[data-break-before]");
    		let after = pageElement.querySelector("[data-break-after]");
    		let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

    		if (before) {
    			if (before.dataset.splitFrom) {
    				page.splitFrom = before.dataset.splitFrom;
    				pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
    			} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
    				page.breakBefore = before.dataset.breakBefore;
    				pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
    			}
    		}

    		if (after && after.dataset) {
    			if (after.dataset.splitTo) {
    				page.splitTo = after.dataset.splitTo;
    				pageElement.setAttribute("data-split-to", after.dataset.splitTo);
    			} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
    				page.breakAfter = after.dataset.breakAfter;
    				pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
    			}
    		}

    		if (previousBreakAfter && previousBreakAfter.dataset) {
    			if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
    				page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
    			}
    		}
    	}

    	afterPageLayout(pageElement, page) {
    		this.addBreakAttributes(pageElement, page);
    	}
    }

    class PrintMedia extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);
    	}

    	onAtMedia(node, item, list) {
    		let media = this.getMediaName(node);
    		let rules;
    		if (media.includes("print")) {
    			rules = node.block.children;

    			// Append rules to the end of main rules list
    			// TODO: this isn't working right, needs to check what is in the prelude
    			/*
    			rules.forEach((selectList) => {
    				if (selectList.prelude) {
    					selectList.prelude.children.forEach((rule) => {

    						rule.children.prependData({
    							type: "Combinator",
    							name: " "
    						});
    	
    						rule.children.prependData({
    							type: "ClassSelector",
    							name: "pagedjs_page"
    						});
    					});	
    				}
    			});

    			list.insertList(rules, item);
    			*/

    			// Append rules to the end of main rules list
    			list.appendList(rules);

    			// Remove rules from the @media block
    			list.remove(item);
    		} else if (!media.includes("all") && !media.includes("pagedjs-ignore")) {
    			list.remove(item);
    		}

    	}

    	getMediaName(node) {
    		let media = [];

    		if (typeof node.prelude === "undefined" ||
    				node.prelude.type !== "AtrulePrelude" ) {
    			return;
    		}

    		csstree.walk(node.prelude, {
    			visit: "Identifier",
    			enter: (identNode, iItem, iList) => {
    				media.push(identNode.name);
    			}
    		});
    		return media;
    	}


    }

    class Splits extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);
    	}

    	afterPageLayout(pageElement, page, breakToken, chunker) {
    		let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
    		let pages = pageElement.parentNode;
    		let index = Array.prototype.indexOf.call(pages.children, pageElement);
    		let prevPage;

    		if (index === 0) {
    			return;
    		}

    		prevPage = pages.children[index - 1];

    		let from; // Capture the last from element
    		splits.forEach((split) => {
    			let ref = split.dataset.ref;
    			from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

    			if (from) {
    				from.dataset.splitTo = ref;

    				if (!from.dataset.splitFrom) {
    					from.dataset.splitOriginal = true;
    				}
    			}
    		});

    		// Fix alignment on the deepest split element
    		if (from) {
    			this.handleAlignment(from);
    		}
    	}

    	handleAlignment(node) {
    		let styles = window.getComputedStyle(node);
    		let align = styles["text-align"];
    		let alignLast = styles["text-align-last"];
    		node.dataset.lastSplitElement = "true";
    		if (align === "justify" && alignLast === "auto") {
    			node.dataset.alignLastSplitElement = "justify";
    		} else {
    			node.dataset.alignLastSplitElement = alignLast;
    		}
    	}

    }

    class Counters extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);

    		this.styleSheet = polisher.styleSheet;
    		this.counters = {};
    		this.resetCountersMap = new Map();
    	}

    	onDeclaration(declaration, dItem, dList, rule) {
    		let property = declaration.property;

    		if (property === "counter-increment") {
    			this.handleIncrement(declaration, rule);
    			// clean up empty declaration
    			let hasProperities = false;
    			declaration.value.children.forEach((data) => {
    				if (data.type && data.type !== "WhiteSpace") {
    					hasProperities = true;
    				}
    			});
    			if (!hasProperities) {
    				dList.remove(dItem);
    			}
    		} else if (property === "counter-reset") {
    			this.handleReset(declaration, rule);
    			// clean up empty declaration
    			let hasProperities = false;
    			declaration.value.children.forEach((data) => {
    				if (data.type && data.type !== "WhiteSpace") {
    					hasProperities = true;
    				}
    			});
    			if (!hasProperities) {
    				dList.remove(dItem);
    			}
    		}
    	}

    	afterParsed(parsed) {
    		this.processCounters(parsed, this.counters);
    		this.scopeCounters(this.counters);
    	}

    	addCounter(name) {
    		if (name in this.counters) {
    			return this.counters[name];
    		}

    		this.counters[name] = {
    			name: name,
    			increments: {},
    			resets: {}
    		};

    		return this.counters[name];
    	}

    	handleIncrement(declaration, rule) {
    		let increments = [];
    		let children = declaration.value.children;

    		children.forEach((data, item) => {
    			if (data.type && data.type === "Identifier") {
    				let name = data.name;

    				if (name === "page" || name.indexOf("target-counter-") === 0) {
    					return;
    				}

    				let whitespace, number, value;
    				if (item.next && item.next.data.type === "WhiteSpace") {
    					whitespace = item.next;
    				}
    				if (whitespace && whitespace.next && whitespace.next.data.type === "Number") {
    					number = whitespace.next;
    					value = parseInt(number.data.value);
    				}

    				let selector = csstree.generate(rule.ruleNode.prelude);

    				let counter;
    				if (!(name in this.counters)) {
    					counter = this.addCounter(name);
    				} else {
    					counter = this.counters[name];
    				}
    				let increment = {
    					selector: selector,
    					number: value || 1
    				};
    				counter.increments[selector] = increment;
    				increments.push(increment);

    				// Remove the parsed resets
    				children.remove(item);
    				if (whitespace) {
    					children.remove(whitespace);
    				}
    				if (number) {
    					children.remove(number);
    				}
    			}
    		});
    		
    		return increments;
    	}

    	handleReset(declaration, rule) {
    		let children = declaration.value.children;

    		children.forEach((data, item) => {
    			if (data.type && data.type === "Identifier") {
    				let name = data.name;
    				let whitespace, number, value;
    				if (item.next && item.next.data.type === "WhiteSpace") {
    					whitespace = item.next;
    				}
    				if (whitespace && whitespace.next) {
    					if (whitespace.next.data.type === "Number") {
    						// The counter reset value is specified using a number. E.g. counter-reset: c2 5;
    						number = whitespace.next;
    						value = parseInt(number.data.value);
    					} else if (whitespace.next.data.type === "Function" && whitespace.next.data.name === "var") {
    						// The counter reset value is specified using a CSS variable (custom property).
    						// E.g. counter-reset: c2 var(--my-variable);
    						// See https://developer.mozilla.org/en-US/docs/Web/CSS/var
    						number = whitespace.next;
    						// Use the variable name (e.g. '--my-variable') as value for now. The actual value is resolved later by the
    						// processCounterResets function.
    						value = whitespace.next.data.children.head.data.name;
    					}
    				}

    				let counter;
    				let selector;
    				let prelude = rule.ruleNode.prelude;

    				if (rule.ruleNode.type === "Atrule" && rule.ruleNode.name === "page") {
    					selector = ".pagedjs_page";
    				} else {
    					selector = csstree.generate(prelude || rule.ruleNode);
    				}

    				if (name === "footnote") {
    					this.addFootnoteMarkerCounter(declaration.value.children);
    				}

    				if (!(name in this.counters)) {
    					counter = this.addCounter(name);
    				} else {
    					counter = this.counters[name];
    				}

    				let reset = {
    					selector: selector,
    					number: value || 0
    				};

    				counter.resets[selector] = reset;

    				if (selector !== ".pagedjs_page") {
    					// Remove the parsed resets
    					children.remove(item);
    					if (whitespace) {
    						children.remove(whitespace);
    					}
    					if (number) {
    						children.remove(number);
    					}
    				}
    			}
    		});
    	}

    	processCounters(parsed, counters) {
    		let counter;
    		for (let c in counters) {
    			counter = this.counters[c];
    			this.processCounterIncrements(parsed, counter);
    			this.processCounterResets(parsed, counter);
    			if (c !== "page") {
    				this.addCounterValues(parsed, counter);
    			}
    		}
    	}

    	scopeCounters(counters) {
    		let countersArray = [];
    		for (let c in counters) {
    			if(c !== "page") {
    				countersArray.push(`${counters[c].name} 0`);
    			}
    		}
    		// Add to pages to allow cross page scope
    		this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count) footnote var(--pagedjs-footnotes-count) footnote-marker var(--pagedjs-footnotes-count)}`);
    	}

    	insertRule(rule) {
    		this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
    	}

    	processCounterIncrements(parsed, counter) {
    		let increment;
    		for (let inc in counter.increments) {
    			increment = counter.increments[inc];
    			// Find elements for increments
    			let incrementElements = parsed.querySelectorAll(increment.selector);
    			// Add counter data
    			for (let i = 0; i < incrementElements.length; i++) {
    				incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
    				if (incrementElements[i].getAttribute("data-counter-increment")) {
    					incrementElements[i].setAttribute("data-counter-increment", incrementElements[i].getAttribute("data-counter-increment") + " " + counter.name);
    				} else {
    					incrementElements[i].setAttribute("data-counter-increment", counter.name);
    				}
    			}
    		}
    	}

    	processCounterResets(parsed, counter) {
    		let reset;
    		for (let r in counter.resets) {
    			reset = counter.resets[r];
    			// Find elements for resets
    			let resetElements = parsed.querySelectorAll(reset.selector);
    			// Add counter data
    			for (var i = 0; i < resetElements.length; i++) {
    				let value = reset.number;
    				if (typeof value === "string" && value.startsWith("--")) {
    					// The value is specified using a CSS variable (custom property).
    					// FIXME: We get the variable value only from the inline style of the element because at this point the
    					// element is detached and thus using:
    					//
    					//		getComputedStyle(resetElements[i]).getPropertyValue(value)
    					//
    					// always returns an empty string. We could try to temporarily attach the element to get its computed style,
    					// but for now using the inline style is enough for us.
    					value = resetElements[i].style.getPropertyValue(value) || 0;
    				}
    				resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", value);
    				if (resetElements[i].getAttribute("data-counter-reset")) {
    					resetElements[i].setAttribute("data-counter-reset", resetElements[i].getAttribute("data-counter-reset") + " " + counter.name);
    				} else {
    					resetElements[i].setAttribute("data-counter-reset", counter.name);
    				}
    			}
    		}
    	}

    	addCounterValues(parsed, counter) {
    		let counterName = counter.name;

    		if (counterName === "page" || counterName === "footnote") {
    			return;
    		}

    		let elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

    		let count = 0;
    		let element;
    		let increment, reset;
    		let resetValue, incrementValue, resetDelta;
    		let incrementArray;

    		for (let i = 0; i < elements.length; i++) {
    			element = elements[i];
    			resetDelta = 0;
    			incrementArray = [];

    			if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
    				reset = element.getAttribute("data-counter-"+ counterName +"-reset");
    				resetValue = parseInt(reset);

    				// Use negative increment value inplace of reset
    				resetDelta = resetValue - count;
    				incrementArray.push(`${counterName} ${resetDelta}`);

    				count = resetValue;
    			}

    			if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

    				increment = element.getAttribute("data-counter-"+ counterName +"-increment");
    				incrementValue = parseInt(increment);

    				count += incrementValue;

    				element.setAttribute("data-counter-"+counterName+"-value", count);

    				incrementArray.push(`${counterName} ${incrementValue}`);
    			}

    			if (incrementArray.length > 0) {
    				this.incrementCounterForElement(element, incrementArray);
    			}

    		}
    	}

    	addFootnoteMarkerCounter(list) {
    		let markers = [];
    		csstree.walk(list, {
    			visit: "Identifier",
    			enter: (identNode, iItem, iList) => {
    				markers.push(identNode.name);
    			}
    		});

    		// Already added
    		if (markers.includes("footnote-maker")) {
    			return;
    		}

    		list.insertData({
    			type: "WhiteSpace",
    			value: " "
    		});

    		list.insertData({
    			type: "Identifier",
    			name: "footnote-marker"
    		});

    		list.insertData({
    			type: "WhiteSpace",
    			value: " "
    		});

    		list.insertData({
    			type: "Number",
    			value: 0
    		});
    	}

    	incrementCounterForElement(element, incrementArray) {
    		if (!element || !incrementArray || incrementArray.length === 0) return;

    		const ref = element.dataset.ref;
    		const increments = Array.from(this.styleSheet.cssRules).filter((rule) => {
    			return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
    						 && rule.style[0] === "counter-increment";
    		}).map(rule => rule.style.counterIncrement);

    		// Merge the current increments by summing the values because we generate both a decrement and an increment when the
    		// element resets and increments the counter at the same time. E.g. ['c1 -7', 'c1 1'] should lead to 'c1 -6'.
    		increments.push(this.mergeIncrements(incrementArray,
    			(prev, next) => (parseInt(prev) || 0) + (parseInt(next) || 0)));

    		// Keep the last value for each counter when merging with the previous increments. E.g. ['c1 -7 c2 3', 'c1 1']
    		// should lead to 'c1 1 c2 3'.
    		const counterIncrement = this.mergeIncrements(increments, (prev, next) => next);
    		this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${counterIncrement} }`);
    	}

    	/**
    	 * Merge multiple values of a counter-increment CSS rule, using the specified operator.
    	 *
    	 * @param {Array} incrementArray the values to merge, e.g. ['c1 1', 'c1 -7 c2 1']
    	 * @param {Function} operator the function used to merge counter values (e.g. keep the last value of a counter or sum
    	 *					the counter values)
    	 * @return {string} the merged value of the counter-increment CSS rule
    	 */
    	mergeIncrements(incrementArray, operator) {
    		const increments = {};
    		incrementArray.forEach(increment => {
    			let values = increment.split(" ");
    			for (let i = 0; i < values.length; i+=2) {
    				increments[values[i]] = operator(increments[values[i]], values[i + 1]);
    			}
    		});

    		return Object.entries(increments).map(([key, value]) => `${key} ${value}`).join(" ");
    	}

    	afterPageLayout(pageElement, page) {
    		let resets = [];

    		let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]:not([data-split-from])");
    		pgreset.forEach((reset) => {
    			const ref = reset.dataset && reset.dataset.ref;
    			if (ref && this.resetCountersMap.has(ref)) ; else {
    				if (ref) {
    					this.resetCountersMap.set(ref, "");
    				}
    				let value = reset.dataset.counterPageReset;
    				resets.push(`page ${value}`);
    			}
    		});

    		let notereset = pageElement.querySelectorAll("[data-counter-footnote-reset]:not([data-split-from])");
    		notereset.forEach((reset) => {
    			let value = reset.dataset.counterFootnoteReset;
    			resets.push(`footnote ${value}`);
    			resets.push(`footnote-marker ${value}`);
    		});

    		if (resets.length) {
    			this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: ${resets.join(" ")} }`, this.styleSheet.cssRules.length);
    		}
    	}

    }

    class Lists extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);
    	}
    	afterParsed(content) {
    		const orderedLists = content.querySelectorAll("ol");

    		for (var list of orderedLists) {
    			this.addDataNumbers(list);
    		}
    	}

    	afterPageLayout(pageElement, page, breakToken, chunker) {
    		var orderedLists = pageElement.getElementsByTagName("ol");
    		for (var list of orderedLists) {
    			if (list.firstElementChild) {
    				list.start = list.firstElementChild.dataset.itemNum;
    			}
    		}
    	}

    	addDataNumbers(list) {
    		let start = 1;
    		if (list.hasAttribute("start")) {
    			start = parseInt(list.getAttribute("start"), 10);
    			if (isNaN(start)) {
    				start = 1;
    			}
    		}
    		let items = list.children;
    		for (var i = 0; i < items.length; i++) {
    			items[i].setAttribute("data-item-num", i + start);
    		}
    	}

    }

    class PositionFixed extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);
    		this.styleSheet = polisher.styleSheet;
    		this.fixedElementsSelector = [];
    		this.fixedElements = [];
    	}

    	onDeclaration(declaration, dItem, dList, rule) {
    		if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
    			let selector = csstree.generate(rule.ruleNode.prelude);
    			this.fixedElementsSelector.push(selector);
    			dList.remove(dItem);
    		}
    	}

    	afterParsed(fragment) {
    		this.fixedElementsSelector.forEach(fixedEl => {
    			fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
    				el.style.setProperty("position", "absolute");
    				this.fixedElements.push(el);
    				el.remove();
    			});
    		});
    	}

    	afterPageLayout(pageElement, page, breakToken) {
    		this.fixedElements.forEach(el => {
    			const clone = el.cloneNode(true);
    			pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
    		});
    	}
    }

    class PageCounterIncrement extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);

    		this.styleSheet = polisher.styleSheet;
    		this.pageCounter = {
    			name: "page",
    			increments: {},
    			resets: {}
    		};
    	}

    	onDeclaration(declaration, dItem, dList, rule) {
    		const property = declaration.property;

    		if (property === "counter-increment") {
    			let inc = this.handleIncrement(declaration, rule);
    			if (inc) {
    				dList.remove(dItem);
    			}
    		}
    	}

    	afterParsed(_) {
    		for (const inc in this.pageCounter.increments) {
    			const increment = this.pageCounter.increments[inc];
    			this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
    		}
    	}

    	handleIncrement(declaration, rule) {
    		const identifier = declaration.value.children.first();
    		const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
    		const name = identifier && identifier.name;

    		if (name && name.indexOf("target-counter-") === 0) {
    			return;
    		}
    		// A counter named page is automatically created and incremented by 1 on every page of the document,
    		// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
    		// https://www.w3.org/TR/css-page-3/#page-based-counters
    		if (name !== "page") {
    			return;
    		}
    		// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
    		if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
    			return;
    		}
    		const selector = csstree.generate(rule.ruleNode.prelude);
    		return this.pageCounter.increments[selector] = {
    			selector: selector,
    			number
    		};
    	}

    	insertRule(rule) {
    		this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
    	}
    }

    class NthOfType extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);

    		this.styleSheet = polisher.styleSheet;
    		this.selectors = {};
    	}

    	onRule(ruleNode, ruleItem, rulelist) {
    		let selector = csstree.generate(ruleNode.prelude);
    		if (selector.match(/:(first|last|nth)-of-type/)) {
    			
    			let declarations = csstree.generate(ruleNode.block);
    			declarations = declarations.replace(/[{}]/g,"");

    			let uuid = "nth-of-type-" + UUID();

    			selector.split(",").forEach((s) => {
    				if (!this.selectors[s]) {
    					this.selectors[s] = [uuid, declarations];
    				} else {
    					this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
    				}
    			});

    			rulelist.remove(ruleItem);
    		}
    	}

    	afterParsed(parsed) {
    		this.processSelectors(parsed, this.selectors);
    	}

    	processSelectors(parsed, selectors) {
    		// add the new attributes to matching elements
    		for (let s in selectors) {
    			let elements = parsed.querySelectorAll(s);

    			for (var i = 0; i < elements.length; i++) {
    				let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

    				if (dataNthOfType && dataNthOfType != "") {
    					dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
    					elements[i].setAttribute("data-nth-of-type", dataNthOfType);
    				} else {
    					elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
    				}
    			}

    			let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
    			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
    		}
    	}
    }

    class Following extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);

    		this.styleSheet = polisher.styleSheet;
    		this.selectors = {};
    	}

    	onRule(ruleNode, ruleItem, rulelist) {
    		let selector = csstree.generate(ruleNode.prelude);
    		if (selector.match(/\+/)) {
    			
    			let declarations = csstree.generate(ruleNode.block);
    			declarations = declarations.replace(/[{}]/g,"");

    			let uuid = "following-" + UUID();

    			selector.split(",").forEach((s) => {
    				if (!this.selectors[s]) {
    					this.selectors[s] = [uuid, declarations];
    				} else {
    					this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
    				}
    			});

    			rulelist.remove(ruleItem);
    		}
    	}

    	afterParsed(parsed) {
    		this.processSelectors(parsed, this.selectors);
    	}

    	processSelectors(parsed, selectors) {
    		// add the new attributes to matching elements
    		for (let s in selectors) {
    			let elements = parsed.querySelectorAll(s);

    			for (var i = 0; i < elements.length; i++) {
    				let dataFollowing = elements[i].getAttribute("data-following");

    				if (dataFollowing && dataFollowing != "") {
    					dataFollowing = `${dataFollowing},${selectors[s][0]}`;
    					elements[i].setAttribute("data-following", dataFollowing);
    				} else {
    					elements[i].setAttribute("data-following", selectors[s][0]);
    				}
    			}

    			let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
    			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
    		}
    	}
    }

    class Footnotes extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);

    		this.footnotes = {};
    		this.needsLayout = [];
    	}

    	onDeclaration(declaration, dItem, dList, rule) {
    		let property = declaration.property;
    		if (property === "float") {
    			let identifier = declaration.value.children && declaration.value.children.first();
    			let location = identifier && identifier.name;
    			if (location === "footnote") {
    				let selector = csstree.generate(rule.ruleNode.prelude);
    				this.footnotes[selector] = {
    					selector: selector,
    					policy: "auto",
    					display: "block"
    				};
    				dList.remove(dItem);
    			}
    		}
    		if (property === "footnote-policy") {
    			let identifier = declaration.value.children && declaration.value.children.first();
    			let policy = identifier && identifier.name;
    			if (policy) {
    				let selector = csstree.generate(rule.ruleNode.prelude);
    				let note = this.footnotes[selector];
    				if (note) {
    					note.policy = policy;
    				}
    			}
    		}
    		if (property === "footnote-display") {
    			let identifier = declaration.value.children && declaration.value.children.first();
    			let display = identifier && identifier.name;
    			let selector = csstree.generate(rule.ruleNode.prelude);
    			if (display && this.footnotes[selector]) {
    				let note = this.footnotes[selector];
    				if (note) {
    					note.display = display;
    				}
    			}
    		}
    	}

    	onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
    		let name = pseudoNode.name;
    		if (name === "footnote-marker") {
    			// switch ::footnote-marker to [data-footnote-marker]::before
    			let prelude = rule.ruleNode.prelude;
    			let newPrelude = new csstree.List();

    			// Can't get remove to work, so just copying everything else
    			prelude.children.first().children.each((node) => {
    				if (node.type !== "PseudoElementSelector") {
    					newPrelude.appendData(node);
    				}
    			});

    			// Add our data call
    			newPrelude.appendData({
    				type: "AttributeSelector",
    				name: {
    					type: "Identifier",
    					name: "data-footnote-marker",
    				},
    				flags: null,
    				loc: null,
    				matcher: null,
    				value: null
    			});

    			// Add new pseudo element
    			newPrelude.appendData({
    				type: "PseudoElementSelector",
    				name: "marker",
    				loc: null,
    				children: null
    			});

    			prelude.children.first().children = newPrelude;
    		}

    		if (name === "footnote-call") {
    			// switch ::footnote-call to [data-footnote-call]::after

    			let prelude = rule.ruleNode.prelude;
    			let newPrelude = new csstree.List();

    			// Can't get remove to work, so just copying everything else
    			prelude.children.first().children.each((node) => {
    				if (node.type !== "PseudoElementSelector") {
    					newPrelude.appendData(node);
    				}
    			});

    			// Add our data call
    			newPrelude.appendData({
    				type: "AttributeSelector",
    				name: {
    					type: "Identifier",
    					name: "data-footnote-call",
    				},
    				flags: null,
    				loc: null,
    				matcher: null,
    				value: null
    			});

    			// Add new pseudo element
    			newPrelude.appendData({
    				type: "PseudoElementSelector",
    				name: "after",
    				loc: null,
    				children: null
    			});

    			prelude.children.first().children = newPrelude;
    		}
    	}

    	afterParsed(parsed) {
    		this.processFootnotes(parsed, this.footnotes);
    	}

    	processFootnotes(parsed, notes) {
    		for (let n in notes) {
    			// Find elements
    			let elements = parsed.querySelectorAll(n);
    			let element;
    			let note = notes[n];
    			for (var i = 0; i < elements.length; i++) {
    				element = elements[i];
    				// Add note type
    				element.setAttribute("data-note", "footnote");
    				element.setAttribute("data-break-before", "avoid");
    				element.setAttribute("data-note-policy", note.policy || "auto");
    				element.setAttribute("data-note-display", note.display || "block");
    				// Mark all parents
    				this.processFootnoteContainer(element);
    			}
    		}
    	}

    	processFootnoteContainer(node) {
    		// Find the container
    		let element = node.parentElement;
    		let prevElement = element;
    		// Walk up the dom until we find a container element
    		while (element) {
    			if (isContainer(element)) {
    				// Add flag to the previous non-container element that will render with children
    				prevElement.setAttribute("data-has-notes", "true");
    				break;
    			}

    			prevElement = element;
    			element = element.parentElement;

    			// If no containers were found and there are no further parents flag the last element
    			if (!element) {
    				prevElement.setAttribute("data-has-notes", "true");
    			}
    		}
    	}

    	renderNode(node) {
    		if (node.nodeType == 1) {
    			// Get all notes
    			let notes;

    			// Ingnore html element nodes, like mathml
    			if (!node.dataset) {
    				return;
    			}

    			if (node.dataset.note === "footnote") {
    				notes = [node];
    			} else if (node.dataset.hasNotes || node.querySelectorAll("[data-note='footnote']")) {
    				notes = node.querySelectorAll("[data-note='footnote']");
    			}

    			if (notes && notes.length) {
    				this.findVisibleFootnotes(notes, node);
    			}
    		}
    	}

    	findVisibleFootnotes(notes, node) {
    		let area, size, right;
    		area = node.closest(".pagedjs_page_content");
    		size = area.getBoundingClientRect();
    		right = size.left + size.width;

    		for (let i = 0; i < notes.length; ++i) {
    			let currentNote = notes[i];
    			let bounds = currentNote.getBoundingClientRect();
    			let left = bounds.left;

    			if (left < right) {
    				// Add call for the note
    				this.moveFootnote(currentNote, node.closest(".pagedjs_area"), true);
    			}
    		}
    	}

    	moveFootnote(node, pageArea, needsNoteCall) {
    		// let pageArea = node.closest(".pagedjs_area");
    		let noteArea = pageArea.querySelector(".pagedjs_footnote_area");
    		let noteContent = noteArea.querySelector(".pagedjs_footnote_content");
    		let noteInnerContent = noteContent.querySelector(".pagedjs_footnote_inner_content");

    		if (!isElement(node)) {
    			return;
    		}

    		// Add call for the note
    		let noteCall;
    		if (needsNoteCall) {
    			noteCall = this.createFootnoteCall(node);
    		}

    		// Remove the break before attribute for future layout
    		node.removeAttribute("data-break-before");

    		// Check if note already exists for overflow
    		let existing = noteInnerContent.querySelector(`[data-ref="${node.dataset.ref}"]`);
    		if (existing) {
    			// Remove the note from the flow but no need to render it again
    			node.remove();
    			return;
    		}

    		// Add the note node
    		noteInnerContent.appendChild(node);

    		// Remove empty class
    		if (noteContent.classList.contains("pagedjs_footnote_empty")) {
    			noteContent.classList.remove("pagedjs_footnote_empty");
    		}

    		// Add marker
    		node.dataset.footnoteMarker = node.dataset.ref;

    		// Add Id
    		node.id = `note-${node.dataset.ref}`;

    		// Get note content size
    		let height = noteContent.scrollHeight;

    		// Check the noteCall is still on screen
    		let area = pageArea.querySelector(".pagedjs_page_content");
    		let size = area.getBoundingClientRect();
    		let right = size.left + size.width;

    		// TODO: add a max height in CSS

    		// Check element sizes
    		let noteCallBounds = noteCall && noteCall.getBoundingClientRect();
    		let noteAreaBounds = noteArea.getBoundingClientRect();

    		// Get the @footnote margins
    		let noteContentMargins = this.marginsHeight(noteContent);
    		let noteContentPadding = this.paddingHeight(noteContent);
    		let noteContentBorders = this.borderHeight(noteContent);
    		let total = noteContentMargins + noteContentPadding + noteContentBorders;

    		// Get the top of the @footnote area
    		let notAreaTop = Math.floor(noteAreaBounds.top);
    		// If the height isn't set yet, remove the margins from the top
    		if (noteAreaBounds.height === 0) {
    			notAreaTop -= this.marginsHeight(noteContent, false);
    			notAreaTop -= this.paddingHeight(noteContent, false);
    			notAreaTop -= this.borderHeight(noteContent, false);
    		}
    		// Determine the note call position and offset per policy
    		let notePolicy = node.dataset.notePolicy;
    		let noteCallPosition = 0;
    		let noteCallOffset = 0;
    		if (noteCall) {
    			// Get the correct line bottom for super or sub styled callouts
    			let prevSibling = noteCall.previousSibling;
    			let range = new Range();
    			if (prevSibling) {
    				range.setStartBefore(prevSibling);
    			} else {
    				range.setStartBefore(noteCall);
    			}
    			range.setEndAfter(noteCall);
    			let rangeBounds = range.getBoundingClientRect();
    			noteCallPosition = rangeBounds.bottom;
    			if (!notePolicy || notePolicy === "auto") {
    				noteCallOffset = Math.ceil(rangeBounds.bottom);
    			} else if (notePolicy === "line") {
    				noteCallOffset = Math.ceil(rangeBounds.top);
    			} else if (notePolicy === "block") {
    				// Check that there is a previous element on the page
    				let parentParagraph = noteCall.closest("p").previousElementSibling;
    				if (parentParagraph) {
    					noteCallOffset = Math.ceil(
    						parentParagraph.getBoundingClientRect().bottom
    					);
    				} else {
    					noteCallOffset = Math.ceil(rangeBounds.bottom);
    				}
    			}
    		}

    		let contentDelta = height + total - noteAreaBounds.height;
    		// Space between the top of the footnotes area and the bottom of the footnote call
    		let noteDelta = noteCallPosition ? notAreaTop - noteCallPosition : 0;
    		// Space needed for the force a break for the policy of the footnote
    		let notePolicyDelta = noteCallPosition ? Math.floor(noteAreaBounds.top) - noteCallOffset : 0;
    		let hasNotes = noteArea.querySelector("[data-note='footnote']");
    		if (needsNoteCall && noteCallBounds.left > right) {
    			// Note is offscreen and will be chunked to the next page on overflow
    			node.remove();
    		} else if (!hasNotes && needsNoteCall && total > noteDelta) {
    			// No space to add even the footnote area
    			pageArea.style.setProperty("--pagedjs-footnotes-height", "0px");
    			// Add a wrapper as this div is removed later
    			let wrapperDiv = document.createElement("div");
    			wrapperDiv.appendChild(node);
    			// Push to the layout queue for the next page
    			this.needsLayout.push(wrapperDiv);
    		} else if (!needsNoteCall) {
    			// Call was previously added, force adding footnote
    			pageArea.style.setProperty(
    				"--pagedjs-footnotes-height",
    				`${height + total}px`
    			);
    		} else if (noteCallPosition < noteAreaBounds.top - contentDelta) {
    			// the current note content will fit without pushing the call to the next page
    			pageArea.style.setProperty(
    				"--pagedjs-footnotes-height",
    				`${height + noteContentMargins + noteContentBorders}px`
    			);
    		} else {
    			// set height to just before note call
    			pageArea.style.setProperty(
    				"--pagedjs-footnotes-height",
    				`${noteAreaBounds.height + notePolicyDelta}px`
    			);
    			noteInnerContent.style.height =
    				noteAreaBounds.height + notePolicyDelta - total + "px";
    		}
    	}

    	createFootnoteCall(node) {
    		let parentElement = node.parentElement;
    		let footnoteCall = document.createElement("a");
    		for (const className of node.classList) {
    			footnoteCall.classList.add(`${className}`);
    		}

    		footnoteCall.dataset.footnoteCall = node.dataset.ref;
    		footnoteCall.dataset.ref = node.dataset.ref;

    		// Increment for counters
    		footnoteCall.dataset.dataCounterFootnoteIncrement = 1;

    		// Add link
    		footnoteCall.href = `#note-${node.dataset.ref}`;

    		parentElement.insertBefore(footnoteCall, node);

    		return footnoteCall;
    	}

    	afterPageLayout(pageElement, page, breakToken, chunker) {
    		let pageArea = pageElement.querySelector(".pagedjs_area");
    		let noteArea = page.footnotesArea;
    		let noteContent = noteArea.querySelector(".pagedjs_footnote_content");
    		let noteInnerContent = noteArea.querySelector(".pagedjs_footnote_inner_content");

    		let noteContentBounds = noteContent.getBoundingClientRect();
    		let { width } = noteContentBounds;

    		noteInnerContent.style.columnWidth = Math.round(width) + "px";
    		noteInnerContent.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";

    		// Get overflow
    		let layout = new Layout(noteArea, undefined, chunker.settings);
    		let overflow = layout.findOverflow(noteInnerContent, noteContentBounds);

    		if (overflow) {
    			let { startContainer, startOffset } = overflow;
    			let startIsNode;
    			if (isElement(startContainer)) {
    				let start = startContainer.childNodes[startOffset];
    				startIsNode = isElement(start) && start.hasAttribute("data-footnote-marker");
    			}

    			let extracted = overflow.extractContents();

    			if (!startIsNode) {
    				let splitChild = extracted.firstElementChild;
    				splitChild.dataset.splitFrom = splitChild.dataset.ref;

    				this.handleAlignment(noteInnerContent.lastElementChild);
    			}

    			this.needsLayout.push(extracted);

    			noteContent.style.removeProperty("height");
    			noteInnerContent.style.removeProperty("height");

    			let noteInnerContentBounds = noteInnerContent.getBoundingClientRect();
    			let { height } = noteInnerContentBounds;

    			// Get the @footnote margins
    			let noteContentMargins = this.marginsHeight(noteContent);
    			let noteContentPadding = this.paddingHeight(noteContent);
    			let noteContentBorders = this.borderHeight(noteContent);
    			pageArea.style.setProperty(
    				"--pagedjs-footnotes-height",
    				`${height + noteContentMargins + noteContentBorders + noteContentPadding}px`
    			);

    			// Hide footnote content if empty
    			if (noteInnerContent.childNodes.length === 0) {
    				noteContent.classList.add("pagedjs_footnote_empty");
    			}

    			if (!breakToken) {
    				chunker.clonePage(page);
    			} else {
    				let breakBefore, previousBreakAfter;
    				if (
    					breakToken.node &&
    					typeof breakToken.node.dataset !== "undefined" &&
    					typeof breakToken.node.dataset.previousBreakAfter !== "undefined"
    				) {
    					previousBreakAfter = breakToken.node.dataset.previousBreakAfter;
    				}

    				if (
    					breakToken.node &&
    					typeof breakToken.node.dataset !== "undefined" &&
    					typeof breakToken.node.dataset.breakBefore !== "undefined"
    				) {
    					breakBefore = breakToken.node.dataset.breakBefore;
    				}

    				if (breakBefore || previousBreakAfter) {
    					chunker.clonePage(page);
    				}
    			}
    		}
    		noteInnerContent.style.height = "auto";
    	}

    	handleAlignment(node) {
    		let styles = window.getComputedStyle(node);
    		let alignLast = styles["text-align-last"];
    		node.dataset.lastSplitElement = "true";
    		if (alignLast === "auto") {
    			node.dataset.alignLastSplitElement = "justify";
    		} else {
    			node.dataset.alignLastSplitElement = alignLast;
    		}
    	}

    	beforePageLayout(page) {
    		while (this.needsLayout.length) {
    			let fragment = this.needsLayout.shift();

    			Array.from(fragment.childNodes).forEach((node) => {
    				this.moveFootnote(
    					node,
    					page.element.querySelector(".pagedjs_area"),
    					false
    				);
    			});
    		}
    	}

    	afterOverflowRemoved(removed, rendered) {
    		// Find the page area
    		let area = rendered.closest(".pagedjs_area");
    		// Get any rendered footnotes
    		let notes = area.querySelectorAll(".pagedjs_footnote_area [data-note='footnote']");
    		for (let n = 0; n < notes.length; n++) {
    			const note = notes[n];
    			// Check if the call for that footnote has been removed with the overflow
    			let call = removed.querySelector(`[data-footnote-call="${note.dataset.ref}"]`);
    			if (call) {
    				note.remove();
    			}
    		}
    		// Hide footnote content if empty
    		let noteInnerContent = area.querySelector(".pagedjs_footnote_inner_content");
    		if (noteInnerContent && noteInnerContent.childNodes.length === 0) {
    			noteInnerContent.parentElement.classList.add("pagedjs_footnote_empty");
    		}
    	}

    	marginsHeight(element, total=true) {
    		let styles = window.getComputedStyle(element);
    		let marginTop = parseInt(styles.marginTop);
    		let marginBottom = parseInt(styles.marginBottom);
    		let margin = 0;
    		if (marginTop) {
    			margin += marginTop;
    		}
    		if (marginBottom && total) {
    			margin += marginBottom;
    		}
    		return margin;
    	}

    	paddingHeight(element, total=true) {
    		let styles = window.getComputedStyle(element);
    		let paddingTop = parseInt(styles.paddingTop);
    		let paddingBottom = parseInt(styles.paddingBottom);
    		let padding = 0;
    		if (paddingTop) {
    			padding += paddingTop;
    		}
    		if (paddingBottom && total) {
    			padding += paddingBottom;
    		}
    		return padding;
    	}

    	borderHeight(element, total=true) {
    		let styles = window.getComputedStyle(element);
    		let borderTop = parseInt(styles.borderTop);
    		let borderBottom = parseInt(styles.borderBottom);
    		let borders = 0;
    		if (borderTop) {
    			borders += borderTop;
    		}
    		if (borderBottom && total) {
    			borders += borderBottom;
    		}
    		return borders;
    	}
    }

    var pagedMediaHandlers = [
    	PrintMedia,
    	AtPage,
    	Breaks,
    	Splits,
    	Counters,
    	Lists,
    	PositionFixed,
    	PageCounterIncrement,
    	NthOfType,
    	Following,
    	Footnotes
    ];

    class RunningHeaders extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);

    		this.runningSelectors = {};
    		this.elements = {};
    	}

    	onDeclaration(declaration, dItem, dList, rule) {
    		if (declaration.property === "position") {
    			let selector = csstree.generate(rule.ruleNode.prelude);
    			let identifier = declaration.value.children.first().name;

    			if (identifier === "running") {
    				let value;
    				csstree.walk(declaration, {
    					visit: "Function",
    					enter: (node, item, list) => {
    						value = node.children.first().name;
    					}
    				});

    				this.runningSelectors[value] = {
    					identifier: identifier,
    					value: value,
    					selector: selector
    				};
    			}
    		}

    		if (declaration.property === "content") {

    			csstree.walk(declaration, {
    				visit: "Function",
    				enter: (funcNode, fItem, fList) => {

    					if (funcNode.name.indexOf("element") > -1) {

    						let selector = csstree.generate(rule.ruleNode.prelude);

    						let func = funcNode.name;

    						let value = funcNode.children.first().name;

    						let args = [value];

    						// we only handle first for now
    						let style = "first";

    						selector.split(",").forEach((s) => {
    							// remove before / after
    							s = s.replace(/::after|::before/, "");

    							this.elements[s] = {
    								func: func,
    								args: args,
    								value: value,
    								style: style,
    								selector: s,
    								fullSelector: selector
    							};
    						});
    					}

    				}
    			});
    		}
    	}

    	afterParsed(fragment) {
    		for (let name of Object.keys(this.runningSelectors)) {
    			let set = this.runningSelectors[name];
    			let selected = Array.from(fragment.querySelectorAll(set.selector));

    			if (set.identifier === "running") {
    				for (let header of selected) {
    					header.style.display = "none";
    				}
    			}

    		}
    	}

    	afterPageLayout(fragment) {
    		for (let name of Object.keys(this.runningSelectors)) {
    			let set = this.runningSelectors[name];
    			let selected = fragment.querySelector(set.selector);
    			if (selected) {
    				// let cssVar;
    				if (set.identifier === "running") {
    					// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
    					// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
    					// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
    					set.first = selected;
    				} else {
    					console.warn(set.value + "needs css replacement");
    				}
    			}
    		}

    		// move elements
    		if (!this.orderedSelectors) {
    			this.orderedSelectors = this.orderSelectors(this.elements);
    		}

    		for (let selector of this.orderedSelectors) {
    			if (selector) {

    				let el = this.elements[selector];
    				let selected = fragment.querySelector(selector);
    				if (selected) {
    					let running = this.runningSelectors[el.args[0]];
    					if (running && running.first) {
    						selected.innerHTML = ""; // Clear node
    						// selected.classList.add("pagedjs_clear-after"); // Clear ::after
    						let clone = running.first.cloneNode(true);
    						clone.style.display = null;
    						selected.appendChild(clone);
    					}
    				}
    			}
    		}
    	}

    	/**
    	* Assign a weight to @page selector classes
    	* 1) page
    	* 2) left & right
    	* 3) blank
    	* 4) first & nth
    	* 5) named page
    	* 6) named left & right
    	* 7) named first & nth
    	* @param {string} [s] selector string
    	* @return {int} weight
    	*/
    	pageWeight(s) {
    		let weight = 1;
    		let selector = s.split(" ");
    		let parts = selector.length && selector[0].split(".");

    		parts.shift(); // remove empty first part

    		switch (parts.length) {
    			case 4:
    				if (/^pagedjs_[\w-]+_first_page$/.test(parts[3])) {
    					weight = 7;
    				} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
    					weight = 6;
    				}
    				break;
    			case 3:
    				if (parts[1] === "pagedjs_named_page") {
    					if (parts[2].indexOf(":nth-of-type") > -1) {
    						weight = 7;
    					} else {
    						weight = 5;
    					}
    				}
    				break;
    			case 2:
    				if (parts[1] === "pagedjs_first_page") {
    					weight = 4;
    				} else if (parts[1] === "pagedjs_blank_page") {
    					weight = 3;
    				} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
    					weight = 2;
    				}
    				break;
    			default:
    				if (parts[0].indexOf(":nth-of-type") > -1) {
    					weight = 4;
    				} else {
    					weight = 1;
    				}
    		}

    		return weight;
    	}

    	/**
    	* Orders the selectors based on weight
    	*
    	* Does not try to deduplicate base on specifity of the selector
    	* Previous matched selector will just be overwritten
    	* @param {obj} [obj] selectors object
    	* @return {Array} orderedSelectors
    	*/
    	orderSelectors(obj) {
    		let selectors = Object.keys(obj);
    		let weighted = {
    			1: [],
    			2: [],
    			3: [],
    			4: [],
    			5: [],
    			6: [],
    			7: []
    		};

    		let orderedSelectors = [];

    		for (let s of selectors) {
    			let w = this.pageWeight(s);
    			weighted[w].unshift(s);
    		}

    		for (var i = 1; i <= 7; i++) {
    			orderedSelectors = orderedSelectors.concat(weighted[i]);
    		}

    		return orderedSelectors;
    	}

    	beforeTreeParse(text, sheet) {
    		// element(x) is parsed as image element selector, so update element to element-ident
    		sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
    	}
    }

    function cleanPseudoContent(el, trim = "\"' ") {
    	if(el == null) return;
    	return el
    		.replace(new RegExp(`^[${trim}]+`), "")
    		.replace(new RegExp(`[${trim}]+$`), "")
    		.replace(/["']/g, match => {
    			return "\\" + match;
    		})
    		.replace(/[\n]/g, match => {
    			return "\\00000A";
    		});
    }

    function cleanSelector(el) {
    	if(el == null) return;
    	return el
    		.replace(new RegExp("::footnote-call", "g"), "")
    		.replace(new RegExp("::footnote-marker", "g"), "");
    }

    class StringSets extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);

    		this.stringSetSelectors = {};
    		this.type;
    		// pageLastString = last string variable defined on the page
    		this.pageLastString;

    	}
    	
    	onDeclaration(declaration, dItem, dList, rule) {
    		if (declaration.property === "string-set") {
    			let selector = csstree.generate(rule.ruleNode.prelude);

    			let identifiers = [];
    			let functions = [];
    			let values = [];

    			declaration.value.children.forEach((child) => {
    				if (child.type === "Identifier") {
    					identifiers.push(child.name);
    				}
    				if (child.type === "Function") {
    					functions.push(child.name);
    					child.children.forEach((subchild) => {
    						if (subchild.type === "Identifier") {
    							values.push(subchild.name);
    						}
    					});
    				}
    			});

    			identifiers.forEach((identifier, index) => {
    				let func = functions[index];
    				let value = values[index];
    				this.stringSetSelectors[identifier] = {
    					identifier,
    					func,
    					value,
    					selector
    				};
    			});

    		}
    	}

    	onContent(funcNode, fItem, fList, declaration, rule) {

    		if (funcNode.name === "string") {
    			let identifier = funcNode.children && funcNode.children.first().name;
    			this.type = funcNode.children.last().name;
    			funcNode.name = "var";
    			funcNode.children = new csstree.List();

     
    			if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
    				funcNode.children.append(
    					funcNode.children.createItem({
    						type: "Identifier",
    						loc: null,
    						name: "--pagedjs-string-" + this.type + "-" + identifier
    					})
    				);
    			}else {
    				funcNode.children.append(
    					funcNode.children.createItem({
    						type: "Identifier",
    						loc: null,
    						name: "--pagedjs-string-first-" + identifier
    					})
    				);
    			}
    		}
    	}

    	afterPageLayout(fragment) {

    	
    		if ( this.pageLastString === undefined )
    		{
    			this.pageLastString = {};
    		}

    		
    		for (let name of Object.keys(this.stringSetSelectors)) {
    	
    			let set = this.stringSetSelectors[name];
    			let value = set.value;
    			let func = set.func;
    			let selected = fragment.querySelectorAll(set.selector);

    			// Get the last found string for the current identifier
    			let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

    			let varFirst, varLast, varStart, varFirstExcept;

    			if(selected.length == 0){
    				// if there is no sel. on the page
    				varFirst = stringPrevPage;
    				varLast = stringPrevPage;
    				varStart = stringPrevPage;
    				varFirstExcept = stringPrevPage;
    			}else {

    				selected.forEach((sel) => {
    					// push each content into the array to define in the variable the first and the last element of the page.
    					if (func === "content") {
    						this.pageLastString[name] = selected[selected.length - 1].textContent;
    					}

    					if (func === "attr") {
    						this.pageLastString[name] = selected[selected.length - 1].getAttribute(value) || "";
    					}

    				});	

    				/* FIRST */
    	
    				if (func === "content") {
    					varFirst = selected[0].textContent;
    				}

    				if (func === "attr") {
    					varFirst = selected[0].getAttribute(value) || "";
    				}


    				/* LAST */

    				if (func === "content") {
    					varLast = selected[selected.length - 1].textContent;
    				}

    				if (func === "attr") {
    					varLast = selected[selected.length - 1].getAttribute(value) || "";
    				}


    				/* START */

    				// Hack to find if the sel. is the first elem of the page / find a better way 
    				let selTop = selected[0].getBoundingClientRect().top;
    				let pageContent = selected[0].closest(".pagedjs_page_content");
    				let pageContentTop = pageContent.getBoundingClientRect().top;

    				if(selTop == pageContentTop){
    					varStart = varFirst;
    				}else {
    					varStart = stringPrevPage;
    				}

    				/* FIRST EXCEPT */

    				varFirstExcept = "";
    				
    			}

    			fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
    			fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
    			fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
    			fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
    			
    	
    		}
    	}
    	

    }

    class TargetCounters extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);

    		this.styleSheet = polisher.styleSheet;

    		this.counterTargets = {};
    	}

    	onContent(funcNode, fItem, fList, declaration, rule) {
    		if (funcNode.name === "target-counter") {
    			let selector = csstree.generate(rule.ruleNode.prelude);

    			let first = funcNode.children.first();
    			let func = first.name;

    			let value = csstree.generate(funcNode);

    			let args = [];

    			first.children.forEach((child) => {
    				if (child.type === "Identifier") {

    					args.push(child.name);
    				}
    			});

    			let counter;
    			let style;
    			let styleIdentifier;

    			funcNode.children.forEach((child) => {
    				if (child.type === "Identifier") {
    					if (!counter) {
    						counter = child.name;
    					} else if (!style) {
    						styleIdentifier = csstree.clone(child);
    						style = child.name;
    					}
    				}
    			});

    			let variable = "target-counter-" + UUID();

    			selector.split(",").forEach((s) => {
    				this.counterTargets[s] = {
    					func: func,
    					args: args,
    					value: value,
    					counter: counter,
    					style: style,
    					selector: s,
    					fullSelector: selector,
    					variable: variable
    				};
    			});

    			// Replace with counter
    			funcNode.name = "counter";
    			funcNode.children = new csstree.List();
    			funcNode.children.appendData({
    				type: "Identifier",
    				loc: 0,
    				name: variable
    			});

    			if (styleIdentifier) {
    				funcNode.children.appendData({type: "Operator", loc: null, value: ","});
    				funcNode.children.appendData(styleIdentifier);
    			}
    		}
    	}

    	afterPageLayout(fragment, page, breakToken, chunker) {
    		Object.keys(this.counterTargets).forEach((name) => {
    			let target = this.counterTargets[name];
    			let split = target.selector.split(/::?/g);
    			let query = split[0];

    			let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

    			queried.forEach((selected, index) => {
    				// TODO: handle func other than attr
    				if (target.func !== "attr") {
    					return;
    				}
    				let val = attr(selected, target.args);
    				let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

    				if (element) {
    					let selector = UUID();
    					selected.setAttribute("data-" + target.variable, selector);
    					// TODO: handle other counter types (by query)
    					let pseudo = "";
    					if (split.length > 1) {
    						pseudo += "::" + split[1];
    					}
    					if (target.counter === "page") {
    						let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
    						let pg = 0;
    						for (let i = 0; i < pages.length; i++) {
    							let page = pages[i];
    							let styles = window.getComputedStyle(page);
    							let reset = styles["counter-reset"].replace("page", "").trim();
    							let increment = styles["counter-increment"].replace("page", "").trim();

    							if (reset !== "none") {
    								pg = parseInt(reset);
    							}
    							if (increment !== "none") {
    								pg += parseInt(increment);
    							}

    							if (page.contains(element)){
    								break;
    							}
    						}
    						this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
    					} else {
    						let value = element.getAttribute(`data-counter-${target.counter}-value`);
    						if (value) {
    							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
    						}
    					}

    					// force redraw
    					let el = document.querySelector(`[data-${target.variable}="${selector}"]`);
    					if (el) {
    						el.style.display = "none";
    						el.clientHeight;
    						el.style.removeProperty("display");
    					}
    				}
    			});
    		});
    	}
    }

    // import { nodeAfter } from "../../utils/dom";

    class TargetText extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);

    		this.styleSheet = polisher.styleSheet;
    		this.textTargets = {};
    		this.beforeContent = "";
    		this.afterContent = "";
    		this.selector = {};
    	}

    	onContent(funcNode, fItem, fList, declaration, rule) {
    		if (funcNode.name === "target-text") {
    			this.selector = csstree.generate(rule.ruleNode.prelude);
    			let first = funcNode.children.first();
    			let last = funcNode.children.last();
    			let func = first.name;

    			let value = csstree.generate(funcNode);

    			let args = [];

    			first.children.forEach(child => {
    				if (child.type === "Identifier") {
    					args.push(child.name);
    				}
    			});

    			let style;
    			if (last !== first) {
    				style = last.name;
    			}

    			let variable = "--pagedjs-" + UUID();

    			this.selector.split(",").forEach(s => {
    				this.textTargets[s] = {
    					func: func,
    					args: args,
    					value: value,
    					style: style || "content",
    					selector: s,
    					fullSelector: this.selector,
    					variable: variable
    				};
    			});

    			// Replace with variable
    			funcNode.name = "var";
    			funcNode.children = new csstree.List();
    			funcNode.children.appendData({
    				type: "Identifier",
    				loc: 0,
    				name: variable
    			});
    		}
    	}

    	//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
    	onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
    		// console.log(pseudoNode);
    		// console.log(rule);

    		rule.ruleNode.block.children.forEach(properties => {
    			if (pseudoNode.name === "before" && properties.property === "content") {
    				// let beforeVariable = "--pagedjs-" + UUID();

    				let contenu = properties.value.children;
    				contenu.forEach(prop => {
    					if (prop.type === "String") {
    						this.beforeContent = prop.value;
    					}
    				});
    			} else if (pseudoNode.name === "after" && properties.property === "content") {
    				properties.value.children.forEach(prop => {
    					if (prop.type === "String") {
    						this.afterContent = prop.value;
    					}
    				});
    			}
    		});
    	}

    	afterParsed(fragment) {
    		Object.keys(this.textTargets).forEach(name => {
    			let target = this.textTargets[name];
    			let split = target.selector.split("::");
    			let query = split[0];
    			let queried = fragment.querySelectorAll(query);
    			let textContent;
    			queried.forEach((selected, index) => {
    				let val = attr(selected, target.args);
    				let element = fragment.querySelector(querySelectorEscape(val));
    				if (element) {
    					// content & first-letter & before & after refactorized
    					if (target.style) {
    						this.selector = UUID();
    						selected.setAttribute("data-target-text", this.selector);

    						let psuedo = "";
    						if (split.length > 1) {
    							psuedo += "::" + split[1];
    						}
    						
    						if (target.style === "before" || target.style === "after") {
    							const pseudoType = `${target.style}Content`;
    							textContent = cleanPseudoContent(this[pseudoType]);
    						} else {
    							textContent = cleanPseudoContent(element.textContent, " ");
    						}
    						textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
    						this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
    					} else {
    						console.warn("missed target", val);
    					}
    				}
    			});
    		});
    	}
    }

    var generatedContentHandlers = [
    	RunningHeaders,
    	StringSets,
    	TargetCounters,
    	TargetText
    ];

    class WhiteSpaceFilter extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);
    	}

    	filter(content) {

    		filterTree(content, (node) => {
    			return this.filterEmpty(node);
    		}, NodeFilter.SHOW_TEXT);

    	}

    	filterEmpty(node) {
    		if (node.textContent.length > 1 && isIgnorable(node)) {

    			// Do not touch the content if text is pre-formatted
    			let parent = node.parentNode;
    			let pre = isElement(parent) && parent.closest("pre");
    			if (pre) {
    				return NodeFilter.FILTER_REJECT;
    			}

    			const previousSibling = previousSignificantNode(node);
    			const nextSibling = nextSignificantNode(node);

    			if (nextSibling === null && previousSibling === null) {
    				// we should not remove a Node that does not have any siblings.
    				node.textContent = " ";
    				return NodeFilter.FILTER_REJECT;
    			}
    			if (nextSibling === null) {
    				// we can safely remove this node
    				return NodeFilter.FILTER_ACCEPT;
    			}
    			if (previousSibling === null) {
    				// we can safely remove this node
    				return NodeFilter.FILTER_ACCEPT;
    			}

    			// replace the content with a single space
    			node.textContent = " ";

    			// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
    			// pre
    			// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
    			//
    			// pre-wrap
    			// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
    			//
    			// pre-line
    			// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
    			//
    			// break-spaces
    			// The behavior is identical to that of pre-wrap, except that:
    			// - Any sequence of preserved white space always takes up space, including at the end of the line.
    			// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
    			// - Such preserved spaces take up space and do not hang, and thus affect the boxs intrinsic sizes (min-content size and max-content size).
    			//
    			// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

    			return NodeFilter.FILTER_REJECT;
    		} else {
    			return NodeFilter.FILTER_REJECT;
    		}
    	}

    }

    class CommentsFilter extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);
    	}

    	filter(content) {
    		filterTree(content, null, NodeFilter.SHOW_COMMENT);
    	}

    }

    class ScriptsFilter extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);
    	}

    	filter(content) {
    		content.querySelectorAll("script").forEach( script => { script.remove(); });
    	}

    }

    var clearCut = {};

    /**
     * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
     *
     * Calculates the specificity of CSS selectors
     * http://www.w3.org/TR/css3-selectors/#specificity
     *
     * Returns a selector integer value
     */

    var hasRequiredClearCut;

    function requireClearCut () {
    	if (hasRequiredClearCut) return clearCut;
    	hasRequiredClearCut = 1;
    	(function (exports) {
    		// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
    		var attributeRegex = /(\[[^\]]+\])/g;
    		var idRegex = /(#[^\s\+>~\.\[:]+)/g;
    		var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
    		var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
    		var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
    		var elementRegex = /([^\s\+>~\.\[:]+)/g;
    		var notRegex = /:not\(([^\)]*)\)/g;
    		var ruleRegex = /\{[^]*/gm;
    		var separatorRegex = /[\*\s\+>~]/g;
    		var straysRegex = /[#\.]/g;

    		// Find matches for a regular expression in a string and push their details to parts
    		// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
    		var findMatch = function(regex, type, types, selector) {
    		  var matches = selector.match(regex);
    		  if (matches) {
    		    for (var i = 0; i < matches.length; i++) {
    		      types[type]++;
    		      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
    		      selector = selector.replace(matches[i], ' ');
    		    }
    		  }

    		  return selector;
    		};

    		// Calculate the specificity for a selector by dividing it into simple selectors and counting them
    		var calculate = function(selector) {
    		  var commaIndex = selector.indexOf(',');
    		  if (commaIndex !== -1) {
    		    selector = selector.substring(0, commaIndex);
    		  }

    		  var  types = {
    		    a: 0,
    		    b: 0,
    		    c: 0
    		  };

    		  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
    		  selector = selector.replace(notRegex, ' $1 ');

    		  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
    		  selector = selector.replace(ruleRegex, ' ');

    		  // Add attribute selectors to parts collection (type b)
    		  selector = findMatch(attributeRegex, 'b', types, selector);

    		  // Add ID selectors to parts collection (type a)
    		  selector = findMatch(idRegex, 'a', types, selector);

    		  // Add class selectors to parts collection (type b)
    		  selector = findMatch(classRegex, 'b', types, selector);

    		  // Add pseudo-element selectors to parts collection (type c)
    		  selector = findMatch(pseudoElementRegex, 'c', types, selector);

    		  // Add pseudo-class selectors to parts collection (type b)
    		  selector = findMatch(pseudoClassRegex, 'b', types, selector);

    		  // Remove universal selector and separator characters
    		  selector = selector.replace(separatorRegex, ' ');

    		  // Remove any stray dots or hashes which aren't attached to words
    		  // These may be present if the user is live-editing this selector
    		  selector = selector.replace(straysRegex, ' ');

    		  // The only things left should be element selectors (type c)
    		  findMatch(elementRegex, 'c', types, selector);

    		  return (types.a * 100) + (types.b * 10) + (types.c * 1);
    		};

    		var specificityCache = {};

    		exports.calculateSpecificity = function(selector) {
    		  var specificity = specificityCache[selector];
    		  if (specificity === undefined) {
    		    specificity = calculate(selector);
    		    specificityCache[selector] = specificity;
    		  }
    		  return specificity;
    		};

    		var validSelectorCache = {};
    		var testSelectorElement = null;

    		exports.isSelectorValid = function(selector) {
    		  var valid = validSelectorCache[selector];
    		  if (valid === undefined) {
    		    if (testSelectorElement == null) {
    		      testSelectorElement = document.createElement('div');
    		    }

    		    try {
    		      testSelectorElement.querySelector(selector);
    		      valid = true;
    		    } catch (error) {
    		      valid = false;
    		    }
    		    validSelectorCache[selector] = valid;
    		  }
    		  return valid;
    		};

    		exports.validateSelector = function(selector) {
    		  if (!exports.isSelectorValid(selector)) {
    		    var error = new SyntaxError(selector + ' is not a valid selector');
    		    error.code = 'EBADSELECTOR';
    		    throw error;
    		  }
    		}; 
    	} (clearCut));
    	return clearCut;
    }

    var clearCutExports = requireClearCut();

    class UndisplayedFilter extends Handler {
    	constructor(chunker, polisher, caller) {
    		super(chunker, polisher, caller);
    		this.displayRules = {};
    	}

    	onDeclaration(declaration, dItem, dList, rule) {
    		if (declaration.property === "display") {
    			let selector = csstree.generate(rule.ruleNode.prelude);
    			let value = declaration.value.children.first().name;

    			selector.split(",").forEach((s) => {
    				this.displayRules[s] = {
    					value: value,
    					selector: s,
    					specificity: clearCutExports.calculateSpecificity(s),
    					important: declaration.important
    				};
    			});
    		}
    	}

    	filter(content) {
    		let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

    		// Find matching elements that have display styles
    		for (let i = 0; i < matches.length; i++) {
    			let element = matches[i];
    			let selector = selectors[i];
    			let displayValue = selector[selector.length-1].value;
    			if(this.removable(element) && displayValue === "none") {
    				element.dataset.undisplayed = "undisplayed";
    			}
    		}

    		// Find elements that have inline styles
    		let styledElements = content.querySelectorAll("[style]");
    		for (let i = 0; i < styledElements.length; i++) {
    			let element = styledElements[i];
    			if (this.removable(element)) {
    				element.dataset.undisplayed = "undisplayed";
    			}
    		}
    	}

    	sorter(a, b) {
    		if (a.important && !b.important) {
    			return 1;
    		}

    		if (b.important && !a.important) {
    			return -1;
    		}

    		return a.specificity - b.specificity;
    	}

    	sortDisplayedSelectors(content, displayRules=[]) {
    		let matches = [];
    		let selectors = [];
    		for (let d in displayRules) {
    			let displayItem = displayRules[d];
    			let selector = displayItem.selector;
    			let query = [];
    			try {
    				try {
    					query = content.querySelectorAll(selector);
    				} catch (e) {
    					query = content.querySelectorAll(cleanSelector(selector));
    				}
    			} catch (e) {
    				query = [];
    			}
    			let elements = Array.from(query);
    			for (let e of elements) {
    				if (matches.includes(e)) {
    					let index = matches.indexOf(e);
    					selectors[index].push(displayItem);
    					selectors[index] = selectors[index].sort(this.sorter);
    				} else {
    					matches.push(e);
    					selectors.push([displayItem]);
    				}
    			}
    		}

    		return { matches, selectors };
    	}

    	removable(element) {
    		if (element.style &&
    				element.style.display !== "" &&
    				element.style.display !== "none") {
    			return false;
    		}

    		return true;
    	}
    }

    var filters = [
    	WhiteSpaceFilter,
    	CommentsFilter,
    	ScriptsFilter,
    	UndisplayedFilter
    ];

    var isImplemented$4;
    var hasRequiredIsImplemented$4;

    function requireIsImplemented$4 () {
    	if (hasRequiredIsImplemented$4) return isImplemented$4;
    	hasRequiredIsImplemented$4 = 1;

    	isImplemented$4 = function () {
    		var from = Array.from, arr, result;
    		if (typeof from !== "function") return false;
    		arr = ["raz", "dwa"];
    		result = from(arr);
    		return Boolean(result && result !== arr && result[1] === "dwa");
    	};
    	return isImplemented$4;
    }

    var isImplemented$3;
    var hasRequiredIsImplemented$3;

    function requireIsImplemented$3 () {
    	if (hasRequiredIsImplemented$3) return isImplemented$3;
    	hasRequiredIsImplemented$3 = 1;

    	isImplemented$3 = function () {
    		if (typeof globalThis !== "object") return false;
    		if (!globalThis) return false;
    		return globalThis.Array === Array;
    	};
    	return isImplemented$3;
    }

    var implementation;
    var hasRequiredImplementation;

    function requireImplementation () {
    	if (hasRequiredImplementation) return implementation;
    	hasRequiredImplementation = 1;
    	var naiveFallback = function () {
    		if (typeof self === "object" && self) return self;
    		if (typeof window === "object" && window) return window;
    		throw new Error("Unable to resolve global `this`");
    	};

    	implementation = (function () {
    		if (this) return this;

    		// Unexpected strict mode (may happen if e.g. bundled into ESM module)

    		// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
    		// In all ES5+ engines global object inherits from Object.prototype
    		// (if you approached one that doesn't please report)
    		try {
    			Object.defineProperty(Object.prototype, "__global__", {
    				get: function () { return this; },
    				configurable: true
    			});
    		} catch (error) {
    			// Unfortunate case of Object.prototype being sealed (via preventExtensions, seal or freeze)
    			return naiveFallback();
    		}
    		try {
    			// Safari case (window.__global__ is resolved with global context, but __global__ does not)
    			if (!__global__) return naiveFallback();
    			return __global__;
    		} finally {
    			delete Object.prototype.__global__;
    		}
    	})();
    	return implementation;
    }

    var globalThis_1;
    var hasRequiredGlobalThis;

    function requireGlobalThis () {
    	if (hasRequiredGlobalThis) return globalThis_1;
    	hasRequiredGlobalThis = 1;

    	globalThis_1 = requireIsImplemented$3()() ? globalThis : requireImplementation();
    	return globalThis_1;
    }

    var isImplemented$2;
    var hasRequiredIsImplemented$2;

    function requireIsImplemented$2 () {
    	if (hasRequiredIsImplemented$2) return isImplemented$2;
    	hasRequiredIsImplemented$2 = 1;

    	var global     = requireGlobalThis()
    	  , validTypes = { object: true, symbol: true };

    	isImplemented$2 = function () {
    		var Symbol = global.Symbol;
    		var symbol;
    		if (typeof Symbol !== "function") return false;
    		symbol = Symbol("test symbol");
    		try { String(symbol); }
    		catch (e) { return false; }

    		// Return 'true' also for polyfills
    		if (!validTypes[typeof Symbol.iterator]) return false;
    		if (!validTypes[typeof Symbol.toPrimitive]) return false;
    		if (!validTypes[typeof Symbol.toStringTag]) return false;

    		return true;
    	};
    	return isImplemented$2;
    }

    var isSymbol;
    var hasRequiredIsSymbol;

    function requireIsSymbol () {
    	if (hasRequiredIsSymbol) return isSymbol;
    	hasRequiredIsSymbol = 1;

    	isSymbol = function (value) {
    		if (!value) return false;
    		if (typeof value === "symbol") return true;
    		if (!value.constructor) return false;
    		if (value.constructor.name !== "Symbol") return false;
    		return value[value.constructor.toStringTag] === "Symbol";
    	};
    	return isSymbol;
    }

    var validateSymbol;
    var hasRequiredValidateSymbol;

    function requireValidateSymbol () {
    	if (hasRequiredValidateSymbol) return validateSymbol;
    	hasRequiredValidateSymbol = 1;

    	var isSymbol = requireIsSymbol();

    	validateSymbol = function (value) {
    		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
    		return value;
    	};
    	return validateSymbol;
    }

    var generateName;
    var hasRequiredGenerateName;

    function requireGenerateName () {
    	if (hasRequiredGenerateName) return generateName;
    	hasRequiredGenerateName = 1;

    	var d = requireD();

    	var create = Object.create, defineProperty = Object.defineProperty, objPrototype = Object.prototype;

    	var created = create(null);
    	generateName = function (desc) {
    		var postfix = 0, name, ie11BugWorkaround;
    		while (created[desc + (postfix || "")]) ++postfix;
    		desc += postfix || "";
    		created[desc] = true;
    		name = "@@" + desc;
    		defineProperty(
    			objPrototype, name,
    			d.gs(null, function (value) {
    				// For IE11 issue see:
    				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
    				//    ie11-broken-getters-on-dom-objects
    				// https://github.com/medikoo/es6-symbol/issues/12
    				if (ie11BugWorkaround) return;
    				ie11BugWorkaround = true;
    				defineProperty(this, name, d(value));
    				ie11BugWorkaround = false;
    			})
    		);
    		return name;
    	};
    	return generateName;
    }

    var standardSymbols;
    var hasRequiredStandardSymbols;

    function requireStandardSymbols () {
    	if (hasRequiredStandardSymbols) return standardSymbols;
    	hasRequiredStandardSymbols = 1;

    	var d            = requireD()
    	  , NativeSymbol = requireGlobalThis().Symbol;

    	standardSymbols = function (SymbolPolyfill) {
    		return Object.defineProperties(SymbolPolyfill, {
    			// To ensure proper interoperability with other native functions (e.g. Array.from)
    			// fallback to eventual native implementation of given symbol
    			hasInstance: d(
    				"", (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill("hasInstance")
    			),
    			isConcatSpreadable: d(
    				"",
    				(NativeSymbol && NativeSymbol.isConcatSpreadable) ||
    					SymbolPolyfill("isConcatSpreadable")
    			),
    			iterator: d("", (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill("iterator")),
    			match: d("", (NativeSymbol && NativeSymbol.match) || SymbolPolyfill("match")),
    			replace: d("", (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill("replace")),
    			search: d("", (NativeSymbol && NativeSymbol.search) || SymbolPolyfill("search")),
    			species: d("", (NativeSymbol && NativeSymbol.species) || SymbolPolyfill("species")),
    			split: d("", (NativeSymbol && NativeSymbol.split) || SymbolPolyfill("split")),
    			toPrimitive: d(
    				"", (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill("toPrimitive")
    			),
    			toStringTag: d(
    				"", (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill("toStringTag")
    			),
    			unscopables: d(
    				"", (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill("unscopables")
    			)
    		});
    	};
    	return standardSymbols;
    }

    var symbolRegistry;
    var hasRequiredSymbolRegistry;

    function requireSymbolRegistry () {
    	if (hasRequiredSymbolRegistry) return symbolRegistry;
    	hasRequiredSymbolRegistry = 1;

    	var d              = requireD()
    	  , validateSymbol = requireValidateSymbol();

    	var registry = Object.create(null);

    	symbolRegistry = function (SymbolPolyfill) {
    		return Object.defineProperties(SymbolPolyfill, {
    			for: d(function (key) {
    				if (registry[key]) return registry[key];
    				return (registry[key] = SymbolPolyfill(String(key)));
    			}),
    			keyFor: d(function (symbol) {
    				var key;
    				validateSymbol(symbol);
    				for (key in registry) {
    					if (registry[key] === symbol) return key;
    				}
    				return undefined;
    			})
    		});
    	};
    	return symbolRegistry;
    }

    var polyfill;
    var hasRequiredPolyfill;

    function requirePolyfill () {
    	if (hasRequiredPolyfill) return polyfill;
    	hasRequiredPolyfill = 1;

    	var d                    = requireD()
    	  , validateSymbol       = requireValidateSymbol()
    	  , NativeSymbol         = requireGlobalThis().Symbol
    	  , generateName         = requireGenerateName()
    	  , setupStandardSymbols = requireStandardSymbols()
    	  , setupSymbolRegistry  = requireSymbolRegistry();

    	var create = Object.create
    	  , defineProperties = Object.defineProperties
    	  , defineProperty = Object.defineProperty;

    	var SymbolPolyfill, HiddenSymbol, isNativeSafe;

    	if (typeof NativeSymbol === "function") {
    		try {
    			String(NativeSymbol());
    			isNativeSafe = true;
    		} catch (ignore) {}
    	} else {
    		NativeSymbol = null;
    	}

    	// Internal constructor (not one exposed) for creating Symbol instances.
    	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
    	HiddenSymbol = function Symbol(description) {
    		if (this instanceof HiddenSymbol) throw new TypeError("Symbol is not a constructor");
    		return SymbolPolyfill(description);
    	};

    	// Exposed `Symbol` constructor
    	// (returns instances of HiddenSymbol)
    	polyfill = SymbolPolyfill = function Symbol(description) {
    		var symbol;
    		if (this instanceof Symbol) throw new TypeError("Symbol is not a constructor");
    		if (isNativeSafe) return NativeSymbol(description);
    		symbol = create(HiddenSymbol.prototype);
    		description = description === undefined ? "" : String(description);
    		return defineProperties(symbol, {
    			__description__: d("", description),
    			__name__: d("", generateName(description))
    		});
    	};

    	setupStandardSymbols(SymbolPolyfill);
    	setupSymbolRegistry(SymbolPolyfill);

    	// Internal tweaks for real symbol producer
    	defineProperties(HiddenSymbol.prototype, {
    		constructor: d(SymbolPolyfill),
    		toString: d("", function () { return this.__name__; })
    	});

    	// Proper implementation of methods exposed on Symbol.prototype
    	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
    	defineProperties(SymbolPolyfill.prototype, {
    		toString: d(function () { return "Symbol (" + validateSymbol(this).__description__ + ")"; }),
    		valueOf: d(function () { return validateSymbol(this); })
    	});
    	defineProperty(
    		SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive,
    		d("", function () {
    			var symbol = validateSymbol(this);
    			if (typeof symbol === "symbol") return symbol;
    			return symbol.toString();
    		})
    	);
    	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol"));

    	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
    	defineProperty(
    		HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
    		d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
    	);

    	// Note: It's important to define `toPrimitive` as last one, as some implementations
    	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
    	// And that may invoke error in definition flow:
    	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
    	defineProperty(
    		HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
    		d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
    	);
    	return polyfill;
    }

    var es6Symbol;
    var hasRequiredEs6Symbol;

    function requireEs6Symbol () {
    	if (hasRequiredEs6Symbol) return es6Symbol;
    	hasRequiredEs6Symbol = 1;

    	es6Symbol = requireIsImplemented$2()()
    		? requireGlobalThis().Symbol
    		: requirePolyfill();
    	return es6Symbol;
    }

    var isArguments;
    var hasRequiredIsArguments;

    function requireIsArguments () {
    	if (hasRequiredIsArguments) return isArguments;
    	hasRequiredIsArguments = 1;

    	var objToString = Object.prototype.toString
    	  , id = objToString.call((function () { return arguments; })());

    	isArguments = function (value) { return objToString.call(value) === id; };
    	return isArguments;
    }

    var isFunction;
    var hasRequiredIsFunction;

    function requireIsFunction () {
    	if (hasRequiredIsFunction) return isFunction;
    	hasRequiredIsFunction = 1;

    	var objToString = Object.prototype.toString
    	  , isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);

    	isFunction = function (value) {
    		return typeof value === "function" && isFunctionStringTag(objToString.call(value));
    	};
    	return isFunction;
    }

    var isImplemented$1;
    var hasRequiredIsImplemented$1;

    function requireIsImplemented$1 () {
    	if (hasRequiredIsImplemented$1) return isImplemented$1;
    	hasRequiredIsImplemented$1 = 1;

    	isImplemented$1 = function () {
    		var sign = Math.sign;
    		if (typeof sign !== "function") return false;
    		return sign(10) === 1 && sign(-20) === -1;
    	};
    	return isImplemented$1;
    }

    var shim$2;
    var hasRequiredShim$2;

    function requireShim$2 () {
    	if (hasRequiredShim$2) return shim$2;
    	hasRequiredShim$2 = 1;

    	shim$2 = function (value) {
    		value = Number(value);
    		if (isNaN(value) || value === 0) return value;
    		return value > 0 ? 1 : -1;
    	};
    	return shim$2;
    }

    var sign;
    var hasRequiredSign;

    function requireSign () {
    	if (hasRequiredSign) return sign;
    	hasRequiredSign = 1;

    	sign = requireIsImplemented$1()() ? Math.sign : requireShim$2();
    	return sign;
    }

    var toInteger;
    var hasRequiredToInteger;

    function requireToInteger () {
    	if (hasRequiredToInteger) return toInteger;
    	hasRequiredToInteger = 1;

    	var sign  = requireSign()
    	  , abs   = Math.abs
    	  , floor = Math.floor;

    	toInteger = function (value) {
    		if (isNaN(value)) return 0;
    		value = Number(value);
    		if (value === 0 || !isFinite(value)) return value;
    		return sign(value) * floor(abs(value));
    	};
    	return toInteger;
    }

    var toPosInteger;
    var hasRequiredToPosInteger;

    function requireToPosInteger () {
    	if (hasRequiredToPosInteger) return toPosInteger;
    	hasRequiredToPosInteger = 1;

    	var toInteger = requireToInteger()
    	  , max       = Math.max;

    	toPosInteger = function (value) { return max(0, toInteger(value)); };
    	return toPosInteger;
    }

    var isString;
    var hasRequiredIsString;

    function requireIsString () {
    	if (hasRequiredIsString) return isString;
    	hasRequiredIsString = 1;

    	var objToString = Object.prototype.toString, id = objToString.call("");

    	isString = function (value) {
    		return (
    			typeof value === "string" ||
    			(value &&
    				typeof value === "object" &&
    				(value instanceof String || objToString.call(value) === id)) ||
    			false
    		);
    	};
    	return isString;
    }

    var shim$1;
    var hasRequiredShim$1;

    function requireShim$1 () {
    	if (hasRequiredShim$1) return shim$1;
    	hasRequiredShim$1 = 1;

    	var iteratorSymbol = requireEs6Symbol().iterator
    	  , isArguments    = requireIsArguments()
    	  , isFunction     = requireIsFunction()
    	  , toPosInt       = requireToPosInteger()
    	  , callable       = requireValidCallable()
    	  , validValue     = requireValidValue()
    	  , isValue        = requireIsValue()
    	  , isString       = requireIsString()
    	  , isArray        = Array.isArray
    	  , call           = Function.prototype.call
    	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
    	  , defineProperty = Object.defineProperty;

    	// eslint-disable-next-line complexity, max-lines-per-function
    	shim$1 = function (arrayLike /*, mapFn, thisArg*/) {
    		var mapFn = arguments[1]
    		  , thisArg = arguments[2]
    		  , Context
    		  , i
    		  , j
    		  , arr
    		  , length
    		  , code
    		  , iterator
    		  , result
    		  , getIterator
    		  , value;

    		arrayLike = Object(validValue(arrayLike));

    		if (isValue(mapFn)) callable(mapFn);
    		if (!this || this === Array || !isFunction(this)) {
    			// Result: Plain array
    			if (!mapFn) {
    				if (isArguments(arrayLike)) {
    					// Source: Arguments
    					length = arrayLike.length;
    					if (length !== 1) return Array.apply(null, arrayLike);
    					arr = new Array(1);
    					arr[0] = arrayLike[0];
    					return arr;
    				}
    				if (isArray(arrayLike)) {
    					// Source: Array
    					arr = new Array((length = arrayLike.length));
    					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
    					return arr;
    				}
    			}
    			arr = [];
    		} else {
    			// Result: Non plain array
    			Context = this;
    		}

    		if (!isArray(arrayLike)) {
    			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
    				// Source: Iterator
    				iterator = callable(getIterator).call(arrayLike);
    				if (Context) arr = new Context();
    				result = iterator.next();
    				i = 0;
    				while (!result.done) {
    					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
    					if (Context) {
    						desc.value = value;
    						defineProperty(arr, i, desc);
    					} else {
    						arr[i] = value;
    					}
    					result = iterator.next();
    					++i;
    				}
    				length = i;
    			} else if (isString(arrayLike)) {
    				// Source: String
    				length = arrayLike.length;
    				if (Context) arr = new Context();
    				for (i = 0, j = 0; i < length; ++i) {
    					value = arrayLike[i];
    					if (i + 1 < length) {
    						code = value.charCodeAt(0);
    						// eslint-disable-next-line max-depth
    						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
    					}
    					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
    					if (Context) {
    						desc.value = value;
    						defineProperty(arr, j, desc);
    					} else {
    						arr[j] = value;
    					}
    					++j;
    				}
    				length = j;
    			}
    		}
    		if (length === undefined) {
    			// Source: array or array-like
    			length = toPosInt(arrayLike.length);
    			if (Context) arr = new Context(length);
    			for (i = 0; i < length; ++i) {
    				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
    				if (Context) {
    					desc.value = value;
    					defineProperty(arr, i, desc);
    				} else {
    					arr[i] = value;
    				}
    			}
    		}
    		if (Context) {
    			desc.value = null;
    			arr.length = length;
    		}
    		return arr;
    	};
    	return shim$1;
    }

    var from;
    var hasRequiredFrom;

    function requireFrom () {
    	if (hasRequiredFrom) return from;
    	hasRequiredFrom = 1;

    	from = requireIsImplemented$4()() ? Array.from : requireShim$1();
    	return from;
    }

    var isImplemented;
    var hasRequiredIsImplemented;

    function requireIsImplemented () {
    	if (hasRequiredIsImplemented) return isImplemented;
    	hasRequiredIsImplemented = 1;

    	isImplemented = function () {
    		var numberIsNaN = Number.isNaN;
    		if (typeof numberIsNaN !== "function") return false;
    		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
    	};
    	return isImplemented;
    }

    var shim;
    var hasRequiredShim;

    function requireShim () {
    	if (hasRequiredShim) return shim;
    	hasRequiredShim = 1;

    	shim = function (value) {
    		// eslint-disable-next-line no-self-compare
    		return value !== value;
    	};
    	return shim;
    }

    var isNan;
    var hasRequiredIsNan;

    function requireIsNan () {
    	if (hasRequiredIsNan) return isNan;
    	hasRequiredIsNan = 1;

    	isNan = requireIsImplemented()() ? Number.isNaN : requireShim();
    	return isNan;
    }

    var eIndexOf;
    var hasRequiredEIndexOf;

    function requireEIndexOf () {
    	if (hasRequiredEIndexOf) return eIndexOf;
    	hasRequiredEIndexOf = 1;

    	var numberIsNaN       = requireIsNan()
    	  , toPosInt          = requireToPosInteger()
    	  , value             = requireValidValue()
    	  , indexOf           = Array.prototype.indexOf
    	  , objHasOwnProperty = Object.prototype.hasOwnProperty
    	  , abs               = Math.abs
    	  , floor             = Math.floor;

    	eIndexOf = function (searchElement /*, fromIndex*/) {
    		var i, length, fromIndex, val;
    		if (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);

    		length = toPosInt(value(this).length);
    		fromIndex = arguments[1];
    		if (isNaN(fromIndex)) fromIndex = 0;
    		else if (fromIndex >= 0) fromIndex = floor(fromIndex);
    		else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));

    		for (i = fromIndex; i < length; ++i) {
    			if (objHasOwnProperty.call(this, i)) {
    				val = this[i];
    				if (numberIsNaN(val)) return i; // Jslint: ignore
    			}
    		}
    		return -1;
    	};
    	return eIndexOf;
    }

    var remove;
    var hasRequiredRemove;

    function requireRemove () {
    	if (hasRequiredRemove) return remove;
    	hasRequiredRemove = 1;

    	var indexOf = requireEIndexOf()
    	  , forEach = Array.prototype.forEach
    	  , splice  = Array.prototype.splice;

    	// eslint-disable-next-line no-unused-vars
    	remove = function (itemToRemove /*, item*/) {
    		forEach.call(
    			arguments,
    			function (item) {
    				var index = indexOf.call(this, item);
    				if (index !== -1) splice.call(this, index, 1);
    			},
    			this
    		);
    	};
    	return remove;
    }

    var isObject;
    var hasRequiredIsObject;

    function requireIsObject () {
    	if (hasRequiredIsObject) return isObject;
    	hasRequiredIsObject = 1;

    	var isValue = requireIsValue();

    	var map = { function: true, object: true };

    	isObject = function (value) { return (isValue(value) && map[typeof value]) || false; };
    	return isObject;
    }

    var validObject;
    var hasRequiredValidObject;

    function requireValidObject () {
    	if (hasRequiredValidObject) return validObject;
    	hasRequiredValidObject = 1;

    	var isObject = requireIsObject();

    	validObject = function (value) {
    		if (!isObject(value)) throw new TypeError(value + " is not an Object");
    		return value;
    	};
    	return validObject;
    }

    var pipe$1;
    var hasRequiredPipe;

    function requirePipe () {
    	if (hasRequiredPipe) return pipe$1;
    	hasRequiredPipe = 1;

    	var aFrom          = requireFrom()
    	  , remove         = requireRemove()
    	  , value          = requireValidObject()
    	  , d              = requireD()
    	  , emit           = requireEventEmitter().methods.emit

    	  , defineProperty = Object.defineProperty
    	  , hasOwnProperty = Object.prototype.hasOwnProperty
    	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

    	pipe$1 = function (e1, e2/*, name*/) {
    		var pipes, pipe, desc, name;

    		(value(e1) && value(e2));
    		name = arguments[2];
    		if (name === undefined) name = 'emit';

    		pipe = {
    			close: function () { remove.call(pipes, e2); }
    		};
    		if (hasOwnProperty.call(e1, '__eePipes__')) {
    			(pipes = e1.__eePipes__).push(e2);
    			return pipe;
    		}
    		defineProperty(e1, '__eePipes__', d('c', pipes = [e2]));
    		desc = getOwnPropertyDescriptor(e1, name);
    		if (!desc) {
    			desc = d('c', undefined);
    		} else {
    			delete desc.get;
    			delete desc.set;
    		}
    		desc.value = function () {
    			var i, emitter, data = aFrom(pipes);
    			emit.apply(this, arguments);
    			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
    		};
    		defineProperty(e1, name, desc);
    		return pipe;
    	};
    	return pipe$1;
    }

    var pipeExports = requirePipe();
    var pipe = /*@__PURE__*/getDefaultExportFromCjs(pipeExports);

    let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

    class Handlers {
    	constructor(chunker, polisher, caller) {

    		registeredHandlers.forEach((Handler) => {
    			let handler = new Handler(chunker, polisher, caller);
    			pipe(handler, this);
    		});
    	}
    }

    EventEmitter(Handlers.prototype);

    function registerHandlers() {
    	for (var i = 0; i < arguments.length; i++) {
    		registeredHandlers.push(arguments[i]);
    	}
    }

    function initializeHandlers(chunker, polisher, caller) {
    	let handlers = new Handlers(chunker, polisher, caller);
    	return handlers;
    }

    class Previewer {
    	constructor(options) {
    		// this.preview = this.getParams("preview") !== "false";

    		this.settings = options || {};

    		// Process styles
    		this.polisher = new Polisher(false);

    		// Chunk contents
    		this.chunker = new Chunker(undefined, undefined, this.settings);

    		// Hooks
    		this.hooks = {};
    		this.hooks.beforePreview = new Hook(this);
    		this.hooks.afterPreview = new Hook(this);

    		// default size
    		this.size = {
    			width: {
    				value: 8.5,
    				unit: "in"
    			},
    			height: {
    				value: 11,
    				unit: "in"
    			},
    			format: undefined,
    			orientation: undefined
    		};

    		this.chunker.on("page", (page) => {
    			this.emit("page", page);
    		});

    		this.chunker.on("rendering", () => {
    			this.emit("rendering", this.chunker);
    		});
    	}

    	initializeHandlers() {
    		let handlers = initializeHandlers(this.chunker, this.polisher, this);

    		handlers.on("size", (size) => {
    			this.size = size;
    			this.emit("size", size);
    		});

    		handlers.on("atpages", (pages) => {
    			this.atpages = pages;
    			this.emit("atpages", pages);
    		});

    		return handlers;
    	}

    	registerHandlers() {
    		return registerHandlers.apply(registerHandlers, arguments);
    	}

    	getParams(name) {
    		let param;
    		let url = new URL(window.location);
    		let params = new URLSearchParams(url.search);
    		for(var pair of params.entries()) {
    			if(pair[0] === name) {
    				param = pair[1];
    			}
    		}

    		return param;
    	}

    	wrapContent() {
    		// Wrap body in template tag
    		let body = document.querySelector("body");

    		// Check if a template exists
    		let template;
    		template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

    		if (!template) {
    			// Otherwise create one
    			template = document.createElement("template");
    			template.dataset.ref = "pagedjs-content";
    			template.innerHTML = body.innerHTML;
    			body.innerHTML = "";
    			body.appendChild(template);
    		}

    		return template.content;
    	}

    	removeStyles(doc=document) {
    		// Get all stylesheets
    		const stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']:not([data-pagedjs-ignore], [media~='screen'])"));
    		// Get inline styles
    		const inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles], [data-pagedjs-ignore], [media~='screen'])"));
    		const elements = [...stylesheets, ...inlineStyles];
    		return elements
    			// preserve order
    			.sort(function (element1, element2) {
    				const position = element1.compareDocumentPosition(element2);
    				if (position === Node.DOCUMENT_POSITION_PRECEDING) {
    					return 1;
    				} else if (position === Node.DOCUMENT_POSITION_FOLLOWING) {
    					return -1;
    				}
    				return 0;
    			})
    			// extract the href
    			.map((element) => {
    				if (element.nodeName === "STYLE") {
    					const obj = {};
    					obj[window.location.href] = element.textContent;
    					element.remove();
    					return obj;
    				}
    				if (element.nodeName === "LINK") {
    					element.remove();
    					return element.href;
    				}
    				// ignore
    				console.warn(`Unable to process: ${element}, ignoring.`);
    			});
    	}

    	async preview(content, stylesheets, renderTo) {

    		await this.hooks.beforePreview.trigger(content, renderTo);

    		if (!content) {
    			content = this.wrapContent();
    		}

    		if (!stylesheets) {
    			stylesheets = this.removeStyles();
    		}

    		this.polisher.setup();

    		this.handlers = this.initializeHandlers();

    		await this.polisher.add(...stylesheets);

    		let startTime = performance.now();

    		// Render flow
    		let flow = await this.chunker.flow(content, renderTo);

    		let endTime = performance.now();

    		flow.performance = (endTime - startTime);
    		flow.size = this.size;

    		this.emit("rendered", flow);

    		await this.hooks.afterPreview.trigger(flow.pages);

    		return flow;
    	}
    }

    EventEmitter(Previewer.prototype);

    class WatermarkHandler extends Handler {
        constructor(chunker, polisher, caller, config) {
            super(chunker, polisher, caller);
            this.chunker = chunker;
            this.polisher = polisher;
            this.caller = caller;
            this.config = config;
        }
        afterPageLayout(pageElement, page, breakToken, chunker) {
            const watermark = document.createElement("div");
            watermark.classList.add("watermark");
            pageElement.querySelector(".pagedjs_area").appendChild(watermark);
        }
    }

    const FOLHA_DE_ROSTO = "folhaDeRosto";
    class HeaderFooterHandler extends Handler {
        constructor(chunker, polisher, caller, config) {
            super(chunker, polisher, caller);
            // Cache for element heights to avoid layout thrashing
            this.heightCache = new Map();
            this.chunker = chunker;
            this.polisher = polisher;
            this.caller = caller;
            this.config = config;
            this.originalWidth = 0;
            this.originalHeight = 0;
        }
        beforePageLayout(page) {
            // Only calculate heights once per content type (Main vs Cover)
            // This reduces layout thrashing from O(N) to O(1) where N is pages.
            if (page.element.classList.contains(`pagedjs_${FOLHA_DE_ROSTO}_page`)) {
                this.createHeaderArea(page, this.config.cabecalhoFolhaDeRosto, 'cover-header');
                this.createFooterArea(page, this.config.footerFolhaDeRosto, 'cover-footer');
                return;
            }
            this.createHeaderArea(page, this.config.cabecalhoPagina, 'main-header');
            this.createFooterArea(page, this.config.footer, 'main-footer');
            page.area.classList.add("adaptive-block-avalicao-visualize");
        }
        createFooterArea(page, content, cacheKey) {
            const pageArea = page.element.querySelector(".pagedjs_area");
            if (pageArea && pageArea.querySelector(".pagedjs_footer_area"))
                return;
            const footerArea = document.createElement("footer");
            footerArea.classList.add("pagedjs_footer_area");
            footerArea.innerHTML = content;
            pageArea.appendChild(footerArea);
            const height = this.getCachedHeight(cacheKey, footerArea.firstElementChild);
            page.element.style.setProperty("--pagedjs-footer-height", height + "px");
        }
        createHeaderArea(page, content, cacheKey) {
            const pageArea = page.element.querySelector(".pagedjs_area");
            if (pageArea && pageArea.querySelector(".pagedjs_headernote_area"))
                return;
            const headerArea = document.createElement("header");
            headerArea.classList.add("pagedjs_headernote_area");
            headerArea.innerHTML = content;
            pageArea.insertBefore(headerArea, pageArea.firstChild);
            const height = this.getCachedHeight(cacheKey, headerArea);
            page.element.style.setProperty("--pagedjs-header-height", height + "px");
        }
        getCachedHeight(key, element) {
            if (this.heightCache.has(key)) {
                return this.heightCache.get(key);
            }
            const h = this.calculateRealHeight(element);
            // Cache the result so subsequent pages don't trigger reflow/restyle
            this.heightCache.set(key, h);
            return h;
        }
        calculateRealHeight(element) {
            if (!element)
                return 0;
            // Optimization: Single DOM Read Phase
            // Get all necessary metrics in one go to minimize browser recalculations
            const { height } = element.getBoundingClientRect();
            const styles = window.getComputedStyle(element);
            // Helper to avoid repetitive parsing
            const getInt = (val) => {
                const parsed = parseInt(val);
                return isNaN(parsed) ? 0 : parsed;
            };
            // Calculate sum of vertical spacings
            const margins = getInt(styles.marginTop) + getInt(styles.marginBottom);
            const paddings = getInt(styles.paddingTop) + getInt(styles.paddingBottom);
            const borders = getInt(styles.borderTopWidth) + getInt(styles.borderBottomWidth);
            // Note: getBoundingClientRect height already includes padding and border in standard box-model,
            // but we preserve the original logic which added them again (possibly for specific Paged.js requirements or custom box-sizing)
            return height + margins + paddings + borders;
        }
    }

    const TIPO_ORDENACAO = Object.freeze({
        NAO_EMBARALHAR: 0,
        ALEATORIO: 1,
        ASCENDENTE: 2,
        DESCENDENTE: 3,
    });
    class OrderHandler extends Handler {
        constructor(chunker, polisher, caller, config = {}) {
            super(chunker, polisher, caller);
            this.orderCache = new Map();
            this.config = config;
        }
        afterPageLayout(pageElement) {
            const blocos = pageElement.querySelectorAll(".avaliacao-alternativas");
            for (const bloco of blocos) {
                this.processarBloco(bloco);
            }
        }
        processarBloco(bloco) {
            const { ref, splitFrom, ordemAlternativa: rawOrdem } = bloco.dataset;
            const filhos = Array.from(bloco.querySelectorAll(".linha-alternativa"));
            if (!filhos.length)
                return;
            // guarda tamanho original apenas na primeira renderizao
            if (!splitFrom) {
                this.orderCache.set(ref, filhos.length);
            }
            const ordem = this.resolverTipoOrdenacao(rawOrdem);
            const alternativas = filhos.map((element) => ({
                element,
                width: this.obterWidth(element)
            }));
            this.aplicarOrdenacao(alternativas, ordem);
            this.reRenderizar(bloco, alternativas, ref, splitFrom);
        }
        resolverTipoOrdenacao(rawOrdem) {
            var _a;
            const parsed = Number.parseInt(rawOrdem, 10);
            if (!rawOrdem || Number.isNaN(parsed) || parsed === 0) {
                return typeof ((_a = this.config) === null || _a === void 0 ? void 0 : _a.ordemAlternativa) === "number"
                    ? this.config.ordemAlternativa
                    : TIPO_ORDENACAO.NAO_EMBARALHAR;
            }
            return parsed;
        }
        obterWidth(element) {
            const conteudo = element.querySelector(".media-corpo");
            const originalWidth = element.style.width;
            const originalMaxWidth = element.style.maxWidth;
            element.style.width = 'max-content';
            element.style.maxWidth = '100%';
            const target = conteudo || element;
            const width = target.getBoundingClientRect().width;
            element.style.width = originalWidth;
            element.style.maxWidth = originalMaxWidth;
            return width;
        }
        aplicarOrdenacao(alternativas, tipo) {
            switch (tipo) {
                case TIPO_ORDENACAO.ASCENDENTE:
                    alternativas.sort((a, b) => a.width - b.width);
                    break;
                case TIPO_ORDENACAO.DESCENDENTE:
                    alternativas.sort((a, b) => b.width - a.width);
                    break;
                case TIPO_ORDENACAO.ALEATORIO:
                    this.shuffle(alternativas);
                    break;
                case TIPO_ORDENACAO.NAO_EMBARALHAR:
            }
        }
        reRenderizar(bloco, alternativas, ref, splitFrom) {
            var _a;
            const fragment = document.createDocumentFragment();
            const baseIndex = splitFrom ? ((_a = this.orderCache.get(ref)) !== null && _a !== void 0 ? _a : 0) : 0;
            alternativas.forEach(({ element }, index) => {
                const indiceFinal = baseIndex + index;
                const label = element.querySelector(".media-esq");
                if (label) {
                    label.innerHTML = conversorDeIndicesParaAlternativas(indiceFinal, this.config.tipoAlternativa);
                }
                fragment.appendChild(element);
            });
            bloco.replaceChildren(fragment);
            bloco.dataset.ordemAlternativaProcessada = "true";
        }
        shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
    }

    class PreventEmptyPageHandler extends Handler {
        onBreakToken(breakToken, overflow, rendered, layout) {
            if (!(breakToken === null || breakToken === void 0 ? void 0 : breakToken.node) || breakToken.node.nodeType !== 1)
                return;
            const el = breakToken.node;
            const hasVisualContent = el.querySelector('img, svg, table, video, canvas, iframe');
            const isEmpty = el.textContent.trim().length === 0 && !hasVisualContent;
            if (isEmpty && el.offsetHeight === 0) {
                // When Paged.js successfully identifies an overflow and creates a breakToken,
                // we intercept it here. If the element causing the break is genuinely empty and 0 height,
                // we want to cancel the page break. 
                // 
                // We cannot return `null` because `layout.js` calls `breakToken.equals()`.
                // Instead, we override `.equals()` to mathematically return `true`. 
                // `layout.js` interprets `breakToken.equals(prevBreakToken) === true` as an infinite loop 
                // and gracefully aborts the layout for this node, preventing the blank page creation
                // without ever hiding or deleting the user's anchors!
                breakToken.equals = function () { return true; };
                return breakToken;
            }
        }
    }

    /**
     * Handler to enforce multi-column layout on specific pages using Paged.js internal layout engine.
     */
    class ColumnHandler extends Handler {
        constructor(chunker, polisher, caller) {
            super(chunker, polisher, caller);
            // Inject global styles to prevent forced breaks inside columns
            // This ensures that the first element doesn't immediately break out of the first column
            const style = document.createElement('style');
            style.id = 'pagedjs-column-styles';
            style.innerHTML = `
            .pagedjs_column > * { 
                break-before: auto !important; 
                page-break-before: auto !important;
                break-inside: auto !important;
            }
            .pagedjs_column_1 {
                padding-right: 10px;
                border-right: solid 1px rgb(66, 65, 65);
            }
            .pagedjs_column_2 {
                padding-left: 10px;
            }
        `;
            document.head.appendChild(style);
        }
        /**
         * Hook called before page layout.
         * Checks if the page is a named page that requires columnization.
         */
        beforePageLayout(page, contents, breakToken, chunker) {
            const pageElement = page.element;
            const computedStyle = window.getComputedStyle(pageElement);
            const columnCountVal = computedStyle.getPropertyValue("--pagedjs-column-count").trim();
            const columnCount = parseInt(columnCountVal);
            computedStyle.getPropertyValue("--pagedjs-column-gap").trim() || "0px";
            // If no column count is defined, return and let Paged.js handle layout normally
            if (isNaN(columnCount) || columnCount < 2) {
                return;
            }
            // Override the page layout method
            page.layout = async (contents, breakToken, prevPage) => {
                page.clear();
                page.startToken = breakToken;
                // Clear existing content in page area
                page.area.innerHTML = '';
                // Create a container for columns
                const columnContainer = document.createElement("div");
                columnContainer.style.display = "flex";
                columnContainer.style.height = "100%";
                columnContainer.style.width = "100%";
                //columnContainer.style.gap = columnGap;
                page.area.appendChild(columnContainer);
                const columnWrappers = [];
                for (let i = 0; i < columnCount; i++) {
                    const col = document.createElement("div");
                    col.classList.add("pagedjs_column", `pagedjs_column_${i + 1}`);
                    col.style.flex = "1";
                    col.style.flexBasis = "0"; // Ensure equal distribution
                    col.style.minWidth = "0"; // Allow shrinking if needed
                    col.style.height = "100%";
                    columnContainer.appendChild(col);
                    columnWrappers.push(col);
                }
                // Force reflow/layout calc to ensure flex items have dimensions
                columnContainer.getBoundingClientRect();
                // Now sequentially fill columns
                let currentBreakToken = breakToken;
                for (let i = 0; i < columnWrappers.length; i++) {
                    // If we ran out of content in previous iteration, stop
                    if (!currentBreakToken && i > 0) {
                        break;
                    }
                    let wrapper = columnWrappers[i];
                    // Use the wrapper itself as the layout scope.
                    // This ensures 'this.bounds' in Layout refers to the column dimensions, not the full page.
                    let layout = new Layout(wrapper, page.hooks, page.settings);
                    let renderResult = await layout.renderTo(wrapper, contents, currentBreakToken);
                    currentBreakToken = renderResult.breakToken;
                }
                page.addListeners(contents);
                page.endToken = currentBreakToken;
                return currentBreakToken;
            };
        }
    }

    class PagedJsRenderer {
        static async render(result, stylesheets = null, pagesContainer) {
            if (!result || pagesContainer === undefined) {
                throw new Error("Parmetros invlidos para renderizao do layout de avaliao.");
            }
            // aplica o HTML
            const contentContainer = document.createElement('div');
            contentContainer.innerHTML = result.layoutHtml;
            // aplica CSS vars
            Object.entries(result.cssVars).forEach(([key, value]) => {
                if (value)
                    document.documentElement.style.setProperty(key, String(value));
            });
            const defaultHandlers = [
                {
                    MyHandler: PreventEmptyPageHandler,
                    config: {},
                },
                {
                    MyHandler: WatermarkHandler,
                    config: { comMarcaDaguaRascunho: result.comMarcaDaguaRascunho },
                },
                {
                    MyHandler: HeaderFooterHandler,
                    config: {
                        cabecalhoPagina: result.header,
                        cabecalhoFolhaDeRosto: result.folhaDeRosto.header,
                        footer: result.footer
                            ? `<div class="footer-avaliacao">${result.footer}</div>`
                            : "",
                        footerFolhaDeRosto: result.folhaDeRosto.footer
                            ? `<div class="footer-avaliacao">${result.folhaDeRosto.footer}</div>`
                            : "",
                    },
                },
                {
                    MyHandler: ColumnHandler,
                    config: {}
                },
                {
                    MyHandler: OrderHandler,
                    config: { ordemAlternativa: result.ordemAlternativa, tipoAlternativa: result.tipoAlternativa }
                },
                ...result.handlers
            ];
            // inicializa preview
            let paged = new Previewer();
            // prepara handlers configurados e registra via paged.registerHandlers
            const configuredHandlers = prepareHandlers(defaultHandlers);
            paged.registerHandlers(...configuredHandlers);
            return paged.preview(contentContainer, stylesheets, pagesContainer).then(chunker => {
                chunker.pages.forEach(page => page.removeListeners());
                contentContainer.remove();
                return chunker;
            });
        }
    }
    function prepareHandlers(handlersWithConfig) {
        return handlersWithConfig.map(({ MyHandler, config }) => {
            class ConfiguredHandler extends MyHandler {
                constructor(chunker, polisher, caller) {
                    super(chunker, polisher, caller, config);
                }
            }
            ConfiguredHandler.__originalHandler = MyHandler;
            const existingIndex = registeredHandlers.findIndex((h) => h.__originalHandler === MyHandler);
            if (existingIndex !== -1) {
                registeredHandlers.splice(existingIndex, 1);
            }
            return ConfiguredHandler;
        });
    }

    /**
     * Lexing or parsing positional information for error reporting.
     * This object is immutable.
     */
    class SourceLocation {
      // The + prefix indicates that these fields aren't writeable
      // Lexer holding the input string.
      // Start offset, zero-based inclusive.
      // End offset, zero-based exclusive.
      constructor(lexer, start, end) {
        this.lexer = void 0;
        this.start = void 0;
        this.end = void 0;
        this.lexer = lexer;
        this.start = start;
        this.end = end;
      }
      /**
       * Merges two `SourceLocation`s from location providers, given they are
       * provided in order of appearance.
       * - Returns the first one's location if only the first is provided.
       * - Returns a merged range of the first and the last if both are provided
       *   and their lexers match.
       * - Otherwise, returns null.
       */


      static range(first, second) {
        if (!second) {
          return first && first.loc;
        } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
          return null;
        } else {
          return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
        }
      }

    }

    /**
     * Interface required to break circular dependency between Token, Lexer, and
     * ParseError.
     */

    /**
     * The resulting token returned from `lex`.
     *
     * It consists of the token text plus some position information.
     * The position information is essentially a range in an input string,
     * but instead of referencing the bare input string, we refer to the lexer.
     * That way it is possible to attach extra metadata to the input string,
     * like for example a file name or similar.
     *
     * The position information is optional, so it is OK to construct synthetic
     * tokens if appropriate. Not providing available position information may
     * lead to degraded error reporting, though.
     */
    class Token {
      // don't expand the token
      // used in \noexpand
      constructor(text, // the text of this token
      loc) {
        this.text = void 0;
        this.loc = void 0;
        this.noexpand = void 0;
        this.treatAsRelax = void 0;
        this.text = text;
        this.loc = loc;
      }
      /**
       * Given a pair of tokens (this and endToken), compute a `Token` encompassing
       * the whole input range enclosed by these two.
       */


      range(endToken, // last token of the range, inclusive
      text // the text of the newly constructed token
      ) {
        return new Token(text, SourceLocation.range(this, endToken));
      }

    }

    /**
     * This is the ParseError class, which is the main error thrown by KaTeX
     * functions when something has gone wrong. This is used to distinguish internal
     * errors from errors in the expression that the user provided.
     *
     * If possible, a caller should provide a Token or ParseNode with information
     * about where in the source string the problem occurred.
     */
    class ParseError {
      // Error start position based on passed-in Token or ParseNode.
      // Length of affected text based on passed-in Token or ParseNode.
      // The underlying error message without any context added.
      constructor(message, // The error message
      token // An object providing position information
      ) {
        this.name = void 0;
        this.position = void 0;
        this.length = void 0;
        this.rawMessage = void 0;
        var error = "KaTeX parse error: " + message;
        var start;
        var end;
        var loc = token && token.loc;

        if (loc && loc.start <= loc.end) {
          // If we have the input and a position, make the error a bit fancier
          // Get the input
          var input = loc.lexer.input; // Prepend some information

          start = loc.start;
          end = loc.end;

          if (start === input.length) {
            error += " at end of input: ";
          } else {
            error += " at position " + (start + 1) + ": ";
          } // Underline token in question using combining underscores


          var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332"); // Extract some context from the input and add it to the error

          var left;

          if (start > 15) {
            left = "" + input.slice(start - 15, start);
          } else {
            left = input.slice(0, start);
          }

          var right;

          if (end + 15 < input.length) {
            right = input.slice(end, end + 15) + "";
          } else {
            right = input.slice(end);
          }

          error += left + underlined + right;
        } // Some hackery to make ParseError a prototype of Error
        // See http://stackoverflow.com/a/8460753
        // $FlowFixMe


        var self = new Error(error);
        self.name = "ParseError"; // $FlowFixMe

        self.__proto__ = ParseError.prototype;
        self.position = start;

        if (start != null && end != null) {
          self.length = end - start;
        }

        self.rawMessage = message;
        return self;
      }

    } // $FlowFixMe More hackery


    ParseError.prototype.__proto__ = Error.prototype;

    /**
     * This file contains a list of utility functions which are useful in other
     * files.
     */

    /**
     * Provide a default value if a setting is undefined
     * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.
     */
    var deflt = function deflt(setting, defaultIfUndefined) {
      return setting === undefined ? defaultIfUndefined : setting;
    }; // hyphenate and escape adapted from Facebook's React under Apache 2 license


    var uppercase = /([A-Z])/g;

    var hyphenate = function hyphenate(str) {
      return str.replace(uppercase, "-$1").toLowerCase();
    };

    var ESCAPE_LOOKUP = {
      "&": "&amp;",
      ">": "&gt;",
      "<": "&lt;",
      "\"": "&quot;",
      "'": "&#x27;"
    };
    var ESCAPE_REGEX = /[&><"']/g;
    /**
     * Escapes text to prevent scripting attacks.
     */

    function escape(text) {
      return String(text).replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);
    }
    /**
     * Sometimes we want to pull out the innermost element of a group. In most
     * cases, this will just be the group itself, but when ordgroups and colors have
     * a single element, we want to pull that out.
     */


    var getBaseElem = function getBaseElem(group) {
      if (group.type === "ordgroup") {
        if (group.body.length === 1) {
          return getBaseElem(group.body[0]);
        } else {
          return group;
        }
      } else if (group.type === "color") {
        if (group.body.length === 1) {
          return getBaseElem(group.body[0]);
        } else {
          return group;
        }
      } else if (group.type === "font") {
        return getBaseElem(group.body);
      } else {
        return group;
      }
    };
    /**
     * TeXbook algorithms often reference "character boxes", which are simply groups
     * with a single character in them. To decide if something is a character box,
     * we find its innermost group, and see if it is a single character.
     */


    var isCharacterBox = function isCharacterBox(group) {
      var baseElem = getBaseElem(group); // These are all they types of groups which hold single characters

      return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
    };

    var assert = function assert(value) {
      if (!value) {
        throw new Error('Expected non-null, but got ' + String(value));
      }

      return value;
    };
    /**
     * Return the protocol of a URL, or "_relative" if the URL does not specify a
     * protocol (and thus is relative), or `null` if URL has invalid protocol
     * (so should be outright rejected).
     */

    var protocolFromUrl = function protocolFromUrl(url) {
      // Check for possible leading protocol.
      // https://url.spec.whatwg.org/#url-parsing strips leading whitespace
      // (U+20) or C0 control (U+00-U+1F) characters.
      // eslint-disable-next-line no-control-regex
      var protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);

      if (!protocol) {
        return "_relative";
      } // Reject weird colons


      if (protocol[2] !== ":") {
        return null;
      } // Reject invalid characters in scheme according to
      // https://datatracker.ietf.org/doc/html/rfc3986#section-3.1


      if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
        return null;
      } // Lowercase the protocol


      return protocol[1].toLowerCase();
    };
    var utils = {
      deflt,
      escape,
      hyphenate,
      getBaseElem,
      isCharacterBox,
      protocolFromUrl
    };

    /* eslint no-console:0 */
    // TODO: automatically generate documentation
    // TODO: check all properties on Settings exist
    // TODO: check the type of a property on Settings matches
    var SETTINGS_SCHEMA = {
      displayMode: {
        type: "boolean",
        description: "Render math in display mode, which puts the math in " + "display style (so \\int and \\sum are large, for example), and " + "centers the math on the page on its own line.",
        cli: "-d, --display-mode"
      },
      output: {
        type: {
          enum: ["htmlAndMathml", "html", "mathml"]
        },
        description: "Determines the markup language of the output.",
        cli: "-F, --format <type>"
      },
      leqno: {
        type: "boolean",
        description: "Render display math in leqno style (left-justified tags)."
      },
      fleqn: {
        type: "boolean",
        description: "Render display math flush left."
      },
      throwOnError: {
        type: "boolean",
        default: true,
        cli: "-t, --no-throw-on-error",
        cliDescription: "Render errors (in the color given by --error-color) ins" + "tead of throwing a ParseError exception when encountering an error."
      },
      errorColor: {
        type: "string",
        default: "#cc0000",
        cli: "-c, --error-color <color>",
        cliDescription: "A color string given in the format 'rgb' or 'rrggbb' " + "(no #). This option determines the color of errors rendered by the " + "-t option.",
        cliProcessor: color => "#" + color
      },
      macros: {
        type: "object",
        cli: "-m, --macro <def>",
        cliDescription: "Define custom macro of the form '\\foo:expansion' (use " + "multiple -m arguments for multiple macros).",
        cliDefault: [],
        cliProcessor: (def, defs) => {
          defs.push(def);
          return defs;
        }
      },
      minRuleThickness: {
        type: "number",
        description: "Specifies a minimum thickness, in ems, for fraction lines," + " `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, " + "`\\hdashline`, `\\underline`, `\\overline`, and the borders of " + "`\\fbox`, `\\boxed`, and `\\fcolorbox`.",
        processor: t => Math.max(0, t),
        cli: "--min-rule-thickness <size>",
        cliProcessor: parseFloat
      },
      colorIsTextColor: {
        type: "boolean",
        description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, " + "instead of LaTeX's one-argument \\color mode change.",
        cli: "-b, --color-is-text-color"
      },
      strict: {
        type: [{
          enum: ["warn", "ignore", "error"]
        }, "boolean", "function"],
        description: "Turn on strict / LaTeX faithfulness mode, which throws an " + "error if the input uses features that are not supported by LaTeX.",
        cli: "-S, --strict",
        cliDefault: false
      },
      trust: {
        type: ["boolean", "function"],
        description: "Trust the input, enabling all HTML features such as \\url.",
        cli: "-T, --trust"
      },
      maxSize: {
        type: "number",
        default: Infinity,
        description: "If non-zero, all user-specified sizes, e.g. in " + "\\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, " + "elements and spaces can be arbitrarily large",
        processor: s => Math.max(0, s),
        cli: "-s, --max-size <n>",
        cliProcessor: parseInt
      },
      maxExpand: {
        type: "number",
        default: 1000,
        description: "Limit the number of macro expansions to the specified " + "number, to prevent e.g. infinite macro loops. If set to Infinity, " + "the macro expander will try to fully expand as in LaTeX.",
        processor: n => Math.max(0, n),
        cli: "-e, --max-expand <n>",
        cliProcessor: n => n === "Infinity" ? Infinity : parseInt(n)
      },
      globalGroup: {
        type: "boolean",
        cli: false
      }
    };

    function getDefaultValue(schema) {
      if (schema.default) {
        return schema.default;
      }

      var type = schema.type;
      var defaultType = Array.isArray(type) ? type[0] : type;

      if (typeof defaultType !== 'string') {
        return defaultType.enum[0];
      }

      switch (defaultType) {
        case 'boolean':
          return false;

        case 'string':
          return '';

        case 'number':
          return 0;

        case 'object':
          return {};
      }
    }
    /**
     * The main Settings object
     *
     * The current options stored are:
     *  - displayMode: Whether the expression should be typeset as inline math
     *                 (false, the default), meaning that the math starts in
     *                 \textstyle and is placed in an inline-block); or as display
     *                 math (true), meaning that the math starts in \displaystyle
     *                 and is placed in a block with vertical margin.
     */


    class Settings {
      constructor(options) {
        this.displayMode = void 0;
        this.output = void 0;
        this.leqno = void 0;
        this.fleqn = void 0;
        this.throwOnError = void 0;
        this.errorColor = void 0;
        this.macros = void 0;
        this.minRuleThickness = void 0;
        this.colorIsTextColor = void 0;
        this.strict = void 0;
        this.trust = void 0;
        this.maxSize = void 0;
        this.maxExpand = void 0;
        this.globalGroup = void 0;
        // allow null options
        options = options || {};

        for (var prop in SETTINGS_SCHEMA) {
          if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
            // $FlowFixMe
            var schema = SETTINGS_SCHEMA[prop]; // TODO: validate options
            // $FlowFixMe

            this[prop] = options[prop] !== undefined ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
          }
        }
      }
      /**
       * Report nonstrict (non-LaTeX-compatible) input.
       * Can safely not be called if `this.strict` is false in JavaScript.
       */


      reportNonstrict(errorCode, errorMsg, token) {
        var strict = this.strict;

        if (typeof strict === "function") {
          // Allow return value of strict function to be boolean or string
          // (or null/undefined, meaning no further processing).
          strict = strict(errorCode, errorMsg, token);
        }

        if (!strict || strict === "ignore") {
          return;
        } else if (strict === true || strict === "error") {
          throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
        } else if (strict === "warn") {
          typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
        } else {
          // won't happen in type-safe code
          typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
        }
      }
      /**
       * Check whether to apply strict (LaTeX-adhering) behavior for unusual
       * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
       * instead, "error" translates to a return value of `true`, while "ignore"
       * translates to a return value of `false`.  May still print a warning:
       * "warn" prints a warning and returns `false`.
       * This is for the second category of `errorCode`s listed in the README.
       */


      useStrictBehavior(errorCode, errorMsg, token) {
        var strict = this.strict;

        if (typeof strict === "function") {
          // Allow return value of strict function to be boolean or string
          // (or null/undefined, meaning no further processing).
          // But catch any exceptions thrown by function, treating them
          // like "error".
          try {
            strict = strict(errorCode, errorMsg, token);
          } catch (error) {
            strict = "error";
          }
        }

        if (!strict || strict === "ignore") {
          return false;
        } else if (strict === true || strict === "error") {
          return true;
        } else if (strict === "warn") {
          typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
          return false;
        } else {
          // won't happen in type-safe code
          typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
          return false;
        }
      }
      /**
       * Check whether to test potentially dangerous input, and return
       * `true` (trusted) or `false` (untrusted).  The sole argument `context`
       * should be an object with `command` field specifying the relevant LaTeX
       * command (as a string starting with `\`), and any other arguments, etc.
       * If `context` has a `url` field, a `protocol` field will automatically
       * get added by this function (changing the specified object).
       */


      isTrusted(context) {
        if (context.url && !context.protocol) {
          var protocol = utils.protocolFromUrl(context.url);

          if (protocol == null) {
            return false;
          }

          context.protocol = protocol;
        }

        var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
        return Boolean(trust);
      }

    }

    /**
     * This file contains information and classes for the various kinds of styles
     * used in TeX. It provides a generic `Style` class, which holds information
     * about a specific style. It then provides instances of all the different kinds
     * of styles possible, and provides functions to move between them and get
     * information about them.
     */

    /**
     * The main style class. Contains a unique id for the style, a size (which is
     * the same for cramped and uncramped version of a style), and a cramped flag.
     */
    class Style {
      constructor(id, size, cramped) {
        this.id = void 0;
        this.size = void 0;
        this.cramped = void 0;
        this.id = id;
        this.size = size;
        this.cramped = cramped;
      }
      /**
       * Get the style of a superscript given a base in the current style.
       */


      sup() {
        return styles[sup[this.id]];
      }
      /**
       * Get the style of a subscript given a base in the current style.
       */


      sub() {
        return styles[sub[this.id]];
      }
      /**
       * Get the style of a fraction numerator given the fraction in the current
       * style.
       */


      fracNum() {
        return styles[fracNum[this.id]];
      }
      /**
       * Get the style of a fraction denominator given the fraction in the current
       * style.
       */


      fracDen() {
        return styles[fracDen[this.id]];
      }
      /**
       * Get the cramped version of a style (in particular, cramping a cramped style
       * doesn't change the style).
       */


      cramp() {
        return styles[cramp[this.id]];
      }
      /**
       * Get a text or display version of this style.
       */


      text() {
        return styles[text$1[this.id]];
      }
      /**
       * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
       */


      isTight() {
        return this.size >= 2;
      }

    } // Export an interface for type checking, but don't expose the implementation.
    // This way, no more styles can be generated.


    // IDs of the different styles
    var D = 0;
    var Dc = 1;
    var T = 2;
    var Tc = 3;
    var S = 4;
    var Sc = 5;
    var SS = 6;
    var SSc = 7; // Instances of the different styles

    var styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)]; // Lookup tables for switching from one style to another

    var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
    var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
    var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
    var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
    var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
    var text$1 = [D, Dc, T, Tc, T, Tc, T, Tc]; // We only export some of the styles.

    var Style$1 = {
      DISPLAY: styles[D],
      TEXT: styles[T],
      SCRIPT: styles[S],
      SCRIPTSCRIPT: styles[SS]
    };

    /*
     * This file defines the Unicode scripts and script families that we
     * support. To add new scripts or families, just add a new entry to the
     * scriptData array below. Adding scripts to the scriptData array allows
     * characters from that script to appear in \text{} environments.
     */

    /**
     * Each script or script family has a name and an array of blocks.
     * Each block is an array of two numbers which specify the start and
     * end points (inclusive) of a block of Unicode codepoints.
     */

    /**
     * Unicode block data for the families of scripts we support in \text{}.
     * Scripts only need to appear here if they do not have font metrics.
     */
    var scriptData = [{
      // Latin characters beyond the Latin-1 characters we have metrics for.
      // Needed for Czech, Hungarian and Turkish text, for example.
      name: 'latin',
      blocks: [[0x0100, 0x024f], // Latin Extended-A and Latin Extended-B
      [0x0300, 0x036f] // Combining Diacritical marks
      ]
    }, {
      // The Cyrillic script used by Russian and related languages.
      // A Cyrillic subset used to be supported as explicitly defined
      // symbols in symbols.js
      name: 'cyrillic',
      blocks: [[0x0400, 0x04ff]]
    }, {
      // Armenian
      name: 'armenian',
      blocks: [[0x0530, 0x058F]]
    }, {
      // The Brahmic scripts of South and Southeast Asia
      // Devanagari (0900097F)
      // Bengali (098009FF)
      // Gurmukhi (0A000A7F)
      // Gujarati (0A800AFF)
      // Oriya (0B000B7F)
      // Tamil (0B800BFF)
      // Telugu (0C000C7F)
      // Kannada (0C800CFF)
      // Malayalam (0D000D7F)
      // Sinhala (0D800DFF)
      // Thai (0E000E7F)
      // Lao (0E800EFF)
      // Tibetan (0F000FFF)
      // Myanmar (1000109F)
      name: 'brahmic',
      blocks: [[0x0900, 0x109F]]
    }, {
      name: 'georgian',
      blocks: [[0x10A0, 0x10ff]]
    }, {
      // Chinese and Japanese.
      // The "k" in cjk is for Korean, but we've separated Korean out
      name: "cjk",
      blocks: [[0x3000, 0x30FF], // CJK symbols and punctuation, Hiragana, Katakana
      [0x4E00, 0x9FAF], // CJK ideograms
      [0xFF00, 0xFF60] // Fullwidth punctuation
      // TODO: add halfwidth Katakana and Romanji glyphs
      ]
    }, {
      // Korean
      name: 'hangul',
      blocks: [[0xAC00, 0xD7AF]]
    }];
    /**
     * Given a codepoint, return the name of the script or script family
     * it is from, or null if it is not part of a known block
     */

    function scriptFromCodepoint(codepoint) {
      for (var i = 0; i < scriptData.length; i++) {
        var script = scriptData[i];

        for (var _i = 0; _i < script.blocks.length; _i++) {
          var block = script.blocks[_i];

          if (codepoint >= block[0] && codepoint <= block[1]) {
            return script.name;
          }
        }
      }

      return null;
    }
    /**
     * A flattened version of all the supported blocks in a single array.
     * This is an optimization to make supportedCodepoint() fast.
     */

    var allBlocks = [];
    scriptData.forEach(s => s.blocks.forEach(b => allBlocks.push(...b)));
    /**
     * Given a codepoint, return true if it falls within one of the
     * scripts or script families defined above and false otherwise.
     *
     * Micro benchmarks shows that this is faster than
     * /[\u3000-\u30FF\u4E00-\u9FAF\uFF00-\uFF60\uAC00-\uD7AF\u0900-\u109F]/.test()
     * in Firefox, Chrome and Node.
     */

    function supportedCodepoint(codepoint) {
      for (var i = 0; i < allBlocks.length; i += 2) {
        if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
          return true;
        }
      }

      return false;
    }

    /**
     * This file provides support to domTree.js and delimiter.js.
     * It's a storehouse of path geometry for SVG images.
     */
    // In all paths below, the viewBox-to-em scale is 1000:1.
    var hLinePad = 80; // padding above a sqrt vinculum. Prevents image cropping.
    // The vinculum of a \sqrt can be made thicker by a KaTeX rendering option.
    // Think of variable extraVinculum as two detours in the SVG path.
    // The detour begins at the lower left of the area labeled extraVinculum below.
    // The detour proceeds one extraVinculum distance up and slightly to the right,
    // displacing the radiused corner between surd and vinculum. The radius is
    // traversed as usual, then the detour resumes. It goes right, to the end of
    // the very long vinculum, then down one extraVinculum distance,
    // after which it resumes regular path geometry for the radical.

    /*                                                  vinculum
                                                       /
             /extraVinculum
            / 0.04em (40 unit) std vinculum thickness
           / /
          / /
         / /\
        / / surd
    */

    var sqrtMain = function sqrtMain(extraVinculum, hLinePad) {
      // sqrtMain path geometry is from glyph U221A in the font KaTeX Main
      return "M95," + (622 + extraVinculum + hLinePad) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad + "h400000v" + (40 + extraVinculum) + "h-400000z";
    };

    var sqrtSize1 = function sqrtSize1(extraVinculum, hLinePad) {
      // size1 is from glyph U221A in the font KaTeX_Size1-Regular
      return "M263," + (601 + extraVinculum + hLinePad) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad + "h400000v" + (40 + extraVinculum) + "h-400000z";
    };

    var sqrtSize2 = function sqrtSize2(extraVinculum, hLinePad) {
      // size2 is from glyph U221A in the font KaTeX_Size2-Regular
      return "M983 " + (10 + extraVinculum + hLinePad) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad + "h400000v" + (40 + extraVinculum) + "h-400000z";
    };

    var sqrtSize3 = function sqrtSize3(extraVinculum, hLinePad) {
      // size3 is from glyph U221A in the font KaTeX_Size3-Regular
      return "M424," + (2398 + extraVinculum + hLinePad) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
    };

    var sqrtSize4 = function sqrtSize4(extraVinculum, hLinePad) {
      // size4 is from glyph U221A in the font KaTeX_Size4-Regular
      return "M473," + (2713 + extraVinculum + hLinePad) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad + "h400000v" + (40 + extraVinculum) + "H1017.7z";
    };

    var phasePath = function phasePath(y) {
      var x = y / 2; // x coordinate at top of angle

      return "M400000 " + y + " H0 L" + x + " 0 l65 45 L145 " + (y - 80) + " H400000z";
    };

    var sqrtTall = function sqrtTall(extraVinculum, hLinePad, viewBoxHeight) {
      // sqrtTall is from glyph U23B7 in the font KaTeX_Size4-Regular
      // One path edge has a variable length. It runs vertically from the vinculum
      // to a point near (14 units) the bottom of the surd. The vinculum
      // is normally 40 units thick. So the length of the line in question is:
      var vertSegment = viewBoxHeight - 54 - hLinePad - extraVinculum;
      return "M702 " + (extraVinculum + hLinePad) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad + "H400000v" + (40 + extraVinculum) + "H742z";
    };

    var sqrtPath = function sqrtPath(size, extraVinculum, viewBoxHeight) {
      extraVinculum = 1000 * extraVinculum; // Convert from document ems to viewBox.

      var path = "";

      switch (size) {
        case "sqrtMain":
          path = sqrtMain(extraVinculum, hLinePad);
          break;

        case "sqrtSize1":
          path = sqrtSize1(extraVinculum, hLinePad);
          break;

        case "sqrtSize2":
          path = sqrtSize2(extraVinculum, hLinePad);
          break;

        case "sqrtSize3":
          path = sqrtSize3(extraVinculum, hLinePad);
          break;

        case "sqrtSize4":
          path = sqrtSize4(extraVinculum, hLinePad);
          break;

        case "sqrtTall":
          path = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
      }

      return path;
    };
    var innerPath = function innerPath(name, height) {
      // The inner part of stretchy tall delimiters
      switch (name) {
        case "\u239c":
          return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";

        case "\u2223":
          return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";

        case "\u2225":
          return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");

        case "\u239f":
          return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";

        case "\u23a2":
          return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";

        case "\u23a5":
          return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";

        case "\u23aa":
          return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";

        case "\u23d0":
          return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";

        case "\u2016":
          return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");

        default:
          return "";
      }
    };
    var path = {
      // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
      doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
      // doublerightarrow is from glyph U+21D2 in font KaTeX Main
      doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
      // leftarrow is from glyph U+2190 in font KaTeX Main
      leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
      // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
      leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
      leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
      // overgroup is from the MnSymbol package (public domain)
      leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
      leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
      // Harpoons are from glyph U+21BD in font KaTeX Main
      leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
      leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
      leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
      leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
      // hook is from glyph U+21A9 in font KaTeX Main
      lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
      leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
      leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
      // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
      leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
      longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
      midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
      midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
      oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
      oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
      oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
      oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
      rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
      rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
      rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
      rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
      rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
      rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
      rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
      rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
      rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
      righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
      rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
      rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
      // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
      twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
      twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
      // tilde1 is a modified version of a glyph from the MnSymbol package
      tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
      // ditto tilde2, tilde3, & tilde4
      tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
      tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
      tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
      // vec is from glyph U+20D7 in font KaTeX Main
      vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
      // widehat1 is a modified version of a glyph from the MnSymbol package
      widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
      // ditto widehat2, widehat3, & widehat4
      widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
      widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
      widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
      // widecheck paths are all inverted versions of widehat
      widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
      widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
      widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
      widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
      // The next ten paths support reaction arrows from the mhchem package.
      // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
      // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
      baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
      // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
      rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
      // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
      // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
      baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
      rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
      shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
      shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
    };
    var tallDelim = function tallDelim(label, midHeight) {
      switch (label) {
        case "lbrack":
          return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";

        case "rbrack":
          return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";

        case "vert":
          return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";

        case "doublevert":
          return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";

        case "lfloor":
          return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";

        case "rfloor":
          return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";

        case "lceil":
          return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";

        case "rceil":
          return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";

        case "lparen":
          return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";

        case "rparen":
          return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";

        default:
          // We should not ever get here.
          throw new Error("Unknown stretchy delimiter.");
      }
    };

    // To ensure that all nodes have compatible signatures for these methods.

    /**
     * This node represents a document fragment, which contains elements, but when
     * placed into the DOM doesn't have any representation itself. It only contains
     * children and doesn't have any DOM node properties.
     */
    class DocumentFragment {
      // Never used; needed for satisfying interface.
      constructor(children) {
        this.children = void 0;
        this.classes = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.maxFontSize = void 0;
        this.style = void 0;
        this.children = children;
        this.classes = [];
        this.height = 0;
        this.depth = 0;
        this.maxFontSize = 0;
        this.style = {};
      }

      hasClass(className) {
        return this.classes.includes(className);
      }
      /** Convert the fragment into a node. */


      toNode() {
        var frag = document.createDocumentFragment();

        for (var i = 0; i < this.children.length; i++) {
          frag.appendChild(this.children[i].toNode());
        }

        return frag;
      }
      /** Convert the fragment into HTML markup. */


      toMarkup() {
        var markup = ""; // Simply concatenate the markup for the children together.

        for (var i = 0; i < this.children.length; i++) {
          markup += this.children[i].toMarkup();
        }

        return markup;
      }
      /**
       * Converts the math node into a string, similar to innerText. Applies to
       * MathDomNode's only.
       */


      toText() {
        // To avoid this, we would subclass documentFragment separately for
        // MathML, but polyfills for subclassing is expensive per PR 1469.
        // $FlowFixMe: Only works for ChildType = MathDomNode.
        var toText = child => child.toText();

        return this.children.map(toText).join("");
      }

    }

    // This file is GENERATED by buildMetrics.sh. DO NOT MODIFY.
    var fontMetricsData = {
      "AMS-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "65": [0, 0.68889, 0, 0, 0.72222],
        "66": [0, 0.68889, 0, 0, 0.66667],
        "67": [0, 0.68889, 0, 0, 0.72222],
        "68": [0, 0.68889, 0, 0, 0.72222],
        "69": [0, 0.68889, 0, 0, 0.66667],
        "70": [0, 0.68889, 0, 0, 0.61111],
        "71": [0, 0.68889, 0, 0, 0.77778],
        "72": [0, 0.68889, 0, 0, 0.77778],
        "73": [0, 0.68889, 0, 0, 0.38889],
        "74": [0.16667, 0.68889, 0, 0, 0.5],
        "75": [0, 0.68889, 0, 0, 0.77778],
        "76": [0, 0.68889, 0, 0, 0.66667],
        "77": [0, 0.68889, 0, 0, 0.94445],
        "78": [0, 0.68889, 0, 0, 0.72222],
        "79": [0.16667, 0.68889, 0, 0, 0.77778],
        "80": [0, 0.68889, 0, 0, 0.61111],
        "81": [0.16667, 0.68889, 0, 0, 0.77778],
        "82": [0, 0.68889, 0, 0, 0.72222],
        "83": [0, 0.68889, 0, 0, 0.55556],
        "84": [0, 0.68889, 0, 0, 0.66667],
        "85": [0, 0.68889, 0, 0, 0.72222],
        "86": [0, 0.68889, 0, 0, 0.72222],
        "87": [0, 0.68889, 0, 0, 1.0],
        "88": [0, 0.68889, 0, 0, 0.72222],
        "89": [0, 0.68889, 0, 0, 0.72222],
        "90": [0, 0.68889, 0, 0, 0.66667],
        "107": [0, 0.68889, 0, 0, 0.55556],
        "160": [0, 0, 0, 0, 0.25],
        "165": [0, 0.675, 0.025, 0, 0.75],
        "174": [0.15559, 0.69224, 0, 0, 0.94666],
        "240": [0, 0.68889, 0, 0, 0.55556],
        "295": [0, 0.68889, 0, 0, 0.54028],
        "710": [0, 0.825, 0, 0, 2.33334],
        "732": [0, 0.9, 0, 0, 2.33334],
        "770": [0, 0.825, 0, 0, 2.33334],
        "771": [0, 0.9, 0, 0, 2.33334],
        "989": [0.08167, 0.58167, 0, 0, 0.77778],
        "1008": [0, 0.43056, 0.04028, 0, 0.66667],
        "8245": [0, 0.54986, 0, 0, 0.275],
        "8463": [0, 0.68889, 0, 0, 0.54028],
        "8487": [0, 0.68889, 0, 0, 0.72222],
        "8498": [0, 0.68889, 0, 0, 0.55556],
        "8502": [0, 0.68889, 0, 0, 0.66667],
        "8503": [0, 0.68889, 0, 0, 0.44445],
        "8504": [0, 0.68889, 0, 0, 0.66667],
        "8513": [0, 0.68889, 0, 0, 0.63889],
        "8592": [-0.03598, 0.46402, 0, 0, 0.5],
        "8594": [-0.03598, 0.46402, 0, 0, 0.5],
        "8602": [-0.13313, 0.36687, 0, 0, 1.0],
        "8603": [-0.13313, 0.36687, 0, 0, 1.0],
        "8606": [0.01354, 0.52239, 0, 0, 1.0],
        "8608": [0.01354, 0.52239, 0, 0, 1.0],
        "8610": [0.01354, 0.52239, 0, 0, 1.11111],
        "8611": [0.01354, 0.52239, 0, 0, 1.11111],
        "8619": [0, 0.54986, 0, 0, 1.0],
        "8620": [0, 0.54986, 0, 0, 1.0],
        "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
        "8622": [-0.13313, 0.36687, 0, 0, 1.0],
        "8624": [0, 0.69224, 0, 0, 0.5],
        "8625": [0, 0.69224, 0, 0, 0.5],
        "8630": [0, 0.43056, 0, 0, 1.0],
        "8631": [0, 0.43056, 0, 0, 1.0],
        "8634": [0.08198, 0.58198, 0, 0, 0.77778],
        "8635": [0.08198, 0.58198, 0, 0, 0.77778],
        "8638": [0.19444, 0.69224, 0, 0, 0.41667],
        "8639": [0.19444, 0.69224, 0, 0, 0.41667],
        "8642": [0.19444, 0.69224, 0, 0, 0.41667],
        "8643": [0.19444, 0.69224, 0, 0, 0.41667],
        "8644": [0.1808, 0.675, 0, 0, 1.0],
        "8646": [0.1808, 0.675, 0, 0, 1.0],
        "8647": [0.1808, 0.675, 0, 0, 1.0],
        "8648": [0.19444, 0.69224, 0, 0, 0.83334],
        "8649": [0.1808, 0.675, 0, 0, 1.0],
        "8650": [0.19444, 0.69224, 0, 0, 0.83334],
        "8651": [0.01354, 0.52239, 0, 0, 1.0],
        "8652": [0.01354, 0.52239, 0, 0, 1.0],
        "8653": [-0.13313, 0.36687, 0, 0, 1.0],
        "8654": [-0.13313, 0.36687, 0, 0, 1.0],
        "8655": [-0.13313, 0.36687, 0, 0, 1.0],
        "8666": [0.13667, 0.63667, 0, 0, 1.0],
        "8667": [0.13667, 0.63667, 0, 0, 1.0],
        "8669": [-0.13313, 0.37788, 0, 0, 1.0],
        "8672": [-0.064, 0.437, 0, 0, 1.334],
        "8674": [-0.064, 0.437, 0, 0, 1.334],
        "8705": [0, 0.825, 0, 0, 0.5],
        "8708": [0, 0.68889, 0, 0, 0.55556],
        "8709": [0.08167, 0.58167, 0, 0, 0.77778],
        "8717": [0, 0.43056, 0, 0, 0.42917],
        "8722": [-0.03598, 0.46402, 0, 0, 0.5],
        "8724": [0.08198, 0.69224, 0, 0, 0.77778],
        "8726": [0.08167, 0.58167, 0, 0, 0.77778],
        "8733": [0, 0.69224, 0, 0, 0.77778],
        "8736": [0, 0.69224, 0, 0, 0.72222],
        "8737": [0, 0.69224, 0, 0, 0.72222],
        "8738": [0.03517, 0.52239, 0, 0, 0.72222],
        "8739": [0.08167, 0.58167, 0, 0, 0.22222],
        "8740": [0.25142, 0.74111, 0, 0, 0.27778],
        "8741": [0.08167, 0.58167, 0, 0, 0.38889],
        "8742": [0.25142, 0.74111, 0, 0, 0.5],
        "8756": [0, 0.69224, 0, 0, 0.66667],
        "8757": [0, 0.69224, 0, 0, 0.66667],
        "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
        "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
        "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
        "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
        "8774": [0.30274, 0.79383, 0, 0, 0.77778],
        "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
        "8778": [0.08167, 0.58167, 0, 0, 0.77778],
        "8782": [0.06062, 0.54986, 0, 0, 0.77778],
        "8783": [0.06062, 0.54986, 0, 0, 0.77778],
        "8785": [0.08198, 0.58198, 0, 0, 0.77778],
        "8786": [0.08198, 0.58198, 0, 0, 0.77778],
        "8787": [0.08198, 0.58198, 0, 0, 0.77778],
        "8790": [0, 0.69224, 0, 0, 0.77778],
        "8791": [0.22958, 0.72958, 0, 0, 0.77778],
        "8796": [0.08198, 0.91667, 0, 0, 0.77778],
        "8806": [0.25583, 0.75583, 0, 0, 0.77778],
        "8807": [0.25583, 0.75583, 0, 0, 0.77778],
        "8808": [0.25142, 0.75726, 0, 0, 0.77778],
        "8809": [0.25142, 0.75726, 0, 0, 0.77778],
        "8812": [0.25583, 0.75583, 0, 0, 0.5],
        "8814": [0.20576, 0.70576, 0, 0, 0.77778],
        "8815": [0.20576, 0.70576, 0, 0, 0.77778],
        "8816": [0.30274, 0.79383, 0, 0, 0.77778],
        "8817": [0.30274, 0.79383, 0, 0, 0.77778],
        "8818": [0.22958, 0.72958, 0, 0, 0.77778],
        "8819": [0.22958, 0.72958, 0, 0, 0.77778],
        "8822": [0.1808, 0.675, 0, 0, 0.77778],
        "8823": [0.1808, 0.675, 0, 0, 0.77778],
        "8828": [0.13667, 0.63667, 0, 0, 0.77778],
        "8829": [0.13667, 0.63667, 0, 0, 0.77778],
        "8830": [0.22958, 0.72958, 0, 0, 0.77778],
        "8831": [0.22958, 0.72958, 0, 0, 0.77778],
        "8832": [0.20576, 0.70576, 0, 0, 0.77778],
        "8833": [0.20576, 0.70576, 0, 0, 0.77778],
        "8840": [0.30274, 0.79383, 0, 0, 0.77778],
        "8841": [0.30274, 0.79383, 0, 0, 0.77778],
        "8842": [0.13597, 0.63597, 0, 0, 0.77778],
        "8843": [0.13597, 0.63597, 0, 0, 0.77778],
        "8847": [0.03517, 0.54986, 0, 0, 0.77778],
        "8848": [0.03517, 0.54986, 0, 0, 0.77778],
        "8858": [0.08198, 0.58198, 0, 0, 0.77778],
        "8859": [0.08198, 0.58198, 0, 0, 0.77778],
        "8861": [0.08198, 0.58198, 0, 0, 0.77778],
        "8862": [0, 0.675, 0, 0, 0.77778],
        "8863": [0, 0.675, 0, 0, 0.77778],
        "8864": [0, 0.675, 0, 0, 0.77778],
        "8865": [0, 0.675, 0, 0, 0.77778],
        "8872": [0, 0.69224, 0, 0, 0.61111],
        "8873": [0, 0.69224, 0, 0, 0.72222],
        "8874": [0, 0.69224, 0, 0, 0.88889],
        "8876": [0, 0.68889, 0, 0, 0.61111],
        "8877": [0, 0.68889, 0, 0, 0.61111],
        "8878": [0, 0.68889, 0, 0, 0.72222],
        "8879": [0, 0.68889, 0, 0, 0.72222],
        "8882": [0.03517, 0.54986, 0, 0, 0.77778],
        "8883": [0.03517, 0.54986, 0, 0, 0.77778],
        "8884": [0.13667, 0.63667, 0, 0, 0.77778],
        "8885": [0.13667, 0.63667, 0, 0, 0.77778],
        "8888": [0, 0.54986, 0, 0, 1.11111],
        "8890": [0.19444, 0.43056, 0, 0, 0.55556],
        "8891": [0.19444, 0.69224, 0, 0, 0.61111],
        "8892": [0.19444, 0.69224, 0, 0, 0.61111],
        "8901": [0, 0.54986, 0, 0, 0.27778],
        "8903": [0.08167, 0.58167, 0, 0, 0.77778],
        "8905": [0.08167, 0.58167, 0, 0, 0.77778],
        "8906": [0.08167, 0.58167, 0, 0, 0.77778],
        "8907": [0, 0.69224, 0, 0, 0.77778],
        "8908": [0, 0.69224, 0, 0, 0.77778],
        "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
        "8910": [0, 0.54986, 0, 0, 0.76042],
        "8911": [0, 0.54986, 0, 0, 0.76042],
        "8912": [0.03517, 0.54986, 0, 0, 0.77778],
        "8913": [0.03517, 0.54986, 0, 0, 0.77778],
        "8914": [0, 0.54986, 0, 0, 0.66667],
        "8915": [0, 0.54986, 0, 0, 0.66667],
        "8916": [0, 0.69224, 0, 0, 0.66667],
        "8918": [0.0391, 0.5391, 0, 0, 0.77778],
        "8919": [0.0391, 0.5391, 0, 0, 0.77778],
        "8920": [0.03517, 0.54986, 0, 0, 1.33334],
        "8921": [0.03517, 0.54986, 0, 0, 1.33334],
        "8922": [0.38569, 0.88569, 0, 0, 0.77778],
        "8923": [0.38569, 0.88569, 0, 0, 0.77778],
        "8926": [0.13667, 0.63667, 0, 0, 0.77778],
        "8927": [0.13667, 0.63667, 0, 0, 0.77778],
        "8928": [0.30274, 0.79383, 0, 0, 0.77778],
        "8929": [0.30274, 0.79383, 0, 0, 0.77778],
        "8934": [0.23222, 0.74111, 0, 0, 0.77778],
        "8935": [0.23222, 0.74111, 0, 0, 0.77778],
        "8936": [0.23222, 0.74111, 0, 0, 0.77778],
        "8937": [0.23222, 0.74111, 0, 0, 0.77778],
        "8938": [0.20576, 0.70576, 0, 0, 0.77778],
        "8939": [0.20576, 0.70576, 0, 0, 0.77778],
        "8940": [0.30274, 0.79383, 0, 0, 0.77778],
        "8941": [0.30274, 0.79383, 0, 0, 0.77778],
        "8994": [0.19444, 0.69224, 0, 0, 0.77778],
        "8995": [0.19444, 0.69224, 0, 0, 0.77778],
        "9416": [0.15559, 0.69224, 0, 0, 0.90222],
        "9484": [0, 0.69224, 0, 0, 0.5],
        "9488": [0, 0.69224, 0, 0, 0.5],
        "9492": [0, 0.37788, 0, 0, 0.5],
        "9496": [0, 0.37788, 0, 0, 0.5],
        "9585": [0.19444, 0.68889, 0, 0, 0.88889],
        "9586": [0.19444, 0.74111, 0, 0, 0.88889],
        "9632": [0, 0.675, 0, 0, 0.77778],
        "9633": [0, 0.675, 0, 0, 0.77778],
        "9650": [0, 0.54986, 0, 0, 0.72222],
        "9651": [0, 0.54986, 0, 0, 0.72222],
        "9654": [0.03517, 0.54986, 0, 0, 0.77778],
        "9660": [0, 0.54986, 0, 0, 0.72222],
        "9661": [0, 0.54986, 0, 0, 0.72222],
        "9664": [0.03517, 0.54986, 0, 0, 0.77778],
        "9674": [0.11111, 0.69224, 0, 0, 0.66667],
        "9733": [0.19444, 0.69224, 0, 0, 0.94445],
        "10003": [0, 0.69224, 0, 0, 0.83334],
        "10016": [0, 0.69224, 0, 0, 0.83334],
        "10731": [0.11111, 0.69224, 0, 0, 0.66667],
        "10846": [0.19444, 0.75583, 0, 0, 0.61111],
        "10877": [0.13667, 0.63667, 0, 0, 0.77778],
        "10878": [0.13667, 0.63667, 0, 0, 0.77778],
        "10885": [0.25583, 0.75583, 0, 0, 0.77778],
        "10886": [0.25583, 0.75583, 0, 0, 0.77778],
        "10887": [0.13597, 0.63597, 0, 0, 0.77778],
        "10888": [0.13597, 0.63597, 0, 0, 0.77778],
        "10889": [0.26167, 0.75726, 0, 0, 0.77778],
        "10890": [0.26167, 0.75726, 0, 0, 0.77778],
        "10891": [0.48256, 0.98256, 0, 0, 0.77778],
        "10892": [0.48256, 0.98256, 0, 0, 0.77778],
        "10901": [0.13667, 0.63667, 0, 0, 0.77778],
        "10902": [0.13667, 0.63667, 0, 0, 0.77778],
        "10933": [0.25142, 0.75726, 0, 0, 0.77778],
        "10934": [0.25142, 0.75726, 0, 0, 0.77778],
        "10935": [0.26167, 0.75726, 0, 0, 0.77778],
        "10936": [0.26167, 0.75726, 0, 0, 0.77778],
        "10937": [0.26167, 0.75726, 0, 0, 0.77778],
        "10938": [0.26167, 0.75726, 0, 0, 0.77778],
        "10949": [0.25583, 0.75583, 0, 0, 0.77778],
        "10950": [0.25583, 0.75583, 0, 0, 0.77778],
        "10955": [0.28481, 0.79383, 0, 0, 0.77778],
        "10956": [0.28481, 0.79383, 0, 0, 0.77778],
        "57350": [0.08167, 0.58167, 0, 0, 0.22222],
        "57351": [0.08167, 0.58167, 0, 0, 0.38889],
        "57352": [0.08167, 0.58167, 0, 0, 0.77778],
        "57353": [0, 0.43056, 0.04028, 0, 0.66667],
        "57356": [0.25142, 0.75726, 0, 0, 0.77778],
        "57357": [0.25142, 0.75726, 0, 0, 0.77778],
        "57358": [0.41951, 0.91951, 0, 0, 0.77778],
        "57359": [0.30274, 0.79383, 0, 0, 0.77778],
        "57360": [0.30274, 0.79383, 0, 0, 0.77778],
        "57361": [0.41951, 0.91951, 0, 0, 0.77778],
        "57366": [0.25142, 0.75726, 0, 0, 0.77778],
        "57367": [0.25142, 0.75726, 0, 0, 0.77778],
        "57368": [0.25142, 0.75726, 0, 0, 0.77778],
        "57369": [0.25142, 0.75726, 0, 0, 0.77778],
        "57370": [0.13597, 0.63597, 0, 0, 0.77778],
        "57371": [0.13597, 0.63597, 0, 0, 0.77778]
      },
      "Caligraphic-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "65": [0, 0.68333, 0, 0.19445, 0.79847],
        "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
        "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
        "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
        "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
        "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
        "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
        "72": [0, 0.68333, 0.00965, 0.11111, 0.84452],
        "73": [0, 0.68333, 0.07382, 0, 0.54452],
        "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
        "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
        "76": [0, 0.68333, 0, 0.13889, 0.68972],
        "77": [0, 0.68333, 0, 0.13889, 1.2009],
        "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
        "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
        "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
        "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
        "82": [0, 0.68333, 0, 0.08334, 0.8475],
        "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
        "84": [0, 0.68333, 0.25417, 0, 0.54464],
        "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
        "86": [0, 0.68333, 0.08222, 0, 0.61278],
        "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
        "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
        "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
        "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
        "160": [0, 0, 0, 0, 0.25]
      },
      "Fraktur-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69141, 0, 0, 0.29574],
        "34": [0, 0.69141, 0, 0, 0.21471],
        "38": [0, 0.69141, 0, 0, 0.73786],
        "39": [0, 0.69141, 0, 0, 0.21201],
        "40": [0.24982, 0.74947, 0, 0, 0.38865],
        "41": [0.24982, 0.74947, 0, 0, 0.38865],
        "42": [0, 0.62119, 0, 0, 0.27764],
        "43": [0.08319, 0.58283, 0, 0, 0.75623],
        "44": [0, 0.10803, 0, 0, 0.27764],
        "45": [0.08319, 0.58283, 0, 0, 0.75623],
        "46": [0, 0.10803, 0, 0, 0.27764],
        "47": [0.24982, 0.74947, 0, 0, 0.50181],
        "48": [0, 0.47534, 0, 0, 0.50181],
        "49": [0, 0.47534, 0, 0, 0.50181],
        "50": [0, 0.47534, 0, 0, 0.50181],
        "51": [0.18906, 0.47534, 0, 0, 0.50181],
        "52": [0.18906, 0.47534, 0, 0, 0.50181],
        "53": [0.18906, 0.47534, 0, 0, 0.50181],
        "54": [0, 0.69141, 0, 0, 0.50181],
        "55": [0.18906, 0.47534, 0, 0, 0.50181],
        "56": [0, 0.69141, 0, 0, 0.50181],
        "57": [0.18906, 0.47534, 0, 0, 0.50181],
        "58": [0, 0.47534, 0, 0, 0.21606],
        "59": [0.12604, 0.47534, 0, 0, 0.21606],
        "61": [-0.13099, 0.36866, 0, 0, 0.75623],
        "63": [0, 0.69141, 0, 0, 0.36245],
        "65": [0, 0.69141, 0, 0, 0.7176],
        "66": [0, 0.69141, 0, 0, 0.88397],
        "67": [0, 0.69141, 0, 0, 0.61254],
        "68": [0, 0.69141, 0, 0, 0.83158],
        "69": [0, 0.69141, 0, 0, 0.66278],
        "70": [0.12604, 0.69141, 0, 0, 0.61119],
        "71": [0, 0.69141, 0, 0, 0.78539],
        "72": [0.06302, 0.69141, 0, 0, 0.7203],
        "73": [0, 0.69141, 0, 0, 0.55448],
        "74": [0.12604, 0.69141, 0, 0, 0.55231],
        "75": [0, 0.69141, 0, 0, 0.66845],
        "76": [0, 0.69141, 0, 0, 0.66602],
        "77": [0, 0.69141, 0, 0, 1.04953],
        "78": [0, 0.69141, 0, 0, 0.83212],
        "79": [0, 0.69141, 0, 0, 0.82699],
        "80": [0.18906, 0.69141, 0, 0, 0.82753],
        "81": [0.03781, 0.69141, 0, 0, 0.82699],
        "82": [0, 0.69141, 0, 0, 0.82807],
        "83": [0, 0.69141, 0, 0, 0.82861],
        "84": [0, 0.69141, 0, 0, 0.66899],
        "85": [0, 0.69141, 0, 0, 0.64576],
        "86": [0, 0.69141, 0, 0, 0.83131],
        "87": [0, 0.69141, 0, 0, 1.04602],
        "88": [0, 0.69141, 0, 0, 0.71922],
        "89": [0.18906, 0.69141, 0, 0, 0.83293],
        "90": [0.12604, 0.69141, 0, 0, 0.60201],
        "91": [0.24982, 0.74947, 0, 0, 0.27764],
        "93": [0.24982, 0.74947, 0, 0, 0.27764],
        "94": [0, 0.69141, 0, 0, 0.49965],
        "97": [0, 0.47534, 0, 0, 0.50046],
        "98": [0, 0.69141, 0, 0, 0.51315],
        "99": [0, 0.47534, 0, 0, 0.38946],
        "100": [0, 0.62119, 0, 0, 0.49857],
        "101": [0, 0.47534, 0, 0, 0.40053],
        "102": [0.18906, 0.69141, 0, 0, 0.32626],
        "103": [0.18906, 0.47534, 0, 0, 0.5037],
        "104": [0.18906, 0.69141, 0, 0, 0.52126],
        "105": [0, 0.69141, 0, 0, 0.27899],
        "106": [0, 0.69141, 0, 0, 0.28088],
        "107": [0, 0.69141, 0, 0, 0.38946],
        "108": [0, 0.69141, 0, 0, 0.27953],
        "109": [0, 0.47534, 0, 0, 0.76676],
        "110": [0, 0.47534, 0, 0, 0.52666],
        "111": [0, 0.47534, 0, 0, 0.48885],
        "112": [0.18906, 0.52396, 0, 0, 0.50046],
        "113": [0.18906, 0.47534, 0, 0, 0.48912],
        "114": [0, 0.47534, 0, 0, 0.38919],
        "115": [0, 0.47534, 0, 0, 0.44266],
        "116": [0, 0.62119, 0, 0, 0.33301],
        "117": [0, 0.47534, 0, 0, 0.5172],
        "118": [0, 0.52396, 0, 0, 0.5118],
        "119": [0, 0.52396, 0, 0, 0.77351],
        "120": [0.18906, 0.47534, 0, 0, 0.38865],
        "121": [0.18906, 0.47534, 0, 0, 0.49884],
        "122": [0.18906, 0.47534, 0, 0, 0.39054],
        "160": [0, 0, 0, 0, 0.25],
        "8216": [0, 0.69141, 0, 0, 0.21471],
        "8217": [0, 0.69141, 0, 0, 0.21471],
        "58112": [0, 0.62119, 0, 0, 0.49749],
        "58113": [0, 0.62119, 0, 0, 0.4983],
        "58114": [0.18906, 0.69141, 0, 0, 0.33328],
        "58115": [0.18906, 0.69141, 0, 0, 0.32923],
        "58116": [0.18906, 0.47534, 0, 0, 0.50343],
        "58117": [0, 0.69141, 0, 0, 0.33301],
        "58118": [0, 0.62119, 0, 0, 0.33409],
        "58119": [0, 0.47534, 0, 0, 0.50073]
      },
      "Main-Bold": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0, 0, 0.35],
        "34": [0, 0.69444, 0, 0, 0.60278],
        "35": [0.19444, 0.69444, 0, 0, 0.95833],
        "36": [0.05556, 0.75, 0, 0, 0.575],
        "37": [0.05556, 0.75, 0, 0, 0.95833],
        "38": [0, 0.69444, 0, 0, 0.89444],
        "39": [0, 0.69444, 0, 0, 0.31944],
        "40": [0.25, 0.75, 0, 0, 0.44722],
        "41": [0.25, 0.75, 0, 0, 0.44722],
        "42": [0, 0.75, 0, 0, 0.575],
        "43": [0.13333, 0.63333, 0, 0, 0.89444],
        "44": [0.19444, 0.15556, 0, 0, 0.31944],
        "45": [0, 0.44444, 0, 0, 0.38333],
        "46": [0, 0.15556, 0, 0, 0.31944],
        "47": [0.25, 0.75, 0, 0, 0.575],
        "48": [0, 0.64444, 0, 0, 0.575],
        "49": [0, 0.64444, 0, 0, 0.575],
        "50": [0, 0.64444, 0, 0, 0.575],
        "51": [0, 0.64444, 0, 0, 0.575],
        "52": [0, 0.64444, 0, 0, 0.575],
        "53": [0, 0.64444, 0, 0, 0.575],
        "54": [0, 0.64444, 0, 0, 0.575],
        "55": [0, 0.64444, 0, 0, 0.575],
        "56": [0, 0.64444, 0, 0, 0.575],
        "57": [0, 0.64444, 0, 0, 0.575],
        "58": [0, 0.44444, 0, 0, 0.31944],
        "59": [0.19444, 0.44444, 0, 0, 0.31944],
        "60": [0.08556, 0.58556, 0, 0, 0.89444],
        "61": [-0.10889, 0.39111, 0, 0, 0.89444],
        "62": [0.08556, 0.58556, 0, 0, 0.89444],
        "63": [0, 0.69444, 0, 0, 0.54305],
        "64": [0, 0.69444, 0, 0, 0.89444],
        "65": [0, 0.68611, 0, 0, 0.86944],
        "66": [0, 0.68611, 0, 0, 0.81805],
        "67": [0, 0.68611, 0, 0, 0.83055],
        "68": [0, 0.68611, 0, 0, 0.88194],
        "69": [0, 0.68611, 0, 0, 0.75555],
        "70": [0, 0.68611, 0, 0, 0.72361],
        "71": [0, 0.68611, 0, 0, 0.90416],
        "72": [0, 0.68611, 0, 0, 0.9],
        "73": [0, 0.68611, 0, 0, 0.43611],
        "74": [0, 0.68611, 0, 0, 0.59444],
        "75": [0, 0.68611, 0, 0, 0.90138],
        "76": [0, 0.68611, 0, 0, 0.69166],
        "77": [0, 0.68611, 0, 0, 1.09166],
        "78": [0, 0.68611, 0, 0, 0.9],
        "79": [0, 0.68611, 0, 0, 0.86388],
        "80": [0, 0.68611, 0, 0, 0.78611],
        "81": [0.19444, 0.68611, 0, 0, 0.86388],
        "82": [0, 0.68611, 0, 0, 0.8625],
        "83": [0, 0.68611, 0, 0, 0.63889],
        "84": [0, 0.68611, 0, 0, 0.8],
        "85": [0, 0.68611, 0, 0, 0.88472],
        "86": [0, 0.68611, 0.01597, 0, 0.86944],
        "87": [0, 0.68611, 0.01597, 0, 1.18888],
        "88": [0, 0.68611, 0, 0, 0.86944],
        "89": [0, 0.68611, 0.02875, 0, 0.86944],
        "90": [0, 0.68611, 0, 0, 0.70277],
        "91": [0.25, 0.75, 0, 0, 0.31944],
        "92": [0.25, 0.75, 0, 0, 0.575],
        "93": [0.25, 0.75, 0, 0, 0.31944],
        "94": [0, 0.69444, 0, 0, 0.575],
        "95": [0.31, 0.13444, 0.03194, 0, 0.575],
        "97": [0, 0.44444, 0, 0, 0.55902],
        "98": [0, 0.69444, 0, 0, 0.63889],
        "99": [0, 0.44444, 0, 0, 0.51111],
        "100": [0, 0.69444, 0, 0, 0.63889],
        "101": [0, 0.44444, 0, 0, 0.52708],
        "102": [0, 0.69444, 0.10903, 0, 0.35139],
        "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
        "104": [0, 0.69444, 0, 0, 0.63889],
        "105": [0, 0.69444, 0, 0, 0.31944],
        "106": [0.19444, 0.69444, 0, 0, 0.35139],
        "107": [0, 0.69444, 0, 0, 0.60694],
        "108": [0, 0.69444, 0, 0, 0.31944],
        "109": [0, 0.44444, 0, 0, 0.95833],
        "110": [0, 0.44444, 0, 0, 0.63889],
        "111": [0, 0.44444, 0, 0, 0.575],
        "112": [0.19444, 0.44444, 0, 0, 0.63889],
        "113": [0.19444, 0.44444, 0, 0, 0.60694],
        "114": [0, 0.44444, 0, 0, 0.47361],
        "115": [0, 0.44444, 0, 0, 0.45361],
        "116": [0, 0.63492, 0, 0, 0.44722],
        "117": [0, 0.44444, 0, 0, 0.63889],
        "118": [0, 0.44444, 0.01597, 0, 0.60694],
        "119": [0, 0.44444, 0.01597, 0, 0.83055],
        "120": [0, 0.44444, 0, 0, 0.60694],
        "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
        "122": [0, 0.44444, 0, 0, 0.51111],
        "123": [0.25, 0.75, 0, 0, 0.575],
        "124": [0.25, 0.75, 0, 0, 0.31944],
        "125": [0.25, 0.75, 0, 0, 0.575],
        "126": [0.35, 0.34444, 0, 0, 0.575],
        "160": [0, 0, 0, 0, 0.25],
        "163": [0, 0.69444, 0, 0, 0.86853],
        "168": [0, 0.69444, 0, 0, 0.575],
        "172": [0, 0.44444, 0, 0, 0.76666],
        "176": [0, 0.69444, 0, 0, 0.86944],
        "177": [0.13333, 0.63333, 0, 0, 0.89444],
        "184": [0.17014, 0, 0, 0, 0.51111],
        "198": [0, 0.68611, 0, 0, 1.04166],
        "215": [0.13333, 0.63333, 0, 0, 0.89444],
        "216": [0.04861, 0.73472, 0, 0, 0.89444],
        "223": [0, 0.69444, 0, 0, 0.59722],
        "230": [0, 0.44444, 0, 0, 0.83055],
        "247": [0.13333, 0.63333, 0, 0, 0.89444],
        "248": [0.09722, 0.54167, 0, 0, 0.575],
        "305": [0, 0.44444, 0, 0, 0.31944],
        "338": [0, 0.68611, 0, 0, 1.16944],
        "339": [0, 0.44444, 0, 0, 0.89444],
        "567": [0.19444, 0.44444, 0, 0, 0.35139],
        "710": [0, 0.69444, 0, 0, 0.575],
        "711": [0, 0.63194, 0, 0, 0.575],
        "713": [0, 0.59611, 0, 0, 0.575],
        "714": [0, 0.69444, 0, 0, 0.575],
        "715": [0, 0.69444, 0, 0, 0.575],
        "728": [0, 0.69444, 0, 0, 0.575],
        "729": [0, 0.69444, 0, 0, 0.31944],
        "730": [0, 0.69444, 0, 0, 0.86944],
        "732": [0, 0.69444, 0, 0, 0.575],
        "733": [0, 0.69444, 0, 0, 0.575],
        "915": [0, 0.68611, 0, 0, 0.69166],
        "916": [0, 0.68611, 0, 0, 0.95833],
        "920": [0, 0.68611, 0, 0, 0.89444],
        "923": [0, 0.68611, 0, 0, 0.80555],
        "926": [0, 0.68611, 0, 0, 0.76666],
        "928": [0, 0.68611, 0, 0, 0.9],
        "931": [0, 0.68611, 0, 0, 0.83055],
        "933": [0, 0.68611, 0, 0, 0.89444],
        "934": [0, 0.68611, 0, 0, 0.83055],
        "936": [0, 0.68611, 0, 0, 0.89444],
        "937": [0, 0.68611, 0, 0, 0.83055],
        "8211": [0, 0.44444, 0.03194, 0, 0.575],
        "8212": [0, 0.44444, 0.03194, 0, 1.14999],
        "8216": [0, 0.69444, 0, 0, 0.31944],
        "8217": [0, 0.69444, 0, 0, 0.31944],
        "8220": [0, 0.69444, 0, 0, 0.60278],
        "8221": [0, 0.69444, 0, 0, 0.60278],
        "8224": [0.19444, 0.69444, 0, 0, 0.51111],
        "8225": [0.19444, 0.69444, 0, 0, 0.51111],
        "8242": [0, 0.55556, 0, 0, 0.34444],
        "8407": [0, 0.72444, 0.15486, 0, 0.575],
        "8463": [0, 0.69444, 0, 0, 0.66759],
        "8465": [0, 0.69444, 0, 0, 0.83055],
        "8467": [0, 0.69444, 0, 0, 0.47361],
        "8472": [0.19444, 0.44444, 0, 0, 0.74027],
        "8476": [0, 0.69444, 0, 0, 0.83055],
        "8501": [0, 0.69444, 0, 0, 0.70277],
        "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8593": [0.19444, 0.69444, 0, 0, 0.575],
        "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8595": [0.19444, 0.69444, 0, 0, 0.575],
        "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8597": [0.25, 0.75, 0, 0, 0.575],
        "8598": [0.19444, 0.69444, 0, 0, 1.14999],
        "8599": [0.19444, 0.69444, 0, 0, 1.14999],
        "8600": [0.19444, 0.69444, 0, 0, 1.14999],
        "8601": [0.19444, 0.69444, 0, 0, 1.14999],
        "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8657": [0.19444, 0.69444, 0, 0, 0.70277],
        "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8659": [0.19444, 0.69444, 0, 0, 0.70277],
        "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8661": [0.25, 0.75, 0, 0, 0.70277],
        "8704": [0, 0.69444, 0, 0, 0.63889],
        "8706": [0, 0.69444, 0.06389, 0, 0.62847],
        "8707": [0, 0.69444, 0, 0, 0.63889],
        "8709": [0.05556, 0.75, 0, 0, 0.575],
        "8711": [0, 0.68611, 0, 0, 0.95833],
        "8712": [0.08556, 0.58556, 0, 0, 0.76666],
        "8715": [0.08556, 0.58556, 0, 0, 0.76666],
        "8722": [0.13333, 0.63333, 0, 0, 0.89444],
        "8723": [0.13333, 0.63333, 0, 0, 0.89444],
        "8725": [0.25, 0.75, 0, 0, 0.575],
        "8726": [0.25, 0.75, 0, 0, 0.575],
        "8727": [-0.02778, 0.47222, 0, 0, 0.575],
        "8728": [-0.02639, 0.47361, 0, 0, 0.575],
        "8729": [-0.02639, 0.47361, 0, 0, 0.575],
        "8730": [0.18, 0.82, 0, 0, 0.95833],
        "8733": [0, 0.44444, 0, 0, 0.89444],
        "8734": [0, 0.44444, 0, 0, 1.14999],
        "8736": [0, 0.69224, 0, 0, 0.72222],
        "8739": [0.25, 0.75, 0, 0, 0.31944],
        "8741": [0.25, 0.75, 0, 0, 0.575],
        "8743": [0, 0.55556, 0, 0, 0.76666],
        "8744": [0, 0.55556, 0, 0, 0.76666],
        "8745": [0, 0.55556, 0, 0, 0.76666],
        "8746": [0, 0.55556, 0, 0, 0.76666],
        "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
        "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
        "8768": [0.19444, 0.69444, 0, 0, 0.31944],
        "8771": [0.00222, 0.50222, 0, 0, 0.89444],
        "8773": [0.027, 0.638, 0, 0, 0.894],
        "8776": [0.02444, 0.52444, 0, 0, 0.89444],
        "8781": [0.00222, 0.50222, 0, 0, 0.89444],
        "8801": [0.00222, 0.50222, 0, 0, 0.89444],
        "8804": [0.19667, 0.69667, 0, 0, 0.89444],
        "8805": [0.19667, 0.69667, 0, 0, 0.89444],
        "8810": [0.08556, 0.58556, 0, 0, 1.14999],
        "8811": [0.08556, 0.58556, 0, 0, 1.14999],
        "8826": [0.08556, 0.58556, 0, 0, 0.89444],
        "8827": [0.08556, 0.58556, 0, 0, 0.89444],
        "8834": [0.08556, 0.58556, 0, 0, 0.89444],
        "8835": [0.08556, 0.58556, 0, 0, 0.89444],
        "8838": [0.19667, 0.69667, 0, 0, 0.89444],
        "8839": [0.19667, 0.69667, 0, 0, 0.89444],
        "8846": [0, 0.55556, 0, 0, 0.76666],
        "8849": [0.19667, 0.69667, 0, 0, 0.89444],
        "8850": [0.19667, 0.69667, 0, 0, 0.89444],
        "8851": [0, 0.55556, 0, 0, 0.76666],
        "8852": [0, 0.55556, 0, 0, 0.76666],
        "8853": [0.13333, 0.63333, 0, 0, 0.89444],
        "8854": [0.13333, 0.63333, 0, 0, 0.89444],
        "8855": [0.13333, 0.63333, 0, 0, 0.89444],
        "8856": [0.13333, 0.63333, 0, 0, 0.89444],
        "8857": [0.13333, 0.63333, 0, 0, 0.89444],
        "8866": [0, 0.69444, 0, 0, 0.70277],
        "8867": [0, 0.69444, 0, 0, 0.70277],
        "8868": [0, 0.69444, 0, 0, 0.89444],
        "8869": [0, 0.69444, 0, 0, 0.89444],
        "8900": [-0.02639, 0.47361, 0, 0, 0.575],
        "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
        "8902": [-0.02778, 0.47222, 0, 0, 0.575],
        "8968": [0.25, 0.75, 0, 0, 0.51111],
        "8969": [0.25, 0.75, 0, 0, 0.51111],
        "8970": [0.25, 0.75, 0, 0, 0.51111],
        "8971": [0.25, 0.75, 0, 0, 0.51111],
        "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
        "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
        "9651": [0.19444, 0.69444, 0, 0, 1.02222],
        "9657": [-0.02778, 0.47222, 0, 0, 0.575],
        "9661": [0.19444, 0.69444, 0, 0, 1.02222],
        "9667": [-0.02778, 0.47222, 0, 0, 0.575],
        "9711": [0.19444, 0.69444, 0, 0, 1.14999],
        "9824": [0.12963, 0.69444, 0, 0, 0.89444],
        "9825": [0.12963, 0.69444, 0, 0, 0.89444],
        "9826": [0.12963, 0.69444, 0, 0, 0.89444],
        "9827": [0.12963, 0.69444, 0, 0, 0.89444],
        "9837": [0, 0.75, 0, 0, 0.44722],
        "9838": [0.19444, 0.69444, 0, 0, 0.44722],
        "9839": [0.19444, 0.69444, 0, 0, 0.44722],
        "10216": [0.25, 0.75, 0, 0, 0.44722],
        "10217": [0.25, 0.75, 0, 0, 0.44722],
        "10815": [0, 0.68611, 0, 0, 0.9],
        "10927": [0.19667, 0.69667, 0, 0, 0.89444],
        "10928": [0.19667, 0.69667, 0, 0, 0.89444],
        "57376": [0.19444, 0.69444, 0, 0, 0]
      },
      "Main-BoldItalic": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0.11417, 0, 0.38611],
        "34": [0, 0.69444, 0.07939, 0, 0.62055],
        "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
        "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
        "38": [0, 0.69444, 0.08528, 0, 0.88555],
        "39": [0, 0.69444, 0.12945, 0, 0.35555],
        "40": [0.25, 0.75, 0.15806, 0, 0.47333],
        "41": [0.25, 0.75, 0.03306, 0, 0.47333],
        "42": [0, 0.75, 0.14333, 0, 0.59111],
        "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
        "44": [0.19444, 0.14722, 0, 0, 0.35555],
        "45": [0, 0.44444, 0.02611, 0, 0.41444],
        "46": [0, 0.14722, 0, 0, 0.35555],
        "47": [0.25, 0.75, 0.15806, 0, 0.59111],
        "48": [0, 0.64444, 0.13167, 0, 0.59111],
        "49": [0, 0.64444, 0.13167, 0, 0.59111],
        "50": [0, 0.64444, 0.13167, 0, 0.59111],
        "51": [0, 0.64444, 0.13167, 0, 0.59111],
        "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
        "53": [0, 0.64444, 0.13167, 0, 0.59111],
        "54": [0, 0.64444, 0.13167, 0, 0.59111],
        "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
        "56": [0, 0.64444, 0.13167, 0, 0.59111],
        "57": [0, 0.64444, 0.13167, 0, 0.59111],
        "58": [0, 0.44444, 0.06695, 0, 0.35555],
        "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
        "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
        "63": [0, 0.69444, 0.11472, 0, 0.59111],
        "64": [0, 0.69444, 0.09208, 0, 0.88555],
        "65": [0, 0.68611, 0, 0, 0.86555],
        "66": [0, 0.68611, 0.0992, 0, 0.81666],
        "67": [0, 0.68611, 0.14208, 0, 0.82666],
        "68": [0, 0.68611, 0.09062, 0, 0.87555],
        "69": [0, 0.68611, 0.11431, 0, 0.75666],
        "70": [0, 0.68611, 0.12903, 0, 0.72722],
        "71": [0, 0.68611, 0.07347, 0, 0.89527],
        "72": [0, 0.68611, 0.17208, 0, 0.8961],
        "73": [0, 0.68611, 0.15681, 0, 0.47166],
        "74": [0, 0.68611, 0.145, 0, 0.61055],
        "75": [0, 0.68611, 0.14208, 0, 0.89499],
        "76": [0, 0.68611, 0, 0, 0.69777],
        "77": [0, 0.68611, 0.17208, 0, 1.07277],
        "78": [0, 0.68611, 0.17208, 0, 0.8961],
        "79": [0, 0.68611, 0.09062, 0, 0.85499],
        "80": [0, 0.68611, 0.0992, 0, 0.78721],
        "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
        "82": [0, 0.68611, 0.02559, 0, 0.85944],
        "83": [0, 0.68611, 0.11264, 0, 0.64999],
        "84": [0, 0.68611, 0.12903, 0, 0.7961],
        "85": [0, 0.68611, 0.17208, 0, 0.88083],
        "86": [0, 0.68611, 0.18625, 0, 0.86555],
        "87": [0, 0.68611, 0.18625, 0, 1.15999],
        "88": [0, 0.68611, 0.15681, 0, 0.86555],
        "89": [0, 0.68611, 0.19803, 0, 0.86555],
        "90": [0, 0.68611, 0.14208, 0, 0.70888],
        "91": [0.25, 0.75, 0.1875, 0, 0.35611],
        "93": [0.25, 0.75, 0.09972, 0, 0.35611],
        "94": [0, 0.69444, 0.06709, 0, 0.59111],
        "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
        "97": [0, 0.44444, 0.09426, 0, 0.59111],
        "98": [0, 0.69444, 0.07861, 0, 0.53222],
        "99": [0, 0.44444, 0.05222, 0, 0.53222],
        "100": [0, 0.69444, 0.10861, 0, 0.59111],
        "101": [0, 0.44444, 0.085, 0, 0.53222],
        "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
        "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
        "104": [0, 0.69444, 0.09426, 0, 0.59111],
        "105": [0, 0.69326, 0.11387, 0, 0.35555],
        "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
        "107": [0, 0.69444, 0.11111, 0, 0.53222],
        "108": [0, 0.69444, 0.10861, 0, 0.29666],
        "109": [0, 0.44444, 0.09426, 0, 0.94444],
        "110": [0, 0.44444, 0.09426, 0, 0.64999],
        "111": [0, 0.44444, 0.07861, 0, 0.59111],
        "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
        "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
        "114": [0, 0.44444, 0.11111, 0, 0.50167],
        "115": [0, 0.44444, 0.08167, 0, 0.48694],
        "116": [0, 0.63492, 0.09639, 0, 0.385],
        "117": [0, 0.44444, 0.09426, 0, 0.62055],
        "118": [0, 0.44444, 0.11111, 0, 0.53222],
        "119": [0, 0.44444, 0.11111, 0, 0.76777],
        "120": [0, 0.44444, 0.12583, 0, 0.56055],
        "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
        "122": [0, 0.44444, 0.13889, 0, 0.49055],
        "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
        "160": [0, 0, 0, 0, 0.25],
        "168": [0, 0.69444, 0.11473, 0, 0.59111],
        "176": [0, 0.69444, 0, 0, 0.94888],
        "184": [0.17014, 0, 0, 0, 0.53222],
        "198": [0, 0.68611, 0.11431, 0, 1.02277],
        "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
        "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
        "230": [0, 0.44444, 0.085, 0, 0.82666],
        "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
        "305": [0, 0.44444, 0.09426, 0, 0.35555],
        "338": [0, 0.68611, 0.11431, 0, 1.14054],
        "339": [0, 0.44444, 0.085, 0, 0.82666],
        "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
        "710": [0, 0.69444, 0.06709, 0, 0.59111],
        "711": [0, 0.63194, 0.08271, 0, 0.59111],
        "713": [0, 0.59444, 0.10444, 0, 0.59111],
        "714": [0, 0.69444, 0.08528, 0, 0.59111],
        "715": [0, 0.69444, 0, 0, 0.59111],
        "728": [0, 0.69444, 0.10333, 0, 0.59111],
        "729": [0, 0.69444, 0.12945, 0, 0.35555],
        "730": [0, 0.69444, 0, 0, 0.94888],
        "732": [0, 0.69444, 0.11472, 0, 0.59111],
        "733": [0, 0.69444, 0.11472, 0, 0.59111],
        "915": [0, 0.68611, 0.12903, 0, 0.69777],
        "916": [0, 0.68611, 0, 0, 0.94444],
        "920": [0, 0.68611, 0.09062, 0, 0.88555],
        "923": [0, 0.68611, 0, 0, 0.80666],
        "926": [0, 0.68611, 0.15092, 0, 0.76777],
        "928": [0, 0.68611, 0.17208, 0, 0.8961],
        "931": [0, 0.68611, 0.11431, 0, 0.82666],
        "933": [0, 0.68611, 0.10778, 0, 0.88555],
        "934": [0, 0.68611, 0.05632, 0, 0.82666],
        "936": [0, 0.68611, 0.10778, 0, 0.88555],
        "937": [0, 0.68611, 0.0992, 0, 0.82666],
        "8211": [0, 0.44444, 0.09811, 0, 0.59111],
        "8212": [0, 0.44444, 0.09811, 0, 1.18221],
        "8216": [0, 0.69444, 0.12945, 0, 0.35555],
        "8217": [0, 0.69444, 0.12945, 0, 0.35555],
        "8220": [0, 0.69444, 0.16772, 0, 0.62055],
        "8221": [0, 0.69444, 0.07939, 0, 0.62055]
      },
      "Main-Italic": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0.12417, 0, 0.30667],
        "34": [0, 0.69444, 0.06961, 0, 0.51444],
        "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
        "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
        "38": [0, 0.69444, 0.09694, 0, 0.76666],
        "39": [0, 0.69444, 0.12417, 0, 0.30667],
        "40": [0.25, 0.75, 0.16194, 0, 0.40889],
        "41": [0.25, 0.75, 0.03694, 0, 0.40889],
        "42": [0, 0.75, 0.14917, 0, 0.51111],
        "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
        "44": [0.19444, 0.10556, 0, 0, 0.30667],
        "45": [0, 0.43056, 0.02826, 0, 0.35778],
        "46": [0, 0.10556, 0, 0, 0.30667],
        "47": [0.25, 0.75, 0.16194, 0, 0.51111],
        "48": [0, 0.64444, 0.13556, 0, 0.51111],
        "49": [0, 0.64444, 0.13556, 0, 0.51111],
        "50": [0, 0.64444, 0.13556, 0, 0.51111],
        "51": [0, 0.64444, 0.13556, 0, 0.51111],
        "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
        "53": [0, 0.64444, 0.13556, 0, 0.51111],
        "54": [0, 0.64444, 0.13556, 0, 0.51111],
        "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
        "56": [0, 0.64444, 0.13556, 0, 0.51111],
        "57": [0, 0.64444, 0.13556, 0, 0.51111],
        "58": [0, 0.43056, 0.0582, 0, 0.30667],
        "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
        "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
        "63": [0, 0.69444, 0.1225, 0, 0.51111],
        "64": [0, 0.69444, 0.09597, 0, 0.76666],
        "65": [0, 0.68333, 0, 0, 0.74333],
        "66": [0, 0.68333, 0.10257, 0, 0.70389],
        "67": [0, 0.68333, 0.14528, 0, 0.71555],
        "68": [0, 0.68333, 0.09403, 0, 0.755],
        "69": [0, 0.68333, 0.12028, 0, 0.67833],
        "70": [0, 0.68333, 0.13305, 0, 0.65277],
        "71": [0, 0.68333, 0.08722, 0, 0.77361],
        "72": [0, 0.68333, 0.16389, 0, 0.74333],
        "73": [0, 0.68333, 0.15806, 0, 0.38555],
        "74": [0, 0.68333, 0.14028, 0, 0.525],
        "75": [0, 0.68333, 0.14528, 0, 0.76888],
        "76": [0, 0.68333, 0, 0, 0.62722],
        "77": [0, 0.68333, 0.16389, 0, 0.89666],
        "78": [0, 0.68333, 0.16389, 0, 0.74333],
        "79": [0, 0.68333, 0.09403, 0, 0.76666],
        "80": [0, 0.68333, 0.10257, 0, 0.67833],
        "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
        "82": [0, 0.68333, 0.03868, 0, 0.72944],
        "83": [0, 0.68333, 0.11972, 0, 0.56222],
        "84": [0, 0.68333, 0.13305, 0, 0.71555],
        "85": [0, 0.68333, 0.16389, 0, 0.74333],
        "86": [0, 0.68333, 0.18361, 0, 0.74333],
        "87": [0, 0.68333, 0.18361, 0, 0.99888],
        "88": [0, 0.68333, 0.15806, 0, 0.74333],
        "89": [0, 0.68333, 0.19383, 0, 0.74333],
        "90": [0, 0.68333, 0.14528, 0, 0.61333],
        "91": [0.25, 0.75, 0.1875, 0, 0.30667],
        "93": [0.25, 0.75, 0.10528, 0, 0.30667],
        "94": [0, 0.69444, 0.06646, 0, 0.51111],
        "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
        "97": [0, 0.43056, 0.07671, 0, 0.51111],
        "98": [0, 0.69444, 0.06312, 0, 0.46],
        "99": [0, 0.43056, 0.05653, 0, 0.46],
        "100": [0, 0.69444, 0.10333, 0, 0.51111],
        "101": [0, 0.43056, 0.07514, 0, 0.46],
        "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
        "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
        "104": [0, 0.69444, 0.07671, 0, 0.51111],
        "105": [0, 0.65536, 0.1019, 0, 0.30667],
        "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
        "107": [0, 0.69444, 0.10764, 0, 0.46],
        "108": [0, 0.69444, 0.10333, 0, 0.25555],
        "109": [0, 0.43056, 0.07671, 0, 0.81777],
        "110": [0, 0.43056, 0.07671, 0, 0.56222],
        "111": [0, 0.43056, 0.06312, 0, 0.51111],
        "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
        "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
        "114": [0, 0.43056, 0.10764, 0, 0.42166],
        "115": [0, 0.43056, 0.08208, 0, 0.40889],
        "116": [0, 0.61508, 0.09486, 0, 0.33222],
        "117": [0, 0.43056, 0.07671, 0, 0.53666],
        "118": [0, 0.43056, 0.10764, 0, 0.46],
        "119": [0, 0.43056, 0.10764, 0, 0.66444],
        "120": [0, 0.43056, 0.12042, 0, 0.46389],
        "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
        "122": [0, 0.43056, 0.12292, 0, 0.40889],
        "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
        "160": [0, 0, 0, 0, 0.25],
        "168": [0, 0.66786, 0.10474, 0, 0.51111],
        "176": [0, 0.69444, 0, 0, 0.83129],
        "184": [0.17014, 0, 0, 0, 0.46],
        "198": [0, 0.68333, 0.12028, 0, 0.88277],
        "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
        "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
        "230": [0, 0.43056, 0.07514, 0, 0.71555],
        "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
        "338": [0, 0.68333, 0.12028, 0, 0.98499],
        "339": [0, 0.43056, 0.07514, 0, 0.71555],
        "710": [0, 0.69444, 0.06646, 0, 0.51111],
        "711": [0, 0.62847, 0.08295, 0, 0.51111],
        "713": [0, 0.56167, 0.10333, 0, 0.51111],
        "714": [0, 0.69444, 0.09694, 0, 0.51111],
        "715": [0, 0.69444, 0, 0, 0.51111],
        "728": [0, 0.69444, 0.10806, 0, 0.51111],
        "729": [0, 0.66786, 0.11752, 0, 0.30667],
        "730": [0, 0.69444, 0, 0, 0.83129],
        "732": [0, 0.66786, 0.11585, 0, 0.51111],
        "733": [0, 0.69444, 0.1225, 0, 0.51111],
        "915": [0, 0.68333, 0.13305, 0, 0.62722],
        "916": [0, 0.68333, 0, 0, 0.81777],
        "920": [0, 0.68333, 0.09403, 0, 0.76666],
        "923": [0, 0.68333, 0, 0, 0.69222],
        "926": [0, 0.68333, 0.15294, 0, 0.66444],
        "928": [0, 0.68333, 0.16389, 0, 0.74333],
        "931": [0, 0.68333, 0.12028, 0, 0.71555],
        "933": [0, 0.68333, 0.11111, 0, 0.76666],
        "934": [0, 0.68333, 0.05986, 0, 0.71555],
        "936": [0, 0.68333, 0.11111, 0, 0.76666],
        "937": [0, 0.68333, 0.10257, 0, 0.71555],
        "8211": [0, 0.43056, 0.09208, 0, 0.51111],
        "8212": [0, 0.43056, 0.09208, 0, 1.02222],
        "8216": [0, 0.69444, 0.12417, 0, 0.30667],
        "8217": [0, 0.69444, 0.12417, 0, 0.30667],
        "8220": [0, 0.69444, 0.1685, 0, 0.51444],
        "8221": [0, 0.69444, 0.06961, 0, 0.51444],
        "8463": [0, 0.68889, 0, 0, 0.54028]
      },
      "Main-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0, 0, 0.27778],
        "34": [0, 0.69444, 0, 0, 0.5],
        "35": [0.19444, 0.69444, 0, 0, 0.83334],
        "36": [0.05556, 0.75, 0, 0, 0.5],
        "37": [0.05556, 0.75, 0, 0, 0.83334],
        "38": [0, 0.69444, 0, 0, 0.77778],
        "39": [0, 0.69444, 0, 0, 0.27778],
        "40": [0.25, 0.75, 0, 0, 0.38889],
        "41": [0.25, 0.75, 0, 0, 0.38889],
        "42": [0, 0.75, 0, 0, 0.5],
        "43": [0.08333, 0.58333, 0, 0, 0.77778],
        "44": [0.19444, 0.10556, 0, 0, 0.27778],
        "45": [0, 0.43056, 0, 0, 0.33333],
        "46": [0, 0.10556, 0, 0, 0.27778],
        "47": [0.25, 0.75, 0, 0, 0.5],
        "48": [0, 0.64444, 0, 0, 0.5],
        "49": [0, 0.64444, 0, 0, 0.5],
        "50": [0, 0.64444, 0, 0, 0.5],
        "51": [0, 0.64444, 0, 0, 0.5],
        "52": [0, 0.64444, 0, 0, 0.5],
        "53": [0, 0.64444, 0, 0, 0.5],
        "54": [0, 0.64444, 0, 0, 0.5],
        "55": [0, 0.64444, 0, 0, 0.5],
        "56": [0, 0.64444, 0, 0, 0.5],
        "57": [0, 0.64444, 0, 0, 0.5],
        "58": [0, 0.43056, 0, 0, 0.27778],
        "59": [0.19444, 0.43056, 0, 0, 0.27778],
        "60": [0.0391, 0.5391, 0, 0, 0.77778],
        "61": [-0.13313, 0.36687, 0, 0, 0.77778],
        "62": [0.0391, 0.5391, 0, 0, 0.77778],
        "63": [0, 0.69444, 0, 0, 0.47222],
        "64": [0, 0.69444, 0, 0, 0.77778],
        "65": [0, 0.68333, 0, 0, 0.75],
        "66": [0, 0.68333, 0, 0, 0.70834],
        "67": [0, 0.68333, 0, 0, 0.72222],
        "68": [0, 0.68333, 0, 0, 0.76389],
        "69": [0, 0.68333, 0, 0, 0.68056],
        "70": [0, 0.68333, 0, 0, 0.65278],
        "71": [0, 0.68333, 0, 0, 0.78472],
        "72": [0, 0.68333, 0, 0, 0.75],
        "73": [0, 0.68333, 0, 0, 0.36111],
        "74": [0, 0.68333, 0, 0, 0.51389],
        "75": [0, 0.68333, 0, 0, 0.77778],
        "76": [0, 0.68333, 0, 0, 0.625],
        "77": [0, 0.68333, 0, 0, 0.91667],
        "78": [0, 0.68333, 0, 0, 0.75],
        "79": [0, 0.68333, 0, 0, 0.77778],
        "80": [0, 0.68333, 0, 0, 0.68056],
        "81": [0.19444, 0.68333, 0, 0, 0.77778],
        "82": [0, 0.68333, 0, 0, 0.73611],
        "83": [0, 0.68333, 0, 0, 0.55556],
        "84": [0, 0.68333, 0, 0, 0.72222],
        "85": [0, 0.68333, 0, 0, 0.75],
        "86": [0, 0.68333, 0.01389, 0, 0.75],
        "87": [0, 0.68333, 0.01389, 0, 1.02778],
        "88": [0, 0.68333, 0, 0, 0.75],
        "89": [0, 0.68333, 0.025, 0, 0.75],
        "90": [0, 0.68333, 0, 0, 0.61111],
        "91": [0.25, 0.75, 0, 0, 0.27778],
        "92": [0.25, 0.75, 0, 0, 0.5],
        "93": [0.25, 0.75, 0, 0, 0.27778],
        "94": [0, 0.69444, 0, 0, 0.5],
        "95": [0.31, 0.12056, 0.02778, 0, 0.5],
        "97": [0, 0.43056, 0, 0, 0.5],
        "98": [0, 0.69444, 0, 0, 0.55556],
        "99": [0, 0.43056, 0, 0, 0.44445],
        "100": [0, 0.69444, 0, 0, 0.55556],
        "101": [0, 0.43056, 0, 0, 0.44445],
        "102": [0, 0.69444, 0.07778, 0, 0.30556],
        "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
        "104": [0, 0.69444, 0, 0, 0.55556],
        "105": [0, 0.66786, 0, 0, 0.27778],
        "106": [0.19444, 0.66786, 0, 0, 0.30556],
        "107": [0, 0.69444, 0, 0, 0.52778],
        "108": [0, 0.69444, 0, 0, 0.27778],
        "109": [0, 0.43056, 0, 0, 0.83334],
        "110": [0, 0.43056, 0, 0, 0.55556],
        "111": [0, 0.43056, 0, 0, 0.5],
        "112": [0.19444, 0.43056, 0, 0, 0.55556],
        "113": [0.19444, 0.43056, 0, 0, 0.52778],
        "114": [0, 0.43056, 0, 0, 0.39167],
        "115": [0, 0.43056, 0, 0, 0.39445],
        "116": [0, 0.61508, 0, 0, 0.38889],
        "117": [0, 0.43056, 0, 0, 0.55556],
        "118": [0, 0.43056, 0.01389, 0, 0.52778],
        "119": [0, 0.43056, 0.01389, 0, 0.72222],
        "120": [0, 0.43056, 0, 0, 0.52778],
        "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
        "122": [0, 0.43056, 0, 0, 0.44445],
        "123": [0.25, 0.75, 0, 0, 0.5],
        "124": [0.25, 0.75, 0, 0, 0.27778],
        "125": [0.25, 0.75, 0, 0, 0.5],
        "126": [0.35, 0.31786, 0, 0, 0.5],
        "160": [0, 0, 0, 0, 0.25],
        "163": [0, 0.69444, 0, 0, 0.76909],
        "167": [0.19444, 0.69444, 0, 0, 0.44445],
        "168": [0, 0.66786, 0, 0, 0.5],
        "172": [0, 0.43056, 0, 0, 0.66667],
        "176": [0, 0.69444, 0, 0, 0.75],
        "177": [0.08333, 0.58333, 0, 0, 0.77778],
        "182": [0.19444, 0.69444, 0, 0, 0.61111],
        "184": [0.17014, 0, 0, 0, 0.44445],
        "198": [0, 0.68333, 0, 0, 0.90278],
        "215": [0.08333, 0.58333, 0, 0, 0.77778],
        "216": [0.04861, 0.73194, 0, 0, 0.77778],
        "223": [0, 0.69444, 0, 0, 0.5],
        "230": [0, 0.43056, 0, 0, 0.72222],
        "247": [0.08333, 0.58333, 0, 0, 0.77778],
        "248": [0.09722, 0.52778, 0, 0, 0.5],
        "305": [0, 0.43056, 0, 0, 0.27778],
        "338": [0, 0.68333, 0, 0, 1.01389],
        "339": [0, 0.43056, 0, 0, 0.77778],
        "567": [0.19444, 0.43056, 0, 0, 0.30556],
        "710": [0, 0.69444, 0, 0, 0.5],
        "711": [0, 0.62847, 0, 0, 0.5],
        "713": [0, 0.56778, 0, 0, 0.5],
        "714": [0, 0.69444, 0, 0, 0.5],
        "715": [0, 0.69444, 0, 0, 0.5],
        "728": [0, 0.69444, 0, 0, 0.5],
        "729": [0, 0.66786, 0, 0, 0.27778],
        "730": [0, 0.69444, 0, 0, 0.75],
        "732": [0, 0.66786, 0, 0, 0.5],
        "733": [0, 0.69444, 0, 0, 0.5],
        "915": [0, 0.68333, 0, 0, 0.625],
        "916": [0, 0.68333, 0, 0, 0.83334],
        "920": [0, 0.68333, 0, 0, 0.77778],
        "923": [0, 0.68333, 0, 0, 0.69445],
        "926": [0, 0.68333, 0, 0, 0.66667],
        "928": [0, 0.68333, 0, 0, 0.75],
        "931": [0, 0.68333, 0, 0, 0.72222],
        "933": [0, 0.68333, 0, 0, 0.77778],
        "934": [0, 0.68333, 0, 0, 0.72222],
        "936": [0, 0.68333, 0, 0, 0.77778],
        "937": [0, 0.68333, 0, 0, 0.72222],
        "8211": [0, 0.43056, 0.02778, 0, 0.5],
        "8212": [0, 0.43056, 0.02778, 0, 1.0],
        "8216": [0, 0.69444, 0, 0, 0.27778],
        "8217": [0, 0.69444, 0, 0, 0.27778],
        "8220": [0, 0.69444, 0, 0, 0.5],
        "8221": [0, 0.69444, 0, 0, 0.5],
        "8224": [0.19444, 0.69444, 0, 0, 0.44445],
        "8225": [0.19444, 0.69444, 0, 0, 0.44445],
        "8230": [0, 0.123, 0, 0, 1.172],
        "8242": [0, 0.55556, 0, 0, 0.275],
        "8407": [0, 0.71444, 0.15382, 0, 0.5],
        "8463": [0, 0.68889, 0, 0, 0.54028],
        "8465": [0, 0.69444, 0, 0, 0.72222],
        "8467": [0, 0.69444, 0, 0.11111, 0.41667],
        "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
        "8476": [0, 0.69444, 0, 0, 0.72222],
        "8501": [0, 0.69444, 0, 0, 0.61111],
        "8592": [-0.13313, 0.36687, 0, 0, 1.0],
        "8593": [0.19444, 0.69444, 0, 0, 0.5],
        "8594": [-0.13313, 0.36687, 0, 0, 1.0],
        "8595": [0.19444, 0.69444, 0, 0, 0.5],
        "8596": [-0.13313, 0.36687, 0, 0, 1.0],
        "8597": [0.25, 0.75, 0, 0, 0.5],
        "8598": [0.19444, 0.69444, 0, 0, 1.0],
        "8599": [0.19444, 0.69444, 0, 0, 1.0],
        "8600": [0.19444, 0.69444, 0, 0, 1.0],
        "8601": [0.19444, 0.69444, 0, 0, 1.0],
        "8614": [0.011, 0.511, 0, 0, 1.0],
        "8617": [0.011, 0.511, 0, 0, 1.126],
        "8618": [0.011, 0.511, 0, 0, 1.126],
        "8636": [-0.13313, 0.36687, 0, 0, 1.0],
        "8637": [-0.13313, 0.36687, 0, 0, 1.0],
        "8640": [-0.13313, 0.36687, 0, 0, 1.0],
        "8641": [-0.13313, 0.36687, 0, 0, 1.0],
        "8652": [0.011, 0.671, 0, 0, 1.0],
        "8656": [-0.13313, 0.36687, 0, 0, 1.0],
        "8657": [0.19444, 0.69444, 0, 0, 0.61111],
        "8658": [-0.13313, 0.36687, 0, 0, 1.0],
        "8659": [0.19444, 0.69444, 0, 0, 0.61111],
        "8660": [-0.13313, 0.36687, 0, 0, 1.0],
        "8661": [0.25, 0.75, 0, 0, 0.61111],
        "8704": [0, 0.69444, 0, 0, 0.55556],
        "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
        "8707": [0, 0.69444, 0, 0, 0.55556],
        "8709": [0.05556, 0.75, 0, 0, 0.5],
        "8711": [0, 0.68333, 0, 0, 0.83334],
        "8712": [0.0391, 0.5391, 0, 0, 0.66667],
        "8715": [0.0391, 0.5391, 0, 0, 0.66667],
        "8722": [0.08333, 0.58333, 0, 0, 0.77778],
        "8723": [0.08333, 0.58333, 0, 0, 0.77778],
        "8725": [0.25, 0.75, 0, 0, 0.5],
        "8726": [0.25, 0.75, 0, 0, 0.5],
        "8727": [-0.03472, 0.46528, 0, 0, 0.5],
        "8728": [-0.05555, 0.44445, 0, 0, 0.5],
        "8729": [-0.05555, 0.44445, 0, 0, 0.5],
        "8730": [0.2, 0.8, 0, 0, 0.83334],
        "8733": [0, 0.43056, 0, 0, 0.77778],
        "8734": [0, 0.43056, 0, 0, 1.0],
        "8736": [0, 0.69224, 0, 0, 0.72222],
        "8739": [0.25, 0.75, 0, 0, 0.27778],
        "8741": [0.25, 0.75, 0, 0, 0.5],
        "8743": [0, 0.55556, 0, 0, 0.66667],
        "8744": [0, 0.55556, 0, 0, 0.66667],
        "8745": [0, 0.55556, 0, 0, 0.66667],
        "8746": [0, 0.55556, 0, 0, 0.66667],
        "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
        "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
        "8768": [0.19444, 0.69444, 0, 0, 0.27778],
        "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
        "8773": [-0.022, 0.589, 0, 0, 0.778],
        "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
        "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
        "8784": [-0.133, 0.673, 0, 0, 0.778],
        "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
        "8804": [0.13597, 0.63597, 0, 0, 0.77778],
        "8805": [0.13597, 0.63597, 0, 0, 0.77778],
        "8810": [0.0391, 0.5391, 0, 0, 1.0],
        "8811": [0.0391, 0.5391, 0, 0, 1.0],
        "8826": [0.0391, 0.5391, 0, 0, 0.77778],
        "8827": [0.0391, 0.5391, 0, 0, 0.77778],
        "8834": [0.0391, 0.5391, 0, 0, 0.77778],
        "8835": [0.0391, 0.5391, 0, 0, 0.77778],
        "8838": [0.13597, 0.63597, 0, 0, 0.77778],
        "8839": [0.13597, 0.63597, 0, 0, 0.77778],
        "8846": [0, 0.55556, 0, 0, 0.66667],
        "8849": [0.13597, 0.63597, 0, 0, 0.77778],
        "8850": [0.13597, 0.63597, 0, 0, 0.77778],
        "8851": [0, 0.55556, 0, 0, 0.66667],
        "8852": [0, 0.55556, 0, 0, 0.66667],
        "8853": [0.08333, 0.58333, 0, 0, 0.77778],
        "8854": [0.08333, 0.58333, 0, 0, 0.77778],
        "8855": [0.08333, 0.58333, 0, 0, 0.77778],
        "8856": [0.08333, 0.58333, 0, 0, 0.77778],
        "8857": [0.08333, 0.58333, 0, 0, 0.77778],
        "8866": [0, 0.69444, 0, 0, 0.61111],
        "8867": [0, 0.69444, 0, 0, 0.61111],
        "8868": [0, 0.69444, 0, 0, 0.77778],
        "8869": [0, 0.69444, 0, 0, 0.77778],
        "8872": [0.249, 0.75, 0, 0, 0.867],
        "8900": [-0.05555, 0.44445, 0, 0, 0.5],
        "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
        "8902": [-0.03472, 0.46528, 0, 0, 0.5],
        "8904": [0.005, 0.505, 0, 0, 0.9],
        "8942": [0.03, 0.903, 0, 0, 0.278],
        "8943": [-0.19, 0.313, 0, 0, 1.172],
        "8945": [-0.1, 0.823, 0, 0, 1.282],
        "8968": [0.25, 0.75, 0, 0, 0.44445],
        "8969": [0.25, 0.75, 0, 0, 0.44445],
        "8970": [0.25, 0.75, 0, 0, 0.44445],
        "8971": [0.25, 0.75, 0, 0, 0.44445],
        "8994": [-0.14236, 0.35764, 0, 0, 1.0],
        "8995": [-0.14236, 0.35764, 0, 0, 1.0],
        "9136": [0.244, 0.744, 0, 0, 0.412],
        "9137": [0.244, 0.745, 0, 0, 0.412],
        "9651": [0.19444, 0.69444, 0, 0, 0.88889],
        "9657": [-0.03472, 0.46528, 0, 0, 0.5],
        "9661": [0.19444, 0.69444, 0, 0, 0.88889],
        "9667": [-0.03472, 0.46528, 0, 0, 0.5],
        "9711": [0.19444, 0.69444, 0, 0, 1.0],
        "9824": [0.12963, 0.69444, 0, 0, 0.77778],
        "9825": [0.12963, 0.69444, 0, 0, 0.77778],
        "9826": [0.12963, 0.69444, 0, 0, 0.77778],
        "9827": [0.12963, 0.69444, 0, 0, 0.77778],
        "9837": [0, 0.75, 0, 0, 0.38889],
        "9838": [0.19444, 0.69444, 0, 0, 0.38889],
        "9839": [0.19444, 0.69444, 0, 0, 0.38889],
        "10216": [0.25, 0.75, 0, 0, 0.38889],
        "10217": [0.25, 0.75, 0, 0, 0.38889],
        "10222": [0.244, 0.744, 0, 0, 0.412],
        "10223": [0.244, 0.745, 0, 0, 0.412],
        "10229": [0.011, 0.511, 0, 0, 1.609],
        "10230": [0.011, 0.511, 0, 0, 1.638],
        "10231": [0.011, 0.511, 0, 0, 1.859],
        "10232": [0.024, 0.525, 0, 0, 1.609],
        "10233": [0.024, 0.525, 0, 0, 1.638],
        "10234": [0.024, 0.525, 0, 0, 1.858],
        "10236": [0.011, 0.511, 0, 0, 1.638],
        "10815": [0, 0.68333, 0, 0, 0.75],
        "10927": [0.13597, 0.63597, 0, 0, 0.77778],
        "10928": [0.13597, 0.63597, 0, 0, 0.77778],
        "57376": [0.19444, 0.69444, 0, 0, 0]
      },
      "Math-BoldItalic": {
        "32": [0, 0, 0, 0, 0.25],
        "48": [0, 0.44444, 0, 0, 0.575],
        "49": [0, 0.44444, 0, 0, 0.575],
        "50": [0, 0.44444, 0, 0, 0.575],
        "51": [0.19444, 0.44444, 0, 0, 0.575],
        "52": [0.19444, 0.44444, 0, 0, 0.575],
        "53": [0.19444, 0.44444, 0, 0, 0.575],
        "54": [0, 0.64444, 0, 0, 0.575],
        "55": [0.19444, 0.44444, 0, 0, 0.575],
        "56": [0, 0.64444, 0, 0, 0.575],
        "57": [0.19444, 0.44444, 0, 0, 0.575],
        "65": [0, 0.68611, 0, 0, 0.86944],
        "66": [0, 0.68611, 0.04835, 0, 0.8664],
        "67": [0, 0.68611, 0.06979, 0, 0.81694],
        "68": [0, 0.68611, 0.03194, 0, 0.93812],
        "69": [0, 0.68611, 0.05451, 0, 0.81007],
        "70": [0, 0.68611, 0.15972, 0, 0.68889],
        "71": [0, 0.68611, 0, 0, 0.88673],
        "72": [0, 0.68611, 0.08229, 0, 0.98229],
        "73": [0, 0.68611, 0.07778, 0, 0.51111],
        "74": [0, 0.68611, 0.10069, 0, 0.63125],
        "75": [0, 0.68611, 0.06979, 0, 0.97118],
        "76": [0, 0.68611, 0, 0, 0.75555],
        "77": [0, 0.68611, 0.11424, 0, 1.14201],
        "78": [0, 0.68611, 0.11424, 0, 0.95034],
        "79": [0, 0.68611, 0.03194, 0, 0.83666],
        "80": [0, 0.68611, 0.15972, 0, 0.72309],
        "81": [0.19444, 0.68611, 0, 0, 0.86861],
        "82": [0, 0.68611, 0.00421, 0, 0.87235],
        "83": [0, 0.68611, 0.05382, 0, 0.69271],
        "84": [0, 0.68611, 0.15972, 0, 0.63663],
        "85": [0, 0.68611, 0.11424, 0, 0.80027],
        "86": [0, 0.68611, 0.25555, 0, 0.67778],
        "87": [0, 0.68611, 0.15972, 0, 1.09305],
        "88": [0, 0.68611, 0.07778, 0, 0.94722],
        "89": [0, 0.68611, 0.25555, 0, 0.67458],
        "90": [0, 0.68611, 0.06979, 0, 0.77257],
        "97": [0, 0.44444, 0, 0, 0.63287],
        "98": [0, 0.69444, 0, 0, 0.52083],
        "99": [0, 0.44444, 0, 0, 0.51342],
        "100": [0, 0.69444, 0, 0, 0.60972],
        "101": [0, 0.44444, 0, 0, 0.55361],
        "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
        "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
        "104": [0, 0.69444, 0, 0, 0.66759],
        "105": [0, 0.69326, 0, 0, 0.4048],
        "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
        "107": [0, 0.69444, 0.01852, 0, 0.6037],
        "108": [0, 0.69444, 0.0088, 0, 0.34815],
        "109": [0, 0.44444, 0, 0, 1.0324],
        "110": [0, 0.44444, 0, 0, 0.71296],
        "111": [0, 0.44444, 0, 0, 0.58472],
        "112": [0.19444, 0.44444, 0, 0, 0.60092],
        "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
        "114": [0, 0.44444, 0.03194, 0, 0.5287],
        "115": [0, 0.44444, 0, 0, 0.53125],
        "116": [0, 0.63492, 0, 0, 0.41528],
        "117": [0, 0.44444, 0, 0, 0.68102],
        "118": [0, 0.44444, 0.03704, 0, 0.56666],
        "119": [0, 0.44444, 0.02778, 0, 0.83148],
        "120": [0, 0.44444, 0, 0, 0.65903],
        "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
        "122": [0, 0.44444, 0.04213, 0, 0.55509],
        "160": [0, 0, 0, 0, 0.25],
        "915": [0, 0.68611, 0.15972, 0, 0.65694],
        "916": [0, 0.68611, 0, 0, 0.95833],
        "920": [0, 0.68611, 0.03194, 0, 0.86722],
        "923": [0, 0.68611, 0, 0, 0.80555],
        "926": [0, 0.68611, 0.07458, 0, 0.84125],
        "928": [0, 0.68611, 0.08229, 0, 0.98229],
        "931": [0, 0.68611, 0.05451, 0, 0.88507],
        "933": [0, 0.68611, 0.15972, 0, 0.67083],
        "934": [0, 0.68611, 0, 0, 0.76666],
        "936": [0, 0.68611, 0.11653, 0, 0.71402],
        "937": [0, 0.68611, 0.04835, 0, 0.8789],
        "945": [0, 0.44444, 0, 0, 0.76064],
        "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
        "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
        "948": [0, 0.69444, 0.03819, 0, 0.52222],
        "949": [0, 0.44444, 0, 0, 0.52882],
        "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
        "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
        "952": [0, 0.69444, 0.03194, 0, 0.5618],
        "953": [0, 0.44444, 0, 0, 0.41204],
        "954": [0, 0.44444, 0, 0, 0.66759],
        "955": [0, 0.69444, 0, 0, 0.67083],
        "956": [0.19444, 0.44444, 0, 0, 0.70787],
        "957": [0, 0.44444, 0.06898, 0, 0.57685],
        "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
        "959": [0, 0.44444, 0, 0, 0.58472],
        "960": [0, 0.44444, 0.03704, 0, 0.68241],
        "961": [0.19444, 0.44444, 0, 0, 0.6118],
        "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
        "963": [0, 0.44444, 0.03704, 0, 0.68588],
        "964": [0, 0.44444, 0.13472, 0, 0.52083],
        "965": [0, 0.44444, 0.03704, 0, 0.63055],
        "966": [0.19444, 0.44444, 0, 0, 0.74722],
        "967": [0.19444, 0.44444, 0, 0, 0.71805],
        "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
        "969": [0, 0.44444, 0.03704, 0, 0.71782],
        "977": [0, 0.69444, 0, 0, 0.69155],
        "981": [0.19444, 0.69444, 0, 0, 0.7125],
        "982": [0, 0.44444, 0.03194, 0, 0.975],
        "1009": [0.19444, 0.44444, 0, 0, 0.6118],
        "1013": [0, 0.44444, 0, 0, 0.48333],
        "57649": [0, 0.44444, 0, 0, 0.39352],
        "57911": [0.19444, 0.44444, 0, 0, 0.43889]
      },
      "Math-Italic": {
        "32": [0, 0, 0, 0, 0.25],
        "48": [0, 0.43056, 0, 0, 0.5],
        "49": [0, 0.43056, 0, 0, 0.5],
        "50": [0, 0.43056, 0, 0, 0.5],
        "51": [0.19444, 0.43056, 0, 0, 0.5],
        "52": [0.19444, 0.43056, 0, 0, 0.5],
        "53": [0.19444, 0.43056, 0, 0, 0.5],
        "54": [0, 0.64444, 0, 0, 0.5],
        "55": [0.19444, 0.43056, 0, 0, 0.5],
        "56": [0, 0.64444, 0, 0, 0.5],
        "57": [0.19444, 0.43056, 0, 0, 0.5],
        "65": [0, 0.68333, 0, 0.13889, 0.75],
        "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
        "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
        "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
        "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
        "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
        "71": [0, 0.68333, 0, 0.08334, 0.78625],
        "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
        "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
        "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
        "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
        "76": [0, 0.68333, 0, 0.02778, 0.68056],
        "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
        "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
        "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
        "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
        "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
        "82": [0, 0.68333, 0.00773, 0.08334, 0.75929],
        "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
        "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
        "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
        "86": [0, 0.68333, 0.22222, 0, 0.58333],
        "87": [0, 0.68333, 0.13889, 0, 0.94445],
        "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
        "89": [0, 0.68333, 0.22222, 0, 0.58056],
        "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
        "97": [0, 0.43056, 0, 0, 0.52859],
        "98": [0, 0.69444, 0, 0, 0.42917],
        "99": [0, 0.43056, 0, 0.05556, 0.43276],
        "100": [0, 0.69444, 0, 0.16667, 0.52049],
        "101": [0, 0.43056, 0, 0.05556, 0.46563],
        "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
        "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
        "104": [0, 0.69444, 0, 0, 0.57616],
        "105": [0, 0.65952, 0, 0, 0.34451],
        "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
        "107": [0, 0.69444, 0.03148, 0, 0.5206],
        "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
        "109": [0, 0.43056, 0, 0, 0.87801],
        "110": [0, 0.43056, 0, 0, 0.60023],
        "111": [0, 0.43056, 0, 0.05556, 0.48472],
        "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
        "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
        "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
        "115": [0, 0.43056, 0, 0.05556, 0.46875],
        "116": [0, 0.61508, 0, 0.08334, 0.36111],
        "117": [0, 0.43056, 0, 0.02778, 0.57246],
        "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
        "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
        "120": [0, 0.43056, 0, 0.02778, 0.57153],
        "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
        "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
        "160": [0, 0, 0, 0, 0.25],
        "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
        "916": [0, 0.68333, 0, 0.16667, 0.83334],
        "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
        "923": [0, 0.68333, 0, 0.16667, 0.69445],
        "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
        "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
        "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
        "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
        "934": [0, 0.68333, 0, 0.08334, 0.66667],
        "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
        "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
        "945": [0, 0.43056, 0.0037, 0.02778, 0.6397],
        "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
        "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
        "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
        "949": [0, 0.43056, 0, 0.08334, 0.46632],
        "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
        "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
        "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
        "953": [0, 0.43056, 0, 0.05556, 0.35394],
        "954": [0, 0.43056, 0, 0, 0.57616],
        "955": [0, 0.69444, 0, 0, 0.58334],
        "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
        "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
        "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
        "959": [0, 0.43056, 0, 0.05556, 0.48472],
        "960": [0, 0.43056, 0.03588, 0, 0.57003],
        "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
        "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
        "963": [0, 0.43056, 0.03588, 0, 0.57141],
        "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
        "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
        "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
        "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
        "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
        "969": [0, 0.43056, 0.03588, 0, 0.62245],
        "977": [0, 0.69444, 0, 0.08334, 0.59144],
        "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
        "982": [0, 0.43056, 0.02778, 0, 0.82813],
        "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
        "1013": [0, 0.43056, 0, 0.05556, 0.4059],
        "57649": [0, 0.43056, 0, 0.02778, 0.32246],
        "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
      },
      "SansSerif-Bold": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0, 0, 0.36667],
        "34": [0, 0.69444, 0, 0, 0.55834],
        "35": [0.19444, 0.69444, 0, 0, 0.91667],
        "36": [0.05556, 0.75, 0, 0, 0.55],
        "37": [0.05556, 0.75, 0, 0, 1.02912],
        "38": [0, 0.69444, 0, 0, 0.83056],
        "39": [0, 0.69444, 0, 0, 0.30556],
        "40": [0.25, 0.75, 0, 0, 0.42778],
        "41": [0.25, 0.75, 0, 0, 0.42778],
        "42": [0, 0.75, 0, 0, 0.55],
        "43": [0.11667, 0.61667, 0, 0, 0.85556],
        "44": [0.10556, 0.13056, 0, 0, 0.30556],
        "45": [0, 0.45833, 0, 0, 0.36667],
        "46": [0, 0.13056, 0, 0, 0.30556],
        "47": [0.25, 0.75, 0, 0, 0.55],
        "48": [0, 0.69444, 0, 0, 0.55],
        "49": [0, 0.69444, 0, 0, 0.55],
        "50": [0, 0.69444, 0, 0, 0.55],
        "51": [0, 0.69444, 0, 0, 0.55],
        "52": [0, 0.69444, 0, 0, 0.55],
        "53": [0, 0.69444, 0, 0, 0.55],
        "54": [0, 0.69444, 0, 0, 0.55],
        "55": [0, 0.69444, 0, 0, 0.55],
        "56": [0, 0.69444, 0, 0, 0.55],
        "57": [0, 0.69444, 0, 0, 0.55],
        "58": [0, 0.45833, 0, 0, 0.30556],
        "59": [0.10556, 0.45833, 0, 0, 0.30556],
        "61": [-0.09375, 0.40625, 0, 0, 0.85556],
        "63": [0, 0.69444, 0, 0, 0.51945],
        "64": [0, 0.69444, 0, 0, 0.73334],
        "65": [0, 0.69444, 0, 0, 0.73334],
        "66": [0, 0.69444, 0, 0, 0.73334],
        "67": [0, 0.69444, 0, 0, 0.70278],
        "68": [0, 0.69444, 0, 0, 0.79445],
        "69": [0, 0.69444, 0, 0, 0.64167],
        "70": [0, 0.69444, 0, 0, 0.61111],
        "71": [0, 0.69444, 0, 0, 0.73334],
        "72": [0, 0.69444, 0, 0, 0.79445],
        "73": [0, 0.69444, 0, 0, 0.33056],
        "74": [0, 0.69444, 0, 0, 0.51945],
        "75": [0, 0.69444, 0, 0, 0.76389],
        "76": [0, 0.69444, 0, 0, 0.58056],
        "77": [0, 0.69444, 0, 0, 0.97778],
        "78": [0, 0.69444, 0, 0, 0.79445],
        "79": [0, 0.69444, 0, 0, 0.79445],
        "80": [0, 0.69444, 0, 0, 0.70278],
        "81": [0.10556, 0.69444, 0, 0, 0.79445],
        "82": [0, 0.69444, 0, 0, 0.70278],
        "83": [0, 0.69444, 0, 0, 0.61111],
        "84": [0, 0.69444, 0, 0, 0.73334],
        "85": [0, 0.69444, 0, 0, 0.76389],
        "86": [0, 0.69444, 0.01528, 0, 0.73334],
        "87": [0, 0.69444, 0.01528, 0, 1.03889],
        "88": [0, 0.69444, 0, 0, 0.73334],
        "89": [0, 0.69444, 0.0275, 0, 0.73334],
        "90": [0, 0.69444, 0, 0, 0.67223],
        "91": [0.25, 0.75, 0, 0, 0.34306],
        "93": [0.25, 0.75, 0, 0, 0.34306],
        "94": [0, 0.69444, 0, 0, 0.55],
        "95": [0.35, 0.10833, 0.03056, 0, 0.55],
        "97": [0, 0.45833, 0, 0, 0.525],
        "98": [0, 0.69444, 0, 0, 0.56111],
        "99": [0, 0.45833, 0, 0, 0.48889],
        "100": [0, 0.69444, 0, 0, 0.56111],
        "101": [0, 0.45833, 0, 0, 0.51111],
        "102": [0, 0.69444, 0.07639, 0, 0.33611],
        "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
        "104": [0, 0.69444, 0, 0, 0.56111],
        "105": [0, 0.69444, 0, 0, 0.25556],
        "106": [0.19444, 0.69444, 0, 0, 0.28611],
        "107": [0, 0.69444, 0, 0, 0.53056],
        "108": [0, 0.69444, 0, 0, 0.25556],
        "109": [0, 0.45833, 0, 0, 0.86667],
        "110": [0, 0.45833, 0, 0, 0.56111],
        "111": [0, 0.45833, 0, 0, 0.55],
        "112": [0.19444, 0.45833, 0, 0, 0.56111],
        "113": [0.19444, 0.45833, 0, 0, 0.56111],
        "114": [0, 0.45833, 0.01528, 0, 0.37222],
        "115": [0, 0.45833, 0, 0, 0.42167],
        "116": [0, 0.58929, 0, 0, 0.40417],
        "117": [0, 0.45833, 0, 0, 0.56111],
        "118": [0, 0.45833, 0.01528, 0, 0.5],
        "119": [0, 0.45833, 0.01528, 0, 0.74445],
        "120": [0, 0.45833, 0, 0, 0.5],
        "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
        "122": [0, 0.45833, 0, 0, 0.47639],
        "126": [0.35, 0.34444, 0, 0, 0.55],
        "160": [0, 0, 0, 0, 0.25],
        "168": [0, 0.69444, 0, 0, 0.55],
        "176": [0, 0.69444, 0, 0, 0.73334],
        "180": [0, 0.69444, 0, 0, 0.55],
        "184": [0.17014, 0, 0, 0, 0.48889],
        "305": [0, 0.45833, 0, 0, 0.25556],
        "567": [0.19444, 0.45833, 0, 0, 0.28611],
        "710": [0, 0.69444, 0, 0, 0.55],
        "711": [0, 0.63542, 0, 0, 0.55],
        "713": [0, 0.63778, 0, 0, 0.55],
        "728": [0, 0.69444, 0, 0, 0.55],
        "729": [0, 0.69444, 0, 0, 0.30556],
        "730": [0, 0.69444, 0, 0, 0.73334],
        "732": [0, 0.69444, 0, 0, 0.55],
        "733": [0, 0.69444, 0, 0, 0.55],
        "915": [0, 0.69444, 0, 0, 0.58056],
        "916": [0, 0.69444, 0, 0, 0.91667],
        "920": [0, 0.69444, 0, 0, 0.85556],
        "923": [0, 0.69444, 0, 0, 0.67223],
        "926": [0, 0.69444, 0, 0, 0.73334],
        "928": [0, 0.69444, 0, 0, 0.79445],
        "931": [0, 0.69444, 0, 0, 0.79445],
        "933": [0, 0.69444, 0, 0, 0.85556],
        "934": [0, 0.69444, 0, 0, 0.79445],
        "936": [0, 0.69444, 0, 0, 0.85556],
        "937": [0, 0.69444, 0, 0, 0.79445],
        "8211": [0, 0.45833, 0.03056, 0, 0.55],
        "8212": [0, 0.45833, 0.03056, 0, 1.10001],
        "8216": [0, 0.69444, 0, 0, 0.30556],
        "8217": [0, 0.69444, 0, 0, 0.30556],
        "8220": [0, 0.69444, 0, 0, 0.55834],
        "8221": [0, 0.69444, 0, 0, 0.55834]
      },
      "SansSerif-Italic": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0.05733, 0, 0.31945],
        "34": [0, 0.69444, 0.00316, 0, 0.5],
        "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
        "36": [0.05556, 0.75, 0.11156, 0, 0.5],
        "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
        "38": [0, 0.69444, 0.03058, 0, 0.75834],
        "39": [0, 0.69444, 0.07816, 0, 0.27778],
        "40": [0.25, 0.75, 0.13164, 0, 0.38889],
        "41": [0.25, 0.75, 0.02536, 0, 0.38889],
        "42": [0, 0.75, 0.11775, 0, 0.5],
        "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
        "44": [0.125, 0.08333, 0, 0, 0.27778],
        "45": [0, 0.44444, 0.01946, 0, 0.33333],
        "46": [0, 0.08333, 0, 0, 0.27778],
        "47": [0.25, 0.75, 0.13164, 0, 0.5],
        "48": [0, 0.65556, 0.11156, 0, 0.5],
        "49": [0, 0.65556, 0.11156, 0, 0.5],
        "50": [0, 0.65556, 0.11156, 0, 0.5],
        "51": [0, 0.65556, 0.11156, 0, 0.5],
        "52": [0, 0.65556, 0.11156, 0, 0.5],
        "53": [0, 0.65556, 0.11156, 0, 0.5],
        "54": [0, 0.65556, 0.11156, 0, 0.5],
        "55": [0, 0.65556, 0.11156, 0, 0.5],
        "56": [0, 0.65556, 0.11156, 0, 0.5],
        "57": [0, 0.65556, 0.11156, 0, 0.5],
        "58": [0, 0.44444, 0.02502, 0, 0.27778],
        "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
        "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
        "63": [0, 0.69444, 0.11809, 0, 0.47222],
        "64": [0, 0.69444, 0.07555, 0, 0.66667],
        "65": [0, 0.69444, 0, 0, 0.66667],
        "66": [0, 0.69444, 0.08293, 0, 0.66667],
        "67": [0, 0.69444, 0.11983, 0, 0.63889],
        "68": [0, 0.69444, 0.07555, 0, 0.72223],
        "69": [0, 0.69444, 0.11983, 0, 0.59722],
        "70": [0, 0.69444, 0.13372, 0, 0.56945],
        "71": [0, 0.69444, 0.11983, 0, 0.66667],
        "72": [0, 0.69444, 0.08094, 0, 0.70834],
        "73": [0, 0.69444, 0.13372, 0, 0.27778],
        "74": [0, 0.69444, 0.08094, 0, 0.47222],
        "75": [0, 0.69444, 0.11983, 0, 0.69445],
        "76": [0, 0.69444, 0, 0, 0.54167],
        "77": [0, 0.69444, 0.08094, 0, 0.875],
        "78": [0, 0.69444, 0.08094, 0, 0.70834],
        "79": [0, 0.69444, 0.07555, 0, 0.73611],
        "80": [0, 0.69444, 0.08293, 0, 0.63889],
        "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
        "82": [0, 0.69444, 0.08293, 0, 0.64584],
        "83": [0, 0.69444, 0.09205, 0, 0.55556],
        "84": [0, 0.69444, 0.13372, 0, 0.68056],
        "85": [0, 0.69444, 0.08094, 0, 0.6875],
        "86": [0, 0.69444, 0.1615, 0, 0.66667],
        "87": [0, 0.69444, 0.1615, 0, 0.94445],
        "88": [0, 0.69444, 0.13372, 0, 0.66667],
        "89": [0, 0.69444, 0.17261, 0, 0.66667],
        "90": [0, 0.69444, 0.11983, 0, 0.61111],
        "91": [0.25, 0.75, 0.15942, 0, 0.28889],
        "93": [0.25, 0.75, 0.08719, 0, 0.28889],
        "94": [0, 0.69444, 0.0799, 0, 0.5],
        "95": [0.35, 0.09444, 0.08616, 0, 0.5],
        "97": [0, 0.44444, 0.00981, 0, 0.48056],
        "98": [0, 0.69444, 0.03057, 0, 0.51667],
        "99": [0, 0.44444, 0.08336, 0, 0.44445],
        "100": [0, 0.69444, 0.09483, 0, 0.51667],
        "101": [0, 0.44444, 0.06778, 0, 0.44445],
        "102": [0, 0.69444, 0.21705, 0, 0.30556],
        "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
        "104": [0, 0.69444, 0.01778, 0, 0.51667],
        "105": [0, 0.67937, 0.09718, 0, 0.23889],
        "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
        "107": [0, 0.69444, 0.08336, 0, 0.48889],
        "108": [0, 0.69444, 0.09483, 0, 0.23889],
        "109": [0, 0.44444, 0.01778, 0, 0.79445],
        "110": [0, 0.44444, 0.01778, 0, 0.51667],
        "111": [0, 0.44444, 0.06613, 0, 0.5],
        "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
        "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
        "114": [0, 0.44444, 0.10836, 0, 0.34167],
        "115": [0, 0.44444, 0.0778, 0, 0.38333],
        "116": [0, 0.57143, 0.07225, 0, 0.36111],
        "117": [0, 0.44444, 0.04169, 0, 0.51667],
        "118": [0, 0.44444, 0.10836, 0, 0.46111],
        "119": [0, 0.44444, 0.10836, 0, 0.68334],
        "120": [0, 0.44444, 0.09169, 0, 0.46111],
        "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
        "122": [0, 0.44444, 0.08752, 0, 0.43472],
        "126": [0.35, 0.32659, 0.08826, 0, 0.5],
        "160": [0, 0, 0, 0, 0.25],
        "168": [0, 0.67937, 0.06385, 0, 0.5],
        "176": [0, 0.69444, 0, 0, 0.73752],
        "184": [0.17014, 0, 0, 0, 0.44445],
        "305": [0, 0.44444, 0.04169, 0, 0.23889],
        "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
        "710": [0, 0.69444, 0.0799, 0, 0.5],
        "711": [0, 0.63194, 0.08432, 0, 0.5],
        "713": [0, 0.60889, 0.08776, 0, 0.5],
        "714": [0, 0.69444, 0.09205, 0, 0.5],
        "715": [0, 0.69444, 0, 0, 0.5],
        "728": [0, 0.69444, 0.09483, 0, 0.5],
        "729": [0, 0.67937, 0.07774, 0, 0.27778],
        "730": [0, 0.69444, 0, 0, 0.73752],
        "732": [0, 0.67659, 0.08826, 0, 0.5],
        "733": [0, 0.69444, 0.09205, 0, 0.5],
        "915": [0, 0.69444, 0.13372, 0, 0.54167],
        "916": [0, 0.69444, 0, 0, 0.83334],
        "920": [0, 0.69444, 0.07555, 0, 0.77778],
        "923": [0, 0.69444, 0, 0, 0.61111],
        "926": [0, 0.69444, 0.12816, 0, 0.66667],
        "928": [0, 0.69444, 0.08094, 0, 0.70834],
        "931": [0, 0.69444, 0.11983, 0, 0.72222],
        "933": [0, 0.69444, 0.09031, 0, 0.77778],
        "934": [0, 0.69444, 0.04603, 0, 0.72222],
        "936": [0, 0.69444, 0.09031, 0, 0.77778],
        "937": [0, 0.69444, 0.08293, 0, 0.72222],
        "8211": [0, 0.44444, 0.08616, 0, 0.5],
        "8212": [0, 0.44444, 0.08616, 0, 1.0],
        "8216": [0, 0.69444, 0.07816, 0, 0.27778],
        "8217": [0, 0.69444, 0.07816, 0, 0.27778],
        "8220": [0, 0.69444, 0.14205, 0, 0.5],
        "8221": [0, 0.69444, 0.00316, 0, 0.5]
      },
      "SansSerif-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0, 0, 0.31945],
        "34": [0, 0.69444, 0, 0, 0.5],
        "35": [0.19444, 0.69444, 0, 0, 0.83334],
        "36": [0.05556, 0.75, 0, 0, 0.5],
        "37": [0.05556, 0.75, 0, 0, 0.83334],
        "38": [0, 0.69444, 0, 0, 0.75834],
        "39": [0, 0.69444, 0, 0, 0.27778],
        "40": [0.25, 0.75, 0, 0, 0.38889],
        "41": [0.25, 0.75, 0, 0, 0.38889],
        "42": [0, 0.75, 0, 0, 0.5],
        "43": [0.08333, 0.58333, 0, 0, 0.77778],
        "44": [0.125, 0.08333, 0, 0, 0.27778],
        "45": [0, 0.44444, 0, 0, 0.33333],
        "46": [0, 0.08333, 0, 0, 0.27778],
        "47": [0.25, 0.75, 0, 0, 0.5],
        "48": [0, 0.65556, 0, 0, 0.5],
        "49": [0, 0.65556, 0, 0, 0.5],
        "50": [0, 0.65556, 0, 0, 0.5],
        "51": [0, 0.65556, 0, 0, 0.5],
        "52": [0, 0.65556, 0, 0, 0.5],
        "53": [0, 0.65556, 0, 0, 0.5],
        "54": [0, 0.65556, 0, 0, 0.5],
        "55": [0, 0.65556, 0, 0, 0.5],
        "56": [0, 0.65556, 0, 0, 0.5],
        "57": [0, 0.65556, 0, 0, 0.5],
        "58": [0, 0.44444, 0, 0, 0.27778],
        "59": [0.125, 0.44444, 0, 0, 0.27778],
        "61": [-0.13, 0.37, 0, 0, 0.77778],
        "63": [0, 0.69444, 0, 0, 0.47222],
        "64": [0, 0.69444, 0, 0, 0.66667],
        "65": [0, 0.69444, 0, 0, 0.66667],
        "66": [0, 0.69444, 0, 0, 0.66667],
        "67": [0, 0.69444, 0, 0, 0.63889],
        "68": [0, 0.69444, 0, 0, 0.72223],
        "69": [0, 0.69444, 0, 0, 0.59722],
        "70": [0, 0.69444, 0, 0, 0.56945],
        "71": [0, 0.69444, 0, 0, 0.66667],
        "72": [0, 0.69444, 0, 0, 0.70834],
        "73": [0, 0.69444, 0, 0, 0.27778],
        "74": [0, 0.69444, 0, 0, 0.47222],
        "75": [0, 0.69444, 0, 0, 0.69445],
        "76": [0, 0.69444, 0, 0, 0.54167],
        "77": [0, 0.69444, 0, 0, 0.875],
        "78": [0, 0.69444, 0, 0, 0.70834],
        "79": [0, 0.69444, 0, 0, 0.73611],
        "80": [0, 0.69444, 0, 0, 0.63889],
        "81": [0.125, 0.69444, 0, 0, 0.73611],
        "82": [0, 0.69444, 0, 0, 0.64584],
        "83": [0, 0.69444, 0, 0, 0.55556],
        "84": [0, 0.69444, 0, 0, 0.68056],
        "85": [0, 0.69444, 0, 0, 0.6875],
        "86": [0, 0.69444, 0.01389, 0, 0.66667],
        "87": [0, 0.69444, 0.01389, 0, 0.94445],
        "88": [0, 0.69444, 0, 0, 0.66667],
        "89": [0, 0.69444, 0.025, 0, 0.66667],
        "90": [0, 0.69444, 0, 0, 0.61111],
        "91": [0.25, 0.75, 0, 0, 0.28889],
        "93": [0.25, 0.75, 0, 0, 0.28889],
        "94": [0, 0.69444, 0, 0, 0.5],
        "95": [0.35, 0.09444, 0.02778, 0, 0.5],
        "97": [0, 0.44444, 0, 0, 0.48056],
        "98": [0, 0.69444, 0, 0, 0.51667],
        "99": [0, 0.44444, 0, 0, 0.44445],
        "100": [0, 0.69444, 0, 0, 0.51667],
        "101": [0, 0.44444, 0, 0, 0.44445],
        "102": [0, 0.69444, 0.06944, 0, 0.30556],
        "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
        "104": [0, 0.69444, 0, 0, 0.51667],
        "105": [0, 0.67937, 0, 0, 0.23889],
        "106": [0.19444, 0.67937, 0, 0, 0.26667],
        "107": [0, 0.69444, 0, 0, 0.48889],
        "108": [0, 0.69444, 0, 0, 0.23889],
        "109": [0, 0.44444, 0, 0, 0.79445],
        "110": [0, 0.44444, 0, 0, 0.51667],
        "111": [0, 0.44444, 0, 0, 0.5],
        "112": [0.19444, 0.44444, 0, 0, 0.51667],
        "113": [0.19444, 0.44444, 0, 0, 0.51667],
        "114": [0, 0.44444, 0.01389, 0, 0.34167],
        "115": [0, 0.44444, 0, 0, 0.38333],
        "116": [0, 0.57143, 0, 0, 0.36111],
        "117": [0, 0.44444, 0, 0, 0.51667],
        "118": [0, 0.44444, 0.01389, 0, 0.46111],
        "119": [0, 0.44444, 0.01389, 0, 0.68334],
        "120": [0, 0.44444, 0, 0, 0.46111],
        "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
        "122": [0, 0.44444, 0, 0, 0.43472],
        "126": [0.35, 0.32659, 0, 0, 0.5],
        "160": [0, 0, 0, 0, 0.25],
        "168": [0, 0.67937, 0, 0, 0.5],
        "176": [0, 0.69444, 0, 0, 0.66667],
        "184": [0.17014, 0, 0, 0, 0.44445],
        "305": [0, 0.44444, 0, 0, 0.23889],
        "567": [0.19444, 0.44444, 0, 0, 0.26667],
        "710": [0, 0.69444, 0, 0, 0.5],
        "711": [0, 0.63194, 0, 0, 0.5],
        "713": [0, 0.60889, 0, 0, 0.5],
        "714": [0, 0.69444, 0, 0, 0.5],
        "715": [0, 0.69444, 0, 0, 0.5],
        "728": [0, 0.69444, 0, 0, 0.5],
        "729": [0, 0.67937, 0, 0, 0.27778],
        "730": [0, 0.69444, 0, 0, 0.66667],
        "732": [0, 0.67659, 0, 0, 0.5],
        "733": [0, 0.69444, 0, 0, 0.5],
        "915": [0, 0.69444, 0, 0, 0.54167],
        "916": [0, 0.69444, 0, 0, 0.83334],
        "920": [0, 0.69444, 0, 0, 0.77778],
        "923": [0, 0.69444, 0, 0, 0.61111],
        "926": [0, 0.69444, 0, 0, 0.66667],
        "928": [0, 0.69444, 0, 0, 0.70834],
        "931": [0, 0.69444, 0, 0, 0.72222],
        "933": [0, 0.69444, 0, 0, 0.77778],
        "934": [0, 0.69444, 0, 0, 0.72222],
        "936": [0, 0.69444, 0, 0, 0.77778],
        "937": [0, 0.69444, 0, 0, 0.72222],
        "8211": [0, 0.44444, 0.02778, 0, 0.5],
        "8212": [0, 0.44444, 0.02778, 0, 1.0],
        "8216": [0, 0.69444, 0, 0, 0.27778],
        "8217": [0, 0.69444, 0, 0, 0.27778],
        "8220": [0, 0.69444, 0, 0, 0.5],
        "8221": [0, 0.69444, 0, 0, 0.5]
      },
      "Script-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "65": [0, 0.7, 0.22925, 0, 0.80253],
        "66": [0, 0.7, 0.04087, 0, 0.90757],
        "67": [0, 0.7, 0.1689, 0, 0.66619],
        "68": [0, 0.7, 0.09371, 0, 0.77443],
        "69": [0, 0.7, 0.18583, 0, 0.56162],
        "70": [0, 0.7, 0.13634, 0, 0.89544],
        "71": [0, 0.7, 0.17322, 0, 0.60961],
        "72": [0, 0.7, 0.29694, 0, 0.96919],
        "73": [0, 0.7, 0.19189, 0, 0.80907],
        "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
        "75": [0, 0.7, 0.31259, 0, 0.91364],
        "76": [0, 0.7, 0.19189, 0, 0.87373],
        "77": [0, 0.7, 0.15981, 0, 1.08031],
        "78": [0, 0.7, 0.3525, 0, 0.9015],
        "79": [0, 0.7, 0.08078, 0, 0.73787],
        "80": [0, 0.7, 0.08078, 0, 1.01262],
        "81": [0, 0.7, 0.03305, 0, 0.88282],
        "82": [0, 0.7, 0.06259, 0, 0.85],
        "83": [0, 0.7, 0.19189, 0, 0.86767],
        "84": [0, 0.7, 0.29087, 0, 0.74697],
        "85": [0, 0.7, 0.25815, 0, 0.79996],
        "86": [0, 0.7, 0.27523, 0, 0.62204],
        "87": [0, 0.7, 0.27523, 0, 0.80532],
        "88": [0, 0.7, 0.26006, 0, 0.94445],
        "89": [0, 0.7, 0.2939, 0, 0.70961],
        "90": [0, 0.7, 0.24037, 0, 0.8212],
        "160": [0, 0, 0, 0, 0.25]
      },
      "Size1-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "40": [0.35001, 0.85, 0, 0, 0.45834],
        "41": [0.35001, 0.85, 0, 0, 0.45834],
        "47": [0.35001, 0.85, 0, 0, 0.57778],
        "91": [0.35001, 0.85, 0, 0, 0.41667],
        "92": [0.35001, 0.85, 0, 0, 0.57778],
        "93": [0.35001, 0.85, 0, 0, 0.41667],
        "123": [0.35001, 0.85, 0, 0, 0.58334],
        "125": [0.35001, 0.85, 0, 0, 0.58334],
        "160": [0, 0, 0, 0, 0.25],
        "710": [0, 0.72222, 0, 0, 0.55556],
        "732": [0, 0.72222, 0, 0, 0.55556],
        "770": [0, 0.72222, 0, 0, 0.55556],
        "771": [0, 0.72222, 0, 0, 0.55556],
        "8214": [-99e-5, 0.601, 0, 0, 0.77778],
        "8593": [1e-05, 0.6, 0, 0, 0.66667],
        "8595": [1e-05, 0.6, 0, 0, 0.66667],
        "8657": [1e-05, 0.6, 0, 0, 0.77778],
        "8659": [1e-05, 0.6, 0, 0, 0.77778],
        "8719": [0.25001, 0.75, 0, 0, 0.94445],
        "8720": [0.25001, 0.75, 0, 0, 0.94445],
        "8721": [0.25001, 0.75, 0, 0, 1.05556],
        "8730": [0.35001, 0.85, 0, 0, 1.0],
        "8739": [-599e-5, 0.606, 0, 0, 0.33333],
        "8741": [-599e-5, 0.606, 0, 0, 0.55556],
        "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
        "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
        "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
        "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
        "8896": [0.25001, 0.75, 0, 0, 0.83334],
        "8897": [0.25001, 0.75, 0, 0, 0.83334],
        "8898": [0.25001, 0.75, 0, 0, 0.83334],
        "8899": [0.25001, 0.75, 0, 0, 0.83334],
        "8968": [0.35001, 0.85, 0, 0, 0.47222],
        "8969": [0.35001, 0.85, 0, 0, 0.47222],
        "8970": [0.35001, 0.85, 0, 0, 0.47222],
        "8971": [0.35001, 0.85, 0, 0, 0.47222],
        "9168": [-99e-5, 0.601, 0, 0, 0.66667],
        "10216": [0.35001, 0.85, 0, 0, 0.47222],
        "10217": [0.35001, 0.85, 0, 0, 0.47222],
        "10752": [0.25001, 0.75, 0, 0, 1.11111],
        "10753": [0.25001, 0.75, 0, 0, 1.11111],
        "10754": [0.25001, 0.75, 0, 0, 1.11111],
        "10756": [0.25001, 0.75, 0, 0, 0.83334],
        "10758": [0.25001, 0.75, 0, 0, 0.83334]
      },
      "Size2-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "40": [0.65002, 1.15, 0, 0, 0.59722],
        "41": [0.65002, 1.15, 0, 0, 0.59722],
        "47": [0.65002, 1.15, 0, 0, 0.81111],
        "91": [0.65002, 1.15, 0, 0, 0.47222],
        "92": [0.65002, 1.15, 0, 0, 0.81111],
        "93": [0.65002, 1.15, 0, 0, 0.47222],
        "123": [0.65002, 1.15, 0, 0, 0.66667],
        "125": [0.65002, 1.15, 0, 0, 0.66667],
        "160": [0, 0, 0, 0, 0.25],
        "710": [0, 0.75, 0, 0, 1.0],
        "732": [0, 0.75, 0, 0, 1.0],
        "770": [0, 0.75, 0, 0, 1.0],
        "771": [0, 0.75, 0, 0, 1.0],
        "8719": [0.55001, 1.05, 0, 0, 1.27778],
        "8720": [0.55001, 1.05, 0, 0, 1.27778],
        "8721": [0.55001, 1.05, 0, 0, 1.44445],
        "8730": [0.65002, 1.15, 0, 0, 1.0],
        "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
        "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
        "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
        "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
        "8896": [0.55001, 1.05, 0, 0, 1.11111],
        "8897": [0.55001, 1.05, 0, 0, 1.11111],
        "8898": [0.55001, 1.05, 0, 0, 1.11111],
        "8899": [0.55001, 1.05, 0, 0, 1.11111],
        "8968": [0.65002, 1.15, 0, 0, 0.52778],
        "8969": [0.65002, 1.15, 0, 0, 0.52778],
        "8970": [0.65002, 1.15, 0, 0, 0.52778],
        "8971": [0.65002, 1.15, 0, 0, 0.52778],
        "10216": [0.65002, 1.15, 0, 0, 0.61111],
        "10217": [0.65002, 1.15, 0, 0, 0.61111],
        "10752": [0.55001, 1.05, 0, 0, 1.51112],
        "10753": [0.55001, 1.05, 0, 0, 1.51112],
        "10754": [0.55001, 1.05, 0, 0, 1.51112],
        "10756": [0.55001, 1.05, 0, 0, 1.11111],
        "10758": [0.55001, 1.05, 0, 0, 1.11111]
      },
      "Size3-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "40": [0.95003, 1.45, 0, 0, 0.73611],
        "41": [0.95003, 1.45, 0, 0, 0.73611],
        "47": [0.95003, 1.45, 0, 0, 1.04445],
        "91": [0.95003, 1.45, 0, 0, 0.52778],
        "92": [0.95003, 1.45, 0, 0, 1.04445],
        "93": [0.95003, 1.45, 0, 0, 0.52778],
        "123": [0.95003, 1.45, 0, 0, 0.75],
        "125": [0.95003, 1.45, 0, 0, 0.75],
        "160": [0, 0, 0, 0, 0.25],
        "710": [0, 0.75, 0, 0, 1.44445],
        "732": [0, 0.75, 0, 0, 1.44445],
        "770": [0, 0.75, 0, 0, 1.44445],
        "771": [0, 0.75, 0, 0, 1.44445],
        "8730": [0.95003, 1.45, 0, 0, 1.0],
        "8968": [0.95003, 1.45, 0, 0, 0.58334],
        "8969": [0.95003, 1.45, 0, 0, 0.58334],
        "8970": [0.95003, 1.45, 0, 0, 0.58334],
        "8971": [0.95003, 1.45, 0, 0, 0.58334],
        "10216": [0.95003, 1.45, 0, 0, 0.75],
        "10217": [0.95003, 1.45, 0, 0, 0.75]
      },
      "Size4-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "40": [1.25003, 1.75, 0, 0, 0.79167],
        "41": [1.25003, 1.75, 0, 0, 0.79167],
        "47": [1.25003, 1.75, 0, 0, 1.27778],
        "91": [1.25003, 1.75, 0, 0, 0.58334],
        "92": [1.25003, 1.75, 0, 0, 1.27778],
        "93": [1.25003, 1.75, 0, 0, 0.58334],
        "123": [1.25003, 1.75, 0, 0, 0.80556],
        "125": [1.25003, 1.75, 0, 0, 0.80556],
        "160": [0, 0, 0, 0, 0.25],
        "710": [0, 0.825, 0, 0, 1.8889],
        "732": [0, 0.825, 0, 0, 1.8889],
        "770": [0, 0.825, 0, 0, 1.8889],
        "771": [0, 0.825, 0, 0, 1.8889],
        "8730": [1.25003, 1.75, 0, 0, 1.0],
        "8968": [1.25003, 1.75, 0, 0, 0.63889],
        "8969": [1.25003, 1.75, 0, 0, 0.63889],
        "8970": [1.25003, 1.75, 0, 0, 0.63889],
        "8971": [1.25003, 1.75, 0, 0, 0.63889],
        "9115": [0.64502, 1.155, 0, 0, 0.875],
        "9116": [1e-05, 0.6, 0, 0, 0.875],
        "9117": [0.64502, 1.155, 0, 0, 0.875],
        "9118": [0.64502, 1.155, 0, 0, 0.875],
        "9119": [1e-05, 0.6, 0, 0, 0.875],
        "9120": [0.64502, 1.155, 0, 0, 0.875],
        "9121": [0.64502, 1.155, 0, 0, 0.66667],
        "9122": [-99e-5, 0.601, 0, 0, 0.66667],
        "9123": [0.64502, 1.155, 0, 0, 0.66667],
        "9124": [0.64502, 1.155, 0, 0, 0.66667],
        "9125": [-99e-5, 0.601, 0, 0, 0.66667],
        "9126": [0.64502, 1.155, 0, 0, 0.66667],
        "9127": [1e-05, 0.9, 0, 0, 0.88889],
        "9128": [0.65002, 1.15, 0, 0, 0.88889],
        "9129": [0.90001, 0, 0, 0, 0.88889],
        "9130": [0, 0.3, 0, 0, 0.88889],
        "9131": [1e-05, 0.9, 0, 0, 0.88889],
        "9132": [0.65002, 1.15, 0, 0, 0.88889],
        "9133": [0.90001, 0, 0, 0, 0.88889],
        "9143": [0.88502, 0.915, 0, 0, 1.05556],
        "10216": [1.25003, 1.75, 0, 0, 0.80556],
        "10217": [1.25003, 1.75, 0, 0, 0.80556],
        "57344": [-499e-5, 0.605, 0, 0, 1.05556],
        "57345": [-499e-5, 0.605, 0, 0, 1.05556],
        "57680": [0, 0.12, 0, 0, 0.45],
        "57681": [0, 0.12, 0, 0, 0.45],
        "57682": [0, 0.12, 0, 0, 0.45],
        "57683": [0, 0.12, 0, 0, 0.45]
      },
      "Typewriter-Regular": {
        "32": [0, 0, 0, 0, 0.525],
        "33": [0, 0.61111, 0, 0, 0.525],
        "34": [0, 0.61111, 0, 0, 0.525],
        "35": [0, 0.61111, 0, 0, 0.525],
        "36": [0.08333, 0.69444, 0, 0, 0.525],
        "37": [0.08333, 0.69444, 0, 0, 0.525],
        "38": [0, 0.61111, 0, 0, 0.525],
        "39": [0, 0.61111, 0, 0, 0.525],
        "40": [0.08333, 0.69444, 0, 0, 0.525],
        "41": [0.08333, 0.69444, 0, 0, 0.525],
        "42": [0, 0.52083, 0, 0, 0.525],
        "43": [-0.08056, 0.53055, 0, 0, 0.525],
        "44": [0.13889, 0.125, 0, 0, 0.525],
        "45": [-0.08056, 0.53055, 0, 0, 0.525],
        "46": [0, 0.125, 0, 0, 0.525],
        "47": [0.08333, 0.69444, 0, 0, 0.525],
        "48": [0, 0.61111, 0, 0, 0.525],
        "49": [0, 0.61111, 0, 0, 0.525],
        "50": [0, 0.61111, 0, 0, 0.525],
        "51": [0, 0.61111, 0, 0, 0.525],
        "52": [0, 0.61111, 0, 0, 0.525],
        "53": [0, 0.61111, 0, 0, 0.525],
        "54": [0, 0.61111, 0, 0, 0.525],
        "55": [0, 0.61111, 0, 0, 0.525],
        "56": [0, 0.61111, 0, 0, 0.525],
        "57": [0, 0.61111, 0, 0, 0.525],
        "58": [0, 0.43056, 0, 0, 0.525],
        "59": [0.13889, 0.43056, 0, 0, 0.525],
        "60": [-0.05556, 0.55556, 0, 0, 0.525],
        "61": [-0.19549, 0.41562, 0, 0, 0.525],
        "62": [-0.05556, 0.55556, 0, 0, 0.525],
        "63": [0, 0.61111, 0, 0, 0.525],
        "64": [0, 0.61111, 0, 0, 0.525],
        "65": [0, 0.61111, 0, 0, 0.525],
        "66": [0, 0.61111, 0, 0, 0.525],
        "67": [0, 0.61111, 0, 0, 0.525],
        "68": [0, 0.61111, 0, 0, 0.525],
        "69": [0, 0.61111, 0, 0, 0.525],
        "70": [0, 0.61111, 0, 0, 0.525],
        "71": [0, 0.61111, 0, 0, 0.525],
        "72": [0, 0.61111, 0, 0, 0.525],
        "73": [0, 0.61111, 0, 0, 0.525],
        "74": [0, 0.61111, 0, 0, 0.525],
        "75": [0, 0.61111, 0, 0, 0.525],
        "76": [0, 0.61111, 0, 0, 0.525],
        "77": [0, 0.61111, 0, 0, 0.525],
        "78": [0, 0.61111, 0, 0, 0.525],
        "79": [0, 0.61111, 0, 0, 0.525],
        "80": [0, 0.61111, 0, 0, 0.525],
        "81": [0.13889, 0.61111, 0, 0, 0.525],
        "82": [0, 0.61111, 0, 0, 0.525],
        "83": [0, 0.61111, 0, 0, 0.525],
        "84": [0, 0.61111, 0, 0, 0.525],
        "85": [0, 0.61111, 0, 0, 0.525],
        "86": [0, 0.61111, 0, 0, 0.525],
        "87": [0, 0.61111, 0, 0, 0.525],
        "88": [0, 0.61111, 0, 0, 0.525],
        "89": [0, 0.61111, 0, 0, 0.525],
        "90": [0, 0.61111, 0, 0, 0.525],
        "91": [0.08333, 0.69444, 0, 0, 0.525],
        "92": [0.08333, 0.69444, 0, 0, 0.525],
        "93": [0.08333, 0.69444, 0, 0, 0.525],
        "94": [0, 0.61111, 0, 0, 0.525],
        "95": [0.09514, 0, 0, 0, 0.525],
        "96": [0, 0.61111, 0, 0, 0.525],
        "97": [0, 0.43056, 0, 0, 0.525],
        "98": [0, 0.61111, 0, 0, 0.525],
        "99": [0, 0.43056, 0, 0, 0.525],
        "100": [0, 0.61111, 0, 0, 0.525],
        "101": [0, 0.43056, 0, 0, 0.525],
        "102": [0, 0.61111, 0, 0, 0.525],
        "103": [0.22222, 0.43056, 0, 0, 0.525],
        "104": [0, 0.61111, 0, 0, 0.525],
        "105": [0, 0.61111, 0, 0, 0.525],
        "106": [0.22222, 0.61111, 0, 0, 0.525],
        "107": [0, 0.61111, 0, 0, 0.525],
        "108": [0, 0.61111, 0, 0, 0.525],
        "109": [0, 0.43056, 0, 0, 0.525],
        "110": [0, 0.43056, 0, 0, 0.525],
        "111": [0, 0.43056, 0, 0, 0.525],
        "112": [0.22222, 0.43056, 0, 0, 0.525],
        "113": [0.22222, 0.43056, 0, 0, 0.525],
        "114": [0, 0.43056, 0, 0, 0.525],
        "115": [0, 0.43056, 0, 0, 0.525],
        "116": [0, 0.55358, 0, 0, 0.525],
        "117": [0, 0.43056, 0, 0, 0.525],
        "118": [0, 0.43056, 0, 0, 0.525],
        "119": [0, 0.43056, 0, 0, 0.525],
        "120": [0, 0.43056, 0, 0, 0.525],
        "121": [0.22222, 0.43056, 0, 0, 0.525],
        "122": [0, 0.43056, 0, 0, 0.525],
        "123": [0.08333, 0.69444, 0, 0, 0.525],
        "124": [0.08333, 0.69444, 0, 0, 0.525],
        "125": [0.08333, 0.69444, 0, 0, 0.525],
        "126": [0, 0.61111, 0, 0, 0.525],
        "127": [0, 0.61111, 0, 0, 0.525],
        "160": [0, 0, 0, 0, 0.525],
        "176": [0, 0.61111, 0, 0, 0.525],
        "184": [0.19445, 0, 0, 0, 0.525],
        "305": [0, 0.43056, 0, 0, 0.525],
        "567": [0.22222, 0.43056, 0, 0, 0.525],
        "711": [0, 0.56597, 0, 0, 0.525],
        "713": [0, 0.56555, 0, 0, 0.525],
        "714": [0, 0.61111, 0, 0, 0.525],
        "715": [0, 0.61111, 0, 0, 0.525],
        "728": [0, 0.61111, 0, 0, 0.525],
        "730": [0, 0.61111, 0, 0, 0.525],
        "770": [0, 0.61111, 0, 0, 0.525],
        "771": [0, 0.61111, 0, 0, 0.525],
        "776": [0, 0.61111, 0, 0, 0.525],
        "915": [0, 0.61111, 0, 0, 0.525],
        "916": [0, 0.61111, 0, 0, 0.525],
        "920": [0, 0.61111, 0, 0, 0.525],
        "923": [0, 0.61111, 0, 0, 0.525],
        "926": [0, 0.61111, 0, 0, 0.525],
        "928": [0, 0.61111, 0, 0, 0.525],
        "931": [0, 0.61111, 0, 0, 0.525],
        "933": [0, 0.61111, 0, 0, 0.525],
        "934": [0, 0.61111, 0, 0, 0.525],
        "936": [0, 0.61111, 0, 0, 0.525],
        "937": [0, 0.61111, 0, 0, 0.525],
        "8216": [0, 0.61111, 0, 0, 0.525],
        "8217": [0, 0.61111, 0, 0, 0.525],
        "8242": [0, 0.61111, 0, 0, 0.525],
        "9251": [0.11111, 0.21944, 0, 0, 0.525]
      }
    };

    /**
     * This file contains metrics regarding fonts and individual symbols. The sigma
     * and xi variables, as well as the metricMap map contain data extracted from
     * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
     * `metrics` variable and the getCharacterMetrics function.
     */
    // In TeX, there are actually three sets of dimensions, one for each of
    // textstyle (size index 5 and higher: >=9pt), scriptstyle (size index 3 and 4:
    // 7-8pt), and scriptscriptstyle (size index 1 and 2: 5-6pt).  These are
    // provided in the arrays below, in that order.
    //
    // The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respectively.
    // This was determined by running the following script:
    //
    //     latex -interaction=nonstopmode \
    //     '\documentclass{article}\usepackage{amsmath}\begin{document}' \
    //     '$a$ \expandafter\show\the\textfont2' \
    //     '\expandafter\show\the\scriptfont2' \
    //     '\expandafter\show\the\scriptscriptfont2' \
    //     '\stop'
    //
    // The metrics themselves were retrieved using the following commands:
    //
    //     tftopl cmsy10
    //     tftopl cmsy7
    //     tftopl cmsy5
    //
    // The output of each of these commands is quite lengthy.  The only part we
    // care about is the FONTDIMEN section. Each value is measured in EMs.
    var sigmasAndXis = {
      slant: [0.250, 0.250, 0.250],
      // sigma1
      space: [0.000, 0.000, 0.000],
      // sigma2
      stretch: [0.000, 0.000, 0.000],
      // sigma3
      shrink: [0.000, 0.000, 0.000],
      // sigma4
      xHeight: [0.431, 0.431, 0.431],
      // sigma5
      quad: [1.000, 1.171, 1.472],
      // sigma6
      extraSpace: [0.000, 0.000, 0.000],
      // sigma7
      num1: [0.677, 0.732, 0.925],
      // sigma8
      num2: [0.394, 0.384, 0.387],
      // sigma9
      num3: [0.444, 0.471, 0.504],
      // sigma10
      denom1: [0.686, 0.752, 1.025],
      // sigma11
      denom2: [0.345, 0.344, 0.532],
      // sigma12
      sup1: [0.413, 0.503, 0.504],
      // sigma13
      sup2: [0.363, 0.431, 0.404],
      // sigma14
      sup3: [0.289, 0.286, 0.294],
      // sigma15
      sub1: [0.150, 0.143, 0.200],
      // sigma16
      sub2: [0.247, 0.286, 0.400],
      // sigma17
      supDrop: [0.386, 0.353, 0.494],
      // sigma18
      subDrop: [0.050, 0.071, 0.100],
      // sigma19
      delim1: [2.390, 1.700, 1.980],
      // sigma20
      delim2: [1.010, 1.157, 1.420],
      // sigma21
      axisHeight: [0.250, 0.250, 0.250],
      // sigma22
      // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
      // they correspond to the font parameters of the extension fonts (family 3).
      // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
      // match cmex7, we'd use cmex7.tfm values for script and scriptscript
      // values.
      defaultRuleThickness: [0.04, 0.049, 0.049],
      // xi8; cmex7: 0.049
      bigOpSpacing1: [0.111, 0.111, 0.111],
      // xi9
      bigOpSpacing2: [0.166, 0.166, 0.166],
      // xi10
      bigOpSpacing3: [0.2, 0.2, 0.2],
      // xi11
      bigOpSpacing4: [0.6, 0.611, 0.611],
      // xi12; cmex7: 0.611
      bigOpSpacing5: [0.1, 0.143, 0.143],
      // xi13; cmex7: 0.143
      // The \sqrt rule width is taken from the height of the surd character.
      // Since we use the same font at all sizes, this thickness doesn't scale.
      sqrtRuleThickness: [0.04, 0.04, 0.04],
      // This value determines how large a pt is, for metrics which are defined
      // in terms of pts.
      // This value is also used in katex.scss; if you change it make sure the
      // values match.
      ptPerEm: [10.0, 10.0, 10.0],
      // The space between adjacent `|` columns in an array definition. From
      // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
      doubleRuleSep: [0.2, 0.2, 0.2],
      // The width of separator lines in {array} environments. From
      // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
      arrayRuleWidth: [0.04, 0.04, 0.04],
      // Two values from LaTeX source2e:
      fboxsep: [0.3, 0.3, 0.3],
      //        3 pt / ptPerEm
      fboxrule: [0.04, 0.04, 0.04] // 0.4 pt / ptPerEm

    }; // This map contains a mapping from font name and character code to character
    // should have Latin-1 and Cyrillic characters, but may not depending on the
    // operating system.  The metrics do not account for extra height from the
    // accents.  In the case of Cyrillic characters which have both ascenders and
    // descenders we prefer approximations with ascenders, primarily to prevent
    // the fraction bar or root line from intersecting the glyph.
    // TODO(kevinb) allow union of multiple glyph metrics for better accuracy.

    var extraCharacterMap = {
      // Latin-1
      '': 'A',
      '': 'D',
      '': 'o',
      '': 'a',
      '': 'd',
      '': 'o',
      // Cyrillic
      '': 'A',
      '': 'B',
      '': 'B',
      '': 'F',
      '': 'A',
      '': 'E',
      '': 'K',
      '': '3',
      '': 'N',
      '': 'N',
      '': 'K',
      '': 'N',
      '': 'M',
      '': 'H',
      '': 'O',
      '': 'N',
      '': 'P',
      '': 'C',
      '': 'T',
      '': 'y',
      '': 'O',
      '': 'X',
      '': 'U',
      '': 'h',
      '': 'W',
      '': 'W',
      '': 'B',
      '': 'X',
      '': 'B',
      '': '3',
      '': 'X',
      '': 'R',
      '': 'a',
      '': 'b',
      '': 'a',
      '': 'r',
      '': 'y',
      '': 'e',
      '': 'm',
      '': 'e',
      '': 'n',
      '': 'n',
      '': 'n',
      '': 'n',
      '': 'm',
      '': 'n',
      '': 'o',
      '': 'n',
      '': 'p',
      '': 'c',
      '': 'o',
      '': 'y',
      '': 'b',
      '': 'x',
      '': 'n',
      '': 'n',
      '': 'w',
      '': 'w',
      '': 'a',
      '': 'm',
      '': 'a',
      '': 'e',
      '': 'm',
      '': 'r'
    };

    /**
     * This function adds new font metrics to default metricMap
     * It can also override existing metrics
     */
    function setFontMetrics(fontName, metrics) {
      fontMetricsData[fontName] = metrics;
    }
    /**
     * This function is a convenience function for looking up information in the
     * metricMap table. It takes a character as a string, and a font.
     *
     * Note: the `width` property may be undefined if fontMetricsData.js wasn't
     * built using `Make extended_metrics`.
     */

    function getCharacterMetrics(character, font, mode) {
      if (!fontMetricsData[font]) {
        throw new Error("Font metrics not found for font: " + font + ".");
      }

      var ch = character.charCodeAt(0);
      var metrics = fontMetricsData[font][ch];

      if (!metrics && character[0] in extraCharacterMap) {
        ch = extraCharacterMap[character[0]].charCodeAt(0);
        metrics = fontMetricsData[font][ch];
      }

      if (!metrics && mode === 'text') {
        // We don't typically have font metrics for Asian scripts.
        // But since we support them in text mode, we need to return
        // some sort of metrics.
        // So if the character is in a script we support but we
        // don't have metrics for it, just use the metrics for
        // the Latin capital letter M. This is close enough because
        // we (currently) only care about the height of the glyph
        // not its width.
        if (supportedCodepoint(ch)) {
          metrics = fontMetricsData[font][77]; // 77 is the charcode for 'M'
        }
      }

      if (metrics) {
        return {
          depth: metrics[0],
          height: metrics[1],
          italic: metrics[2],
          skew: metrics[3],
          width: metrics[4]
        };
      }
    }
    var fontMetricsBySizeIndex = {};
    /**
     * Get the font metrics for a given size.
     */

    function getGlobalMetrics(size) {
      var sizeIndex;

      if (size >= 5) {
        sizeIndex = 0;
      } else if (size >= 3) {
        sizeIndex = 1;
      } else {
        sizeIndex = 2;
      }

      if (!fontMetricsBySizeIndex[sizeIndex]) {
        var metrics = fontMetricsBySizeIndex[sizeIndex] = {
          cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
        };

        for (var key in sigmasAndXis) {
          if (sigmasAndXis.hasOwnProperty(key)) {
            metrics[key] = sigmasAndXis[key][sizeIndex];
          }
        }
      }

      return fontMetricsBySizeIndex[sizeIndex];
    }

    /**
     * This file contains information about the options that the Parser carries
     * around with it while parsing. Data is held in an `Options` object, and when
     * recursing, a new `Options` object can be created with the `.with*` and
     * `.reset` functions.
     */
    var sizeStyleMap = [// Each element contains [textsize, scriptsize, scriptscriptsize].
    // The size mappings are taken from TeX with \normalsize=10pt.
    [1, 1, 1], // size1: [5, 5, 5]              \tiny
    [2, 1, 1], // size2: [6, 5, 5]
    [3, 1, 1], // size3: [7, 5, 5]              \scriptsize
    [4, 2, 1], // size4: [8, 6, 5]              \footnotesize
    [5, 2, 1], // size5: [9, 6, 5]              \small
    [6, 3, 1], // size6: [10, 7, 5]             \normalsize
    [7, 4, 2], // size7: [12, 8, 6]             \large
    [8, 6, 3], // size8: [14.4, 10, 7]          \Large
    [9, 7, 6], // size9: [17.28, 12, 10]        \LARGE
    [10, 8, 7], // size10: [20.74, 14.4, 12]     \huge
    [11, 10, 9] // size11: [24.88, 20.74, 17.28] \HUGE
    ];
    var sizeMultipliers = [// fontMetrics.js:getGlobalMetrics also uses size indexes, so if
    // you change size indexes, change that function.
    0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.44, 1.728, 2.074, 2.488];

    var sizeAtStyle = function sizeAtStyle(size, style) {
      return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
    }; // In these types, "" (empty string) means "no change".


    /**
     * This is the main options class. It contains the current style, size, color,
     * and font.
     *
     * Options objects should not be modified. To create a new Options with
     * different properties, call a `.having*` method.
     */
    class Options {
      // A font family applies to a group of fonts (i.e. SansSerif), while a font
      // represents a specific font (i.e. SansSerif Bold).
      // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm

      /**
       * The base size index.
       */
      constructor(data) {
        this.style = void 0;
        this.color = void 0;
        this.size = void 0;
        this.textSize = void 0;
        this.phantom = void 0;
        this.font = void 0;
        this.fontFamily = void 0;
        this.fontWeight = void 0;
        this.fontShape = void 0;
        this.sizeMultiplier = void 0;
        this.maxSize = void 0;
        this.minRuleThickness = void 0;
        this._fontMetrics = void 0;
        this.style = data.style;
        this.color = data.color;
        this.size = data.size || Options.BASESIZE;
        this.textSize = data.textSize || this.size;
        this.phantom = !!data.phantom;
        this.font = data.font || "";
        this.fontFamily = data.fontFamily || "";
        this.fontWeight = data.fontWeight || '';
        this.fontShape = data.fontShape || '';
        this.sizeMultiplier = sizeMultipliers[this.size - 1];
        this.maxSize = data.maxSize;
        this.minRuleThickness = data.minRuleThickness;
        this._fontMetrics = undefined;
      }
      /**
       * Returns a new options object with the same properties as "this".  Properties
       * from "extension" will be copied to the new options object.
       */


      extend(extension) {
        var data = {
          style: this.style,
          size: this.size,
          textSize: this.textSize,
          color: this.color,
          phantom: this.phantom,
          font: this.font,
          fontFamily: this.fontFamily,
          fontWeight: this.fontWeight,
          fontShape: this.fontShape,
          maxSize: this.maxSize,
          minRuleThickness: this.minRuleThickness
        };

        for (var key in extension) {
          if (extension.hasOwnProperty(key)) {
            data[key] = extension[key];
          }
        }

        return new Options(data);
      }
      /**
       * Return an options object with the given style. If `this.style === style`,
       * returns `this`.
       */


      havingStyle(style) {
        if (this.style === style) {
          return this;
        } else {
          return this.extend({
            style: style,
            size: sizeAtStyle(this.textSize, style)
          });
        }
      }
      /**
       * Return an options object with a cramped version of the current style. If
       * the current style is cramped, returns `this`.
       */


      havingCrampedStyle() {
        return this.havingStyle(this.style.cramp());
      }
      /**
       * Return an options object with the given size and in at least `\textstyle`.
       * Returns `this` if appropriate.
       */


      havingSize(size) {
        if (this.size === size && this.textSize === size) {
          return this;
        } else {
          return this.extend({
            style: this.style.text(),
            size: size,
            textSize: size,
            sizeMultiplier: sizeMultipliers[size - 1]
          });
        }
      }
      /**
       * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
       * changes to at least `\textstyle`.
       */


      havingBaseStyle(style) {
        style = style || this.style.text();
        var wantSize = sizeAtStyle(Options.BASESIZE, style);

        if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
          return this;
        } else {
          return this.extend({
            style: style,
            size: wantSize
          });
        }
      }
      /**
       * Remove the effect of sizing changes such as \Huge.
       * Keep the effect of the current style, such as \scriptstyle.
       */


      havingBaseSizing() {
        var size;

        switch (this.style.id) {
          case 4:
          case 5:
            size = 3; // normalsize in scriptstyle

            break;

          case 6:
          case 7:
            size = 1; // normalsize in scriptscriptstyle

            break;

          default:
            size = 6;
          // normalsize in textstyle or displaystyle
        }

        return this.extend({
          style: this.style.text(),
          size: size
        });
      }
      /**
       * Create a new options object with the given color.
       */


      withColor(color) {
        return this.extend({
          color: color
        });
      }
      /**
       * Create a new options object with "phantom" set to true.
       */


      withPhantom() {
        return this.extend({
          phantom: true
        });
      }
      /**
       * Creates a new options object with the given math font or old text font.
       * @type {[type]}
       */


      withFont(font) {
        return this.extend({
          font
        });
      }
      /**
       * Create a new options objects with the given fontFamily.
       */


      withTextFontFamily(fontFamily) {
        return this.extend({
          fontFamily,
          font: ""
        });
      }
      /**
       * Creates a new options object with the given font weight
       */


      withTextFontWeight(fontWeight) {
        return this.extend({
          fontWeight,
          font: ""
        });
      }
      /**
       * Creates a new options object with the given font weight
       */


      withTextFontShape(fontShape) {
        return this.extend({
          fontShape,
          font: ""
        });
      }
      /**
       * Return the CSS sizing classes required to switch from enclosing options
       * `oldOptions` to `this`. Returns an array of classes.
       */


      sizingClasses(oldOptions) {
        if (oldOptions.size !== this.size) {
          return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
        } else {
          return [];
        }
      }
      /**
       * Return the CSS sizing classes required to switch to the base size. Like
       * `this.havingSize(BASESIZE).sizingClasses(this)`.
       */


      baseSizingClasses() {
        if (this.size !== Options.BASESIZE) {
          return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
        } else {
          return [];
        }
      }
      /**
       * Return the font metrics for this size.
       */


      fontMetrics() {
        if (!this._fontMetrics) {
          this._fontMetrics = getGlobalMetrics(this.size);
        }

        return this._fontMetrics;
      }
      /**
       * Gets the CSS color of the current options object
       */


      getColor() {
        if (this.phantom) {
          return "transparent";
        } else {
          return this.color;
        }
      }

    }

    Options.BASESIZE = 6;

    /**
     * This file does conversion between units.  In particular, it provides
     * calculateSize to convert other units into ems.
     */
    // Thus, multiplying a length by this number converts the length from units
    // into pts.  Dividing the result by ptPerEm gives the number of ems
    // *assuming* a font size of ptPerEm (normal size, normal style).

    var ptPerUnit = {
      // https://en.wikibooks.org/wiki/LaTeX/Lengths and
      // https://tex.stackexchange.com/a/8263
      "pt": 1,
      // TeX point
      "mm": 7227 / 2540,
      // millimeter
      "cm": 7227 / 254,
      // centimeter
      "in": 72.27,
      // inch
      "bp": 803 / 800,
      // big (PostScript) points
      "pc": 12,
      // pica
      "dd": 1238 / 1157,
      // didot
      "cc": 14856 / 1157,
      // cicero (12 didot)
      "nd": 685 / 642,
      // new didot
      "nc": 1370 / 107,
      // new cicero (12 new didot)
      "sp": 1 / 65536,
      // scaled point (TeX's internal smallest unit)
      // https://tex.stackexchange.com/a/41371
      "px": 803 / 800 // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX

    }; // Dictionary of relative units, for fast validity testing.

    var relativeUnit = {
      "ex": true,
      "em": true,
      "mu": true
    };

    /**
     * Determine whether the specified unit (either a string defining the unit
     * or a "size" parse node containing a unit field) is valid.
     */
    var validUnit = function validUnit(unit) {
      if (typeof unit !== "string") {
        unit = unit.unit;
      }

      return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
    };
    /*
     * Convert a "size" parse node (with numeric "number" and string "unit" fields,
     * as parsed by functions.js argType "size") into a CSS em value for the
     * current style/scale.  `options` gives the current options.
     */

    var calculateSize = function calculateSize(sizeValue, options) {
      var scale;

      if (sizeValue.unit in ptPerUnit) {
        // Absolute units
        scale = ptPerUnit[sizeValue.unit] // Convert unit to pt
        / options.fontMetrics().ptPerEm // Convert pt to CSS em
        / options.sizeMultiplier; // Unscale to make absolute units
      } else if (sizeValue.unit === "mu") {
        // `mu` units scale with scriptstyle/scriptscriptstyle.
        scale = options.fontMetrics().cssEmPerMu;
      } else {
        // Other relative units always refer to the *textstyle* font
        // in the current size.
        var unitOptions;

        if (options.style.isTight()) {
          // isTight() means current style is script/scriptscript.
          unitOptions = options.havingStyle(options.style.text());
        } else {
          unitOptions = options;
        } // TODO: In TeX these units are relative to the quad of the current
        // *text* font, e.g. cmr10. KaTeX instead uses values from the
        // comparably-sized *Computer Modern symbol* font. At 10pt, these
        // match. At 7pt and 5pt, they differ: cmr7=1.138894, cmsy7=1.170641;
        // cmr5=1.361133, cmsy5=1.472241. Consider $\scriptsize a\kern1emb$.
        // TeX \showlists shows a kern of 1.13889 * fontsize;
        // KaTeX shows a kern of 1.171 * fontsize.


        if (sizeValue.unit === "ex") {
          scale = unitOptions.fontMetrics().xHeight;
        } else if (sizeValue.unit === "em") {
          scale = unitOptions.fontMetrics().quad;
        } else {
          throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
        }

        if (unitOptions !== options) {
          scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
        }
      }

      return Math.min(sizeValue.number * scale, options.maxSize);
    };
    /**
     * Round `n` to 4 decimal places, or to the nearest 1/10,000th em. See
     * https://github.com/KaTeX/KaTeX/pull/2460.
     */

    var makeEm = function makeEm(n) {
      return +n.toFixed(4) + "em";
    };

    /**
     * These objects store the data about the DOM nodes we create, as well as some
     * extra data. They can then be transformed into real DOM nodes with the
     * `toNode` function or HTML markup using `toMarkup`. They are useful for both
     * storing extra properties on the nodes, as well as providing a way to easily
     * work with the DOM.
     *
     * Similar functions for working with MathML nodes exist in mathMLTree.js.
     *
     * TODO: refactor `span` and `anchor` into common superclass when
     * target environments support class inheritance
     */

    /**
     * Create an HTML className based on a list of classes. In addition to joining
     * with spaces, we also remove empty classes.
     */
    var createClass = function createClass(classes) {
      return classes.filter(cls => cls).join(" ");
    };

    var initNode = function initNode(classes, options, style) {
      this.classes = classes || [];
      this.attributes = {};
      this.height = 0;
      this.depth = 0;
      this.maxFontSize = 0;
      this.style = style || {};

      if (options) {
        if (options.style.isTight()) {
          this.classes.push("mtight");
        }

        var color = options.getColor();

        if (color) {
          this.style.color = color;
        }
      }
    };
    /**
     * Convert into an HTML node
     */


    var toNode = function toNode(tagName) {
      var node = document.createElement(tagName); // Apply the class

      node.className = createClass(this.classes); // Apply inline styles

      for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
          // $FlowFixMe Flow doesn't seem to understand span.style's type.
          node.style[style] = this.style[style];
        }
      } // Apply attributes


      for (var attr in this.attributes) {
        if (this.attributes.hasOwnProperty(attr)) {
          node.setAttribute(attr, this.attributes[attr]);
        }
      } // Append the children, also as HTML nodes


      for (var i = 0; i < this.children.length; i++) {
        node.appendChild(this.children[i].toNode());
      }

      return node;
    };
    /**
     * https://w3c.github.io/html-reference/syntax.html#syntax-attributes
     *
     * > Attribute Names must consist of one or more characters
     * other than the space characters, U+0000 NULL,
     * '"', "'", ">", "/", "=", the control characters,
     * and any characters that are not defined by Unicode.
     */


    var invalidAttributeNameRegex = /[\s"'>/=\x00-\x1f]/;
    /**
     * Convert into an HTML markup string
     */

    var toMarkup = function toMarkup(tagName) {
      var markup = "<" + tagName; // Add the class

      if (this.classes.length) {
        markup += " class=\"" + utils.escape(createClass(this.classes)) + "\"";
      }

      var styles = ""; // Add the styles, after hyphenation

      for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
          styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
      }

      if (styles) {
        markup += " style=\"" + utils.escape(styles) + "\"";
      } // Add the attributes


      for (var attr in this.attributes) {
        if (this.attributes.hasOwnProperty(attr)) {
          if (invalidAttributeNameRegex.test(attr)) {
            throw new ParseError("Invalid attribute name '" + attr + "'");
          }

          markup += " " + attr + "=\"" + utils.escape(this.attributes[attr]) + "\"";
        }
      }

      markup += ">"; // Add the markup of the children, also as markup

      for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
      }

      markup += "</" + tagName + ">";
      return markup;
    }; // Making the type below exact with all optional fields doesn't work due to
    // - https://github.com/facebook/flow/issues/4582
    // - https://github.com/facebook/flow/issues/5688
    // However, since *all* fields are optional, $Shape<> works as suggested in 5688
    // above.
    // This type does not include all CSS properties. Additional properties should
    // be added as needed.


    /**
     * This node represents a span node, with a className, a list of children, and
     * an inline style. It also contains information about its height, depth, and
     * maxFontSize.
     *
     * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan
     * otherwise. This typesafety is important when HTML builders access a span's
     * children.
     */
    class Span {
      constructor(classes, children, options, style) {
        this.children = void 0;
        this.attributes = void 0;
        this.classes = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.width = void 0;
        this.maxFontSize = void 0;
        this.style = void 0;
        initNode.call(this, classes, options, style);
        this.children = children || [];
      }
      /**
       * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
       * all browsers support attributes the same, and having too many custom
       * attributes is probably bad.
       */


      setAttribute(attribute, value) {
        this.attributes[attribute] = value;
      }

      hasClass(className) {
        return this.classes.includes(className);
      }

      toNode() {
        return toNode.call(this, "span");
      }

      toMarkup() {
        return toMarkup.call(this, "span");
      }

    }
    /**
     * This node represents an anchor (<a>) element with a hyperlink.  See `span`
     * for further details.
     */

    class Anchor {
      constructor(href, classes, children, options) {
        this.children = void 0;
        this.attributes = void 0;
        this.classes = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.maxFontSize = void 0;
        this.style = void 0;
        initNode.call(this, classes, options);
        this.children = children || [];
        this.setAttribute('href', href);
      }

      setAttribute(attribute, value) {
        this.attributes[attribute] = value;
      }

      hasClass(className) {
        return this.classes.includes(className);
      }

      toNode() {
        return toNode.call(this, "a");
      }

      toMarkup() {
        return toMarkup.call(this, "a");
      }

    }
    /**
     * This node represents an image embed (<img>) element.
     */

    class Img {
      constructor(src, alt, style) {
        this.src = void 0;
        this.alt = void 0;
        this.classes = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.maxFontSize = void 0;
        this.style = void 0;
        this.alt = alt;
        this.src = src;
        this.classes = ["mord"];
        this.style = style;
      }

      hasClass(className) {
        return this.classes.includes(className);
      }

      toNode() {
        var node = document.createElement("img");
        node.src = this.src;
        node.alt = this.alt;
        node.className = "mord"; // Apply inline styles

        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            // $FlowFixMe
            node.style[style] = this.style[style];
          }
        }

        return node;
      }

      toMarkup() {
        var markup = "<img src=\"" + utils.escape(this.src) + "\"" + (" alt=\"" + utils.escape(this.alt) + "\""); // Add the styles, after hyphenation

        var styles = "";

        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
          }
        }

        if (styles) {
          markup += " style=\"" + utils.escape(styles) + "\"";
        }

        markup += "'/>";
        return markup;
      }

    }
    var iCombinations = {
      '': '\u0131\u0302',
      '': '\u0131\u0308',
      '': '\u0131\u0301',
      // '': '\u0131\u0304', // enable when we add Extended Latin
      '': '\u0131\u0300'
    };
    /**
     * A symbol node contains information about a single symbol. It either renders
     * to a single text node, or a span with a single text node in it, depending on
     * whether it has CSS classes, styles, or needs italic correction.
     */

    class SymbolNode {
      constructor(text, height, depth, italic, skew, width, classes, style) {
        this.text = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.italic = void 0;
        this.skew = void 0;
        this.width = void 0;
        this.maxFontSize = void 0;
        this.classes = void 0;
        this.style = void 0;
        this.text = text;
        this.height = height || 0;
        this.depth = depth || 0;
        this.italic = italic || 0;
        this.skew = skew || 0;
        this.width = width || 0;
        this.classes = classes || [];
        this.style = style || {};
        this.maxFontSize = 0; // Mark text from non-Latin scripts with specific classes so that we
        // can specify which fonts to use.  This allows us to render these
        // characters with a serif font in situations where the browser would
        // either default to a sans serif or render a placeholder character.
        // We use CSS class names like cjk_fallback, hangul_fallback and
        // brahmic_fallback. See ./unicodeScripts.js for the set of possible
        // script names

        var script = scriptFromCodepoint(this.text.charCodeAt(0));

        if (script) {
          this.classes.push(script + "_fallback");
        }

        if (/[]/.test(this.text)) {
          // add  when we add Extended Latin
          this.text = iCombinations[this.text];
        }
      }

      hasClass(className) {
        return this.classes.includes(className);
      }
      /**
       * Creates a text node or span from a symbol node. Note that a span is only
       * created if it is needed.
       */


      toNode() {
        var node = document.createTextNode(this.text);
        var span = null;

        if (this.italic > 0) {
          span = document.createElement("span");
          span.style.marginRight = makeEm(this.italic);
        }

        if (this.classes.length > 0) {
          span = span || document.createElement("span");
          span.className = createClass(this.classes);
        }

        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            span = span || document.createElement("span"); // $FlowFixMe Flow doesn't seem to understand span.style's type.

            span.style[style] = this.style[style];
          }
        }

        if (span) {
          span.appendChild(node);
          return span;
        } else {
          return node;
        }
      }
      /**
       * Creates markup for a symbol node.
       */


      toMarkup() {
        // TODO(alpert): More duplication than I'd like from
        // span.prototype.toMarkup and symbolNode.prototype.toNode...
        var needsSpan = false;
        var markup = "<span";

        if (this.classes.length) {
          needsSpan = true;
          markup += " class=\"";
          markup += utils.escape(createClass(this.classes));
          markup += "\"";
        }

        var styles = "";

        if (this.italic > 0) {
          styles += "margin-right:" + this.italic + "em;";
        }

        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
          }
        }

        if (styles) {
          needsSpan = true;
          markup += " style=\"" + utils.escape(styles) + "\"";
        }

        var escaped = utils.escape(this.text);

        if (needsSpan) {
          markup += ">";
          markup += escaped;
          markup += "</span>";
          return markup;
        } else {
          return escaped;
        }
      }

    }
    /**
     * SVG nodes are used to render stretchy wide elements.
     */

    class SvgNode {
      constructor(children, attributes) {
        this.children = void 0;
        this.attributes = void 0;
        this.children = children || [];
        this.attributes = attributes || {};
      }

      toNode() {
        var svgNS = "http://www.w3.org/2000/svg";
        var node = document.createElementNS(svgNS, "svg"); // Apply attributes

        for (var attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            node.setAttribute(attr, this.attributes[attr]);
          }
        }

        for (var i = 0; i < this.children.length; i++) {
          node.appendChild(this.children[i].toNode());
        }

        return node;
      }

      toMarkup() {
        var markup = "<svg xmlns=\"http://www.w3.org/2000/svg\""; // Apply attributes

        for (var attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "=\"" + utils.escape(this.attributes[attr]) + "\"";
          }
        }

        markup += ">";

        for (var i = 0; i < this.children.length; i++) {
          markup += this.children[i].toMarkup();
        }

        markup += "</svg>";
        return markup;
      }

    }
    class PathNode {
      constructor(pathName, alternate) {
        this.pathName = void 0;
        this.alternate = void 0;
        this.pathName = pathName;
        this.alternate = alternate; // Used only for \sqrt, \phase, & tall delims
      }

      toNode() {
        var svgNS = "http://www.w3.org/2000/svg";
        var node = document.createElementNS(svgNS, "path");

        if (this.alternate) {
          node.setAttribute("d", this.alternate);
        } else {
          node.setAttribute("d", path[this.pathName]);
        }

        return node;
      }

      toMarkup() {
        if (this.alternate) {
          return "<path d=\"" + utils.escape(this.alternate) + "\"/>";
        } else {
          return "<path d=\"" + utils.escape(path[this.pathName]) + "\"/>";
        }
      }

    }
    class LineNode {
      constructor(attributes) {
        this.attributes = void 0;
        this.attributes = attributes || {};
      }

      toNode() {
        var svgNS = "http://www.w3.org/2000/svg";
        var node = document.createElementNS(svgNS, "line"); // Apply attributes

        for (var attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            node.setAttribute(attr, this.attributes[attr]);
          }
        }

        return node;
      }

      toMarkup() {
        var markup = "<line";

        for (var attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "=\"" + utils.escape(this.attributes[attr]) + "\"";
          }
        }

        markup += "/>";
        return markup;
      }

    }
    function assertSymbolDomNode(group) {
      if (group instanceof SymbolNode) {
        return group;
      } else {
        throw new Error("Expected symbolNode but got " + String(group) + ".");
      }
    }
    function assertSpan(group) {
      if (group instanceof Span) {
        return group;
      } else {
        throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
      }
    }

    /**
     * This file holds a list of all no-argument functions and single-character
     * symbols (like 'a' or ';').
     *
     * For each of the symbols, there are three properties they can have:
     * - font (required): the font to be used for this symbol. Either "main" (the
         normal font), or "ams" (the ams fonts).
     * - group (required): the ParseNode group type the symbol should have (i.e.
         "textord", "mathord", etc).
         See https://github.com/KaTeX/KaTeX/wiki/Examining-TeX#group-types
     * - replace: the character that this symbol or function should be
     *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
     *   character in the main font).
     *
     * The outermost map in the table indicates what mode the symbols should be
     * accepted in (e.g. "math" or "text").
     */
    // Some of these have a "-token" suffix since these are also used as `ParseNode`
    // types for raw text tokens, and we want to avoid conflicts with higher-level
    // `ParseNode` types. These `ParseNode`s are constructed within `Parser` by
    // looking up the `symbols` map.
    var ATOMS = {
      "bin": 1,
      "close": 1,
      "inner": 1,
      "open": 1,
      "punct": 1,
      "rel": 1
    };
    var NON_ATOMS = {
      "accent-token": 1,
      "mathord": 1,
      "op-token": 1,
      "spacing": 1,
      "textord": 1
    };
    var symbols = {
      "math": {},
      "text": {}
    };
    /** `acceptUnicodeChar = true` is only applicable if `replace` is set. */

    function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
      symbols[mode][name] = {
        font,
        group,
        replace
      };

      if (acceptUnicodeChar && replace) {
        symbols[mode][replace] = symbols[mode][name];
      }
    } // Some abbreviations for commonly used strings.
    // This helps minify the code, and also spotting typos using jshint.
    // modes:

    var math = "math";
    var text = "text"; // fonts:

    var main = "main";
    var ams = "ams"; // groups:

    var accent = "accent-token";
    var bin = "bin";
    var close = "close";
    var inner = "inner";
    var mathord = "mathord";
    var op = "op-token";
    var open = "open";
    var punct = "punct";
    var rel = "rel";
    var spacing = "spacing";
    var textord = "textord"; // Now comes the symbol table
    // Relation Symbols

    defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
    defineSymbol(math, main, rel, "\u227a", "\\prec", true);
    defineSymbol(math, main, rel, "\u227b", "\\succ", true);
    defineSymbol(math, main, rel, "\u223c", "\\sim", true);
    defineSymbol(math, main, rel, "\u22a5", "\\perp");
    defineSymbol(math, main, rel, "\u2aaf", "\\preceq", true);
    defineSymbol(math, main, rel, "\u2ab0", "\\succeq", true);
    defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
    defineSymbol(math, main, rel, "\u2223", "\\mid", true);
    defineSymbol(math, main, rel, "\u226a", "\\ll", true);
    defineSymbol(math, main, rel, "\u226b", "\\gg", true);
    defineSymbol(math, main, rel, "\u224d", "\\asymp", true);
    defineSymbol(math, main, rel, "\u2225", "\\parallel");
    defineSymbol(math, main, rel, "\u22c8", "\\bowtie", true);
    defineSymbol(math, main, rel, "\u2323", "\\smile", true);
    defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
    defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
    defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
    defineSymbol(math, main, rel, "\u2322", "\\frown", true);
    defineSymbol(math, main, rel, "\u220b", "\\ni", true);
    defineSymbol(math, main, rel, "\u221d", "\\propto", true);
    defineSymbol(math, main, rel, "\u22a2", "\\vdash", true);
    defineSymbol(math, main, rel, "\u22a3", "\\dashv", true);
    defineSymbol(math, main, rel, "\u220b", "\\owns"); // Punctuation

    defineSymbol(math, main, punct, "\u002e", "\\ldotp");
    defineSymbol(math, main, punct, "\u22c5", "\\cdotp"); // Misc Symbols

    defineSymbol(math, main, textord, "\u0023", "\\#");
    defineSymbol(text, main, textord, "\u0023", "\\#");
    defineSymbol(math, main, textord, "\u0026", "\\&");
    defineSymbol(text, main, textord, "\u0026", "\\&");
    defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
    defineSymbol(math, main, textord, "\u2200", "\\forall", true);
    defineSymbol(math, main, textord, "\u210f", "\\hbar", true);
    defineSymbol(math, main, textord, "\u2203", "\\exists", true);
    defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
    defineSymbol(math, main, textord, "\u266d", "\\flat", true);
    defineSymbol(math, main, textord, "\u2113", "\\ell", true);
    defineSymbol(math, main, textord, "\u266e", "\\natural", true);
    defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
    defineSymbol(math, main, textord, "\u2118", "\\wp", true);
    defineSymbol(math, main, textord, "\u266f", "\\sharp", true);
    defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
    defineSymbol(math, main, textord, "\u211c", "\\Re", true);
    defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
    defineSymbol(math, main, textord, "\u2111", "\\Im", true);
    defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
    defineSymbol(math, main, textord, "\u00a7", "\\S", true);
    defineSymbol(text, main, textord, "\u00a7", "\\S");
    defineSymbol(math, main, textord, "\u00b6", "\\P", true);
    defineSymbol(text, main, textord, "\u00b6", "\\P"); // Math and Text

    defineSymbol(math, main, textord, "\u2020", "\\dag");
    defineSymbol(text, main, textord, "\u2020", "\\dag");
    defineSymbol(text, main, textord, "\u2020", "\\textdagger");
    defineSymbol(math, main, textord, "\u2021", "\\ddag");
    defineSymbol(text, main, textord, "\u2021", "\\ddag");
    defineSymbol(text, main, textord, "\u2021", "\\textdaggerdbl"); // Large Delimiters

    defineSymbol(math, main, close, "\u23b1", "\\rmoustache", true);
    defineSymbol(math, main, open, "\u23b0", "\\lmoustache", true);
    defineSymbol(math, main, close, "\u27ef", "\\rgroup", true);
    defineSymbol(math, main, open, "\u27ee", "\\lgroup", true); // Binary Operators

    defineSymbol(math, main, bin, "\u2213", "\\mp", true);
    defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
    defineSymbol(math, main, bin, "\u228e", "\\uplus", true);
    defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
    defineSymbol(math, main, bin, "\u2217", "\\ast");
    defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
    defineSymbol(math, main, bin, "\u25ef", "\\bigcirc", true);
    defineSymbol(math, main, bin, "\u2219", "\\bullet", true);
    defineSymbol(math, main, bin, "\u2021", "\\ddagger");
    defineSymbol(math, main, bin, "\u2240", "\\wr", true);
    defineSymbol(math, main, bin, "\u2a3f", "\\amalg");
    defineSymbol(math, main, bin, "\u0026", "\\And"); // from amsmath
    // Arrow Symbols

    defineSymbol(math, main, rel, "\u27f5", "\\longleftarrow", true);
    defineSymbol(math, main, rel, "\u21d0", "\\Leftarrow", true);
    defineSymbol(math, main, rel, "\u27f8", "\\Longleftarrow", true);
    defineSymbol(math, main, rel, "\u27f6", "\\longrightarrow", true);
    defineSymbol(math, main, rel, "\u21d2", "\\Rightarrow", true);
    defineSymbol(math, main, rel, "\u27f9", "\\Longrightarrow", true);
    defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
    defineSymbol(math, main, rel, "\u27f7", "\\longleftrightarrow", true);
    defineSymbol(math, main, rel, "\u21d4", "\\Leftrightarrow", true);
    defineSymbol(math, main, rel, "\u27fa", "\\Longleftrightarrow", true);
    defineSymbol(math, main, rel, "\u21a6", "\\mapsto", true);
    defineSymbol(math, main, rel, "\u27fc", "\\longmapsto", true);
    defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
    defineSymbol(math, main, rel, "\u21a9", "\\hookleftarrow", true);
    defineSymbol(math, main, rel, "\u21aa", "\\hookrightarrow", true);
    defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
    defineSymbol(math, main, rel, "\u21bc", "\\leftharpoonup", true);
    defineSymbol(math, main, rel, "\u21c0", "\\rightharpoonup", true);
    defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
    defineSymbol(math, main, rel, "\u21bd", "\\leftharpoondown", true);
    defineSymbol(math, main, rel, "\u21c1", "\\rightharpoondown", true);
    defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
    defineSymbol(math, main, rel, "\u21cc", "\\rightleftharpoons", true); // AMS Negated Binary Relations

    defineSymbol(math, ams, rel, "\u226e", "\\nless", true); // Symbol names preceded by "@" each have a corresponding macro.

    defineSymbol(math, ams, rel, "\ue010", "\\@nleqslant");
    defineSymbol(math, ams, rel, "\ue011", "\\@nleqq");
    defineSymbol(math, ams, rel, "\u2a87", "\\lneq", true);
    defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
    defineSymbol(math, ams, rel, "\ue00c", "\\@lvertneqq");
    defineSymbol(math, ams, rel, "\u22e6", "\\lnsim", true);
    defineSymbol(math, ams, rel, "\u2a89", "\\lnapprox", true);
    defineSymbol(math, ams, rel, "\u2280", "\\nprec", true); // unicode-math maps \u22e0 to \npreccurlyeq. We'll use the AMS synonym.

    defineSymbol(math, ams, rel, "\u22e0", "\\npreceq", true);
    defineSymbol(math, ams, rel, "\u22e8", "\\precnsim", true);
    defineSymbol(math, ams, rel, "\u2ab9", "\\precnapprox", true);
    defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
    defineSymbol(math, ams, rel, "\ue006", "\\@nshortmid");
    defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
    defineSymbol(math, ams, rel, "\u22ac", "\\nvdash", true);
    defineSymbol(math, ams, rel, "\u22ad", "\\nvDash", true);
    defineSymbol(math, ams, rel, "\u22ea", "\\ntriangleleft");
    defineSymbol(math, ams, rel, "\u22ec", "\\ntrianglelefteq", true);
    defineSymbol(math, ams, rel, "\u228a", "\\subsetneq", true);
    defineSymbol(math, ams, rel, "\ue01a", "\\@varsubsetneq");
    defineSymbol(math, ams, rel, "\u2acb", "\\subsetneqq", true);
    defineSymbol(math, ams, rel, "\ue017", "\\@varsubsetneqq");
    defineSymbol(math, ams, rel, "\u226f", "\\ngtr", true);
    defineSymbol(math, ams, rel, "\ue00f", "\\@ngeqslant");
    defineSymbol(math, ams, rel, "\ue00e", "\\@ngeqq");
    defineSymbol(math, ams, rel, "\u2a88", "\\gneq", true);
    defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
    defineSymbol(math, ams, rel, "\ue00d", "\\@gvertneqq");
    defineSymbol(math, ams, rel, "\u22e7", "\\gnsim", true);
    defineSymbol(math, ams, rel, "\u2a8a", "\\gnapprox", true);
    defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true); // unicode-math maps \u22e1 to \nsucccurlyeq. We'll use the AMS synonym.

    defineSymbol(math, ams, rel, "\u22e1", "\\nsucceq", true);
    defineSymbol(math, ams, rel, "\u22e9", "\\succnsim", true);
    defineSymbol(math, ams, rel, "\u2aba", "\\succnapprox", true); // unicode-math maps \u2246 to \simneqq. We'll use the AMS synonym.

    defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
    defineSymbol(math, ams, rel, "\ue007", "\\@nshortparallel");
    defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
    defineSymbol(math, ams, rel, "\u22af", "\\nVDash", true);
    defineSymbol(math, ams, rel, "\u22eb", "\\ntriangleright");
    defineSymbol(math, ams, rel, "\u22ed", "\\ntrianglerighteq", true);
    defineSymbol(math, ams, rel, "\ue018", "\\@nsupseteqq");
    defineSymbol(math, ams, rel, "\u228b", "\\supsetneq", true);
    defineSymbol(math, ams, rel, "\ue01b", "\\@varsupsetneq");
    defineSymbol(math, ams, rel, "\u2acc", "\\supsetneqq", true);
    defineSymbol(math, ams, rel, "\ue019", "\\@varsupsetneqq");
    defineSymbol(math, ams, rel, "\u22ae", "\\nVdash", true);
    defineSymbol(math, ams, rel, "\u2ab5", "\\precneqq", true);
    defineSymbol(math, ams, rel, "\u2ab6", "\\succneqq", true);
    defineSymbol(math, ams, rel, "\ue016", "\\@nsubseteqq");
    defineSymbol(math, ams, bin, "\u22b4", "\\unlhd");
    defineSymbol(math, ams, bin, "\u22b5", "\\unrhd"); // AMS Negated Arrows

    defineSymbol(math, ams, rel, "\u219a", "\\nleftarrow", true);
    defineSymbol(math, ams, rel, "\u219b", "\\nrightarrow", true);
    defineSymbol(math, ams, rel, "\u21cd", "\\nLeftarrow", true);
    defineSymbol(math, ams, rel, "\u21cf", "\\nRightarrow", true);
    defineSymbol(math, ams, rel, "\u21ae", "\\nleftrightarrow", true);
    defineSymbol(math, ams, rel, "\u21ce", "\\nLeftrightarrow", true); // AMS Misc

    defineSymbol(math, ams, rel, "\u25b3", "\\vartriangle");
    defineSymbol(math, ams, textord, "\u210f", "\\hslash");
    defineSymbol(math, ams, textord, "\u25bd", "\\triangledown");
    defineSymbol(math, ams, textord, "\u25ca", "\\lozenge");
    defineSymbol(math, ams, textord, "\u24c8", "\\circledS");
    defineSymbol(math, ams, textord, "\u00ae", "\\circledR");
    defineSymbol(text, ams, textord, "\u00ae", "\\circledR");
    defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
    defineSymbol(math, ams, textord, "\u2204", "\\nexists");
    defineSymbol(math, ams, textord, "\u2127", "\\mho");
    defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
    defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
    defineSymbol(math, ams, textord, "\u2035", "\\backprime");
    defineSymbol(math, ams, textord, "\u25b2", "\\blacktriangle");
    defineSymbol(math, ams, textord, "\u25bc", "\\blacktriangledown");
    defineSymbol(math, ams, textord, "\u25a0", "\\blacksquare");
    defineSymbol(math, ams, textord, "\u29eb", "\\blacklozenge");
    defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
    defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
    defineSymbol(math, ams, textord, "\u2201", "\\complement", true); // unicode-math maps U+F0 to \matheth. We map to AMS function \eth

    defineSymbol(math, ams, textord, "\u00f0", "\\eth", true);
    defineSymbol(text, main, textord, "\u00f0", "\u00f0");
    defineSymbol(math, ams, textord, "\u2571", "\\diagup");
    defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
    defineSymbol(math, ams, textord, "\u25a1", "\\square");
    defineSymbol(math, ams, textord, "\u25a1", "\\Box");
    defineSymbol(math, ams, textord, "\u25ca", "\\Diamond"); // unicode-math maps U+A5 to \mathyen. We map to AMS function \yen

    defineSymbol(math, ams, textord, "\u00a5", "\\yen", true);
    defineSymbol(text, ams, textord, "\u00a5", "\\yen", true);
    defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
    defineSymbol(text, ams, textord, "\u2713", "\\checkmark"); // AMS Hebrew

    defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
    defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
    defineSymbol(math, ams, textord, "\u2137", "\\gimel", true); // AMS Greek

    defineSymbol(math, ams, textord, "\u03dd", "\\digamma", true);
    defineSymbol(math, ams, textord, "\u03f0", "\\varkappa"); // AMS Delimiters

    defineSymbol(math, ams, open, "\u250c", "\\@ulcorner", true);
    defineSymbol(math, ams, close, "\u2510", "\\@urcorner", true);
    defineSymbol(math, ams, open, "\u2514", "\\@llcorner", true);
    defineSymbol(math, ams, close, "\u2518", "\\@lrcorner", true); // AMS Binary Relations

    defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
    defineSymbol(math, ams, rel, "\u2a7d", "\\leqslant", true);
    defineSymbol(math, ams, rel, "\u2a95", "\\eqslantless", true);
    defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
    defineSymbol(math, ams, rel, "\u2a85", "\\lessapprox", true);
    defineSymbol(math, ams, rel, "\u224a", "\\approxeq", true);
    defineSymbol(math, ams, bin, "\u22d6", "\\lessdot");
    defineSymbol(math, ams, rel, "\u22d8", "\\lll", true);
    defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
    defineSymbol(math, ams, rel, "\u22da", "\\lesseqgtr", true);
    defineSymbol(math, ams, rel, "\u2a8b", "\\lesseqqgtr", true);
    defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
    defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
    defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
    defineSymbol(math, ams, rel, "\u223d", "\\backsim", true);
    defineSymbol(math, ams, rel, "\u22cd", "\\backsimeq", true);
    defineSymbol(math, ams, rel, "\u2ac5", "\\subseteqq", true);
    defineSymbol(math, ams, rel, "\u22d0", "\\Subset", true);
    defineSymbol(math, ams, rel, "\u228f", "\\sqsubset", true);
    defineSymbol(math, ams, rel, "\u227c", "\\preccurlyeq", true);
    defineSymbol(math, ams, rel, "\u22de", "\\curlyeqprec", true);
    defineSymbol(math, ams, rel, "\u227e", "\\precsim", true);
    defineSymbol(math, ams, rel, "\u2ab7", "\\precapprox", true);
    defineSymbol(math, ams, rel, "\u22b2", "\\vartriangleleft");
    defineSymbol(math, ams, rel, "\u22b4", "\\trianglelefteq");
    defineSymbol(math, ams, rel, "\u22a8", "\\vDash", true);
    defineSymbol(math, ams, rel, "\u22aa", "\\Vvdash", true);
    defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
    defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
    defineSymbol(math, ams, rel, "\u224f", "\\bumpeq", true);
    defineSymbol(math, ams, rel, "\u224e", "\\Bumpeq", true);
    defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
    defineSymbol(math, ams, rel, "\u2a7e", "\\geqslant", true);
    defineSymbol(math, ams, rel, "\u2a96", "\\eqslantgtr", true);
    defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
    defineSymbol(math, ams, rel, "\u2a86", "\\gtrapprox", true);
    defineSymbol(math, ams, bin, "\u22d7", "\\gtrdot");
    defineSymbol(math, ams, rel, "\u22d9", "\\ggg", true);
    defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
    defineSymbol(math, ams, rel, "\u22db", "\\gtreqless", true);
    defineSymbol(math, ams, rel, "\u2a8c", "\\gtreqqless", true);
    defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
    defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
    defineSymbol(math, ams, rel, "\u225c", "\\triangleq", true);
    defineSymbol(math, ams, rel, "\u223c", "\\thicksim");
    defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
    defineSymbol(math, ams, rel, "\u2ac6", "\\supseteqq", true);
    defineSymbol(math, ams, rel, "\u22d1", "\\Supset", true);
    defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
    defineSymbol(math, ams, rel, "\u227d", "\\succcurlyeq", true);
    defineSymbol(math, ams, rel, "\u22df", "\\curlyeqsucc", true);
    defineSymbol(math, ams, rel, "\u227f", "\\succsim", true);
    defineSymbol(math, ams, rel, "\u2ab8", "\\succapprox", true);
    defineSymbol(math, ams, rel, "\u22b3", "\\vartriangleright");
    defineSymbol(math, ams, rel, "\u22b5", "\\trianglerighteq");
    defineSymbol(math, ams, rel, "\u22a9", "\\Vdash", true);
    defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
    defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
    defineSymbol(math, ams, rel, "\u226c", "\\between", true);
    defineSymbol(math, ams, rel, "\u22d4", "\\pitchfork", true);
    defineSymbol(math, ams, rel, "\u221d", "\\varpropto");
    defineSymbol(math, ams, rel, "\u25c0", "\\blacktriangleleft"); // unicode-math says that \therefore is a mathord atom.
    // We kept the amssymb atom type, which is rel.

    defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
    defineSymbol(math, ams, rel, "\u220d", "\\backepsilon");
    defineSymbol(math, ams, rel, "\u25b6", "\\blacktriangleright"); // unicode-math says that \because is a mathord atom.
    // We kept the amssymb atom type, which is rel.

    defineSymbol(math, ams, rel, "\u2235", "\\because", true);
    defineSymbol(math, ams, rel, "\u22d8", "\\llless");
    defineSymbol(math, ams, rel, "\u22d9", "\\gggtr");
    defineSymbol(math, ams, bin, "\u22b2", "\\lhd");
    defineSymbol(math, ams, bin, "\u22b3", "\\rhd");
    defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
    defineSymbol(math, main, rel, "\u22c8", "\\Join");
    defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true); // AMS Binary Operators

    defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
    defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
    defineSymbol(math, ams, bin, "\u22d2", "\\Cap", true);
    defineSymbol(math, ams, bin, "\u22d3", "\\Cup", true);
    defineSymbol(math, ams, bin, "\u2a5e", "\\doublebarwedge", true);
    defineSymbol(math, ams, bin, "\u229f", "\\boxminus", true);
    defineSymbol(math, ams, bin, "\u229e", "\\boxplus", true);
    defineSymbol(math, ams, bin, "\u22c7", "\\divideontimes", true);
    defineSymbol(math, ams, bin, "\u22c9", "\\ltimes", true);
    defineSymbol(math, ams, bin, "\u22ca", "\\rtimes", true);
    defineSymbol(math, ams, bin, "\u22cb", "\\leftthreetimes", true);
    defineSymbol(math, ams, bin, "\u22cc", "\\rightthreetimes", true);
    defineSymbol(math, ams, bin, "\u22cf", "\\curlywedge", true);
    defineSymbol(math, ams, bin, "\u22ce", "\\curlyvee", true);
    defineSymbol(math, ams, bin, "\u229d", "\\circleddash", true);
    defineSymbol(math, ams, bin, "\u229b", "\\circledast", true);
    defineSymbol(math, ams, bin, "\u22c5", "\\centerdot");
    defineSymbol(math, ams, bin, "\u22ba", "\\intercal", true);
    defineSymbol(math, ams, bin, "\u22d2", "\\doublecap");
    defineSymbol(math, ams, bin, "\u22d3", "\\doublecup");
    defineSymbol(math, ams, bin, "\u22a0", "\\boxtimes", true); // AMS Arrows
    // Note: unicode-math maps \u21e2 to their own function \rightdasharrow.
    // We'll map it to AMS function \dashrightarrow. It produces the same atom.

    defineSymbol(math, ams, rel, "\u21e2", "\\dashrightarrow", true); // unicode-math maps \u21e0 to \leftdasharrow. We'll use the AMS synonym.

    defineSymbol(math, ams, rel, "\u21e0", "\\dashleftarrow", true);
    defineSymbol(math, ams, rel, "\u21c7", "\\leftleftarrows", true);
    defineSymbol(math, ams, rel, "\u21c6", "\\leftrightarrows", true);
    defineSymbol(math, ams, rel, "\u21da", "\\Lleftarrow", true);
    defineSymbol(math, ams, rel, "\u219e", "\\twoheadleftarrow", true);
    defineSymbol(math, ams, rel, "\u21a2", "\\leftarrowtail", true);
    defineSymbol(math, ams, rel, "\u21ab", "\\looparrowleft", true);
    defineSymbol(math, ams, rel, "\u21cb", "\\leftrightharpoons", true);
    defineSymbol(math, ams, rel, "\u21b6", "\\curvearrowleft", true); // unicode-math maps \u21ba to \acwopencirclearrow. We'll use the AMS synonym.

    defineSymbol(math, ams, rel, "\u21ba", "\\circlearrowleft", true);
    defineSymbol(math, ams, rel, "\u21b0", "\\Lsh", true);
    defineSymbol(math, ams, rel, "\u21c8", "\\upuparrows", true);
    defineSymbol(math, ams, rel, "\u21bf", "\\upharpoonleft", true);
    defineSymbol(math, ams, rel, "\u21c3", "\\downharpoonleft", true);
    defineSymbol(math, main, rel, "\u22b6", "\\origof", true); // not in font

    defineSymbol(math, main, rel, "\u22b7", "\\imageof", true); // not in font

    defineSymbol(math, ams, rel, "\u22b8", "\\multimap", true);
    defineSymbol(math, ams, rel, "\u21ad", "\\leftrightsquigarrow", true);
    defineSymbol(math, ams, rel, "\u21c9", "\\rightrightarrows", true);
    defineSymbol(math, ams, rel, "\u21c4", "\\rightleftarrows", true);
    defineSymbol(math, ams, rel, "\u21a0", "\\twoheadrightarrow", true);
    defineSymbol(math, ams, rel, "\u21a3", "\\rightarrowtail", true);
    defineSymbol(math, ams, rel, "\u21ac", "\\looparrowright", true);
    defineSymbol(math, ams, rel, "\u21b7", "\\curvearrowright", true); // unicode-math maps \u21bb to \cwopencirclearrow. We'll use the AMS synonym.

    defineSymbol(math, ams, rel, "\u21bb", "\\circlearrowright", true);
    defineSymbol(math, ams, rel, "\u21b1", "\\Rsh", true);
    defineSymbol(math, ams, rel, "\u21ca", "\\downdownarrows", true);
    defineSymbol(math, ams, rel, "\u21be", "\\upharpoonright", true);
    defineSymbol(math, ams, rel, "\u21c2", "\\downharpoonright", true);
    defineSymbol(math, ams, rel, "\u21dd", "\\rightsquigarrow", true);
    defineSymbol(math, ams, rel, "\u21dd", "\\leadsto");
    defineSymbol(math, ams, rel, "\u21db", "\\Rrightarrow", true);
    defineSymbol(math, ams, rel, "\u21be", "\\restriction");
    defineSymbol(math, main, textord, "\u2018", "`");
    defineSymbol(math, main, textord, "$", "\\$");
    defineSymbol(text, main, textord, "$", "\\$");
    defineSymbol(text, main, textord, "$", "\\textdollar");
    defineSymbol(math, main, textord, "%", "\\%");
    defineSymbol(text, main, textord, "%", "\\%");
    defineSymbol(math, main, textord, "_", "\\_");
    defineSymbol(text, main, textord, "_", "\\_");
    defineSymbol(text, main, textord, "_", "\\textunderscore");
    defineSymbol(math, main, textord, "\u2220", "\\angle", true);
    defineSymbol(math, main, textord, "\u221e", "\\infty", true);
    defineSymbol(math, main, textord, "\u2032", "\\prime");
    defineSymbol(math, main, textord, "\u25b3", "\\triangle");
    defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
    defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
    defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
    defineSymbol(math, main, textord, "\u039b", "\\Lambda", true);
    defineSymbol(math, main, textord, "\u039e", "\\Xi", true);
    defineSymbol(math, main, textord, "\u03a0", "\\Pi", true);
    defineSymbol(math, main, textord, "\u03a3", "\\Sigma", true);
    defineSymbol(math, main, textord, "\u03a5", "\\Upsilon", true);
    defineSymbol(math, main, textord, "\u03a6", "\\Phi", true);
    defineSymbol(math, main, textord, "\u03a8", "\\Psi", true);
    defineSymbol(math, main, textord, "\u03a9", "\\Omega", true);
    defineSymbol(math, main, textord, "A", "\u0391");
    defineSymbol(math, main, textord, "B", "\u0392");
    defineSymbol(math, main, textord, "E", "\u0395");
    defineSymbol(math, main, textord, "Z", "\u0396");
    defineSymbol(math, main, textord, "H", "\u0397");
    defineSymbol(math, main, textord, "I", "\u0399");
    defineSymbol(math, main, textord, "K", "\u039A");
    defineSymbol(math, main, textord, "M", "\u039C");
    defineSymbol(math, main, textord, "N", "\u039D");
    defineSymbol(math, main, textord, "O", "\u039F");
    defineSymbol(math, main, textord, "P", "\u03A1");
    defineSymbol(math, main, textord, "T", "\u03A4");
    defineSymbol(math, main, textord, "X", "\u03A7");
    defineSymbol(math, main, textord, "\u00ac", "\\neg", true);
    defineSymbol(math, main, textord, "\u00ac", "\\lnot");
    defineSymbol(math, main, textord, "\u22a4", "\\top");
    defineSymbol(math, main, textord, "\u22a5", "\\bot");
    defineSymbol(math, main, textord, "\u2205", "\\emptyset");
    defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
    defineSymbol(math, main, mathord, "\u03b1", "\\alpha", true);
    defineSymbol(math, main, mathord, "\u03b2", "\\beta", true);
    defineSymbol(math, main, mathord, "\u03b3", "\\gamma", true);
    defineSymbol(math, main, mathord, "\u03b4", "\\delta", true);
    defineSymbol(math, main, mathord, "\u03f5", "\\epsilon", true);
    defineSymbol(math, main, mathord, "\u03b6", "\\zeta", true);
    defineSymbol(math, main, mathord, "\u03b7", "\\eta", true);
    defineSymbol(math, main, mathord, "\u03b8", "\\theta", true);
    defineSymbol(math, main, mathord, "\u03b9", "\\iota", true);
    defineSymbol(math, main, mathord, "\u03ba", "\\kappa", true);
    defineSymbol(math, main, mathord, "\u03bb", "\\lambda", true);
    defineSymbol(math, main, mathord, "\u03bc", "\\mu", true);
    defineSymbol(math, main, mathord, "\u03bd", "\\nu", true);
    defineSymbol(math, main, mathord, "\u03be", "\\xi", true);
    defineSymbol(math, main, mathord, "\u03bf", "\\omicron", true);
    defineSymbol(math, main, mathord, "\u03c0", "\\pi", true);
    defineSymbol(math, main, mathord, "\u03c1", "\\rho", true);
    defineSymbol(math, main, mathord, "\u03c3", "\\sigma", true);
    defineSymbol(math, main, mathord, "\u03c4", "\\tau", true);
    defineSymbol(math, main, mathord, "\u03c5", "\\upsilon", true);
    defineSymbol(math, main, mathord, "\u03d5", "\\phi", true);
    defineSymbol(math, main, mathord, "\u03c7", "\\chi", true);
    defineSymbol(math, main, mathord, "\u03c8", "\\psi", true);
    defineSymbol(math, main, mathord, "\u03c9", "\\omega", true);
    defineSymbol(math, main, mathord, "\u03b5", "\\varepsilon", true);
    defineSymbol(math, main, mathord, "\u03d1", "\\vartheta", true);
    defineSymbol(math, main, mathord, "\u03d6", "\\varpi", true);
    defineSymbol(math, main, mathord, "\u03f1", "\\varrho", true);
    defineSymbol(math, main, mathord, "\u03c2", "\\varsigma", true);
    defineSymbol(math, main, mathord, "\u03c6", "\\varphi", true);
    defineSymbol(math, main, bin, "\u2217", "*", true);
    defineSymbol(math, main, bin, "+", "+");
    defineSymbol(math, main, bin, "\u2212", "-", true);
    defineSymbol(math, main, bin, "\u22c5", "\\cdot", true);
    defineSymbol(math, main, bin, "\u2218", "\\circ", true);
    defineSymbol(math, main, bin, "\u00f7", "\\div", true);
    defineSymbol(math, main, bin, "\u00b1", "\\pm", true);
    defineSymbol(math, main, bin, "\u00d7", "\\times", true);
    defineSymbol(math, main, bin, "\u2229", "\\cap", true);
    defineSymbol(math, main, bin, "\u222a", "\\cup", true);
    defineSymbol(math, main, bin, "\u2216", "\\setminus", true);
    defineSymbol(math, main, bin, "\u2227", "\\land");
    defineSymbol(math, main, bin, "\u2228", "\\lor");
    defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
    defineSymbol(math, main, bin, "\u2228", "\\vee", true);
    defineSymbol(math, main, textord, "\u221a", "\\surd");
    defineSymbol(math, main, open, "\u27e8", "\\langle", true);
    defineSymbol(math, main, open, "\u2223", "\\lvert");
    defineSymbol(math, main, open, "\u2225", "\\lVert");
    defineSymbol(math, main, close, "?", "?");
    defineSymbol(math, main, close, "!", "!");
    defineSymbol(math, main, close, "\u27e9", "\\rangle", true);
    defineSymbol(math, main, close, "\u2223", "\\rvert");
    defineSymbol(math, main, close, "\u2225", "\\rVert");
    defineSymbol(math, main, rel, "=", "=");
    defineSymbol(math, main, rel, ":", ":");
    defineSymbol(math, main, rel, "\u2248", "\\approx", true);
    defineSymbol(math, main, rel, "\u2245", "\\cong", true);
    defineSymbol(math, main, rel, "\u2265", "\\ge");
    defineSymbol(math, main, rel, "\u2265", "\\geq", true);
    defineSymbol(math, main, rel, "\u2190", "\\gets");
    defineSymbol(math, main, rel, ">", "\\gt", true);
    defineSymbol(math, main, rel, "\u2208", "\\in", true);
    defineSymbol(math, main, rel, "\ue020", "\\@not");
    defineSymbol(math, main, rel, "\u2282", "\\subset", true);
    defineSymbol(math, main, rel, "\u2283", "\\supset", true);
    defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
    defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
    defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
    defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
    defineSymbol(math, main, rel, "\u22a8", "\\models");
    defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
    defineSymbol(math, main, rel, "\u2264", "\\le");
    defineSymbol(math, main, rel, "\u2264", "\\leq", true);
    defineSymbol(math, main, rel, "<", "\\lt", true);
    defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
    defineSymbol(math, main, rel, "\u2192", "\\to");
    defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
    defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
    defineSymbol(math, main, spacing, "\u00a0", "\\ ");
    defineSymbol(math, main, spacing, "\u00a0", "\\space"); // Ref: LaTeX Source 2e: \DeclareRobustCommand{\nobreakspace}{%

    defineSymbol(math, main, spacing, "\u00a0", "\\nobreakspace");
    defineSymbol(text, main, spacing, "\u00a0", "\\ ");
    defineSymbol(text, main, spacing, "\u00a0", " ");
    defineSymbol(text, main, spacing, "\u00a0", "\\space");
    defineSymbol(text, main, spacing, "\u00a0", "\\nobreakspace");
    defineSymbol(math, main, spacing, null, "\\nobreak");
    defineSymbol(math, main, spacing, null, "\\allowbreak");
    defineSymbol(math, main, punct, ",", ",");
    defineSymbol(math, main, punct, ";", ";");
    defineSymbol(math, ams, bin, "\u22bc", "\\barwedge", true);
    defineSymbol(math, ams, bin, "\u22bb", "\\veebar", true);
    defineSymbol(math, main, bin, "\u2299", "\\odot", true);
    defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
    defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
    defineSymbol(math, main, textord, "\u2202", "\\partial", true);
    defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
    defineSymbol(math, ams, bin, "\u229a", "\\circledcirc", true);
    defineSymbol(math, ams, bin, "\u22a1", "\\boxdot", true);
    defineSymbol(math, main, bin, "\u25b3", "\\bigtriangleup");
    defineSymbol(math, main, bin, "\u25bd", "\\bigtriangledown");
    defineSymbol(math, main, bin, "\u2020", "\\dagger");
    defineSymbol(math, main, bin, "\u22c4", "\\diamond");
    defineSymbol(math, main, bin, "\u22c6", "\\star");
    defineSymbol(math, main, bin, "\u25c3", "\\triangleleft");
    defineSymbol(math, main, bin, "\u25b9", "\\triangleright");
    defineSymbol(math, main, open, "{", "\\{");
    defineSymbol(text, main, textord, "{", "\\{");
    defineSymbol(text, main, textord, "{", "\\textbraceleft");
    defineSymbol(math, main, close, "}", "\\}");
    defineSymbol(text, main, textord, "}", "\\}");
    defineSymbol(text, main, textord, "}", "\\textbraceright");
    defineSymbol(math, main, open, "{", "\\lbrace");
    defineSymbol(math, main, close, "}", "\\rbrace");
    defineSymbol(math, main, open, "[", "\\lbrack", true);
    defineSymbol(text, main, textord, "[", "\\lbrack", true);
    defineSymbol(math, main, close, "]", "\\rbrack", true);
    defineSymbol(text, main, textord, "]", "\\rbrack", true);
    defineSymbol(math, main, open, "(", "\\lparen", true);
    defineSymbol(math, main, close, ")", "\\rparen", true);
    defineSymbol(text, main, textord, "<", "\\textless", true); // in T1 fontenc

    defineSymbol(text, main, textord, ">", "\\textgreater", true); // in T1 fontenc

    defineSymbol(math, main, open, "\u230a", "\\lfloor", true);
    defineSymbol(math, main, close, "\u230b", "\\rfloor", true);
    defineSymbol(math, main, open, "\u2308", "\\lceil", true);
    defineSymbol(math, main, close, "\u2309", "\\rceil", true);
    defineSymbol(math, main, textord, "\\", "\\backslash");
    defineSymbol(math, main, textord, "\u2223", "|");
    defineSymbol(math, main, textord, "\u2223", "\\vert");
    defineSymbol(text, main, textord, "|", "\\textbar", true); // in T1 fontenc

    defineSymbol(math, main, textord, "\u2225", "\\|");
    defineSymbol(math, main, textord, "\u2225", "\\Vert");
    defineSymbol(text, main, textord, "\u2225", "\\textbardbl");
    defineSymbol(text, main, textord, "~", "\\textasciitilde");
    defineSymbol(text, main, textord, "\\", "\\textbackslash");
    defineSymbol(text, main, textord, "^", "\\textasciicircum");
    defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
    defineSymbol(math, main, rel, "\u21d1", "\\Uparrow", true);
    defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
    defineSymbol(math, main, rel, "\u21d3", "\\Downarrow", true);
    defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
    defineSymbol(math, main, rel, "\u21d5", "\\Updownarrow", true);
    defineSymbol(math, main, op, "\u2210", "\\coprod");
    defineSymbol(math, main, op, "\u22c1", "\\bigvee");
    defineSymbol(math, main, op, "\u22c0", "\\bigwedge");
    defineSymbol(math, main, op, "\u2a04", "\\biguplus");
    defineSymbol(math, main, op, "\u22c2", "\\bigcap");
    defineSymbol(math, main, op, "\u22c3", "\\bigcup");
    defineSymbol(math, main, op, "\u222b", "\\int");
    defineSymbol(math, main, op, "\u222b", "\\intop");
    defineSymbol(math, main, op, "\u222c", "\\iint");
    defineSymbol(math, main, op, "\u222d", "\\iiint");
    defineSymbol(math, main, op, "\u220f", "\\prod");
    defineSymbol(math, main, op, "\u2211", "\\sum");
    defineSymbol(math, main, op, "\u2a02", "\\bigotimes");
    defineSymbol(math, main, op, "\u2a01", "\\bigoplus");
    defineSymbol(math, main, op, "\u2a00", "\\bigodot");
    defineSymbol(math, main, op, "\u222e", "\\oint");
    defineSymbol(math, main, op, "\u222f", "\\oiint");
    defineSymbol(math, main, op, "\u2230", "\\oiiint");
    defineSymbol(math, main, op, "\u2a06", "\\bigsqcup");
    defineSymbol(math, main, op, "\u222b", "\\smallint");
    defineSymbol(text, main, inner, "\u2026", "\\textellipsis");
    defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
    defineSymbol(text, main, inner, "\u2026", "\\ldots", true);
    defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
    defineSymbol(math, main, inner, "\u22ef", "\\@cdots", true);
    defineSymbol(math, main, inner, "\u22f1", "\\ddots", true); // \vdots is a macro that uses one of these two symbols (with made-up names):

    defineSymbol(math, main, textord, "\u22ee", "\\varvdots");
    defineSymbol(text, main, textord, "\u22ee", "\\varvdots");
    defineSymbol(math, main, accent, "\u02ca", "\\acute");
    defineSymbol(math, main, accent, "\u02cb", "\\grave");
    defineSymbol(math, main, accent, "\u00a8", "\\ddot");
    defineSymbol(math, main, accent, "\u007e", "\\tilde");
    defineSymbol(math, main, accent, "\u02c9", "\\bar");
    defineSymbol(math, main, accent, "\u02d8", "\\breve");
    defineSymbol(math, main, accent, "\u02c7", "\\check");
    defineSymbol(math, main, accent, "\u005e", "\\hat");
    defineSymbol(math, main, accent, "\u20d7", "\\vec");
    defineSymbol(math, main, accent, "\u02d9", "\\dot");
    defineSymbol(math, main, accent, "\u02da", "\\mathring"); // \imath and \jmath should be invariant to \mathrm, \mathbf, etc., so use PUA

    defineSymbol(math, main, mathord, "\ue131", "\\@imath");
    defineSymbol(math, main, mathord, "\ue237", "\\@jmath");
    defineSymbol(math, main, textord, "\u0131", "\u0131");
    defineSymbol(math, main, textord, "\u0237", "\u0237");
    defineSymbol(text, main, textord, "\u0131", "\\i", true);
    defineSymbol(text, main, textord, "\u0237", "\\j", true);
    defineSymbol(text, main, textord, "\u00df", "\\ss", true);
    defineSymbol(text, main, textord, "\u00e6", "\\ae", true);
    defineSymbol(text, main, textord, "\u0153", "\\oe", true);
    defineSymbol(text, main, textord, "\u00f8", "\\o", true);
    defineSymbol(text, main, textord, "\u00c6", "\\AE", true);
    defineSymbol(text, main, textord, "\u0152", "\\OE", true);
    defineSymbol(text, main, textord, "\u00d8", "\\O", true);
    defineSymbol(text, main, accent, "\u02ca", "\\'"); // acute

    defineSymbol(text, main, accent, "\u02cb", "\\`"); // grave

    defineSymbol(text, main, accent, "\u02c6", "\\^"); // circumflex

    defineSymbol(text, main, accent, "\u02dc", "\\~"); // tilde

    defineSymbol(text, main, accent, "\u02c9", "\\="); // macron

    defineSymbol(text, main, accent, "\u02d8", "\\u"); // breve

    defineSymbol(text, main, accent, "\u02d9", "\\."); // dot above

    defineSymbol(text, main, accent, "\u00b8", "\\c"); // cedilla

    defineSymbol(text, main, accent, "\u02da", "\\r"); // ring above

    defineSymbol(text, main, accent, "\u02c7", "\\v"); // caron

    defineSymbol(text, main, accent, "\u00a8", '\\"'); // diaeresis

    defineSymbol(text, main, accent, "\u02dd", "\\H"); // double acute

    defineSymbol(text, main, accent, "\u25ef", "\\textcircled"); // \bigcirc glyph
    // These ligatures are detected and created in Parser.js's `formLigatures`.

    var ligatures = {
      "--": true,
      "---": true,
      "``": true,
      "''": true
    };
    defineSymbol(text, main, textord, "\u2013", "--", true);
    defineSymbol(text, main, textord, "\u2013", "\\textendash");
    defineSymbol(text, main, textord, "\u2014", "---", true);
    defineSymbol(text, main, textord, "\u2014", "\\textemdash");
    defineSymbol(text, main, textord, "\u2018", "`", true);
    defineSymbol(text, main, textord, "\u2018", "\\textquoteleft");
    defineSymbol(text, main, textord, "\u2019", "'", true);
    defineSymbol(text, main, textord, "\u2019", "\\textquoteright");
    defineSymbol(text, main, textord, "\u201c", "``", true);
    defineSymbol(text, main, textord, "\u201c", "\\textquotedblleft");
    defineSymbol(text, main, textord, "\u201d", "''", true);
    defineSymbol(text, main, textord, "\u201d", "\\textquotedblright"); //  \degree from gensymb package

    defineSymbol(math, main, textord, "\u00b0", "\\degree", true);
    defineSymbol(text, main, textord, "\u00b0", "\\degree"); // \textdegree from inputenc package

    defineSymbol(text, main, textord, "\u00b0", "\\textdegree", true); // TODO: In LaTeX, \pounds can generate a different character in text and math
    // mode, but among our fonts, only Main-Regular defines this character "163".

    defineSymbol(math, main, textord, "\u00a3", "\\pounds");
    defineSymbol(math, main, textord, "\u00a3", "\\mathsterling", true);
    defineSymbol(text, main, textord, "\u00a3", "\\pounds");
    defineSymbol(text, main, textord, "\u00a3", "\\textsterling", true);
    defineSymbol(math, ams, textord, "\u2720", "\\maltese");
    defineSymbol(text, ams, textord, "\u2720", "\\maltese"); // There are lots of symbols which are the same, so we add them in afterwards.
    // All of these are textords in math mode

    var mathTextSymbols = "0123456789/@.\"";

    for (var i = 0; i < mathTextSymbols.length; i++) {
      var ch = mathTextSymbols.charAt(i);
      defineSymbol(math, main, textord, ch, ch);
    } // All of these are textords in text mode


    var textSymbols = "0123456789!@*()-=+\";:?/.,";

    for (var _i = 0; _i < textSymbols.length; _i++) {
      var _ch = textSymbols.charAt(_i);

      defineSymbol(text, main, textord, _ch, _ch);
    } // All of these are textords in text mode, and mathords in math mode


    var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

    for (var _i2 = 0; _i2 < letters.length; _i2++) {
      var _ch2 = letters.charAt(_i2);

      defineSymbol(math, main, mathord, _ch2, _ch2);
      defineSymbol(text, main, textord, _ch2, _ch2);
    } // Blackboard bold and script letters in Unicode range


    defineSymbol(math, ams, textord, "C", "\u2102"); // blackboard bold

    defineSymbol(text, ams, textord, "C", "\u2102");
    defineSymbol(math, ams, textord, "H", "\u210D");
    defineSymbol(text, ams, textord, "H", "\u210D");
    defineSymbol(math, ams, textord, "N", "\u2115");
    defineSymbol(text, ams, textord, "N", "\u2115");
    defineSymbol(math, ams, textord, "P", "\u2119");
    defineSymbol(text, ams, textord, "P", "\u2119");
    defineSymbol(math, ams, textord, "Q", "\u211A");
    defineSymbol(text, ams, textord, "Q", "\u211A");
    defineSymbol(math, ams, textord, "R", "\u211D");
    defineSymbol(text, ams, textord, "R", "\u211D");
    defineSymbol(math, ams, textord, "Z", "\u2124");
    defineSymbol(text, ams, textord, "Z", "\u2124");
    defineSymbol(math, main, mathord, "h", "\u210E"); // italic h, Planck constant

    defineSymbol(text, main, mathord, "h", "\u210E"); // The next loop loads wide (surrogate pair) characters.
    // We support some letters in the Unicode range U+1D400 to U+1D7FF,
    // Mathematical Alphanumeric Symbols.
    // Some editors do not deal well with wide characters. So don't write the
    // string into this file. Instead, create the string from the surrogate pair.

    var wideChar = "";

    for (var _i3 = 0; _i3 < letters.length; _i3++) {
      var _ch3 = letters.charAt(_i3); // The hex numbers in the next line are a surrogate pair.
      // 0xD835 is the high surrogate for all letters in the range we support.
      // 0xDC00 is the low surrogate for bold A.


      wideChar = String.fromCharCode(0xD835, 0xDC00 + _i3); // A-Z a-z bold

      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDC34 + _i3); // A-Z a-z italic

      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDC68 + _i3); // A-Z a-z bold italic

      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDD04 + _i3); // A-Z a-z Fraktur

      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDD6C + _i3); // A-Z a-z bold Fraktur

      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDDA0 + _i3); // A-Z a-z sans-serif

      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDDD4 + _i3); // A-Z a-z sans bold

      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDE08 + _i3); // A-Z a-z sans italic

      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDE70 + _i3); // A-Z a-z monospace

      defineSymbol(math, main, mathord, _ch3, wideChar);
      defineSymbol(text, main, textord, _ch3, wideChar);

      if (_i3 < 26) {
        // KaTeX fonts have only capital letters for blackboard bold and script.
        // See exception for k below.
        wideChar = String.fromCharCode(0xD835, 0xDD38 + _i3); // A-Z double struck

        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(0xD835, 0xDC9C + _i3); // A-Z script

        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text, main, textord, _ch3, wideChar);
      } // TODO: Add bold script when it is supported by a KaTeX font.

    } // "k" is the only double struck lower case letter in the KaTeX fonts.


    wideChar = String.fromCharCode(0xD835, 0xDD5C); // k double struck

    defineSymbol(math, main, mathord, "k", wideChar);
    defineSymbol(text, main, textord, "k", wideChar); // Next, some wide character numerals

    for (var _i4 = 0; _i4 < 10; _i4++) {
      var _ch4 = _i4.toString();

      wideChar = String.fromCharCode(0xD835, 0xDFCE + _i4); // 0-9 bold

      defineSymbol(math, main, mathord, _ch4, wideChar);
      defineSymbol(text, main, textord, _ch4, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDFE2 + _i4); // 0-9 sans serif

      defineSymbol(math, main, mathord, _ch4, wideChar);
      defineSymbol(text, main, textord, _ch4, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDFEC + _i4); // 0-9 bold sans

      defineSymbol(math, main, mathord, _ch4, wideChar);
      defineSymbol(text, main, textord, _ch4, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDFF6 + _i4); // 0-9 monospace

      defineSymbol(math, main, mathord, _ch4, wideChar);
      defineSymbol(text, main, textord, _ch4, wideChar);
    } // We add these Latin-1 letters as symbols for backwards-compatibility,
    // but they are not actually in the font, nor are they supported by the
    // Unicode accent mechanism, so they fall back to Times font and look ugly.
    // TODO(edemaine): Fix this.


    var extraLatin = "\u00d0\u00de\u00fe";

    for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
      var _ch5 = extraLatin.charAt(_i5);

      defineSymbol(math, main, mathord, _ch5, _ch5);
      defineSymbol(text, main, textord, _ch5, _ch5);
    }

    /**
     * This file provides support for Unicode range U+1D400 to U+1D7FF,
     * Mathematical Alphanumeric Symbols.
     *
     * Function wideCharacterFont takes a wide character as input and returns
     * the font information necessary to render it properly.
     */
    /**
     * Data below is from https://www.unicode.org/charts/PDF/U1D400.pdf
     * That document sorts characters into groups by font type, say bold or italic.
     *
     * In the arrays below, each subarray consists three elements:
     *      * The CSS class of that group when in math mode.
     *      * The CSS class of that group when in text mode.
     *      * The font name, so that KaTeX can get font metrics.
     */

    var wideLatinLetterData = [["mathbf", "textbf", "Main-Bold"], // A-Z bold upright
    ["mathbf", "textbf", "Main-Bold"], // a-z bold upright
    ["mathnormal", "textit", "Math-Italic"], // A-Z italic
    ["mathnormal", "textit", "Math-Italic"], // a-z italic
    ["boldsymbol", "boldsymbol", "Main-BoldItalic"], // A-Z bold italic
    ["boldsymbol", "boldsymbol", "Main-BoldItalic"], // a-z bold italic
    // Map fancy A-Z letters to script, not calligraphic.
    // This aligns with unicode-math and math fonts (except Cambria Math).
    ["mathscr", "textscr", "Script-Regular"], // A-Z script
    ["", "", ""], // a-z script.  No font
    ["", "", ""], // A-Z bold script. No font
    ["", "", ""], // a-z bold script. No font
    ["mathfrak", "textfrak", "Fraktur-Regular"], // A-Z Fraktur
    ["mathfrak", "textfrak", "Fraktur-Regular"], // a-z Fraktur
    ["mathbb", "textbb", "AMS-Regular"], // A-Z double-struck
    ["mathbb", "textbb", "AMS-Regular"], // k double-struck
    // Note that we are using a bold font, but font metrics for regular Fraktur.
    ["mathboldfrak", "textboldfrak", "Fraktur-Regular"], // A-Z bold Fraktur
    ["mathboldfrak", "textboldfrak", "Fraktur-Regular"], // a-z bold Fraktur
    ["mathsf", "textsf", "SansSerif-Regular"], // A-Z sans-serif
    ["mathsf", "textsf", "SansSerif-Regular"], // a-z sans-serif
    ["mathboldsf", "textboldsf", "SansSerif-Bold"], // A-Z bold sans-serif
    ["mathboldsf", "textboldsf", "SansSerif-Bold"], // a-z bold sans-serif
    ["mathitsf", "textitsf", "SansSerif-Italic"], // A-Z italic sans-serif
    ["mathitsf", "textitsf", "SansSerif-Italic"], // a-z italic sans-serif
    ["", "", ""], // A-Z bold italic sans. No font
    ["", "", ""], // a-z bold italic sans. No font
    ["mathtt", "texttt", "Typewriter-Regular"], // A-Z monospace
    ["mathtt", "texttt", "Typewriter-Regular"] // a-z monospace
    ];
    var wideNumeralData = [["mathbf", "textbf", "Main-Bold"], // 0-9 bold
    ["", "", ""], // 0-9 double-struck. No KaTeX font.
    ["mathsf", "textsf", "SansSerif-Regular"], // 0-9 sans-serif
    ["mathboldsf", "textboldsf", "SansSerif-Bold"], // 0-9 bold sans-serif
    ["mathtt", "texttt", "Typewriter-Regular"] // 0-9 monospace
    ];
    var wideCharacterFont = function wideCharacterFont(wideChar, mode) {
      // IE doesn't support codePointAt(). So work with the surrogate pair.
      var H = wideChar.charCodeAt(0); // high surrogate

      var L = wideChar.charCodeAt(1); // low surrogate

      var codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000;
      var j = mode === "math" ? 0 : 1; // column index for CSS class.

      if (0x1D400 <= codePoint && codePoint < 0x1D6A4) {
        // wideLatinLetterData contains exactly 26 chars on each row.
        // So we can calculate the relevant row. No traverse necessary.
        var i = Math.floor((codePoint - 0x1D400) / 26);
        return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
      } else if (0x1D7CE <= codePoint && codePoint <= 0x1D7FF) {
        // Numerals, ten per row.
        var _i = Math.floor((codePoint - 0x1D7CE) / 10);

        return [wideNumeralData[_i][2], wideNumeralData[_i][j]];
      } else if (codePoint === 0x1D6A5 || codePoint === 0x1D6A6) {
        // dotless i or j
        return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
      } else if (0x1D6A6 < codePoint && codePoint < 0x1D7CE) {
        // Greek letters. Not supported, yet.
        return ["", ""];
      } else {
        // We don't support any wide characters outside 1D4001D7FF.
        throw new ParseError("Unsupported character: " + wideChar);
      }
    };

    /* eslint no-console:0 */

    /**
     * Looks up the given symbol in fontMetrics, after applying any symbol
     * replacements defined in symbol.js
     */
    var lookupSymbol = function lookupSymbol(value, // TODO(#963): Use a union type for this.
    fontName, mode) {
      // Replace the value with its replaced value from symbol.js
      if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
      }

      return {
        value: value,
        metrics: getCharacterMetrics(value, fontName, mode)
      };
    };
    /**
     * Makes a symbolNode after translation via the list of symbols in symbols.js.
     * Correctly pulls out metrics for the character, and optionally takes a list of
     * classes to be attached to the node.
     *
     * TODO: make argument order closer to makeSpan
     * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
     * should if present come first in `classes`.
     * TODO(#953): Make `options` mandatory and always pass it in.
     */


    var makeSymbol = function makeSymbol(value, fontName, mode, options, classes) {
      var lookup = lookupSymbol(value, fontName, mode);
      var metrics = lookup.metrics;
      value = lookup.value;
      var symbolNode;

      if (metrics) {
        var italic = metrics.italic;

        if (mode === "text" || options && options.font === "mathit") {
          italic = 0;
        }

        symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
      } else {
        // TODO(emily): Figure out a good way to only print this in development
        typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
        symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
      }

      if (options) {
        symbolNode.maxFontSize = options.sizeMultiplier;

        if (options.style.isTight()) {
          symbolNode.classes.push("mtight");
        }

        var color = options.getColor();

        if (color) {
          symbolNode.style.color = color;
        }
      }

      return symbolNode;
    };
    /**
     * Makes a symbol in Main-Regular or AMS-Regular.
     * Used for rel, bin, open, close, inner, and punct.
     */


    var mathsym = function mathsym(value, mode, options, classes) {
      if (classes === void 0) {
        classes = [];
      }

      // Decide what font to render the symbol in by its entry in the symbols
      // table.
      // Have a special case for when the value = \ because the \ is used as a
      // textord in unsupported command errors but cannot be parsed as a regular
      // text ordinal and is therefore not present as a symbol in the symbols
      // table for text, as well as a special case for boldsymbol because it
      // can be used for bold + and -
      if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
        return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
      } else if (value === "\\" || symbols[mode][value].font === "main") {
        return makeSymbol(value, "Main-Regular", mode, options, classes);
      } else {
        return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
      }
    };
    /**
     * Determines which of the two font names (Main-Bold and Math-BoldItalic) and
     * corresponding style tags (mathbf or boldsymbol) to use for font "boldsymbol",
     * depending on the symbol.  Use this function instead of fontMap for font
     * "boldsymbol".
     */


    var boldsymbol = function boldsymbol(value, mode, options, classes, type) {
      if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
        return {
          fontName: "Math-BoldItalic",
          fontClass: "boldsymbol"
        };
      } else {
        // Some glyphs do not exist in Math-BoldItalic so we need to use
        // Main-Bold instead.
        return {
          fontName: "Main-Bold",
          fontClass: "mathbf"
        };
      }
    };
    /**
     * Makes either a mathord or textord in the correct font and color.
     */


    var makeOrd = function makeOrd(group, options, type) {
      var mode = group.mode;
      var text = group.text;
      var classes = ["mord"]; // Math mode or Old font (i.e. \rm)

      var isFont = mode === "math" || mode === "text" && options.font;
      var fontOrFamily = isFont ? options.font : options.fontFamily;
      var wideFontName = "";
      var wideFontClass = "";

      if (text.charCodeAt(0) === 0xD835) {
        [wideFontName, wideFontClass] = wideCharacterFont(text, mode);
      }

      if (wideFontName.length > 0) {
        // surrogate pairs get special treatment
        return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));
      } else if (fontOrFamily) {
        var fontName;
        var fontClasses;

        if (fontOrFamily === "boldsymbol") {
          var fontData = boldsymbol(text, mode, options, classes, type);
          fontName = fontData.fontName;
          fontClasses = [fontData.fontClass];
        } else if (isFont) {
          fontName = fontMap[fontOrFamily].fontName;
          fontClasses = [fontOrFamily];
        } else {
          fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
          fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
        }

        if (lookupSymbol(text, fontName, mode).metrics) {
          return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));
        } else if (ligatures.hasOwnProperty(text) && fontName.slice(0, 10) === "Typewriter") {
          // Deconstruct ligatures in monospace fonts (\texttt, \tt).
          var parts = [];

          for (var i = 0; i < text.length; i++) {
            parts.push(makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));
          }

          return makeFragment(parts);
        }
      } // Makes a symbol in the default font for mathords and textords.


      if (type === "mathord") {
        return makeSymbol(text, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
      } else if (type === "textord") {
        var font = symbols[mode][text] && symbols[mode][text].font;

        if (font === "ams") {
          var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);

          return makeSymbol(text, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
        } else if (font === "main" || !font) {
          var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);

          return makeSymbol(text, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
        } else {
          // fonts added by plugins
          var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape); // We add font name as a css class


          return makeSymbol(text, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
        }
      } else {
        throw new Error("unexpected type: " + type + " in makeOrd");
      }
    };
    /**
     * Returns true if subsequent symbolNodes have the same classes, skew, maxFont,
     * and styles.
     */


    var canCombine = (prev, next) => {
      if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
        return false;
      } // If prev and next both are just "mbin"s or "mord"s we don't combine them
      // so that the proper spacing can be preserved.


      if (prev.classes.length === 1) {
        var cls = prev.classes[0];

        if (cls === "mbin" || cls === "mord") {
          return false;
        }
      }

      for (var style in prev.style) {
        if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
          return false;
        }
      }

      for (var _style in next.style) {
        if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
          return false;
        }
      }

      return true;
    };
    /**
     * Combine consecutive domTree.symbolNodes into a single symbolNode.
     * Note: this function mutates the argument.
     */


    var tryCombineChars = chars => {
      for (var i = 0; i < chars.length - 1; i++) {
        var prev = chars[i];
        var next = chars[i + 1];

        if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
          prev.text += next.text;
          prev.height = Math.max(prev.height, next.height);
          prev.depth = Math.max(prev.depth, next.depth); // Use the last character's italic correction since we use
          // it to add padding to the right of the span created from
          // the combined characters.

          prev.italic = next.italic;
          chars.splice(i + 1, 1);
          i--;
        }
      }

      return chars;
    };
    /**
     * Calculate the height, depth, and maxFontSize of an element based on its
     * children.
     */


    var sizeElementFromChildren = function sizeElementFromChildren(elem) {
      var height = 0;
      var depth = 0;
      var maxFontSize = 0;

      for (var i = 0; i < elem.children.length; i++) {
        var child = elem.children[i];

        if (child.height > height) {
          height = child.height;
        }

        if (child.depth > depth) {
          depth = child.depth;
        }

        if (child.maxFontSize > maxFontSize) {
          maxFontSize = child.maxFontSize;
        }
      }

      elem.height = height;
      elem.depth = depth;
      elem.maxFontSize = maxFontSize;
    };
    /**
     * Makes a span with the given list of classes, list of children, and options.
     *
     * TODO(#953): Ensure that `options` is always provided (currently some call
     * sites don't pass it) and make the type below mandatory.
     * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
     * should if present come first in `classes`.
     */


    var makeSpan$2 = function makeSpan(classes, children, options, style) {
      var span = new Span(classes, children, options, style);
      sizeElementFromChildren(span);
      return span;
    }; // SVG one is simpler -- doesn't require height, depth, max-font setting.
    // This is also a separate method for typesafety.


    var makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);

    var makeLineSpan = function makeLineSpan(className, options, thickness) {
      var line = makeSpan$2([className], [], options);
      line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
      line.style.borderBottomWidth = makeEm(line.height);
      line.maxFontSize = 1.0;
      return line;
    };
    /**
     * Makes an anchor with the given href, list of classes, list of children,
     * and options.
     */


    var makeAnchor = function makeAnchor(href, classes, children, options) {
      var anchor = new Anchor(href, classes, children, options);
      sizeElementFromChildren(anchor);
      return anchor;
    };
    /**
     * Makes a document fragment with the given list of children.
     */


    var makeFragment = function makeFragment(children) {
      var fragment = new DocumentFragment(children);
      sizeElementFromChildren(fragment);
      return fragment;
    };
    /**
     * Wraps group in a span if it's a document fragment, allowing to apply classes
     * and styles
     */


    var wrapFragment = function wrapFragment(group, options) {
      if (group instanceof DocumentFragment) {
        return makeSpan$2([], [group], options);
      }

      return group;
    }; // These are exact object types to catch typos in the names of the optional fields.


    // Computes the updated `children` list and the overall depth.
    //
    // This helper function for makeVList makes it easier to enforce type safety by
    // allowing early exits (returns) in the logic.
    var getVListChildrenAndDepth = function getVListChildrenAndDepth(params) {
      if (params.positionType === "individualShift") {
        var oldChildren = params.children;
        var children = [oldChildren[0]]; // Add in kerns to the list of params.children to get each element to be
        // shifted to the correct specified shift

        var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;

        var currPos = _depth;

        for (var i = 1; i < oldChildren.length; i++) {
          var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
          var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
          currPos = currPos + diff;
          children.push({
            type: "kern",
            size
          });
          children.push(oldChildren[i]);
        }

        return {
          children,
          depth: _depth
        };
      }

      var depth;

      if (params.positionType === "top") {
        // We always start at the bottom, so calculate the bottom by adding up
        // all the sizes
        var bottom = params.positionData;

        for (var _i = 0; _i < params.children.length; _i++) {
          var child = params.children[_i];
          bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
        }

        depth = bottom;
      } else if (params.positionType === "bottom") {
        depth = -params.positionData;
      } else {
        var firstChild = params.children[0];

        if (firstChild.type !== "elem") {
          throw new Error('First child must have type "elem".');
        }

        if (params.positionType === "shift") {
          depth = -firstChild.elem.depth - params.positionData;
        } else if (params.positionType === "firstBaseline") {
          depth = -firstChild.elem.depth;
        } else {
          throw new Error("Invalid positionType " + params.positionType + ".");
        }
      }

      return {
        children: params.children,
        depth
      };
    };
    /**
     * Makes a vertical list by stacking elements and kerns on top of each other.
     * Allows for many different ways of specifying the positioning method.
     *
     * See VListParam documentation above.
     */


    var makeVList = function makeVList(params, options) {
      var {
        children,
        depth
      } = getVListChildrenAndDepth(params); // Create a strut that is taller than any list item. The strut is added to
      // each item, where it will determine the item's baseline. Since it has
      // `overflow:hidden`, the strut's top edge will sit on the item's line box's
      // top edge and the strut's bottom edge will sit on the item's baseline,
      // with no additional line-height spacing. This allows the item baseline to
      // be positioned precisely without worrying about font ascent and
      // line-height.

      var pstrutSize = 0;

      for (var i = 0; i < children.length; i++) {
        var child = children[i];

        if (child.type === "elem") {
          var elem = child.elem;
          pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
        }
      }

      pstrutSize += 2;
      var pstrut = makeSpan$2(["pstrut"], []);
      pstrut.style.height = makeEm(pstrutSize); // Create a new list of actual children at the correct offsets

      var realChildren = [];
      var minPos = depth;
      var maxPos = depth;
      var currPos = depth;

      for (var _i2 = 0; _i2 < children.length; _i2++) {
        var _child = children[_i2];

        if (_child.type === "kern") {
          currPos += _child.size;
        } else {
          var _elem = _child.elem;
          var classes = _child.wrapperClasses || [];
          var style = _child.wrapperStyle || {};
          var childWrap = makeSpan$2(classes, [pstrut, _elem], undefined, style);
          childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);

          if (_child.marginLeft) {
            childWrap.style.marginLeft = _child.marginLeft;
          }

          if (_child.marginRight) {
            childWrap.style.marginRight = _child.marginRight;
          }

          realChildren.push(childWrap);
          currPos += _elem.height + _elem.depth;
        }

        minPos = Math.min(minPos, currPos);
        maxPos = Math.max(maxPos, currPos);
      } // The vlist contents go in a table-cell with `vertical-align:bottom`.
      // This cell's bottom edge will determine the containing table's baseline
      // without overly expanding the containing line-box.


      var vlist = makeSpan$2(["vlist"], realChildren);
      vlist.style.height = makeEm(maxPos); // A second row is used if necessary to represent the vlist's depth.

      var rows;

      if (minPos < 0) {
        // We will define depth in an empty span with display: table-cell.
        // It should render with the height that we define. But Chrome, in
        // contenteditable mode only, treats that span as if it contains some
        // text content. And that min-height over-rides our desired height.
        // So we put another empty span inside the depth strut span.
        var emptySpan = makeSpan$2([], []);
        var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
        depthStrut.style.height = makeEm(-minPos); // Safari wants the first row to have inline content; otherwise it
        // puts the bottom of the *second* row on the baseline.

        var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("\u200b")]);
        rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
      } else {
        rows = [makeSpan$2(["vlist-r"], [vlist])];
      }

      var vtable = makeSpan$2(["vlist-t"], rows);

      if (rows.length === 2) {
        vtable.classes.push("vlist-t2");
      }

      vtable.height = maxPos;
      vtable.depth = -minPos;
      return vtable;
    }; // Glue is a concept from TeX which is a flexible space between elements in
    // either a vertical or horizontal list. In KaTeX, at least for now, it's
    // static space between elements in a horizontal layout.


    var makeGlue = (measurement, options) => {
      // Make an empty span for the space
      var rule = makeSpan$2(["mspace"], [], options);
      var size = calculateSize(measurement, options);
      rule.style.marginRight = makeEm(size);
      return rule;
    }; // Takes font options, and returns the appropriate fontLookup name


    var retrieveTextFontName = function retrieveTextFontName(fontFamily, fontWeight, fontShape) {
      var baseFontName = "";

      switch (fontFamily) {
        case "amsrm":
          baseFontName = "AMS";
          break;

        case "textrm":
          baseFontName = "Main";
          break;

        case "textsf":
          baseFontName = "SansSerif";
          break;

        case "texttt":
          baseFontName = "Typewriter";
          break;

        default:
          baseFontName = fontFamily;
        // use fonts added by a plugin
      }

      var fontStylesName;

      if (fontWeight === "textbf" && fontShape === "textit") {
        fontStylesName = "BoldItalic";
      } else if (fontWeight === "textbf") {
        fontStylesName = "Bold";
      } else if (fontWeight === "textit") {
        fontStylesName = "Italic";
      } else {
        fontStylesName = "Regular";
      }

      return baseFontName + "-" + fontStylesName;
    };
    /**
     * Maps TeX font commands to objects containing:
     * - variant: string used for "mathvariant" attribute in buildMathML.js
     * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
     */
    // A map between tex font commands an MathML mathvariant attribute values


    var fontMap = {
      // styles
      "mathbf": {
        variant: "bold",
        fontName: "Main-Bold"
      },
      "mathrm": {
        variant: "normal",
        fontName: "Main-Regular"
      },
      "textit": {
        variant: "italic",
        fontName: "Main-Italic"
      },
      "mathit": {
        variant: "italic",
        fontName: "Main-Italic"
      },
      "mathnormal": {
        variant: "italic",
        fontName: "Math-Italic"
      },
      "mathsfit": {
        variant: "sans-serif-italic",
        fontName: "SansSerif-Italic"
      },
      // "boldsymbol" is missing because they require the use of multiple fonts:
      // Math-BoldItalic and Main-Bold.  This is handled by a special case in
      // makeOrd which ends up calling boldsymbol.
      // families
      "mathbb": {
        variant: "double-struck",
        fontName: "AMS-Regular"
      },
      "mathcal": {
        variant: "script",
        fontName: "Caligraphic-Regular"
      },
      "mathfrak": {
        variant: "fraktur",
        fontName: "Fraktur-Regular"
      },
      "mathscr": {
        variant: "script",
        fontName: "Script-Regular"
      },
      "mathsf": {
        variant: "sans-serif",
        fontName: "SansSerif-Regular"
      },
      "mathtt": {
        variant: "monospace",
        fontName: "Typewriter-Regular"
      }
    };
    var svgData = {
      //   path, width, height
      vec: ["vec", 0.471, 0.714],
      // values from the font glyph
      oiintSize1: ["oiintSize1", 0.957, 0.499],
      // oval to overlay the integrand
      oiintSize2: ["oiintSize2", 1.472, 0.659],
      oiiintSize1: ["oiiintSize1", 1.304, 0.499],
      oiiintSize2: ["oiiintSize2", 1.98, 0.659]
    };

    var staticSvg = function staticSvg(value, options) {
      // Create a span with inline SVG for the element.
      var [pathName, width, height] = svgData[value];
      var path = new PathNode(pathName);
      var svgNode = new SvgNode([path], {
        "width": makeEm(width),
        "height": makeEm(height),
        // Override CSS rule `.katex svg { width: 100% }`
        "style": "width:" + makeEm(width),
        "viewBox": "0 0 " + 1000 * width + " " + 1000 * height,
        "preserveAspectRatio": "xMinYMin"
      });
      var span = makeSvgSpan(["overlay"], [svgNode], options);
      span.height = height;
      span.style.height = makeEm(height);
      span.style.width = makeEm(width);
      return span;
    };

    var buildCommon = {
      fontMap,
      makeSymbol,
      mathsym,
      makeSpan: makeSpan$2,
      makeSvgSpan,
      makeLineSpan,
      makeAnchor,
      makeFragment,
      wrapFragment,
      makeVList,
      makeOrd,
      makeGlue,
      staticSvg,
      svgData,
      tryCombineChars
    };

    /**
     * Describes spaces between different classes of atoms.
     */
    var thinspace = {
      number: 3,
      unit: "mu"
    };
    var mediumspace = {
      number: 4,
      unit: "mu"
    };
    var thickspace = {
      number: 5,
      unit: "mu"
    }; // Making the type below exact with all optional fields doesn't work due to
    // - https://github.com/facebook/flow/issues/4582
    // - https://github.com/facebook/flow/issues/5688
    // However, since *all* fields are optional, $Shape<> works as suggested in 5688
    // above.

    // Spacing relationships for display and text styles
    var spacings = {
      mord: {
        mop: thinspace,
        mbin: mediumspace,
        mrel: thickspace,
        minner: thinspace
      },
      mop: {
        mord: thinspace,
        mop: thinspace,
        mrel: thickspace,
        minner: thinspace
      },
      mbin: {
        mord: mediumspace,
        mop: mediumspace,
        mopen: mediumspace,
        minner: mediumspace
      },
      mrel: {
        mord: thickspace,
        mop: thickspace,
        mopen: thickspace,
        minner: thickspace
      },
      mopen: {},
      mclose: {
        mop: thinspace,
        mbin: mediumspace,
        mrel: thickspace,
        minner: thinspace
      },
      mpunct: {
        mord: thinspace,
        mop: thinspace,
        mrel: thickspace,
        mopen: thinspace,
        mclose: thinspace,
        mpunct: thinspace,
        minner: thinspace
      },
      minner: {
        mord: thinspace,
        mop: thinspace,
        mbin: mediumspace,
        mrel: thickspace,
        mopen: thinspace,
        mpunct: thinspace,
        minner: thinspace
      }
    }; // Spacing relationships for script and scriptscript styles

    var tightSpacings = {
      mord: {
        mop: thinspace
      },
      mop: {
        mord: thinspace,
        mop: thinspace
      },
      mbin: {},
      mrel: {},
      mopen: {},
      mclose: {
        mop: thinspace
      },
      mpunct: {},
      minner: {
        mop: thinspace
      }
    };

    /** Context provided to function handlers for error messages. */
    // Note: reverse the order of the return type union will cause a flow error.
    // See https://github.com/facebook/flow/issues/3663.
    // More general version of `HtmlBuilder` for nodes (e.g. \sum, accent types)
    // whose presence impacts super/subscripting. In this case, ParseNode<"supsub">
    // delegates its HTML building to the HtmlBuilder corresponding to these nodes.

    /**
     * Final function spec for use at parse time.
     * This is almost identical to `FunctionPropSpec`, except it
     * 1. includes the function handler, and
     * 2. requires all arguments except argTypes.
     * It is generated by `defineFunction()` below.
     */

    /**
     * All registered functions.
     * `functions.js` just exports this same dictionary again and makes it public.
     * `Parser.js` requires this dictionary.
     */
    var _functions = {};
    /**
     * All HTML builders. Should be only used in the `define*` and the `build*ML`
     * functions.
     */

    var _htmlGroupBuilders = {};
    /**
     * All MathML builders. Should be only used in the `define*` and the `build*ML`
     * functions.
     */

    var _mathmlGroupBuilders = {};
    function defineFunction(_ref) {
      var {
        type,
        names,
        props,
        handler,
        htmlBuilder,
        mathmlBuilder
      } = _ref;
      // Set default values of functions
      var data = {
        type,
        numArgs: props.numArgs,
        argTypes: props.argTypes,
        allowedInArgument: !!props.allowedInArgument,
        allowedInText: !!props.allowedInText,
        allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,
        numOptionalArgs: props.numOptionalArgs || 0,
        infix: !!props.infix,
        primitive: !!props.primitive,
        handler: handler
      };

      for (var i = 0; i < names.length; ++i) {
        _functions[names[i]] = data;
      }

      if (type) {
        if (htmlBuilder) {
          _htmlGroupBuilders[type] = htmlBuilder;
        }

        if (mathmlBuilder) {
          _mathmlGroupBuilders[type] = mathmlBuilder;
        }
      }
    }
    /**
     * Use this to register only the HTML and MathML builders for a function (e.g.
     * if the function's ParseNode is generated in Parser.js rather than via a
     * stand-alone handler provided to `defineFunction`).
     */

    function defineFunctionBuilders(_ref2) {
      var {
        type,
        htmlBuilder,
        mathmlBuilder
      } = _ref2;
      defineFunction({
        type,
        names: [],
        props: {
          numArgs: 0
        },

        handler() {
          throw new Error('Should never be called.');
        },

        htmlBuilder,
        mathmlBuilder
      });
    }
    var normalizeArgument = function normalizeArgument(arg) {
      return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
    }; // Since the corresponding buildHTML/buildMathML function expects a
    // list of elements, we normalize for different kinds of arguments

    var ordargument = function ordargument(arg) {
      return arg.type === "ordgroup" ? arg.body : [arg];
    };

    /**
     * This file does the main work of building a domTree structure from a parse
     * tree. The entry point is the `buildHTML` function, which takes a parse tree.
     * Then, the buildExpression, buildGroup, and various groupBuilders functions
     * are called, to produce a final HTML tree.
     */
    var makeSpan$1 = buildCommon.makeSpan; // Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)
    // depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,
    // and the text before Rule 19.

    var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
    var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
    var styleMap$1 = {
      "display": Style$1.DISPLAY,
      "text": Style$1.TEXT,
      "script": Style$1.SCRIPT,
      "scriptscript": Style$1.SCRIPTSCRIPT
    };
    var DomEnum = {
      mord: "mord",
      mop: "mop",
      mbin: "mbin",
      mrel: "mrel",
      mopen: "mopen",
      mclose: "mclose",
      mpunct: "mpunct",
      minner: "minner"
    };

    /**
     * Take a list of nodes, build them in order, and return a list of the built
     * nodes. documentFragments are flattened into their contents, so the
     * returned list contains no fragments. `isRealGroup` is true if `expression`
     * is a real group (no atoms will be added on either side), as opposed to
     * a partial group (e.g. one created by \color). `surrounding` is an array
     * consisting type of nodes that will be added to the left and right.
     */
    var buildExpression$1 = function buildExpression(expression, options, isRealGroup, surrounding) {
      if (surrounding === void 0) {
        surrounding = [null, null];
      }

      // Parse expressions into `groups`.
      var groups = [];

      for (var i = 0; i < expression.length; i++) {
        var output = buildGroup$1(expression[i], options);

        if (output instanceof DocumentFragment) {
          var children = output.children;
          groups.push(...children);
        } else {
          groups.push(output);
        }
      } // Combine consecutive domTree.symbolNodes into a single symbolNode.


      buildCommon.tryCombineChars(groups); // If `expression` is a partial group, let the parent handle spacings
      // to avoid processing groups multiple times.

      if (!isRealGroup) {
        return groups;
      }

      var glueOptions = options;

      if (expression.length === 1) {
        var node = expression[0];

        if (node.type === "sizing") {
          glueOptions = options.havingSize(node.size);
        } else if (node.type === "styling") {
          glueOptions = options.havingStyle(styleMap$1[node.style]);
        }
      } // Dummy spans for determining spacings between surrounding atoms.
      // If `expression` has no atoms on the left or right, class "leftmost"
      // or "rightmost", respectively, is used to indicate it.


      var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options);
      var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options); // TODO: These code assumes that a node's math class is the first element
      // of its `classes` array. A later cleanup should ensure this, for
      // instance by changing the signature of `makeSpan`.
      // Before determining what spaces to insert, perform bin cancellation.
      // Binary operators change to ordinary symbols in some contexts.

      var isRoot = isRealGroup === "root";
      traverseNonSpaceNodes(groups, (node, prev) => {
        var prevType = prev.classes[0];
        var type = node.classes[0];

        if (prevType === "mbin" && binRightCanceller.includes(type)) {
          prev.classes[0] = "mord";
        } else if (type === "mbin" && binLeftCanceller.includes(prevType)) {
          node.classes[0] = "mord";
        }
      }, {
        node: dummyPrev
      }, dummyNext, isRoot);
      traverseNonSpaceNodes(groups, (node, prev) => {
        var prevType = getTypeOfDomTree(prev);
        var type = getTypeOfDomTree(node); // 'mtight' indicates that the node is script or scriptscript style.

        var space = prevType && type ? node.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;

        if (space) {
          // Insert glue (spacing) after the `prev`.
          return buildCommon.makeGlue(space, glueOptions);
        }
      }, {
        node: dummyPrev
      }, dummyNext, isRoot);
      return groups;
    }; // Depth-first traverse non-space `nodes`, calling `callback` with the current and
    // previous node as arguments, optionally returning a node to insert after the
    // previous node. `prev` is an object with the previous node and `insertAfter`
    // function to insert after it. `next` is a node that will be added to the right.
    // Used for bin cancellation and inserting spacings.

    var traverseNonSpaceNodes = function traverseNonSpaceNodes(nodes, callback, prev, next, isRoot) {
      if (next) {
        // temporarily append the right node, if exists
        nodes.push(next);
      }

      var i = 0;

      for (; i < nodes.length; i++) {
        var node = nodes[i];
        var partialGroup = checkPartialGroup(node);

        if (partialGroup) {
          // Recursive DFS
          // $FlowFixMe: make nodes a $ReadOnlyArray by returning a new array
          traverseNonSpaceNodes(partialGroup.children, callback, prev, null, isRoot);
          continue;
        } // Ignore explicit spaces (e.g., \;, \,) when determining what implicit
        // spacing should go between atoms of different classes


        var nonspace = !node.hasClass("mspace");

        if (nonspace) {
          var result = callback(node, prev.node);

          if (result) {
            if (prev.insertAfter) {
              prev.insertAfter(result);
            } else {
              // insert at front
              nodes.unshift(result);
              i++;
            }
          }
        }

        if (nonspace) {
          prev.node = node;
        } else if (isRoot && node.hasClass("newline")) {
          prev.node = makeSpan$1(["leftmost"]); // treat like beginning of line
        }

        prev.insertAfter = (index => n => {
          nodes.splice(index + 1, 0, n);
          i++;
        })(i);
      }

      if (next) {
        nodes.pop();
      }
    }; // Check if given node is a partial group, i.e., does not affect spacing around.


    var checkPartialGroup = function checkPartialGroup(node) {
      if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
        return node;
      }

      return null;
    }; // Return the outermost node of a domTree.


    var getOutermostNode = function getOutermostNode(node, side) {
      var partialGroup = checkPartialGroup(node);

      if (partialGroup) {
        var children = partialGroup.children;

        if (children.length) {
          if (side === "right") {
            return getOutermostNode(children[children.length - 1], "right");
          } else if (side === "left") {
            return getOutermostNode(children[0], "left");
          }
        }
      }

      return node;
    }; // Return math atom class (mclass) of a domTree.
    // If `side` is given, it will get the type of the outermost node at given side.


    var getTypeOfDomTree = function getTypeOfDomTree(node, side) {
      if (!node) {
        return null;
      }

      if (side) {
        node = getOutermostNode(node, side);
      } // This makes a lot of assumptions as to where the type of atom
      // appears.  We should do a better job of enforcing this.


      return DomEnum[node.classes[0]] || null;
    };
    var makeNullDelimiter = function makeNullDelimiter(options, classes) {
      var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
      return makeSpan$1(classes.concat(moreClasses));
    };
    /**
     * buildGroup is the function that takes a group and calls the correct groupType
     * function for it. It also handles the interaction of size and style changes
     * between parents and children.
     */

    var buildGroup$1 = function buildGroup(group, options, baseOptions) {
      if (!group) {
        return makeSpan$1();
      }

      if (_htmlGroupBuilders[group.type]) {
        // Call the groupBuilders function
        // $FlowFixMe
        var groupNode = _htmlGroupBuilders[group.type](group, options); // If the size changed between the parent and the current group, account
        // for that size difference.

        if (baseOptions && options.size !== baseOptions.size) {
          groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);
          var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
          groupNode.height *= multiplier;
          groupNode.depth *= multiplier;
        }

        return groupNode;
      } else {
        throw new ParseError("Got group of unknown type: '" + group.type + "'");
      }
    };
    /**
     * Combine an array of HTML DOM nodes (e.g., the output of `buildExpression`)
     * into an unbreakable HTML node of class .base, with proper struts to
     * guarantee correct vertical extent.  `buildHTML` calls this repeatedly to
     * make up the entire expression as a sequence of unbreakable units.
     */

    function buildHTMLUnbreakable(children, options) {
      // Compute height and depth of this chunk.
      var body = makeSpan$1(["base"], children, options); // Add strut, which ensures that the top of the HTML element falls at
      // the height of the expression, and the bottom of the HTML element
      // falls at the depth of the expression.

      var strut = makeSpan$1(["strut"]);
      strut.style.height = makeEm(body.height + body.depth);

      if (body.depth) {
        strut.style.verticalAlign = makeEm(-body.depth);
      }

      body.children.unshift(strut);
      return body;
    }
    /**
     * Take an entire parse tree, and build it into an appropriate set of HTML
     * nodes.
     */


    function buildHTML(tree, options) {
      // Strip off outer tag wrapper for processing below.
      var tag = null;

      if (tree.length === 1 && tree[0].type === "tag") {
        tag = tree[0].tag;
        tree = tree[0].body;
      } // Build the expression contained in the tree


      var expression = buildExpression$1(tree, options, "root");
      var eqnNum;

      if (expression.length === 2 && expression[1].hasClass("tag")) {
        // An environment with automatic equation numbers, e.g. {gather}.
        eqnNum = expression.pop();
      }

      var children = []; // Create one base node for each chunk between potential line breaks.
      // The TeXBook [p.173] says "A formula will be broken only after a
      // relation symbol like $=$ or $<$ or $\rightarrow$, or after a binary
      // operation symbol like $+$ or $-$ or $\times$, where the relation or
      // binary operation is on the ``outer level'' of the formula (i.e., not
      // enclosed in {...} and not part of an \over construction)."

      var parts = [];

      for (var i = 0; i < expression.length; i++) {
        parts.push(expression[i]);

        if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
          // Put any post-operator glue on same line as operator.
          // Watch for \nobreak along the way, and stop at \newline.
          var nobreak = false;

          while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
            i++;
            parts.push(expression[i]);

            if (expression[i].hasClass("nobreak")) {
              nobreak = true;
            }
          } // Don't allow break if \nobreak among the post-operator glue.


          if (!nobreak) {
            children.push(buildHTMLUnbreakable(parts, options));
            parts = [];
          }
        } else if (expression[i].hasClass("newline")) {
          // Write the line except the newline
          parts.pop();

          if (parts.length > 0) {
            children.push(buildHTMLUnbreakable(parts, options));
            parts = [];
          } // Put the newline at the top level


          children.push(expression[i]);
        }
      }

      if (parts.length > 0) {
        children.push(buildHTMLUnbreakable(parts, options));
      } // Now, if there was a tag, build it too and append it as a final child.


      var tagChild;

      if (tag) {
        tagChild = buildHTMLUnbreakable(buildExpression$1(tag, options, true));
        tagChild.classes = ["tag"];
        children.push(tagChild);
      } else if (eqnNum) {
        children.push(eqnNum);
      }

      var htmlNode = makeSpan$1(["katex-html"], children);
      htmlNode.setAttribute("aria-hidden", "true"); // Adjust the strut of the tag to be the maximum height of all children
      // (the height of the enclosing htmlNode) for proper vertical alignment.

      if (tagChild) {
        var strut = tagChild.children[0];
        strut.style.height = makeEm(htmlNode.height + htmlNode.depth);

        if (htmlNode.depth) {
          strut.style.verticalAlign = makeEm(-htmlNode.depth);
        }
      }

      return htmlNode;
    }

    /**
     * These objects store data about MathML nodes. This is the MathML equivalent
     * of the types in domTree.js. Since MathML handles its own rendering, and
     * since we're mainly using MathML to improve accessibility, we don't manage
     * any of the styling state that the plain DOM nodes do.
     *
     * The `toNode` and `toMarkup` functions work similarly to how they do in
     * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
     */
    function newDocumentFragment(children) {
      return new DocumentFragment(children);
    }
    /**
     * This node represents a general purpose MathML node of any type. The
     * constructor requires the type of node to create (for example, `"mo"` or
     * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
     */

    class MathNode {
      constructor(type, children, classes) {
        this.type = void 0;
        this.attributes = void 0;
        this.children = void 0;
        this.classes = void 0;
        this.type = type;
        this.attributes = {};
        this.children = children || [];
        this.classes = classes || [];
      }
      /**
       * Sets an attribute on a MathML node. MathML depends on attributes to convey a
       * semantic content, so this is used heavily.
       */


      setAttribute(name, value) {
        this.attributes[name] = value;
      }
      /**
       * Gets an attribute on a MathML node.
       */


      getAttribute(name) {
        return this.attributes[name];
      }
      /**
       * Converts the math node into a MathML-namespaced DOM element.
       */


      toNode() {
        var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);

        for (var attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            node.setAttribute(attr, this.attributes[attr]);
          }
        }

        if (this.classes.length > 0) {
          node.className = createClass(this.classes);
        }

        for (var i = 0; i < this.children.length; i++) {
          // Combine multiple TextNodes into one TextNode, to prevent
          // screen readers from reading each as a separate word [#3995]
          if (this.children[i] instanceof TextNode && this.children[i + 1] instanceof TextNode) {
            var text = this.children[i].toText() + this.children[++i].toText();

            while (this.children[i + 1] instanceof TextNode) {
              text += this.children[++i].toText();
            }

            node.appendChild(new TextNode(text).toNode());
          } else {
            node.appendChild(this.children[i].toNode());
          }
        }

        return node;
      }
      /**
       * Converts the math node into an HTML markup string.
       */


      toMarkup() {
        var markup = "<" + this.type; // Add the attributes

        for (var attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "=\"";
            markup += utils.escape(this.attributes[attr]);
            markup += "\"";
          }
        }

        if (this.classes.length > 0) {
          markup += " class =\"" + utils.escape(createClass(this.classes)) + "\"";
        }

        markup += ">";

        for (var i = 0; i < this.children.length; i++) {
          markup += this.children[i].toMarkup();
        }

        markup += "</" + this.type + ">";
        return markup;
      }
      /**
       * Converts the math node into a string, similar to innerText, but escaped.
       */


      toText() {
        return this.children.map(child => child.toText()).join("");
      }

    }
    /**
     * This node represents a piece of text.
     */

    class TextNode {
      constructor(text) {
        this.text = void 0;
        this.text = text;
      }
      /**
       * Converts the text node into a DOM text node.
       */


      toNode() {
        return document.createTextNode(this.text);
      }
      /**
       * Converts the text node into escaped HTML markup
       * (representing the text itself).
       */


      toMarkup() {
        return utils.escape(this.toText());
      }
      /**
       * Converts the text node into a string
       * (representing the text itself).
       */


      toText() {
        return this.text;
      }

    }
    /**
     * This node represents a space, but may render as <mspace.../> or as text,
     * depending on the width.
     */

    class SpaceNode {
      /**
       * Create a Space node with width given in CSS ems.
       */
      constructor(width) {
        this.width = void 0;
        this.character = void 0;
        this.width = width; // See https://www.w3.org/TR/2000/WD-MathML2-20000328/chapter6.html
        // for a table of space-like characters.  We use Unicode
        // representations instead of &LongNames; as it's not clear how to
        // make the latter via document.createTextNode.

        if (width >= 0.05555 && width <= 0.05556) {
          this.character = "\u200a"; // &VeryThinSpace;
        } else if (width >= 0.1666 && width <= 0.1667) {
          this.character = "\u2009"; // &ThinSpace;
        } else if (width >= 0.2222 && width <= 0.2223) {
          this.character = "\u2005"; // &MediumSpace;
        } else if (width >= 0.2777 && width <= 0.2778) {
          this.character = "\u2005\u200a"; // &ThickSpace;
        } else if (width >= -0.05556 && width <= -0.05555) {
          this.character = "\u200a\u2063"; // &NegativeVeryThinSpace;
        } else if (width >= -0.1667 && width <= -0.1666) {
          this.character = "\u2009\u2063"; // &NegativeThinSpace;
        } else if (width >= -0.2223 && width <= -0.2222) {
          this.character = "\u205f\u2063"; // &NegativeMediumSpace;
        } else if (width >= -0.2778 && width <= -0.2777) {
          this.character = "\u2005\u2063"; // &NegativeThickSpace;
        } else {
          this.character = null;
        }
      }
      /**
       * Converts the math node into a MathML-namespaced DOM element.
       */


      toNode() {
        if (this.character) {
          return document.createTextNode(this.character);
        } else {
          var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
          node.setAttribute("width", makeEm(this.width));
          return node;
        }
      }
      /**
       * Converts the math node into an HTML markup string.
       */


      toMarkup() {
        if (this.character) {
          return "<mtext>" + this.character + "</mtext>";
        } else {
          return "<mspace width=\"" + makeEm(this.width) + "\"/>";
        }
      }
      /**
       * Converts the math node into a string, similar to innerText.
       */


      toText() {
        if (this.character) {
          return this.character;
        } else {
          return " ";
        }
      }

    }

    var mathMLTree = {
      MathNode,
      TextNode,
      SpaceNode,
      newDocumentFragment
    };

    /**
     * This file converts a parse tree into a corresponding MathML tree. The main
     * entry point is the `buildMathML` function, which takes a parse tree from the
     * parser.
     */

    /**
     * Takes a symbol and converts it into a MathML text node after performing
     * optional replacement from symbols.js.
     */
    var makeText = function makeText(text, mode, options) {
      if (symbols[mode][text] && symbols[mode][text].replace && text.charCodeAt(0) !== 0xD835 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
        text = symbols[mode][text].replace;
      }

      return new mathMLTree.TextNode(text);
    };
    /**
     * Wrap the given array of nodes in an <mrow> node if needed, i.e.,
     * unless the array has length 1.  Always returns a single node.
     */

    var makeRow = function makeRow(body) {
      if (body.length === 1) {
        return body[0];
      } else {
        return new mathMLTree.MathNode("mrow", body);
      }
    };
    /**
     * Returns the math variant as a string or null if none is required.
     */

    var getVariant = function getVariant(group, options) {
      // Handle \text... font specifiers as best we can.
      // MathML has a limited list of allowable mathvariant specifiers; see
      // https://www.w3.org/TR/MathML3/chapter3.html#presm.commatt
      if (options.fontFamily === "texttt") {
        return "monospace";
      } else if (options.fontFamily === "textsf") {
        if (options.fontShape === "textit" && options.fontWeight === "textbf") {
          return "sans-serif-bold-italic";
        } else if (options.fontShape === "textit") {
          return "sans-serif-italic";
        } else if (options.fontWeight === "textbf") {
          return "bold-sans-serif";
        } else {
          return "sans-serif";
        }
      } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
        return "bold-italic";
      } else if (options.fontShape === "textit") {
        return "italic";
      } else if (options.fontWeight === "textbf") {
        return "bold";
      }

      var font = options.font;

      if (!font || font === "mathnormal") {
        return null;
      }

      var mode = group.mode;

      if (font === "mathit") {
        return "italic";
      } else if (font === "boldsymbol") {
        return group.type === "textord" ? "bold" : "bold-italic";
      } else if (font === "mathbf") {
        return "bold";
      } else if (font === "mathbb") {
        return "double-struck";
      } else if (font === "mathsfit") {
        return "sans-serif-italic";
      } else if (font === "mathfrak") {
        return "fraktur";
      } else if (font === "mathscr" || font === "mathcal") {
        // MathML makes no distinction between script and calligraphic
        return "script";
      } else if (font === "mathsf") {
        return "sans-serif";
      } else if (font === "mathtt") {
        return "monospace";
      }

      var text = group.text;

      if (["\\imath", "\\jmath"].includes(text)) {
        return null;
      }

      if (symbols[mode][text] && symbols[mode][text].replace) {
        text = symbols[mode][text].replace;
      }

      var fontName = buildCommon.fontMap[font].fontName;

      if (getCharacterMetrics(text, fontName, mode)) {
        return buildCommon.fontMap[font].variant;
      }

      return null;
    };
    /**
     * Check for <mi>.</mi> which is how a dot renders in MathML,
     * or <mo separator="true" lspace="0em" rspace="0em">,</mo>
     * which is how a braced comma {,} renders in MathML
     */

    function isNumberPunctuation(group) {
      if (!group) {
        return false;
      }

      if (group.type === 'mi' && group.children.length === 1) {
        var child = group.children[0];
        return child instanceof TextNode && child.text === '.';
      } else if (group.type === 'mo' && group.children.length === 1 && group.getAttribute('separator') === 'true' && group.getAttribute('lspace') === '0em' && group.getAttribute('rspace') === '0em') {
        var _child = group.children[0];
        return _child instanceof TextNode && _child.text === ',';
      } else {
        return false;
      }
    }
    /**
     * Takes a list of nodes, builds them, and returns a list of the generated
     * MathML nodes.  Also combine consecutive <mtext> outputs into a single
     * <mtext> tag.
     */


    var buildExpression = function buildExpression(expression, options, isOrdgroup) {
      if (expression.length === 1) {
        var group = buildGroup(expression[0], options);

        if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
          // When TeX writers want to suppress spacing on an operator,
          // they often put the operator by itself inside braces.
          group.setAttribute("lspace", "0em");
          group.setAttribute("rspace", "0em");
        }

        return [group];
      }

      var groups = [];
      var lastGroup;

      for (var i = 0; i < expression.length; i++) {
        var _group = buildGroup(expression[i], options);

        if (_group instanceof MathNode && lastGroup instanceof MathNode) {
          // Concatenate adjacent <mtext>s
          if (_group.type === 'mtext' && lastGroup.type === 'mtext' && _group.getAttribute('mathvariant') === lastGroup.getAttribute('mathvariant')) {
            lastGroup.children.push(..._group.children);
            continue; // Concatenate adjacent <mn>s
          } else if (_group.type === 'mn' && lastGroup.type === 'mn') {
            lastGroup.children.push(..._group.children);
            continue; // Concatenate <mn>...</mn> followed by <mi>.</mi>
          } else if (isNumberPunctuation(_group) && lastGroup.type === 'mn') {
            lastGroup.children.push(..._group.children);
            continue; // Concatenate <mi>.</mi> followed by <mn>...</mn>
          } else if (_group.type === 'mn' && isNumberPunctuation(lastGroup)) {
            _group.children = [...lastGroup.children, ..._group.children];
            groups.pop(); // Put preceding <mn>...</mn> or <mi>.</mi> inside base of
            // <msup><mn>...base...</mn>...exponent...</msup> (or <msub>)
          } else if ((_group.type === 'msup' || _group.type === 'msub') && _group.children.length >= 1 && (lastGroup.type === 'mn' || isNumberPunctuation(lastGroup))) {
            var base = _group.children[0];

            if (base instanceof MathNode && base.type === 'mn') {
              base.children = [...lastGroup.children, ...base.children];
              groups.pop();
            } // \not

          } else if (lastGroup.type === 'mi' && lastGroup.children.length === 1) {
            var lastChild = lastGroup.children[0];

            if (lastChild instanceof TextNode && lastChild.text === '\u0338' && (_group.type === 'mo' || _group.type === 'mi' || _group.type === 'mn')) {
              var child = _group.children[0];

              if (child instanceof TextNode && child.text.length > 0) {
                // Overlay with combining character long solidus
                child.text = child.text.slice(0, 1) + "\u0338" + child.text.slice(1);
                groups.pop();
              }
            }
          }
        }

        groups.push(_group);
        lastGroup = _group;
      }

      return groups;
    };
    /**
     * Equivalent to buildExpression, but wraps the elements in an <mrow>
     * if there's more than one.  Returns a single node instead of an array.
     */

    var buildExpressionRow = function buildExpressionRow(expression, options, isOrdgroup) {
      return makeRow(buildExpression(expression, options, isOrdgroup));
    };
    /**
     * Takes a group from the parser and calls the appropriate groupBuilders function
     * on it to produce a MathML node.
     */

    var buildGroup = function buildGroup(group, options) {
      if (!group) {
        return new mathMLTree.MathNode("mrow");
      }

      if (_mathmlGroupBuilders[group.type]) {
        // Call the groupBuilders function
        // $FlowFixMe
        var result = _mathmlGroupBuilders[group.type](group, options); // $FlowFixMe

        return result;
      } else {
        throw new ParseError("Got group of unknown type: '" + group.type + "'");
      }
    };
    /**
     * Takes a full parse tree and settings and builds a MathML representation of
     * it. In particular, we put the elements from building the parse tree into a
     * <semantics> tag so we can also include that TeX source as an annotation.
     *
     * Note that we actually return a domTree element with a `<math>` inside it so
     * we can do appropriate styling.
     */

    function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
      var expression = buildExpression(tree, options); // TODO: Make a pass thru the MathML similar to buildHTML.traverseNonSpaceNodes
      // and add spacing nodes. This is necessary only adjacent to math operators
      // like \sin or \lim or to subsup elements that contain math operators.
      // MathML takes care of the other spacing issues.
      // Wrap up the expression in an mrow so it is presented in the semantics
      // tag correctly, unless it's a single <mrow> or <mtable>.

      var wrapper;

      if (expression.length === 1 && expression[0] instanceof MathNode && ["mrow", "mtable"].includes(expression[0].type)) {
        wrapper = expression[0];
      } else {
        wrapper = new mathMLTree.MathNode("mrow", expression);
      } // Build a TeX annotation of the source


      var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
      annotation.setAttribute("encoding", "application/x-tex");
      var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
      var math = new mathMLTree.MathNode("math", [semantics]);
      math.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");

      if (isDisplayMode) {
        math.setAttribute("display", "block");
      } // You can't style <math> nodes, so we wrap the node in a span.
      // NOTE: The span class is not typed to have <math> nodes as children, and
      // we don't want to make the children type more generic since the children
      // of span are expected to have more fields in `buildHtml` contexts.


      var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml"; // $FlowFixMe

      return buildCommon.makeSpan([wrapperClass], [math]);
    }

    var optionsFromSettings = function optionsFromSettings(settings) {
      return new Options({
        style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
        maxSize: settings.maxSize,
        minRuleThickness: settings.minRuleThickness
      });
    };

    var displayWrap = function displayWrap(node, settings) {
      if (settings.displayMode) {
        var classes = ["katex-display"];

        if (settings.leqno) {
          classes.push("leqno");
        }

        if (settings.fleqn) {
          classes.push("fleqn");
        }

        node = buildCommon.makeSpan(classes, [node]);
      }

      return node;
    };

    var buildTree = function buildTree(tree, expression, settings) {
      var options = optionsFromSettings(settings);
      var katexNode;

      if (settings.output === "mathml") {
        return buildMathML(tree, expression, options, settings.displayMode, true);
      } else if (settings.output === "html") {
        var htmlNode = buildHTML(tree, options);
        katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
      } else {
        var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);

        var _htmlNode = buildHTML(tree, options);

        katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
      }

      return displayWrap(katexNode, settings);
    };
    var buildHTMLTree = function buildHTMLTree(tree, expression, settings) {
      var options = optionsFromSettings(settings);
      var htmlNode = buildHTML(tree, options);
      var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
      return displayWrap(katexNode, settings);
    };

    /**
     * This file provides support to buildMathML.js and buildHTML.js
     * for stretchy wide elements rendered from SVG files
     * and other CSS trickery.
     */
    var stretchyCodePoint = {
      widehat: "^",
      widecheck: "",
      widetilde: "~",
      utilde: "~",
      overleftarrow: "\u2190",
      underleftarrow: "\u2190",
      xleftarrow: "\u2190",
      overrightarrow: "\u2192",
      underrightarrow: "\u2192",
      xrightarrow: "\u2192",
      underbrace: "\u23df",
      overbrace: "\u23de",
      overgroup: "\u23e0",
      undergroup: "\u23e1",
      overleftrightarrow: "\u2194",
      underleftrightarrow: "\u2194",
      xleftrightarrow: "\u2194",
      Overrightarrow: "\u21d2",
      xRightarrow: "\u21d2",
      overleftharpoon: "\u21bc",
      xleftharpoonup: "\u21bc",
      overrightharpoon: "\u21c0",
      xrightharpoonup: "\u21c0",
      xLeftarrow: "\u21d0",
      xLeftrightarrow: "\u21d4",
      xhookleftarrow: "\u21a9",
      xhookrightarrow: "\u21aa",
      xmapsto: "\u21a6",
      xrightharpoondown: "\u21c1",
      xleftharpoondown: "\u21bd",
      xrightleftharpoons: "\u21cc",
      xleftrightharpoons: "\u21cb",
      xtwoheadleftarrow: "\u219e",
      xtwoheadrightarrow: "\u21a0",
      xlongequal: "=",
      xtofrom: "\u21c4",
      xrightleftarrows: "\u21c4",
      xrightequilibrium: "\u21cc",
      // Not a perfect match.
      xleftequilibrium: "\u21cb",
      // None better available.
      "\\cdrightarrow": "\u2192",
      "\\cdleftarrow": "\u2190",
      "\\cdlongequal": "="
    };

    var mathMLnode = function mathMLnode(label) {
      var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, '')])]);
      node.setAttribute("stretchy", "true");
      return node;
    }; // Many of the KaTeX SVG images have been adapted from glyphs in KaTeX fonts.
    // Copyright (c) 2009-2010, Design Science, Inc. (<www.mathjax.org>)
    // Copyright (c) 2014-2017 Khan Academy (<www.khanacademy.org>)
    // Licensed under the SIL Open Font License, Version 1.1.
    // See \nhttp://scripts.sil.org/OFL
    // Very Long SVGs
    //    Many of the KaTeX stretchy wide elements use a long SVG image and an
    //    overflow: hidden tactic to achieve a stretchy image while avoiding
    //    distortion of arrowheads or brace corners.
    //    The SVG typically contains a very long (400 em) arrow.
    //    The SVG is in a container span that has overflow: hidden, so the span
    //    acts like a window that exposes only part of the  SVG.
    //    The SVG always has a longer, thinner aspect ratio than the container span.
    //    After the SVG fills 100% of the height of the container span,
    //    there is a long arrow shaft left over. That left-over shaft is not shown.
    //    Instead, it is sliced off because the span's CSS has overflow: hidden.
    //    Thus, the reader sees an arrow that matches the subject matter width
    //    without distortion.
    //    Some functions, such as \cancel, need to vary their aspect ratio. These
    //    functions do not get the overflow SVG treatment.
    // Second Brush Stroke
    //    Low resolution monitors struggle to display images in fine detail.
    //    So browsers apply anti-aliasing. A long straight arrow shaft therefore
    //    will sometimes appear as if it has a blurred edge.
    //    To mitigate this, these SVG files contain a second "brush-stroke" on the
    //    arrow shafts. That is, a second long thin rectangular SVG path has been
    //    written directly on top of each arrow shaft. This reinforcement causes
    //    some of the screen pixels to display as black instead of the anti-aliased
    //    gray pixel that a  single path would generate. So we get arrow shafts
    //    whose edges appear to be sharper.
    // In the katexImagesData object just below, the dimensions all
    // correspond to path geometry inside the relevant SVG.
    // For example, \overrightarrow uses the same arrowhead as glyph U+2192
    // from the KaTeX Main font. The scaling factor is 1000.
    // That is, inside the font, that arrowhead is 522 units tall, which
    // corresponds to 0.522 em inside the document.


    var katexImagesData = {
      //   path(s), minWidth, height, align
      overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
      overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
      underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
      underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
      xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
      "\\cdrightarrow": [["rightarrow"], 3.0, 522, "xMaxYMin"],
      // CD minwwidth2.5pc
      xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
      "\\cdleftarrow": [["leftarrow"], 3.0, 522, "xMinYMin"],
      Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
      xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
      xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
      overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
      xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
      xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
      overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
      xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
      xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
      xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
      "\\cdlongequal": [["longequal"], 3.0, 334, "xMinYMin"],
      xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
      xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
      overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
      overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
      underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
      underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
      xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
      xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
      xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
      xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
      xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
      xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
      overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
      underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
      overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
      undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
      xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
      xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
      // The next three arrows are from the mhchem package.
      // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
      // document as \xrightarrow or \xrightleftharpoons. Those have
      // min-length = 1.75em, so we set min-length on these next three to match.
      xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
      xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
      xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
    };

    var groupLength = function groupLength(arg) {
      if (arg.type === "ordgroup") {
        return arg.body.length;
      } else {
        return 1;
      }
    };

    var svgSpan = function svgSpan(group, options) {
      // Create a span with inline SVG for the element.
      function buildSvgSpan_() {
        var viewBoxWidth = 400000; // default

        var label = group.label.slice(1);

        if (["widehat", "widecheck", "widetilde", "utilde"].includes(label)) {
          // Each type in the `if` statement corresponds to one of the ParseNode
          // types below. This narrowing is required to access `grp.base`.
          // $FlowFixMe
          var grp = group; // There are four SVG images available for each function.
          // Choose a taller image when there are more characters.

          var numChars = groupLength(grp.base);
          var viewBoxHeight;
          var pathName;

          var _height;

          if (numChars > 5) {
            if (label === "widehat" || label === "widecheck") {
              viewBoxHeight = 420;
              viewBoxWidth = 2364;
              _height = 0.42;
              pathName = label + "4";
            } else {
              viewBoxHeight = 312;
              viewBoxWidth = 2340;
              _height = 0.34;
              pathName = "tilde4";
            }
          } else {
            var imgIndex = [1, 1, 2, 2, 3, 3][numChars];

            if (label === "widehat" || label === "widecheck") {
              viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
              viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
              _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
              pathName = label + imgIndex;
            } else {
              viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
              viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
              _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
              pathName = "tilde" + imgIndex;
            }
          }

          var path = new PathNode(pathName);
          var svgNode = new SvgNode([path], {
            "width": "100%",
            "height": makeEm(_height),
            "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
            "preserveAspectRatio": "none"
          });
          return {
            span: buildCommon.makeSvgSpan([], [svgNode], options),
            minWidth: 0,
            height: _height
          };
        } else {
          var spans = [];
          var data = katexImagesData[label];
          var [paths, _minWidth, _viewBoxHeight] = data;

          var _height2 = _viewBoxHeight / 1000;

          var numSvgChildren = paths.length;
          var widthClasses;
          var aligns;

          if (numSvgChildren === 1) {
            // $FlowFixMe: All these cases must be of the 4-tuple type.
            var align1 = data[3];
            widthClasses = ["hide-tail"];
            aligns = [align1];
          } else if (numSvgChildren === 2) {
            widthClasses = ["halfarrow-left", "halfarrow-right"];
            aligns = ["xMinYMin", "xMaxYMin"];
          } else if (numSvgChildren === 3) {
            widthClasses = ["brace-left", "brace-center", "brace-right"];
            aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
          } else {
            throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
          }

          for (var i = 0; i < numSvgChildren; i++) {
            var _path = new PathNode(paths[i]);

            var _svgNode = new SvgNode([_path], {
              "width": "400em",
              "height": makeEm(_height2),
              "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
              "preserveAspectRatio": aligns[i] + " slice"
            });

            var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);

            if (numSvgChildren === 1) {
              return {
                span: _span,
                minWidth: _minWidth,
                height: _height2
              };
            } else {
              _span.style.height = makeEm(_height2);
              spans.push(_span);
            }
          }

          return {
            span: buildCommon.makeSpan(["stretchy"], spans, options),
            minWidth: _minWidth,
            height: _height2
          };
        }
      } // buildSvgSpan_()


      var {
        span,
        minWidth,
        height
      } = buildSvgSpan_(); // Note that we are returning span.depth = 0.
      // Any adjustments relative to the baseline must be done in buildHTML.

      span.height = height;
      span.style.height = makeEm(height);

      if (minWidth > 0) {
        span.style.minWidth = makeEm(minWidth);
      }

      return span;
    };

    var encloseSpan = function encloseSpan(inner, label, topPad, bottomPad, options) {
      // Return an image span for \cancel, \bcancel, \xcancel, \fbox, or \angl
      var img;
      var totalHeight = inner.height + inner.depth + topPad + bottomPad;

      if (/fbox|color|angl/.test(label)) {
        img = buildCommon.makeSpan(["stretchy", label], [], options);

        if (label === "fbox") {
          var color = options.color && options.getColor();

          if (color) {
            img.style.borderColor = color;
          }
        }
      } else {
        // \cancel, \bcancel, or \xcancel
        // Since \cancel's SVG is inline and it omits the viewBox attribute,
        // its stroke-width will not vary with span area.
        var lines = [];

        if (/^[bx]cancel$/.test(label)) {
          lines.push(new LineNode({
            "x1": "0",
            "y1": "0",
            "x2": "100%",
            "y2": "100%",
            "stroke-width": "0.046em"
          }));
        }

        if (/^x?cancel$/.test(label)) {
          lines.push(new LineNode({
            "x1": "0",
            "y1": "100%",
            "x2": "100%",
            "y2": "0",
            "stroke-width": "0.046em"
          }));
        }

        var svgNode = new SvgNode(lines, {
          "width": "100%",
          "height": makeEm(totalHeight)
        });
        img = buildCommon.makeSvgSpan([], [svgNode], options);
      }

      img.height = totalHeight;
      img.style.height = makeEm(totalHeight);
      return img;
    };

    var stretchy = {
      encloseSpan,
      mathMLnode,
      svgSpan
    };

    /**
     * Asserts that the node is of the given type and returns it with stricter
     * typing. Throws if the node's type does not match.
     */
    function assertNodeType(node, type) {
      if (!node || node.type !== type) {
        throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
      } // $FlowFixMe, >=0.125


      return node;
    }
    /**
     * Returns the node more strictly typed iff it is of the given type. Otherwise,
     * returns null.
     */

    function assertSymbolNodeType(node) {
      var typedNode = checkSymbolNodeType(node);

      if (!typedNode) {
        throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
      }

      return typedNode;
    }
    /**
     * Returns the node more strictly typed iff it is of the given type. Otherwise,
     * returns null.
     */

    function checkSymbolNodeType(node) {
      if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
        // $FlowFixMe
        return node;
      }

      return null;
    }

    // NOTE: Unlike most `htmlBuilder`s, this one handles not only "accent", but
    // also "supsub" since an accent can affect super/subscripting.
    var htmlBuilder$a = (grp, options) => {
      // Accents are handled in the TeXbook pg. 443, rule 12.
      var base;
      var group;
      var supSubGroup;

      if (grp && grp.type === "supsub") {
        // If our base is a character box, and we have superscripts and
        // subscripts, the supsub will defer to us. In particular, we want
        // to attach the superscripts and subscripts to the inner body (so
        // that the position of the superscripts and subscripts won't be
        // affected by the height of the accent). We accomplish this by
        // sticking the base of the accent into the base of the supsub, and
        // rendering that, while keeping track of where the accent is.
        // The real accent group is the base of the supsub group
        group = assertNodeType(grp.base, "accent"); // The character box is the base of the accent group

        base = group.base; // Stick the character box into the base of the supsub group

        grp.base = base; // Rerender the supsub group with its new base, and store that
        // result.

        supSubGroup = assertSpan(buildGroup$1(grp, options)); // reset original base

        grp.base = group;
      } else {
        group = assertNodeType(grp, "accent");
        base = group.base;
      } // Build the base group


      var body = buildGroup$1(base, options.havingCrampedStyle()); // Does the accent need to shift for the skew of a character?

      var mustShift = group.isShifty && utils.isCharacterBox(base); // Calculate the skew of the accent. This is based on the line "If the
      // nucleus is not a single character, let s = 0; otherwise set s to the
      // kern amount for the nucleus followed by the \skewchar of its font."
      // Note that our skew metrics are just the kern between each character
      // and the skewchar.

      var skew = 0;

      if (mustShift) {
        // If the base is a character box, then we want the skew of the
        // innermost character. To do that, we find the innermost character:
        var baseChar = utils.getBaseElem(base); // Then, we render its group to get the symbol inside it

        var baseGroup = buildGroup$1(baseChar, options.havingCrampedStyle()); // Finally, we pull the skew off of the symbol.

        skew = assertSymbolDomNode(baseGroup).skew; // Note that we now throw away baseGroup, because the layers we
        // removed with getBaseElem might contain things like \color which
        // we can't get rid of.
        // TODO(emily): Find a better way to get the skew
      }

      var accentBelow = group.label === "\\c"; // calculate the amount of space between the body and the accent

      var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight); // Build the accent

      var accentBody;

      if (!group.isStretchy) {
        var accent;
        var width;

        if (group.label === "\\vec") {
          // Before version 0.9, \vec used the combining font glyph U+20D7.
          // But browsers, especially Safari, are not consistent in how they
          // render combining characters when not preceded by a character.
          // So now we use an SVG.
          // If Safari reforms, we should consider reverting to the glyph.
          accent = buildCommon.staticSvg("vec", options);
          width = buildCommon.svgData.vec[1];
        } else {
          accent = buildCommon.makeOrd({
            mode: group.mode,
            text: group.label
          }, options, "textord");
          accent = assertSymbolDomNode(accent); // Remove the italic correction of the accent, because it only serves to
          // shift the accent over to a place we don't want.

          accent.italic = 0;
          width = accent.width;

          if (accentBelow) {
            clearance += accent.depth;
          }
        }

        accentBody = buildCommon.makeSpan(["accent-body"], [accent]); // "Full" accents expand the width of the resulting symbol to be
        // at least the width of the accent, and overlap directly onto the
        // character without any vertical offset.

        var accentFull = group.label === "\\textcircled";

        if (accentFull) {
          accentBody.classes.push('accent-full');
          clearance = body.height;
        } // Shift the accent over by the skew.


        var left = skew; // CSS defines `.katex .accent .accent-body:not(.accent-full) { width: 0 }`
        // so that the accent doesn't contribute to the bounding box.
        // We need to shift the character by its width (effectively half
        // its width) to compensate.

        if (!accentFull) {
          left -= width / 2;
        }

        accentBody.style.left = makeEm(left); // \textcircled uses the \bigcirc glyph, so it needs some
        // vertical adjustment to match LaTeX.

        if (group.label === "\\textcircled") {
          accentBody.style.top = ".2em";
        }

        accentBody = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: body
          }, {
            type: "kern",
            size: -clearance
          }, {
            type: "elem",
            elem: accentBody
          }]
        }, options);
      } else {
        accentBody = stretchy.svgSpan(group, options);
        accentBody = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: body
          }, {
            type: "elem",
            elem: accentBody,
            wrapperClasses: ["svg-align"],
            wrapperStyle: skew > 0 ? {
              width: "calc(100% - " + makeEm(2 * skew) + ")",
              marginLeft: makeEm(2 * skew)
            } : undefined
          }]
        }, options);
      }

      var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);

      if (supSubGroup) {
        // Here, we replace the "base" child of the supsub with our newly
        // generated accent.
        supSubGroup.children[0] = accentWrap; // Since we don't rerun the height calculation after replacing the
        // accent, we manually recalculate height.

        supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height); // Accents should always be ords, even when their innards are not.

        supSubGroup.classes[0] = "mord";
        return supSubGroup;
      } else {
        return accentWrap;
      }
    };

    var mathmlBuilder$9 = (group, options) => {
      var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
      var node = new mathMLTree.MathNode("mover", [buildGroup(group.base, options), accentNode]);
      node.setAttribute("accent", "true");
      return node;
    };

    var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(accent => "\\" + accent).join("|")); // Accents

    defineFunction({
      type: "accent",
      names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
      props: {
        numArgs: 1
      },
      handler: (context, args) => {
        var base = normalizeArgument(args[0]);
        var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
        var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
        return {
          type: "accent",
          mode: context.parser.mode,
          label: context.funcName,
          isStretchy: isStretchy,
          isShifty: isShifty,
          base: base
        };
      },
      htmlBuilder: htmlBuilder$a,
      mathmlBuilder: mathmlBuilder$9
    }); // Text-mode accents

    defineFunction({
      type: "accent",
      names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
      props: {
        numArgs: 1,
        allowedInText: true,
        allowedInMath: true,
        // unless in strict mode
        argTypes: ["primitive"]
      },
      handler: (context, args) => {
        var base = args[0];
        var mode = context.parser.mode;

        if (mode === "math") {
          context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
          mode = "text";
        }

        return {
          type: "accent",
          mode: mode,
          label: context.funcName,
          isStretchy: false,
          isShifty: true,
          base: base
        };
      },
      htmlBuilder: htmlBuilder$a,
      mathmlBuilder: mathmlBuilder$9
    });

    // Horizontal overlap functions
    defineFunction({
      type: "accentUnder",
      names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
      props: {
        numArgs: 1
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName
        } = _ref;
        var base = args[0];
        return {
          type: "accentUnder",
          mode: parser.mode,
          label: funcName,
          base: base
        };
      },
      htmlBuilder: (group, options) => {
        // Treat under accents much like underlines.
        var innerGroup = buildGroup$1(group.base, options);
        var accentBody = stretchy.svgSpan(group, options);
        var kern = group.label === "\\utilde" ? 0.12 : 0; // Generate the vlist, with the appropriate kerns

        var vlist = buildCommon.makeVList({
          positionType: "top",
          positionData: innerGroup.height,
          children: [{
            type: "elem",
            elem: accentBody,
            wrapperClasses: ["svg-align"]
          }, {
            type: "kern",
            size: kern
          }, {
            type: "elem",
            elem: innerGroup
          }]
        }, options);
        return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
      },
      mathmlBuilder: (group, options) => {
        var accentNode = stretchy.mathMLnode(group.label);
        var node = new mathMLTree.MathNode("munder", [buildGroup(group.base, options), accentNode]);
        node.setAttribute("accentunder", "true");
        return node;
      }
    });

    // Helper function
    var paddedNode = group => {
      var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
      node.setAttribute("width", "+0.6em");
      node.setAttribute("lspace", "0.3em");
      return node;
    }; // Stretchy arrows with an optional argument


    defineFunction({
      type: "xArrow",
      names: ["\\xleftarrow", "\\xrightarrow", "\\xLeftarrow", "\\xRightarrow", "\\xleftrightarrow", "\\xLeftrightarrow", "\\xhookleftarrow", "\\xhookrightarrow", "\\xmapsto", "\\xrightharpoondown", "\\xrightharpoonup", "\\xleftharpoondown", "\\xleftharpoonup", "\\xrightleftharpoons", "\\xleftrightharpoons", "\\xlongequal", "\\xtwoheadrightarrow", "\\xtwoheadleftarrow", "\\xtofrom", // The next 3 functions are here to support the mhchem extension.
      // Direct use of these functions is discouraged and may break someday.
      "\\xrightleftarrows", "\\xrightequilibrium", "\\xleftequilibrium", // The next 3 functions are here only to support the {CD} environment.
      "\\\\cdrightarrow", "\\\\cdleftarrow", "\\\\cdlongequal"],
      props: {
        numArgs: 1,
        numOptionalArgs: 1
      },

      handler(_ref, args, optArgs) {
        var {
          parser,
          funcName
        } = _ref;
        return {
          type: "xArrow",
          mode: parser.mode,
          label: funcName,
          body: args[0],
          below: optArgs[0]
        };
      },

      // Flow is unable to correctly infer the type of `group`, even though it's
      // unambiguously determined from the passed-in `type` above.
      htmlBuilder(group, options) {
        var style = options.style; // Build the argument groups in the appropriate style.
        // Ref: amsmath.dtx:   \hbox{$\scriptstyle\mkern#3mu{#6}\mkern#4mu$}%
        // Some groups can return document fragments.  Handle those by wrapping
        // them in a span.

        var newOptions = options.havingStyle(style.sup());
        var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options), options);
        var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
        upperGroup.classes.push(arrowPrefix + "-arrow-pad");
        var lowerGroup;

        if (group.below) {
          // Build the lower group
          newOptions = options.havingStyle(style.sub());
          lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options), options);
          lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
        }

        var arrowBody = stretchy.svgSpan(group, options); // Re shift: Note that stretchy.svgSpan returned arrowBody.depth = 0.
        // The point we want on the math axis is at 0.5 * arrowBody.height.

        var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height; // 2 mu kern. Ref: amsmath.dtx: #7\if0#2\else\mkern#2mu\fi

        var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111; // 0.111 em = 2 mu

        if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
          upperShift -= upperGroup.depth; // shift up if depth encroaches
        } // Generate the vlist


        var vlist;

        if (lowerGroup) {
          var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: upperGroup,
              shift: upperShift
            }, {
              type: "elem",
              elem: arrowBody,
              shift: arrowShift
            }, {
              type: "elem",
              elem: lowerGroup,
              shift: lowerShift
            }]
          }, options);
        } else {
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: upperGroup,
              shift: upperShift
            }, {
              type: "elem",
              elem: arrowBody,
              shift: arrowShift
            }]
          }, options);
        } // $FlowFixMe: Replace this with passing "svg-align" into makeVList.


        vlist.children[0].children[0].children[1].classes.push("svg-align");
        return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
      },

      mathmlBuilder(group, options) {
        var arrowNode = stretchy.mathMLnode(group.label);
        arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
        var node;

        if (group.body) {
          var upperNode = paddedNode(buildGroup(group.body, options));

          if (group.below) {
            var lowerNode = paddedNode(buildGroup(group.below, options));
            node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
          } else {
            node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
          }
        } else if (group.below) {
          var _lowerNode = paddedNode(buildGroup(group.below, options));

          node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
        } else {
          // This should never happen.
          // Parser.js throws an error if there is no argument.
          node = paddedNode();
          node = new mathMLTree.MathNode("mover", [arrowNode, node]);
        }

        return node;
      }

    });

    var makeSpan = buildCommon.makeSpan;

    function htmlBuilder$9(group, options) {
      var elements = buildExpression$1(group.body, options, true);
      return makeSpan([group.mclass], elements, options);
    }

    function mathmlBuilder$8(group, options) {
      var node;
      var inner = buildExpression(group.body, options);

      if (group.mclass === "minner") {
        node = new mathMLTree.MathNode("mpadded", inner);
      } else if (group.mclass === "mord") {
        if (group.isCharacterBox) {
          node = inner[0];
          node.type = "mi";
        } else {
          node = new mathMLTree.MathNode("mi", inner);
        }
      } else {
        if (group.isCharacterBox) {
          node = inner[0];
          node.type = "mo";
        } else {
          node = new mathMLTree.MathNode("mo", inner);
        } // Set spacing based on what is the most likely adjacent atom type.
        // See TeXbook p170.


        if (group.mclass === "mbin") {
          node.attributes.lspace = "0.22em"; // medium space

          node.attributes.rspace = "0.22em";
        } else if (group.mclass === "mpunct") {
          node.attributes.lspace = "0em";
          node.attributes.rspace = "0.17em"; // thinspace
        } else if (group.mclass === "mopen" || group.mclass === "mclose") {
          node.attributes.lspace = "0em";
          node.attributes.rspace = "0em";
        } else if (group.mclass === "minner") {
          node.attributes.lspace = "0.0556em"; // 1 mu is the most likely option

          node.attributes.width = "+0.1111em";
        } // MathML <mo> default space is 5/18 em, so <mrel> needs no action.
        // Ref: https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo

      }

      return node;
    } // Math class commands except \mathop


    defineFunction({
      type: "mclass",
      names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
      props: {
        numArgs: 1,
        primitive: true
      },

      handler(_ref, args) {
        var {
          parser,
          funcName
        } = _ref;
        var body = args[0];
        return {
          type: "mclass",
          mode: parser.mode,
          mclass: "m" + funcName.slice(5),
          // TODO(kevinb): don't prefix with 'm'
          body: ordargument(body),
          isCharacterBox: utils.isCharacterBox(body)
        };
      },

      htmlBuilder: htmlBuilder$9,
      mathmlBuilder: mathmlBuilder$8
    });
    var binrelClass = arg => {
      // \binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.
      // (by rendering separately and with {}s before and after, and measuring
      // the change in spacing).  We'll do roughly the same by detecting the
      // atom type directly.
      var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;

      if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
        return "m" + atom.family;
      } else {
        return "mord";
      }
    }; // \@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.
    // This is equivalent to \binrel@{x}\binrel@@{y} in AMSTeX.

    defineFunction({
      type: "mclass",
      names: ["\\@binrel"],
      props: {
        numArgs: 2
      },

      handler(_ref2, args) {
        var {
          parser
        } = _ref2;
        return {
          type: "mclass",
          mode: parser.mode,
          mclass: binrelClass(args[0]),
          body: ordargument(args[1]),
          isCharacterBox: utils.isCharacterBox(args[1])
        };
      }

    }); // Build a relation or stacked op by placing one symbol on top of another

    defineFunction({
      type: "mclass",
      names: ["\\stackrel", "\\overset", "\\underset"],
      props: {
        numArgs: 2
      },

      handler(_ref3, args) {
        var {
          parser,
          funcName
        } = _ref3;
        var baseArg = args[1];
        var shiftedArg = args[0];
        var mclass;

        if (funcName !== "\\stackrel") {
          // LaTeX applies \binrel spacing to \overset and \underset.
          mclass = binrelClass(baseArg);
        } else {
          mclass = "mrel"; // for \stackrel
        }

        var baseOp = {
          type: "op",
          mode: baseArg.mode,
          limits: true,
          alwaysHandleSupSub: true,
          parentIsSupSub: false,
          symbol: false,
          suppressBaseShift: funcName !== "\\stackrel",
          body: ordargument(baseArg)
        };
        var supsub = {
          type: "supsub",
          mode: shiftedArg.mode,
          base: baseOp,
          sup: funcName === "\\underset" ? null : shiftedArg,
          sub: funcName === "\\underset" ? shiftedArg : null
        };
        return {
          type: "mclass",
          mode: parser.mode,
          mclass,
          body: [supsub],
          isCharacterBox: utils.isCharacterBox(supsub)
        };
      },

      htmlBuilder: htmlBuilder$9,
      mathmlBuilder: mathmlBuilder$8
    });

    // \pmb is a simulation of bold font.
    // The version of \pmb in ambsy.sty works by typesetting three copies
    // with small offsets. We use CSS text-shadow.
    // It's a hack. Not as good as a real bold font. Better than nothing.
    defineFunction({
      type: "pmb",
      names: ["\\pmb"],
      props: {
        numArgs: 1,
        allowedInText: true
      },

      handler(_ref, args) {
        var {
          parser
        } = _ref;
        return {
          type: "pmb",
          mode: parser.mode,
          mclass: binrelClass(args[0]),
          body: ordargument(args[0])
        };
      },

      htmlBuilder(group, options) {
        var elements = buildExpression$1(group.body, options, true);
        var node = buildCommon.makeSpan([group.mclass], elements, options);
        node.style.textShadow = "0.02em 0.01em 0.04px";
        return node;
      },

      mathmlBuilder(group, style) {
        var inner = buildExpression(group.body, style); // Wrap with an <mstyle> element.

        var node = new mathMLTree.MathNode("mstyle", inner);
        node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
        return node;
      }

    });

    var cdArrowFunctionName = {
      ">": "\\\\cdrightarrow",
      "<": "\\\\cdleftarrow",
      "=": "\\\\cdlongequal",
      "A": "\\uparrow",
      "V": "\\downarrow",
      "|": "\\Vert",
      ".": "no arrow"
    };

    var newCell = () => {
      // Create an empty cell, to be filled below with parse nodes.
      // The parseTree from this module must be constructed like the
      // one created by parseArray(), so an empty CD cell must
      // be a ParseNode<"styling">. And CD is always displaystyle.
      // So these values are fixed and flow can do implicit typing.
      return {
        type: "styling",
        body: [],
        mode: "math",
        style: "display"
      };
    };

    var isStartOfArrow = node => {
      return node.type === "textord" && node.text === "@";
    };

    var isLabelEnd = (node, endChar) => {
      return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
    };

    function cdArrow(arrowChar, labels, parser) {
      // Return a parse tree of an arrow and its labels.
      // This acts in a way similar to a macro expansion.
      var funcName = cdArrowFunctionName[arrowChar];

      switch (funcName) {
        case "\\\\cdrightarrow":
        case "\\\\cdleftarrow":
          return parser.callFunction(funcName, [labels[0]], [labels[1]]);

        case "\\uparrow":
        case "\\downarrow":
          {
            var leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
            var bareArrow = {
              type: "atom",
              text: funcName,
              mode: "math",
              family: "rel"
            };
            var sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
            var rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
            var arrowGroup = {
              type: "ordgroup",
              mode: "math",
              body: [leftLabel, sizedArrow, rightLabel]
            };
            return parser.callFunction("\\\\cdparent", [arrowGroup], []);
          }

        case "\\\\cdlongequal":
          return parser.callFunction("\\\\cdlongequal", [], []);

        case "\\Vert":
          {
            var arrow = {
              type: "textord",
              text: "\\Vert",
              mode: "math"
            };
            return parser.callFunction("\\Big", [arrow], []);
          }

        default:
          return {
            type: "textord",
            text: " ",
            mode: "math"
          };
      }
    }

    function parseCD(parser) {
      // Get the array's parse nodes with \\ temporarily mapped to \cr.
      var parsedRows = [];
      parser.gullet.beginGroup();
      parser.gullet.macros.set("\\cr", "\\\\\\relax");
      parser.gullet.beginGroup();

      while (true) {
        // eslint-disable-line no-constant-condition
        // Get the parse nodes for the next row.
        parsedRows.push(parser.parseExpression(false, "\\\\"));
        parser.gullet.endGroup();
        parser.gullet.beginGroup();
        var next = parser.fetch().text;

        if (next === "&" || next === "\\\\") {
          parser.consume();
        } else if (next === "\\end") {
          if (parsedRows[parsedRows.length - 1].length === 0) {
            parsedRows.pop(); // final row ended in \\
          }

          break;
        } else {
          throw new ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
        }
      }

      var row = [];
      var body = [row]; // Loop thru the parse nodes. Collect them into cells and arrows.

      for (var i = 0; i < parsedRows.length; i++) {
        // Start a new row.
        var rowNodes = parsedRows[i]; // Create the first cell.

        var cell = newCell();

        for (var j = 0; j < rowNodes.length; j++) {
          if (!isStartOfArrow(rowNodes[j])) {
            // If a parseNode is not an arrow, it goes into a cell.
            cell.body.push(rowNodes[j]);
          } else {
            // Parse node j is an "@", the start of an arrow.
            // Before starting on the arrow, push the cell into `row`.
            row.push(cell); // Now collect parseNodes into an arrow.
            // The character after "@" defines the arrow type.

            j += 1;
            var arrowChar = assertSymbolNodeType(rowNodes[j]).text; // Create two empty label nodes. We may or may not use them.

            var labels = new Array(2);
            labels[0] = {
              type: "ordgroup",
              mode: "math",
              body: []
            };
            labels[1] = {
              type: "ordgroup",
              mode: "math",
              body: []
            }; // Process the arrow.

            if ("=|.".indexOf(arrowChar) > -1) ; else if ("<>AV".indexOf(arrowChar) > -1) {
              // Four arrows, `@>>>`, `@<<<`, `@AAA`, and `@VVV`, each take
              // two optional labels. E.g. the right-point arrow syntax is
              // really:  @>{optional label}>{optional label}>
              // Collect parseNodes into labels.
              for (var labelNum = 0; labelNum < 2; labelNum++) {
                var inLabel = true;

                for (var k = j + 1; k < rowNodes.length; k++) {
                  if (isLabelEnd(rowNodes[k], arrowChar)) {
                    inLabel = false;
                    j = k;
                    break;
                  }

                  if (isStartOfArrow(rowNodes[k])) {
                    throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
                  }

                  labels[labelNum].body.push(rowNodes[k]);
                }

                if (inLabel) {
                  // isLabelEnd never returned a true.
                  throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
                }
              }
            } else {
              throw new ParseError("Expected one of \"<>AV=|.\" after @", rowNodes[j]);
            } // Now join the arrow to its labels.


            var arrow = cdArrow(arrowChar, labels, parser); // Wrap the arrow in  ParseNode<"styling">.
            // This is done to match parseArray() behavior.

            var wrappedArrow = {
              type: "styling",
              body: [arrow],
              mode: "math",
              style: "display" // CD is always displaystyle.

            };
            row.push(wrappedArrow); // In CD's syntax, cells are implicit. That is, everything that
            // is not an arrow gets collected into a cell. So create an empty
            // cell now. It will collect upcoming parseNodes.

            cell = newCell();
          }
        }

        if (i % 2 === 0) {
          // Even-numbered rows consist of: cell, arrow, cell, arrow, ... cell
          // The last cell is not yet pushed into `row`, so:
          row.push(cell);
        } else {
          // Odd-numbered rows consist of: vert arrow, empty cell, ... vert arrow
          // Remove the empty cell that was placed at the beginning of `row`.
          row.shift();
        }

        row = [];
        body.push(row);
      } // End row group


      parser.gullet.endGroup(); // End array group defining \\

      parser.gullet.endGroup(); // define column separation.

      var cols = new Array(body[0].length).fill({
        type: "align",
        align: "c",
        pregap: 0.25,
        // CD package sets \enskip between columns.
        postgap: 0.25 // So pre and post each get half an \enskip, i.e. 0.25em.

      });
      return {
        type: "array",
        mode: "math",
        body,
        arraystretch: 1,
        addJot: true,
        rowGaps: [null],
        cols,
        colSeparationType: "CD",
        hLinesBeforeRow: new Array(body.length + 1).fill([])
      };
    } // The functions below are not available for general use.
    // They are here only for internal use by the {CD} environment in placing labels
    // next to vertical arrows.
    // We don't need any such functions for horizontal arrows because we can reuse
    // the functionality that already exists for extensible arrows.

    defineFunction({
      type: "cdlabel",
      names: ["\\\\cdleft", "\\\\cdright"],
      props: {
        numArgs: 1
      },

      handler(_ref, args) {
        var {
          parser,
          funcName
        } = _ref;
        return {
          type: "cdlabel",
          mode: parser.mode,
          side: funcName.slice(4),
          label: args[0]
        };
      },

      htmlBuilder(group, options) {
        var newOptions = options.havingStyle(options.style.sup());
        var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options), options);
        label.classes.push("cd-label-" + group.side);
        label.style.bottom = makeEm(0.8 - label.depth); // Zero out label height & depth, so vertical align of arrow is set
        // by the arrow height, not by the label.

        label.height = 0;
        label.depth = 0;
        return label;
      },

      mathmlBuilder(group, options) {
        var label = new mathMLTree.MathNode("mrow", [buildGroup(group.label, options)]);
        label = new mathMLTree.MathNode("mpadded", [label]);
        label.setAttribute("width", "0");

        if (group.side === "left") {
          label.setAttribute("lspace", "-1width");
        } // We have to guess at vertical alignment. We know the arrow is 1.8em tall,
        // But we don't know the height or depth of the label.


        label.setAttribute("voffset", "0.7em");
        label = new mathMLTree.MathNode("mstyle", [label]);
        label.setAttribute("displaystyle", "false");
        label.setAttribute("scriptlevel", "1");
        return label;
      }

    });
    defineFunction({
      type: "cdlabelparent",
      names: ["\\\\cdparent"],
      props: {
        numArgs: 1
      },

      handler(_ref2, args) {
        var {
          parser
        } = _ref2;
        return {
          type: "cdlabelparent",
          mode: parser.mode,
          fragment: args[0]
        };
      },

      htmlBuilder(group, options) {
        // Wrap the vertical arrow and its labels.
        // The parent gets position: relative. The child gets position: absolute.
        // So CSS can locate the label correctly.
        var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options), options);
        parent.classes.push("cd-vert-arrow");
        return parent;
      },

      mathmlBuilder(group, options) {
        return new mathMLTree.MathNode("mrow", [buildGroup(group.fragment, options)]);
      }

    });

    // {123} and converts into symbol with code 123.  It is used by the *macro*
    // \char defined in macros.js.

    defineFunction({
      type: "textord",
      names: ["\\@char"],
      props: {
        numArgs: 1,
        allowedInText: true
      },

      handler(_ref, args) {
        var {
          parser
        } = _ref;
        var arg = assertNodeType(args[0], "ordgroup");
        var group = arg.body;
        var number = "";

        for (var i = 0; i < group.length; i++) {
          var node = assertNodeType(group[i], "textord");
          number += node.text;
        }

        var code = parseInt(number);
        var text;

        if (isNaN(code)) {
          throw new ParseError("\\@char has non-numeric argument " + number); // If we drop IE support, the following code could be replaced with
          // text = String.fromCodePoint(code)
        } else if (code < 0 || code >= 0x10ffff) {
          throw new ParseError("\\@char with invalid code point " + number);
        } else if (code <= 0xffff) {
          text = String.fromCharCode(code);
        } else {
          // Astral code point; split into surrogate halves
          code -= 0x10000;
          text = String.fromCharCode((code >> 10) + 0xd800, (code & 0x3ff) + 0xdc00);
        }

        return {
          type: "textord",
          mode: parser.mode,
          text: text
        };
      }

    });

    var htmlBuilder$8 = (group, options) => {
      var elements = buildExpression$1(group.body, options.withColor(group.color), false); // \color isn't supposed to affect the type of the elements it contains.
      // To accomplish this, we wrap the results in a fragment, so the inner
      // elements will be able to directly interact with their neighbors. For
      // example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`

      return buildCommon.makeFragment(elements);
    };

    var mathmlBuilder$7 = (group, options) => {
      var inner = buildExpression(group.body, options.withColor(group.color));
      var node = new mathMLTree.MathNode("mstyle", inner);
      node.setAttribute("mathcolor", group.color);
      return node;
    };

    defineFunction({
      type: "color",
      names: ["\\textcolor"],
      props: {
        numArgs: 2,
        allowedInText: true,
        argTypes: ["color", "original"]
      },

      handler(_ref, args) {
        var {
          parser
        } = _ref;
        var color = assertNodeType(args[0], "color-token").color;
        var body = args[1];
        return {
          type: "color",
          mode: parser.mode,
          color,
          body: ordargument(body)
        };
      },

      htmlBuilder: htmlBuilder$8,
      mathmlBuilder: mathmlBuilder$7
    });
    defineFunction({
      type: "color",
      names: ["\\color"],
      props: {
        numArgs: 1,
        allowedInText: true,
        argTypes: ["color"]
      },

      handler(_ref2, args) {
        var {
          parser,
          breakOnTokenText
        } = _ref2;
        var color = assertNodeType(args[0], "color-token").color; // Set macro \current@color in current namespace to store the current
        // color, mimicking the behavior of color.sty.
        // This is currently used just to correctly color a \right
        // that follows a \color command.

        parser.gullet.macros.set("\\current@color", color); // Parse out the implicit body that should be colored.

        var body = parser.parseExpression(true, breakOnTokenText);
        return {
          type: "color",
          mode: parser.mode,
          color,
          body
        };
      },

      htmlBuilder: htmlBuilder$8,
      mathmlBuilder: mathmlBuilder$7
    });

    // Row breaks within tabular environments, and line breaks at top level

    defineFunction({
      type: "cr",
      names: ["\\\\"],
      props: {
        numArgs: 0,
        numOptionalArgs: 0,
        allowedInText: true
      },

      handler(_ref, args, optArgs) {
        var {
          parser
        } = _ref;
        var size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
        var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline " + "does nothing in display mode");
        return {
          type: "cr",
          mode: parser.mode,
          newLine,
          size: size && assertNodeType(size, "size").value
        };
      },

      // The following builders are called only at the top level,
      // not within tabular/array environments.
      htmlBuilder(group, options) {
        var span = buildCommon.makeSpan(["mspace"], [], options);

        if (group.newLine) {
          span.classes.push("newline");

          if (group.size) {
            span.style.marginTop = makeEm(calculateSize(group.size, options));
          }
        }

        return span;
      },

      mathmlBuilder(group, options) {
        var node = new mathMLTree.MathNode("mspace");

        if (group.newLine) {
          node.setAttribute("linebreak", "newline");

          if (group.size) {
            node.setAttribute("height", makeEm(calculateSize(group.size, options)));
          }
        }

        return node;
      }

    });

    var globalMap = {
      "\\global": "\\global",
      "\\long": "\\\\globallong",
      "\\\\globallong": "\\\\globallong",
      "\\def": "\\gdef",
      "\\gdef": "\\gdef",
      "\\edef": "\\xdef",
      "\\xdef": "\\xdef",
      "\\let": "\\\\globallet",
      "\\futurelet": "\\\\globalfuture"
    };

    var checkControlSequence = tok => {
      var name = tok.text;

      if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
        throw new ParseError("Expected a control sequence", tok);
      }

      return name;
    };

    var getRHS = parser => {
      var tok = parser.gullet.popToken();

      if (tok.text === "=") {
        // consume optional equals
        tok = parser.gullet.popToken();

        if (tok.text === " ") {
          // consume one optional space
          tok = parser.gullet.popToken();
        }
      }

      return tok;
    };

    var letCommand = (parser, name, tok, global) => {
      var macro = parser.gullet.macros.get(tok.text);

      if (macro == null) {
        // don't expand it later even if a macro with the same name is defined
        // e.g., \let\foo=\frac \def\frac{\relax} \frac12
        tok.noexpand = true;
        macro = {
          tokens: [tok],
          numArgs: 0,
          // reproduce the same behavior in expansion
          unexpandable: !parser.gullet.isExpandable(tok.text)
        };
      }

      parser.gullet.macros.set(name, macro, global);
    }; // <assignment> -> <non-macro assignment>|<macro assignment>
    // <non-macro assignment> -> <simple assignment>|\global<non-macro assignment>
    // <macro assignment> -> <definition>|<prefix><macro assignment>
    // <prefix> -> \global|\long|\outer


    defineFunction({
      type: "internal",
      names: ["\\global", "\\long", "\\\\globallong" // cant be entered directly
      ],
      props: {
        numArgs: 0,
        allowedInText: true
      },

      handler(_ref) {
        var {
          parser,
          funcName
        } = _ref;
        parser.consumeSpaces();
        var token = parser.fetch();

        if (globalMap[token.text]) {
          // KaTeX doesn't have \par, so ignore \long
          if (funcName === "\\global" || funcName === "\\\\globallong") {
            token.text = globalMap[token.text];
          }

          return assertNodeType(parser.parseFunction(), "internal");
        }

        throw new ParseError("Invalid token after macro prefix", token);
      }

    }); // Basic support for macro definitions: \def, \gdef, \edef, \xdef
    // <definition> -> <def><control sequence><definition text>
    // <def> -> \def|\gdef|\edef|\xdef
    // <definition text> -> <parameter text><left brace><balanced text><right brace>

    defineFunction({
      type: "internal",
      names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
      props: {
        numArgs: 0,
        allowedInText: true,
        primitive: true
      },

      handler(_ref2) {
        var {
          parser,
          funcName
        } = _ref2;
        var tok = parser.gullet.popToken();
        var name = tok.text;

        if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
          throw new ParseError("Expected a control sequence", tok);
        }

        var numArgs = 0;
        var insert;
        var delimiters = [[]]; // <parameter text> contains no braces

        while (parser.gullet.future().text !== "{") {
          tok = parser.gullet.popToken();

          if (tok.text === "#") {
            // If the very last character of the <parameter text> is #, so that
            // this # is immediately followed by {, TeX will behave as if the {
            // had been inserted at the right end of both the parameter text
            // and the replacement text.
            if (parser.gullet.future().text === "{") {
              insert = parser.gullet.future();
              delimiters[numArgs].push("{");
              break;
            } // A parameter, the first appearance of # must be followed by 1,
            // the next by 2, and so on; up to nine #s are allowed


            tok = parser.gullet.popToken();

            if (!/^[1-9]$/.test(tok.text)) {
              throw new ParseError("Invalid argument number \"" + tok.text + "\"");
            }

            if (parseInt(tok.text) !== numArgs + 1) {
              throw new ParseError("Argument number \"" + tok.text + "\" out of order");
            }

            numArgs++;
            delimiters.push([]);
          } else if (tok.text === "EOF") {
            throw new ParseError("Expected a macro definition");
          } else {
            delimiters[numArgs].push(tok.text);
          }
        } // replacement text, enclosed in '{' and '}' and properly nested


        var {
          tokens
        } = parser.gullet.consumeArg();

        if (insert) {
          tokens.unshift(insert);
        }

        if (funcName === "\\edef" || funcName === "\\xdef") {
          tokens = parser.gullet.expandTokens(tokens);
          tokens.reverse(); // to fit in with stack order
        } // Final arg is the expansion of the macro


        parser.gullet.macros.set(name, {
          tokens,
          numArgs,
          delimiters
        }, funcName === globalMap[funcName]);
        return {
          type: "internal",
          mode: parser.mode
        };
      }

    }); // <simple assignment> -> <let assignment>
    // <let assignment> -> \futurelet<control sequence><token><token>
    //     | \let<control sequence><equals><one optional space><token>
    // <equals> -> <optional spaces>|<optional spaces>=

    defineFunction({
      type: "internal",
      names: ["\\let", "\\\\globallet" // cant be entered directly
      ],
      props: {
        numArgs: 0,
        allowedInText: true,
        primitive: true
      },

      handler(_ref3) {
        var {
          parser,
          funcName
        } = _ref3;
        var name = checkControlSequence(parser.gullet.popToken());
        parser.gullet.consumeSpaces();
        var tok = getRHS(parser);
        letCommand(parser, name, tok, funcName === "\\\\globallet");
        return {
          type: "internal",
          mode: parser.mode
        };
      }

    }); // ref: https://www.tug.org/TUGboat/tb09-3/tb22bechtolsheim.pdf

    defineFunction({
      type: "internal",
      names: ["\\futurelet", "\\\\globalfuture" // cant be entered directly
      ],
      props: {
        numArgs: 0,
        allowedInText: true,
        primitive: true
      },

      handler(_ref4) {
        var {
          parser,
          funcName
        } = _ref4;
        var name = checkControlSequence(parser.gullet.popToken());
        var middle = parser.gullet.popToken();
        var tok = parser.gullet.popToken();
        letCommand(parser, name, tok, funcName === "\\\\globalfuture");
        parser.gullet.pushToken(tok);
        parser.gullet.pushToken(middle);
        return {
          type: "internal",
          mode: parser.mode
        };
      }

    });

    /**
     * This file deals with creating delimiters of various sizes. The TeXbook
     * discusses these routines on page 441-442, in the "Another subroutine sets box
     * x to a specified variable delimiter" paragraph.
     *
     * There are three main routines here. `makeSmallDelim` makes a delimiter in the
     * normal font, but in either text, script, or scriptscript style.
     * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
     * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
     * smaller pieces that are stacked on top of one another.
     *
     * The functions take a parameter `center`, which determines if the delimiter
     * should be centered around the axis.
     *
     * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
     * one of the given sizes. This is used for things like `\bigl`.
     * `customSizedDelim` makes a delimiter with a given total height+depth. It is
     * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
     * delimiter which surrounds an expression of a given height an depth. It is
     * used in `\left` and `\right`.
     */

    /**
     * Get the metrics for a given symbol and font, after transformation (i.e.
     * after following replacement from symbols.js)
     */
    var getMetrics = function getMetrics(symbol, font, mode) {
      var replace = symbols.math[symbol] && symbols.math[symbol].replace;
      var metrics = getCharacterMetrics(replace || symbol, font, mode);

      if (!metrics) {
        throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
      }

      return metrics;
    };
    /**
     * Puts a delimiter span in a given style, and adds appropriate height, depth,
     * and maxFontSizes.
     */


    var styleWrap = function styleWrap(delim, toStyle, options, classes) {
      var newOptions = options.havingBaseStyle(toStyle);
      var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
      var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
      span.height *= delimSizeMultiplier;
      span.depth *= delimSizeMultiplier;
      span.maxFontSize = newOptions.sizeMultiplier;
      return span;
    };

    var centerSpan = function centerSpan(span, options, style) {
      var newOptions = options.havingBaseStyle(style);
      var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
      span.classes.push("delimcenter");
      span.style.top = makeEm(shift);
      span.height -= shift;
      span.depth += shift;
    };
    /**
     * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
     * font, but is restyled to either be in textstyle, scriptstyle, or
     * scriptscriptstyle.
     */


    var makeSmallDelim = function makeSmallDelim(delim, style, center, options, mode, classes) {
      var text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
      var span = styleWrap(text, style, options, classes);

      if (center) {
        centerSpan(span, options, style);
      }

      return span;
    };
    /**
     * Builds a symbol in the given font size (note size is an integer)
     */


    var mathrmSize = function mathrmSize(value, size, mode, options) {
      return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
    };
    /**
     * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
     * Size3, or Size4 fonts. It is always rendered in textstyle.
     */


    var makeLargeDelim = function makeLargeDelim(delim, size, center, options, mode, classes) {
      var inner = mathrmSize(delim, size, mode, options);
      var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner], options), Style$1.TEXT, options, classes);

      if (center) {
        centerSpan(span, options, Style$1.TEXT);
      }

      return span;
    };
    /**
     * Make a span from a font glyph with the given offset and in the given font.
     * This is used in makeStackedDelim to make the stacking pieces for the delimiter.
     */


    var makeGlyphSpan = function makeGlyphSpan(symbol, font, mode) {
      var sizeClass; // Apply the correct CSS class to choose the right font.

      if (font === "Size1-Regular") {
        sizeClass = "delim-size1";
      } else
        /* if (font === "Size4-Regular") */
        {
          sizeClass = "delim-size4";
        }

      var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]); // Since this will be passed into `makeVList` in the end, wrap the element
      // in the appropriate tag that VList uses.

      return {
        type: "elem",
        elem: corner
      };
    };

    var makeInner = function makeInner(ch, height, options) {
      // Create a span with inline SVG for the inner part of a tall stacked delimiter.
      var width = fontMetricsData['Size4-Regular'][ch.charCodeAt(0)] ? fontMetricsData['Size4-Regular'][ch.charCodeAt(0)][4] : fontMetricsData['Size1-Regular'][ch.charCodeAt(0)][4];
      var path = new PathNode("inner", innerPath(ch, Math.round(1000 * height)));
      var svgNode = new SvgNode([path], {
        "width": makeEm(width),
        "height": makeEm(height),
        // Override CSS rule `.katex svg { width: 100% }`
        "style": "width:" + makeEm(width),
        "viewBox": "0 0 " + 1000 * width + " " + Math.round(1000 * height),
        "preserveAspectRatio": "xMinYMin"
      });
      var span = buildCommon.makeSvgSpan([], [svgNode], options);
      span.height = height;
      span.style.height = makeEm(height);
      span.style.width = makeEm(width);
      return {
        type: "elem",
        elem: span
      };
    }; // Helpers for makeStackedDelim


    var lapInEms = 0.008;
    var lap = {
      type: "kern",
      size: -1 * lapInEms
    };
    var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
    var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
    /**
     * Make a stacked delimiter out of a given delimiter, with the total height at
     * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
     */

    var makeStackedDelim = function makeStackedDelim(delim, heightTotal, center, options, mode, classes) {
      // There are four parts, the top, an optional middle, a repeated part, and a
      // bottom.
      var top;
      var middle;
      var repeat;
      var bottom;
      var svgLabel = "";
      var viewBoxWidth = 0;
      top = repeat = bottom = delim;
      middle = null; // Also keep track of what font the delimiters are in

      var font = "Size1-Regular"; // We set the parts and font based on the symbol. Note that we use
      // '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
      // repeats of the arrows

      if (delim === "\\uparrow") {
        repeat = bottom = "\u23d0";
      } else if (delim === "\\Uparrow") {
        repeat = bottom = "\u2016";
      } else if (delim === "\\downarrow") {
        top = repeat = "\u23d0";
      } else if (delim === "\\Downarrow") {
        top = repeat = "\u2016";
      } else if (delim === "\\updownarrow") {
        top = "\\uparrow";
        repeat = "\u23d0";
        bottom = "\\downarrow";
      } else if (delim === "\\Updownarrow") {
        top = "\\Uparrow";
        repeat = "\u2016";
        bottom = "\\Downarrow";
      } else if (verts.includes(delim)) {
        repeat = "\u2223";
        svgLabel = "vert";
        viewBoxWidth = 333;
      } else if (doubleVerts.includes(delim)) {
        repeat = "\u2225";
        svgLabel = "doublevert";
        viewBoxWidth = 556;
      } else if (delim === "[" || delim === "\\lbrack") {
        top = "\u23a1";
        repeat = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
        svgLabel = "lbrack";
        viewBoxWidth = 667;
      } else if (delim === "]" || delim === "\\rbrack") {
        top = "\u23a4";
        repeat = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
        svgLabel = "rbrack";
        viewBoxWidth = 667;
      } else if (delim === "\\lfloor" || delim === "\u230a") {
        repeat = top = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
        svgLabel = "lfloor";
        viewBoxWidth = 667;
      } else if (delim === "\\lceil" || delim === "\u2308") {
        top = "\u23a1";
        repeat = bottom = "\u23a2";
        font = "Size4-Regular";
        svgLabel = "lceil";
        viewBoxWidth = 667;
      } else if (delim === "\\rfloor" || delim === "\u230b") {
        repeat = top = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
        svgLabel = "rfloor";
        viewBoxWidth = 667;
      } else if (delim === "\\rceil" || delim === "\u2309") {
        top = "\u23a4";
        repeat = bottom = "\u23a5";
        font = "Size4-Regular";
        svgLabel = "rceil";
        viewBoxWidth = 667;
      } else if (delim === "(" || delim === "\\lparen") {
        top = "\u239b";
        repeat = "\u239c";
        bottom = "\u239d";
        font = "Size4-Regular";
        svgLabel = "lparen";
        viewBoxWidth = 875;
      } else if (delim === ")" || delim === "\\rparen") {
        top = "\u239e";
        repeat = "\u239f";
        bottom = "\u23a0";
        font = "Size4-Regular";
        svgLabel = "rparen";
        viewBoxWidth = 875;
      } else if (delim === "\\{" || delim === "\\lbrace") {
        top = "\u23a7";
        middle = "\u23a8";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\}" || delim === "\\rbrace") {
        top = "\u23ab";
        middle = "\u23ac";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\lgroup" || delim === "\u27ee") {
        top = "\u23a7";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\rgroup" || delim === "\u27ef") {
        top = "\u23ab";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\lmoustache" || delim === "\u23b0") {
        top = "\u23a7";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\rmoustache" || delim === "\u23b1") {
        top = "\u23ab";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } // Get the metrics of the four sections


      var topMetrics = getMetrics(top, font, mode);
      var topHeightTotal = topMetrics.height + topMetrics.depth;
      var repeatMetrics = getMetrics(repeat, font, mode);
      var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
      var bottomMetrics = getMetrics(bottom, font, mode);
      var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
      var middleHeightTotal = 0;
      var middleFactor = 1;

      if (middle !== null) {
        var middleMetrics = getMetrics(middle, font, mode);
        middleHeightTotal = middleMetrics.height + middleMetrics.depth;
        middleFactor = 2; // repeat symmetrically above and below middle
      } // Calculate the minimal height that the delimiter can have.
      // It is at least the size of the top, bottom, and optional middle combined.


      var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal; // Compute the number of copies of the repeat symbol we will need

      var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal))); // Compute the total height of the delimiter including all the symbols

      var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal; // The center of the delimiter is placed at the center of the axis. Note
      // that in this context, "center" means that the delimiter should be
      // centered around the axis in the current style, while normally it is
      // centered around the axis in textstyle.

      var axisHeight = options.fontMetrics().axisHeight;

      if (center) {
        axisHeight *= options.sizeMultiplier;
      } // Calculate the depth


      var depth = realHeightTotal / 2 - axisHeight; // Now, we start building the pieces that will go into the vlist
      // Keep a list of the pieces of the stacked delimiter

      var stack = [];

      if (svgLabel.length > 0) {
        // Instead of stacking glyphs, create a single SVG.
        // This evades browser problems with imprecise positioning of spans.
        var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
        var viewBoxHeight = Math.round(realHeightTotal * 1000);
        var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1000));
        var path = new PathNode(svgLabel, pathStr);
        var width = (viewBoxWidth / 1000).toFixed(3) + "em";
        var height = (viewBoxHeight / 1000).toFixed(3) + "em";
        var svg = new SvgNode([path], {
          "width": width,
          "height": height,
          "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
        });
        var wrapper = buildCommon.makeSvgSpan([], [svg], options);
        wrapper.height = viewBoxHeight / 1000;
        wrapper.style.width = width;
        wrapper.style.height = height;
        stack.push({
          type: "elem",
          elem: wrapper
        });
      } else {
        // Stack glyphs
        // Start by adding the bottom symbol
        stack.push(makeGlyphSpan(bottom, font, mode));
        stack.push(lap); // overlap

        if (middle === null) {
          // The middle section will be an SVG. Make it an extra 0.016em tall.
          // We'll overlap by 0.008em at top and bottom.
          var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
          stack.push(makeInner(repeat, innerHeight, options));
        } else {
          // When there is a middle bit, we need the middle part and two repeated
          // sections
          var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;

          stack.push(makeInner(repeat, _innerHeight, options)); // Now insert the middle of the brace.

          stack.push(lap);
          stack.push(makeGlyphSpan(middle, font, mode));
          stack.push(lap);
          stack.push(makeInner(repeat, _innerHeight, options));
        } // Add the top symbol


        stack.push(lap);
        stack.push(makeGlyphSpan(top, font, mode));
      } // Finally, build the vlist


      var newOptions = options.havingBaseStyle(Style$1.TEXT);
      var inner = buildCommon.makeVList({
        positionType: "bottom",
        positionData: depth,
        children: stack
      }, newOptions);
      return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner], newOptions), Style$1.TEXT, options, classes);
    }; // All surds have 0.08em padding above the vinculum inside the SVG.
    // That keeps browser span height rounding error from pinching the line.


    var vbPad = 80; // padding above the surd, measured inside the viewBox.

    var emPad = 0.08; // padding, in ems, measured in the document.

    var sqrtSvg = function sqrtSvg(sqrtName, height, viewBoxHeight, extraVinculum, options) {
      var path = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
      var pathNode = new PathNode(sqrtName, path);
      var svg = new SvgNode([pathNode], {
        // Note: 1000:1 ratio of viewBox to document em width.
        "width": "400em",
        "height": makeEm(height),
        "viewBox": "0 0 400000 " + viewBoxHeight,
        "preserveAspectRatio": "xMinYMin slice"
      });
      return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
    };
    /**
     * Make a sqrt image of the given height,
     */


    var makeSqrtImage = function makeSqrtImage(height, options) {
      // Define a newOptions that removes the effect of size changes such as \Huge.
      // We don't pick different a height surd for \Huge. For it, we scale up.
      var newOptions = options.havingBaseSizing(); // Pick the desired surd glyph from a sequence of surds.

      var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
      var sizeMultiplier = newOptions.sizeMultiplier; // default
      // The standard sqrt SVGs each have a 0.04em thick vinculum.
      // If Settings.minRuleThickness is larger than that, we add extraVinculum.

      var extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness); // Create a span containing an SVG image of a sqrt symbol.

      var span;
      var spanHeight = 0;
      var texHeight = 0;
      var viewBoxHeight = 0;
      var advanceWidth; // We create viewBoxes with 80 units of "padding" above each surd.
      // Then browser rounding error on the parent span height will not
      // encroach on the ink of the vinculum. But that padding is not
      // included in the TeX-like `height` used for calculation of
      // vertical alignment. So texHeight = span.height < span.style.height.

      if (delim.type === "small") {
        // Get an SVG that is derived from glyph U+221A in font KaTeX-Main.
        // 1000 unit normal glyph height.
        viewBoxHeight = 1000 + 1000 * extraVinculum + vbPad;

        if (height < 1.0) {
          sizeMultiplier = 1.0; // mimic a \textfont radical
        } else if (height < 1.4) {
          sizeMultiplier = 0.7; // mimic a \scriptfont radical
        }

        spanHeight = (1.0 + extraVinculum + emPad) / sizeMultiplier;
        texHeight = (1.00 + extraVinculum) / sizeMultiplier;
        span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
        span.style.minWidth = "0.853em";
        advanceWidth = 0.833 / sizeMultiplier; // from the font.
      } else if (delim.type === "large") {
        // These SVGs come from fonts: KaTeX_Size1, _Size2, etc.
        viewBoxHeight = (1000 + vbPad) * sizeToMaxHeight[delim.size];
        texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
        spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
        span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
        span.style.minWidth = "1.02em";
        advanceWidth = 1.0 / sizeMultiplier; // 1.0 from the font.
      } else {
        // Tall sqrt. In TeX, this would be stacked using multiple glyphs.
        // We'll use a single SVG to accomplish the same thing.
        spanHeight = height + extraVinculum + emPad;
        texHeight = height + extraVinculum;
        viewBoxHeight = Math.floor(1000 * height + extraVinculum) + vbPad;
        span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
        span.style.minWidth = "0.742em";
        advanceWidth = 1.056;
      }

      span.height = texHeight;
      span.style.height = makeEm(spanHeight);
      return {
        span,
        advanceWidth,
        // Calculate the actual line width.
        // This actually should depend on the chosen font -- e.g. \boldmath
        // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
        // have thicker rules.
        ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
      };
    }; // There are three kinds of delimiters, delimiters that stack when they become
    // too large


    var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230a", "\u230b", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"]; // delimiters that always stack

    var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27ee", "\u27ef", "\\lmoustache", "\\rmoustache", "\u23b0", "\u23b1"]; // and delimiters that never stack

    var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"]; // Metrics of the different sizes. Found by looking at TeX's output of
    // $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
    // Used to create stacked delimiters of appropriate sizes in makeSizedDelim.

    var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];
    /**
     * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
     */

    var makeSizedDelim = function makeSizedDelim(delim, size, options, mode, classes) {
      // < and > turn into \langle and \rangle in delimiters
      if (delim === "<" || delim === "\\lt" || delim === "\u27e8") {
        delim = "\\langle";
      } else if (delim === ">" || delim === "\\gt" || delim === "\u27e9") {
        delim = "\\rangle";
      } // Sized delimiters are never centered.


      if (stackLargeDelimiters.includes(delim) || stackNeverDelimiters.includes(delim)) {
        return makeLargeDelim(delim, size, false, options, mode, classes);
      } else if (stackAlwaysDelimiters.includes(delim)) {
        return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
      } else {
        throw new ParseError("Illegal delimiter: '" + delim + "'");
      }
    };
    /**
     * There are three different sequences of delimiter sizes that the delimiters
     * follow depending on the kind of delimiter. This is used when creating custom
     * sized delimiters to decide whether to create a small, large, or stacked
     * delimiter.
     *
     * In real TeX, these sequences aren't explicitly defined, but are instead
     * defined inside the font metrics. Since there are only three sequences that
     * are possible for the delimiters that TeX defines, it is easier to just encode
     * them explicitly here.
     */


    // Delimiters that never stack try small delimiters and large delimiters only
    var stackNeverDelimiterSequence = [{
      type: "small",
      style: Style$1.SCRIPTSCRIPT
    }, {
      type: "small",
      style: Style$1.SCRIPT
    }, {
      type: "small",
      style: Style$1.TEXT
    }, {
      type: "large",
      size: 1
    }, {
      type: "large",
      size: 2
    }, {
      type: "large",
      size: 3
    }, {
      type: "large",
      size: 4
    }]; // Delimiters that always stack try the small delimiters first, then stack

    var stackAlwaysDelimiterSequence = [{
      type: "small",
      style: Style$1.SCRIPTSCRIPT
    }, {
      type: "small",
      style: Style$1.SCRIPT
    }, {
      type: "small",
      style: Style$1.TEXT
    }, {
      type: "stack"
    }]; // Delimiters that stack when large try the small and then large delimiters, and
    // stack afterwards

    var stackLargeDelimiterSequence = [{
      type: "small",
      style: Style$1.SCRIPTSCRIPT
    }, {
      type: "small",
      style: Style$1.SCRIPT
    }, {
      type: "small",
      style: Style$1.TEXT
    }, {
      type: "large",
      size: 1
    }, {
      type: "large",
      size: 2
    }, {
      type: "large",
      size: 3
    }, {
      type: "large",
      size: 4
    }, {
      type: "stack"
    }];
    /**
     * Get the font used in a delimiter based on what kind of delimiter it is.
     * TODO(#963) Use more specific font family return type once that is introduced.
     */

    var delimTypeToFont = function delimTypeToFont(type) {
      if (type.type === "small") {
        return "Main-Regular";
      } else if (type.type === "large") {
        return "Size" + type.size + "-Regular";
      } else if (type.type === "stack") {
        return "Size4-Regular";
      } else {
        throw new Error("Add support for delim type '" + type.type + "' here.");
      }
    };
    /**
     * Traverse a sequence of types of delimiters to decide what kind of delimiter
     * should be used to create a delimiter of the given height+depth.
     */


    var traverseSequence = function traverseSequence(delim, height, sequence, options) {
      // Here, we choose the index we should start at in the sequences. In smaller
      // sizes (which correspond to larger numbers in style.size) we start earlier
      // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
      // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
      var start = Math.min(2, 3 - options.style.size);

      for (var i = start; i < sequence.length; i++) {
        if (sequence[i].type === "stack") {
          // This is always the last delimiter, so we just break the loop now.
          break;
        }

        var metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
        var heightDepth = metrics.height + metrics.depth; // Small delimiters are scaled down versions of the same font, so we
        // account for the style change size.

        if (sequence[i].type === "small") {
          var newOptions = options.havingBaseStyle(sequence[i].style);
          heightDepth *= newOptions.sizeMultiplier;
        } // Check if the delimiter at this size works for the given height.


        if (heightDepth > height) {
          return sequence[i];
        }
      } // If we reached the end of the sequence, return the last sequence element.


      return sequence[sequence.length - 1];
    };
    /**
     * Make a delimiter of a given height+depth, with optional centering. Here, we
     * traverse the sequences, and create a delimiter that the sequence tells us to.
     */


    var makeCustomSizedDelim = function makeCustomSizedDelim(delim, height, center, options, mode, classes) {
      if (delim === "<" || delim === "\\lt" || delim === "\u27e8") {
        delim = "\\langle";
      } else if (delim === ">" || delim === "\\gt" || delim === "\u27e9") {
        delim = "\\rangle";
      } // Decide what sequence to use


      var sequence;

      if (stackNeverDelimiters.includes(delim)) {
        sequence = stackNeverDelimiterSequence;
      } else if (stackLargeDelimiters.includes(delim)) {
        sequence = stackLargeDelimiterSequence;
      } else {
        sequence = stackAlwaysDelimiterSequence;
      } // Look through the sequence


      var delimType = traverseSequence(delim, height, sequence, options); // Get the delimiter from font glyphs.
      // Depending on the sequence element we decided on, call the
      // appropriate function.

      if (delimType.type === "small") {
        return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
      } else if (delimType.type === "large") {
        return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
      } else
        /* if (delimType.type === "stack") */
        {
          return makeStackedDelim(delim, height, center, options, mode, classes);
        }
    };
    /**
     * Make a delimiter for use with `\left` and `\right`, given a height and depth
     * of an expression that the delimiters surround.
     */


    var makeLeftRightDelim = function makeLeftRightDelim(delim, height, depth, options, mode, classes) {
      // We always center \left/\right delimiters, so the axis is always shifted
      var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier; // Taken from TeX source, tex.web, function make_left_right

      var delimiterFactor = 901;
      var delimiterExtend = 5.0 / options.fontMetrics().ptPerEm;
      var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
      var totalHeight = Math.max( // In real TeX, calculations are done using integral values which are
      // 65536 per pt, or 655360 per em. So, the division here truncates in
      // TeX but doesn't here, producing different results. If we wanted to
      // exactly match TeX's calculation, we could do
      //   Math.floor(655360 * maxDistFromAxis / 500) *
      //    delimiterFactor / 655360
      // (To see the difference, compare
      //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
      // in TeX and KaTeX)
      maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend); // Finally, we defer to `makeCustomSizedDelim` with our calculated total
      // height

      return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
    };

    var delimiter = {
      sqrtImage: makeSqrtImage,
      sizedDelim: makeSizedDelim,
      sizeToMaxHeight: sizeToMaxHeight,
      customSizedDelim: makeCustomSizedDelim,
      leftRightDelim: makeLeftRightDelim
    };

    // Extra data needed for the delimiter handler down below
    var delimiterSizes = {
      "\\bigl": {
        mclass: "mopen",
        size: 1
      },
      "\\Bigl": {
        mclass: "mopen",
        size: 2
      },
      "\\biggl": {
        mclass: "mopen",
        size: 3
      },
      "\\Biggl": {
        mclass: "mopen",
        size: 4
      },
      "\\bigr": {
        mclass: "mclose",
        size: 1
      },
      "\\Bigr": {
        mclass: "mclose",
        size: 2
      },
      "\\biggr": {
        mclass: "mclose",
        size: 3
      },
      "\\Biggr": {
        mclass: "mclose",
        size: 4
      },
      "\\bigm": {
        mclass: "mrel",
        size: 1
      },
      "\\Bigm": {
        mclass: "mrel",
        size: 2
      },
      "\\biggm": {
        mclass: "mrel",
        size: 3
      },
      "\\Biggm": {
        mclass: "mrel",
        size: 4
      },
      "\\big": {
        mclass: "mord",
        size: 1
      },
      "\\Big": {
        mclass: "mord",
        size: 2
      },
      "\\bigg": {
        mclass: "mord",
        size: 3
      },
      "\\Bigg": {
        mclass: "mord",
        size: 4
      }
    };
    var delimiters$1 = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230a", "\u230b", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27e8", "\\rangle", "\u27e9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27ee", "\u27ef", "\\lmoustache", "\\rmoustache", "\u23b0", "\u23b1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];

    // Delimiter functions
    function checkDelimiter(delim, context) {
      var symDelim = checkSymbolNodeType(delim);

      if (symDelim && delimiters$1.includes(symDelim.text)) {
        return symDelim;
      } else if (symDelim) {
        throw new ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
      } else {
        throw new ParseError("Invalid delimiter type '" + delim.type + "'", delim);
      }
    }

    defineFunction({
      type: "delimsizing",
      names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
      props: {
        numArgs: 1,
        argTypes: ["primitive"]
      },
      handler: (context, args) => {
        var delim = checkDelimiter(args[0], context);
        return {
          type: "delimsizing",
          mode: context.parser.mode,
          size: delimiterSizes[context.funcName].size,
          mclass: delimiterSizes[context.funcName].mclass,
          delim: delim.text
        };
      },
      htmlBuilder: (group, options) => {
        if (group.delim === ".") {
          // Empty delimiters still count as elements, even though they don't
          // show anything.
          return buildCommon.makeSpan([group.mclass]);
        } // Use delimiter.sizedDelim to generate the delimiter.


        return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
      },
      mathmlBuilder: group => {
        var children = [];

        if (group.delim !== ".") {
          children.push(makeText(group.delim, group.mode));
        }

        var node = new mathMLTree.MathNode("mo", children);

        if (group.mclass === "mopen" || group.mclass === "mclose") {
          // Only some of the delimsizing functions act as fences, and they
          // return "mopen" or "mclose" mclass.
          node.setAttribute("fence", "true");
        } else {
          // Explicitly disable fencing if it's not a fence, to override the
          // defaults.
          node.setAttribute("fence", "false");
        }

        node.setAttribute("stretchy", "true");
        var size = makeEm(delimiter.sizeToMaxHeight[group.size]);
        node.setAttribute("minsize", size);
        node.setAttribute("maxsize", size);
        return node;
      }
    });

    function assertParsed(group) {
      if (!group.body) {
        throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
      }
    }

    defineFunction({
      type: "leftright-right",
      names: ["\\right"],
      props: {
        numArgs: 1,
        primitive: true
      },
      handler: (context, args) => {
        // \left case below triggers parsing of \right in
        //   `const right = parser.parseFunction();`
        // uses this return value.
        var color = context.parser.gullet.macros.get("\\current@color");

        if (color && typeof color !== "string") {
          throw new ParseError("\\current@color set to non-string in \\right");
        }

        return {
          type: "leftright-right",
          mode: context.parser.mode,
          delim: checkDelimiter(args[0], context).text,
          color // undefined if not set via \color

        };
      }
    });
    defineFunction({
      type: "leftright",
      names: ["\\left"],
      props: {
        numArgs: 1,
        primitive: true
      },
      handler: (context, args) => {
        var delim = checkDelimiter(args[0], context);
        var parser = context.parser; // Parse out the implicit body

        ++parser.leftrightDepth; // parseExpression stops before '\\right'

        var body = parser.parseExpression(false);
        --parser.leftrightDepth; // Check the next token

        parser.expect("\\right", false);
        var right = assertNodeType(parser.parseFunction(), "leftright-right");
        return {
          type: "leftright",
          mode: parser.mode,
          body,
          left: delim.text,
          right: right.delim,
          rightColor: right.color
        };
      },
      htmlBuilder: (group, options) => {
        assertParsed(group); // Build the inner expression

        var inner = buildExpression$1(group.body, options, true, ["mopen", "mclose"]);
        var innerHeight = 0;
        var innerDepth = 0;
        var hadMiddle = false; // Calculate its height and depth

        for (var i = 0; i < inner.length; i++) {
          // Property `isMiddle` not defined on `span`. See comment in
          // "middle"'s htmlBuilder.
          // $FlowFixMe
          if (inner[i].isMiddle) {
            hadMiddle = true;
          } else {
            innerHeight = Math.max(inner[i].height, innerHeight);
            innerDepth = Math.max(inner[i].depth, innerDepth);
          }
        } // The size of delimiters is the same, regardless of what style we are
        // in. Thus, to correctly calculate the size of delimiter we need around
        // a group, we scale down the inner size based on the size.


        innerHeight *= options.sizeMultiplier;
        innerDepth *= options.sizeMultiplier;
        var leftDelim;

        if (group.left === ".") {
          // Empty delimiters in \left and \right make null delimiter spaces.
          leftDelim = makeNullDelimiter(options, ["mopen"]);
        } else {
          // Otherwise, use leftRightDelim to generate the correct sized
          // delimiter.
          leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
        } // Add it to the beginning of the expression


        inner.unshift(leftDelim); // Handle middle delimiters

        if (hadMiddle) {
          for (var _i = 1; _i < inner.length; _i++) {
            var middleDelim = inner[_i]; // Property `isMiddle` not defined on `span`. See comment in
            // "middle"'s htmlBuilder.
            // $FlowFixMe

            var isMiddle = middleDelim.isMiddle;

            if (isMiddle) {
              // Apply the options that were active when \middle was called
              inner[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
            }
          }
        }

        var rightDelim; // Same for the right delimiter, but using color specified by \color

        if (group.right === ".") {
          rightDelim = makeNullDelimiter(options, ["mclose"]);
        } else {
          var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
          rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
        } // Add it to the end of the expression.


        inner.push(rightDelim);
        return buildCommon.makeSpan(["minner"], inner, options);
      },
      mathmlBuilder: (group, options) => {
        assertParsed(group);
        var inner = buildExpression(group.body, options);

        if (group.left !== ".") {
          var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
          leftNode.setAttribute("fence", "true");
          inner.unshift(leftNode);
        }

        if (group.right !== ".") {
          var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
          rightNode.setAttribute("fence", "true");

          if (group.rightColor) {
            rightNode.setAttribute("mathcolor", group.rightColor);
          }

          inner.push(rightNode);
        }

        return makeRow(inner);
      }
    });
    defineFunction({
      type: "middle",
      names: ["\\middle"],
      props: {
        numArgs: 1,
        primitive: true
      },
      handler: (context, args) => {
        var delim = checkDelimiter(args[0], context);

        if (!context.parser.leftrightDepth) {
          throw new ParseError("\\middle without preceding \\left", delim);
        }

        return {
          type: "middle",
          mode: context.parser.mode,
          delim: delim.text
        };
      },
      htmlBuilder: (group, options) => {
        var middleDelim;

        if (group.delim === ".") {
          middleDelim = makeNullDelimiter(options, []);
        } else {
          middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
          var isMiddle = {
            delim: group.delim,
            options
          }; // Property `isMiddle` not defined on `span`. It is only used in
          // this file above.
          // TODO: Fix this violation of the `span` type and possibly rename
          // things since `isMiddle` sounds like a boolean, but is a struct.
          // $FlowFixMe

          middleDelim.isMiddle = isMiddle;
        }

        return middleDelim;
      },
      mathmlBuilder: (group, options) => {
        // A Firefox \middle will stretch a character vertically only if it
        // is in the fence part of the operator dictionary at:
        // https://www.w3.org/TR/MathML3/appendixc.html.
        // So we need to avoid U+2223 and use plain "|" instead.
        var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
        var middleNode = new mathMLTree.MathNode("mo", [textNode]);
        middleNode.setAttribute("fence", "true"); // MathML gives 5/18em spacing to each <mo> element.
        // \middle should get delimiter spacing instead.

        middleNode.setAttribute("lspace", "0.05em");
        middleNode.setAttribute("rspace", "0.05em");
        return middleNode;
      }
    });

    var htmlBuilder$7 = (group, options) => {
      // \cancel, \bcancel, \xcancel, \sout, \fbox, \colorbox, \fcolorbox, \phase
      // Some groups can return document fragments.  Handle those by wrapping
      // them in a span.
      var inner = buildCommon.wrapFragment(buildGroup$1(group.body, options), options);
      var label = group.label.slice(1);
      var scale = options.sizeMultiplier;
      var img;
      var imgShift = 0; // In the LaTeX cancel package, line geometry is slightly different
      // depending on whether the subject is wider than it is tall, or vice versa.
      // We don't know the width of a group, so as a proxy, we test if
      // the subject is a single character. This captures most of the
      // subjects that should get the "tall" treatment.

      var isSingleChar = utils.isCharacterBox(group.body);

      if (label === "sout") {
        img = buildCommon.makeSpan(["stretchy", "sout"]);
        img.height = options.fontMetrics().defaultRuleThickness / scale;
        imgShift = -0.5 * options.fontMetrics().xHeight;
      } else if (label === "phase") {
        // Set a couple of dimensions from the steinmetz package.
        var lineWeight = calculateSize({
          number: 0.6,
          unit: "pt"
        }, options);
        var clearance = calculateSize({
          number: 0.35,
          unit: "ex"
        }, options); // Prevent size changes like \Huge from affecting line thickness

        var newOptions = options.havingBaseSizing();
        scale = scale / newOptions.sizeMultiplier;
        var angleHeight = inner.height + inner.depth + lineWeight + clearance; // Reserve a left pad for the angle.

        inner.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight); // Create an SVG

        var viewBoxHeight = Math.floor(1000 * angleHeight * scale);
        var path = phasePath(viewBoxHeight);
        var svgNode = new SvgNode([new PathNode("phase", path)], {
          "width": "400em",
          "height": makeEm(viewBoxHeight / 1000),
          "viewBox": "0 0 400000 " + viewBoxHeight,
          "preserveAspectRatio": "xMinYMin slice"
        }); // Wrap it in a span with overflow: hidden.

        img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
        img.style.height = makeEm(angleHeight);
        imgShift = inner.depth + lineWeight + clearance;
      } else {
        // Add horizontal padding
        if (/cancel/.test(label)) {
          if (!isSingleChar) {
            inner.classes.push("cancel-pad");
          }
        } else if (label === "angl") {
          inner.classes.push("anglpad");
        } else {
          inner.classes.push("boxpad");
        } // Add vertical padding


        var topPad = 0;
        var bottomPad = 0;
        var ruleThickness = 0; // ref: cancel package: \advance\totalheight2\p@ % "+2"

        if (/box/.test(label)) {
          ruleThickness = Math.max(options.fontMetrics().fboxrule, // default
          options.minRuleThickness // User override.
          );
          topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
          bottomPad = topPad;
        } else if (label === "angl") {
          ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
          topPad = 4 * ruleThickness; // gap = 3  line, plus the line itself.

          bottomPad = Math.max(0, 0.25 - inner.depth);
        } else {
          topPad = isSingleChar ? 0.2 : 0;
          bottomPad = topPad;
        }

        img = stretchy.encloseSpan(inner, label, topPad, bottomPad, options);

        if (/fbox|boxed|fcolorbox/.test(label)) {
          img.style.borderStyle = "solid";
          img.style.borderWidth = makeEm(ruleThickness);
        } else if (label === "angl" && ruleThickness !== 0.049) {
          img.style.borderTopWidth = makeEm(ruleThickness);
          img.style.borderRightWidth = makeEm(ruleThickness);
        }

        imgShift = inner.depth + bottomPad;

        if (group.backgroundColor) {
          img.style.backgroundColor = group.backgroundColor;

          if (group.borderColor) {
            img.style.borderColor = group.borderColor;
          }
        }
      }

      var vlist;

      if (group.backgroundColor) {
        vlist = buildCommon.makeVList({
          positionType: "individualShift",
          children: [// Put the color background behind inner;
          {
            type: "elem",
            elem: img,
            shift: imgShift
          }, {
            type: "elem",
            elem: inner,
            shift: 0
          }]
        }, options);
      } else {
        var classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
        vlist = buildCommon.makeVList({
          positionType: "individualShift",
          children: [// Write the \cancel stroke on top of inner.
          {
            type: "elem",
            elem: inner,
            shift: 0
          }, {
            type: "elem",
            elem: img,
            shift: imgShift,
            wrapperClasses: classes
          }]
        }, options);
      }

      if (/cancel/.test(label)) {
        // The cancel package documentation says that cancel lines add their height
        // to the expression, but tests show that isn't how it actually works.
        vlist.height = inner.height;
        vlist.depth = inner.depth;
      }

      if (/cancel/.test(label) && !isSingleChar) {
        // cancel does not create horiz space for its line extension.
        return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
      } else {
        return buildCommon.makeSpan(["mord"], [vlist], options);
      }
    };

    var mathmlBuilder$6 = (group, options) => {
      var fboxsep = 0;
      var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup(group.body, options)]);

      switch (group.label) {
        case "\\cancel":
          node.setAttribute("notation", "updiagonalstrike");
          break;

        case "\\bcancel":
          node.setAttribute("notation", "downdiagonalstrike");
          break;

        case "\\phase":
          node.setAttribute("notation", "phasorangle");
          break;

        case "\\sout":
          node.setAttribute("notation", "horizontalstrike");
          break;

        case "\\fbox":
          node.setAttribute("notation", "box");
          break;

        case "\\angl":
          node.setAttribute("notation", "actuarial");
          break;

        case "\\fcolorbox":
        case "\\colorbox":
          // <menclose> doesn't have a good notation option. So use <mpadded>
          // instead. Set some attributes that come included with <menclose>.
          fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
          node.setAttribute("width", "+" + 2 * fboxsep + "pt");
          node.setAttribute("height", "+" + 2 * fboxsep + "pt");
          node.setAttribute("lspace", fboxsep + "pt"); //

          node.setAttribute("voffset", fboxsep + "pt");

          if (group.label === "\\fcolorbox") {
            var thk = Math.max(options.fontMetrics().fboxrule, // default
            options.minRuleThickness // user override
            );
            node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
          }

          break;

        case "\\xcancel":
          node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
          break;
      }

      if (group.backgroundColor) {
        node.setAttribute("mathbackground", group.backgroundColor);
      }

      return node;
    };

    defineFunction({
      type: "enclose",
      names: ["\\colorbox"],
      props: {
        numArgs: 2,
        allowedInText: true,
        argTypes: ["color", "text"]
      },

      handler(_ref, args, optArgs) {
        var {
          parser,
          funcName
        } = _ref;
        var color = assertNodeType(args[0], "color-token").color;
        var body = args[1];
        return {
          type: "enclose",
          mode: parser.mode,
          label: funcName,
          backgroundColor: color,
          body
        };
      },

      htmlBuilder: htmlBuilder$7,
      mathmlBuilder: mathmlBuilder$6
    });
    defineFunction({
      type: "enclose",
      names: ["\\fcolorbox"],
      props: {
        numArgs: 3,
        allowedInText: true,
        argTypes: ["color", "color", "text"]
      },

      handler(_ref2, args, optArgs) {
        var {
          parser,
          funcName
        } = _ref2;
        var borderColor = assertNodeType(args[0], "color-token").color;
        var backgroundColor = assertNodeType(args[1], "color-token").color;
        var body = args[2];
        return {
          type: "enclose",
          mode: parser.mode,
          label: funcName,
          backgroundColor,
          borderColor,
          body
        };
      },

      htmlBuilder: htmlBuilder$7,
      mathmlBuilder: mathmlBuilder$6
    });
    defineFunction({
      type: "enclose",
      names: ["\\fbox"],
      props: {
        numArgs: 1,
        argTypes: ["hbox"],
        allowedInText: true
      },

      handler(_ref3, args) {
        var {
          parser
        } = _ref3;
        return {
          type: "enclose",
          mode: parser.mode,
          label: "\\fbox",
          body: args[0]
        };
      }

    });
    defineFunction({
      type: "enclose",
      names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
      props: {
        numArgs: 1
      },

      handler(_ref4, args) {
        var {
          parser,
          funcName
        } = _ref4;
        var body = args[0];
        return {
          type: "enclose",
          mode: parser.mode,
          label: funcName,
          body
        };
      },

      htmlBuilder: htmlBuilder$7,
      mathmlBuilder: mathmlBuilder$6
    });
    defineFunction({
      type: "enclose",
      names: ["\\angl"],
      props: {
        numArgs: 1,
        argTypes: ["hbox"],
        allowedInText: false
      },

      handler(_ref5, args) {
        var {
          parser
        } = _ref5;
        return {
          type: "enclose",
          mode: parser.mode,
          label: "\\angl",
          body: args[0]
        };
      }

    });

    /**
     * All registered environments.
     * `environments.js` exports this same dictionary again and makes it public.
     * `Parser.js` requires this dictionary via `environments.js`.
     */
    var _environments = {};
    function defineEnvironment(_ref) {
      var {
        type,
        names,
        props,
        handler,
        htmlBuilder,
        mathmlBuilder
      } = _ref;
      // Set default values of environments.
      var data = {
        type,
        numArgs: props.numArgs || 0,
        allowedInText: false,
        numOptionalArgs: 0,
        handler
      };

      for (var i = 0; i < names.length; ++i) {
        // TODO: The value type of _environments should be a type union of all
        // possible `EnvSpec<>` possibilities instead of `EnvSpec<*>`, which is
        // an existential type.
        _environments[names[i]] = data;
      }

      if (htmlBuilder) {
        _htmlGroupBuilders[type] = htmlBuilder;
      }

      if (mathmlBuilder) {
        _mathmlGroupBuilders[type] = mathmlBuilder;
      }
    }

    /**
     * All registered global/built-in macros.
     * `macros.js` exports this same dictionary again and makes it public.
     * `Parser.js` requires this dictionary via `macros.js`.
     */
    var _macros = {}; // This function might one day accept an additional argument and do more things.

    function defineMacro(name, body) {
      _macros[name] = body;
    }

    // Helper functions
    function getHLines(parser) {
      // Return an array. The array length = number of hlines.
      // Each element in the array tells if the line is dashed.
      var hlineInfo = [];
      parser.consumeSpaces();
      var nxt = parser.fetch().text;

      if (nxt === "\\relax") {
        // \relax is an artifact of the \cr macro below
        parser.consume();
        parser.consumeSpaces();
        nxt = parser.fetch().text;
      }

      while (nxt === "\\hline" || nxt === "\\hdashline") {
        parser.consume();
        hlineInfo.push(nxt === "\\hdashline");
        parser.consumeSpaces();
        nxt = parser.fetch().text;
      }

      return hlineInfo;
    }

    var validateAmsEnvironmentContext = context => {
      var settings = context.parser.settings;

      if (!settings.displayMode) {
        throw new ParseError("{" + context.envName + "} can be used only in" + " display mode.");
      }
    }; // autoTag (an argument to parseArray) can be one of three values:
    // * undefined: Regular (not-top-level) array; no tags on each row
    // * true: Automatic equation numbering, overridable by \tag
    // * false: Tags allowed on each row, but no automatic numbering
    // This function *doesn't* work with the "split" environment name.


    function getAutoTag(name) {
      if (name.indexOf("ed") === -1) {
        return name.indexOf("*") === -1;
      } // return undefined;

    }
    /**
     * Parse the body of the environment, with rows delimited by \\ and
     * columns delimited by &, and create a nested list in row-major order
     * with one group per cell.  If given an optional argument style
     * ("text", "display", etc.), then each cell is cast into that style.
     */


    function parseArray(parser, _ref, style) {
      var {
        hskipBeforeAndAfter,
        addJot,
        cols,
        arraystretch,
        colSeparationType,
        autoTag,
        singleRow,
        emptySingleRow,
        maxNumCols,
        leqno
      } = _ref;
      parser.gullet.beginGroup();

      if (!singleRow) {
        // \cr is equivalent to \\ without the optional size argument (see below)
        // TODO: provide helpful error when \cr is used outside array environment
        parser.gullet.macros.set("\\cr", "\\\\\\relax");
      } // Get current arraystretch if it's not set by the environment


      if (!arraystretch) {
        var stretch = parser.gullet.expandMacroAsText("\\arraystretch");

        if (stretch == null) {
          // Default \arraystretch from lttab.dtx
          arraystretch = 1;
        } else {
          arraystretch = parseFloat(stretch);

          if (!arraystretch || arraystretch < 0) {
            throw new ParseError("Invalid \\arraystretch: " + stretch);
          }
        }
      } // Start group for first cell


      parser.gullet.beginGroup();
      var row = [];
      var body = [row];
      var rowGaps = [];
      var hLinesBeforeRow = [];
      var tags = autoTag != null ? [] : undefined; // amsmath uses \global\@eqnswtrue and \global\@eqnswfalse to represent
      // whether this row should have an equation number.  Simulate this with
      // a \@eqnsw macro set to 1 or 0.

      function beginRow() {
        if (autoTag) {
          parser.gullet.macros.set("\\@eqnsw", "1", true);
        }
      }

      function endRow() {
        if (tags) {
          if (parser.gullet.macros.get("\\df@tag")) {
            tags.push(parser.subparse([new Token("\\df@tag")]));
            parser.gullet.macros.set("\\df@tag", undefined, true);
          } else {
            tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
          }
        }
      }

      beginRow(); // Test for \hline at the top of the array.

      hLinesBeforeRow.push(getHLines(parser));

      while (true) {
        // eslint-disable-line no-constant-condition
        // Parse each cell in its own group (namespace)
        var cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
        parser.gullet.endGroup();
        parser.gullet.beginGroup();
        cell = {
          type: "ordgroup",
          mode: parser.mode,
          body: cell
        };

        if (style) {
          cell = {
            type: "styling",
            mode: parser.mode,
            style,
            body: [cell]
          };
        }

        row.push(cell);
        var next = parser.fetch().text;

        if (next === "&") {
          if (maxNumCols && row.length === maxNumCols) {
            if (singleRow || colSeparationType) {
              // {equation} or {split}
              throw new ParseError("Too many tab characters: &", parser.nextToken);
            } else {
              // {array} environment
              parser.settings.reportNonstrict("textEnv", "Too few columns " + "specified in the {array} column argument.");
            }
          }

          parser.consume();
        } else if (next === "\\end") {
          endRow(); // Arrays terminate newlines with `\crcr` which consumes a `\cr` if
          // the last line is empty.  However, AMS environments keep the
          // empty row if it's the only one.
          // NOTE: Currently, `cell` is the last item added into `row`.

          if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
            body.pop();
          }

          if (hLinesBeforeRow.length < body.length + 1) {
            hLinesBeforeRow.push([]);
          }

          break;
        } else if (next === "\\\\") {
          parser.consume();
          var size = void 0; // \def\Let@{\let\\\math@cr}
          // \def\math@cr{...\math@cr@}
          // \def\math@cr@{\new@ifnextchar[\math@cr@@{\math@cr@@[\z@]}}
          // \def\math@cr@@[#1]{...\math@cr@@@...}
          // \def\math@cr@@@{\cr}

          if (parser.gullet.future().text !== " ") {
            size = parser.parseSizeGroup(true);
          }

          rowGaps.push(size ? size.value : null);
          endRow(); // check for \hline(s) following the row separator

          hLinesBeforeRow.push(getHLines(parser));
          row = [];
          body.push(row);
          beginRow();
        } else {
          throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
        }
      } // End cell group


      parser.gullet.endGroup(); // End array group defining \cr

      parser.gullet.endGroup();
      return {
        type: "array",
        mode: parser.mode,
        addJot,
        arraystretch,
        body,
        cols,
        rowGaps,
        hskipBeforeAndAfter,
        hLinesBeforeRow,
        colSeparationType,
        tags,
        leqno
      };
    } // Decides on a style for cells in an array according to whether the given
    // environment name starts with the letter 'd'.


    function dCellStyle(envName) {
      if (envName.slice(0, 1) === "d") {
        return "display";
      } else {
        return "text";
      }
    }

    var htmlBuilder$6 = function htmlBuilder(group, options) {
      var r;
      var c;
      var nr = group.body.length;
      var hLinesBeforeRow = group.hLinesBeforeRow;
      var nc = 0;
      var body = new Array(nr);
      var hlines = [];
      var ruleThickness = Math.max( // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
      options.fontMetrics().arrayRuleWidth, options.minRuleThickness // User override.
      ); // Horizontal spacing

      var pt = 1 / options.fontMetrics().ptPerEm;
      var arraycolsep = 5 * pt; // default value, i.e. \arraycolsep in article.cls

      if (group.colSeparationType && group.colSeparationType === "small") {
        // We're in a {smallmatrix}. Default column space is \thickspace,
        // i.e. 5/18em = 0.2778em, per amsmath.dtx for {smallmatrix}.
        // But that needs adjustment because LaTeX applies \scriptstyle to the
        // entire array, including the colspace, but this function applies
        // \scriptstyle only inside each element.
        var localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;
        arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
      } // Vertical spacing


      var baselineskip = group.colSeparationType === "CD" ? calculateSize({
        number: 3,
        unit: "ex"
      }, options) : 12 * pt; // see size10.clo
      // Default \jot from ltmath.dtx
      // TODO(edemaine): allow overriding \jot via \setlength (#687)

      var jot = 3 * pt;
      var arrayskip = group.arraystretch * baselineskip;
      var arstrutHeight = 0.7 * arrayskip; // \strutbox in ltfsstrc.dtx and

      var arstrutDepth = 0.3 * arrayskip; // \@arstrutbox in lttab.dtx

      var totalHeight = 0; // Set a position for \hline(s) at the top of the array, if any.

      function setHLinePos(hlinesInGap) {
        for (var i = 0; i < hlinesInGap.length; ++i) {
          if (i > 0) {
            totalHeight += 0.25;
          }

          hlines.push({
            pos: totalHeight,
            isDashed: hlinesInGap[i]
          });
        }
      }

      setHLinePos(hLinesBeforeRow[0]);

      for (r = 0; r < group.body.length; ++r) {
        var inrow = group.body[r];
        var height = arstrutHeight; // \@array adds an \@arstrut

        var depth = arstrutDepth; // to each tow (via the template)

        if (nc < inrow.length) {
          nc = inrow.length;
        }

        var outrow = new Array(inrow.length);

        for (c = 0; c < inrow.length; ++c) {
          var elt = buildGroup$1(inrow[c], options);

          if (depth < elt.depth) {
            depth = elt.depth;
          }

          if (height < elt.height) {
            height = elt.height;
          }

          outrow[c] = elt;
        }

        var rowGap = group.rowGaps[r];
        var gap = 0;

        if (rowGap) {
          gap = calculateSize(rowGap, options);

          if (gap > 0) {
            // \@argarraycr
            gap += arstrutDepth;

            if (depth < gap) {
              depth = gap; // \@xargarraycr
            }

            gap = 0;
          }
        } // In AMS multiline environments such as aligned and gathered, rows
        // correspond to lines that have additional \jot added to the
        // \baselineskip via \openup.


        if (group.addJot) {
          depth += jot;
        }

        outrow.height = height;
        outrow.depth = depth;
        totalHeight += height;
        outrow.pos = totalHeight;
        totalHeight += depth + gap; // \@yargarraycr

        body[r] = outrow; // Set a position for \hline(s), if any.

        setHLinePos(hLinesBeforeRow[r + 1]);
      }

      var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
      var colDescriptions = group.cols || [];
      var cols = [];
      var colSep;
      var colDescrNum;
      var tagSpans = [];

      if (group.tags && group.tags.some(tag => tag)) {
        // An environment with manual tags and/or automatic equation numbers.
        // Create node(s), the latter of which trigger CSS counter increment.
        for (r = 0; r < nr; ++r) {
          var rw = body[r];
          var shift = rw.pos - offset;
          var tag = group.tags[r];
          var tagSpan = void 0;

          if (tag === true) {
            // automatic numbering
            tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
          } else if (tag === false) {
            // \nonumber/\notag or starred environment
            tagSpan = buildCommon.makeSpan([], [], options);
          } else {
            // manual \tag
            tagSpan = buildCommon.makeSpan([], buildExpression$1(tag, options, true), options);
          }

          tagSpan.depth = rw.depth;
          tagSpan.height = rw.height;
          tagSpans.push({
            type: "elem",
            elem: tagSpan,
            shift
          });
        }
      }

      for (c = 0, colDescrNum = 0; // Continue while either there are more columns or more column
      // descriptions, so trailing separators don't get lost.
      c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {
        var colDescr = colDescriptions[colDescrNum] || {};
        var firstSeparator = true;

        while (colDescr.type === "separator") {
          // If there is more than one separator in a row, add a space
          // between them.
          if (!firstSeparator) {
            colSep = buildCommon.makeSpan(["arraycolsep"], []);
            colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
            cols.push(colSep);
          }

          if (colDescr.separator === "|" || colDescr.separator === ":") {
            var lineType = colDescr.separator === "|" ? "solid" : "dashed";
            var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
            separator.style.height = makeEm(totalHeight);
            separator.style.borderRightWidth = makeEm(ruleThickness);
            separator.style.borderRightStyle = lineType;
            separator.style.margin = "0 " + makeEm(-ruleThickness / 2);

            var _shift = totalHeight - offset;

            if (_shift) {
              separator.style.verticalAlign = makeEm(-_shift);
            }

            cols.push(separator);
          } else {
            throw new ParseError("Invalid separator type: " + colDescr.separator);
          }

          colDescrNum++;
          colDescr = colDescriptions[colDescrNum] || {};
          firstSeparator = false;
        }

        if (c >= nc) {
          continue;
        }

        var sepwidth = void 0;

        if (c > 0 || group.hskipBeforeAndAfter) {
          sepwidth = utils.deflt(colDescr.pregap, arraycolsep);

          if (sepwidth !== 0) {
            colSep = buildCommon.makeSpan(["arraycolsep"], []);
            colSep.style.width = makeEm(sepwidth);
            cols.push(colSep);
          }
        }

        var col = [];

        for (r = 0; r < nr; ++r) {
          var row = body[r];
          var elem = row[c];

          if (!elem) {
            continue;
          }

          var _shift2 = row.pos - offset;

          elem.depth = row.depth;
          elem.height = row.height;
          col.push({
            type: "elem",
            elem: elem,
            shift: _shift2
          });
        }

        col = buildCommon.makeVList({
          positionType: "individualShift",
          children: col
        }, options);
        col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
        cols.push(col);

        if (c < nc - 1 || group.hskipBeforeAndAfter) {
          sepwidth = utils.deflt(colDescr.postgap, arraycolsep);

          if (sepwidth !== 0) {
            colSep = buildCommon.makeSpan(["arraycolsep"], []);
            colSep.style.width = makeEm(sepwidth);
            cols.push(colSep);
          }
        }
      }

      body = buildCommon.makeSpan(["mtable"], cols); // Add \hline(s), if any.

      if (hlines.length > 0) {
        var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
        var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
        var vListElems = [{
          type: "elem",
          elem: body,
          shift: 0
        }];

        while (hlines.length > 0) {
          var hline = hlines.pop();
          var lineShift = hline.pos - offset;

          if (hline.isDashed) {
            vListElems.push({
              type: "elem",
              elem: dashes,
              shift: lineShift
            });
          } else {
            vListElems.push({
              type: "elem",
              elem: line,
              shift: lineShift
            });
          }
        }

        body = buildCommon.makeVList({
          positionType: "individualShift",
          children: vListElems
        }, options);
      }

      if (tagSpans.length === 0) {
        return buildCommon.makeSpan(["mord"], [body], options);
      } else {
        var eqnNumCol = buildCommon.makeVList({
          positionType: "individualShift",
          children: tagSpans
        }, options);
        eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
        return buildCommon.makeFragment([body, eqnNumCol]);
      }
    };

    var alignMap = {
      c: "center ",
      l: "left ",
      r: "right "
    };

    var mathmlBuilder$5 = function mathmlBuilder(group, options) {
      var tbl = [];
      var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
      var tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);

      for (var i = 0; i < group.body.length; i++) {
        var rw = group.body[i];
        var row = [];

        for (var j = 0; j < rw.length; j++) {
          row.push(new mathMLTree.MathNode("mtd", [buildGroup(rw[j], options)]));
        }

        if (group.tags && group.tags[i]) {
          row.unshift(glue);
          row.push(glue);

          if (group.leqno) {
            row.unshift(tag);
          } else {
            row.push(tag);
          }
        }

        tbl.push(new mathMLTree.MathNode("mtr", row));
      }

      var table = new mathMLTree.MathNode("mtable", tbl); // Set column alignment, row spacing, column spacing, and
      // array lines by setting attributes on the table element.
      // Set the row spacing. In MathML, we specify a gap distance.
      // We do not use rowGap[] because MathML automatically increases
      // cell height with the height/depth of the element content.
      // LaTeX \arraystretch multiplies the row baseline-to-baseline distance.
      // We simulate this by adding (arraystretch - 1)em to the gap. This
      // does a reasonable job of adjusting arrays containing 1 em tall content.
      // The 0.16 and 0.09 values are found empirically. They produce an array
      // similar to LaTeX and in which content does not interfere with \hlines.

      var gap = group.arraystretch === 0.5 ? 0.1 // {smallmatrix}, {subarray}
      : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
      table.setAttribute("rowspacing", makeEm(gap)); // MathML table lines go only between cells.
      // To place a line on an edge we'll use <menclose>, if necessary.

      var menclose = "";
      var align = "";

      if (group.cols && group.cols.length > 0) {
        // Find column alignment, column spacing, and  vertical lines.
        var cols = group.cols;
        var columnLines = "";
        var prevTypeWasAlign = false;
        var iStart = 0;
        var iEnd = cols.length;

        if (cols[0].type === "separator") {
          menclose += "top ";
          iStart = 1;
        }

        if (cols[cols.length - 1].type === "separator") {
          menclose += "bottom ";
          iEnd -= 1;
        }

        for (var _i = iStart; _i < iEnd; _i++) {
          if (cols[_i].type === "align") {
            align += alignMap[cols[_i].align];

            if (prevTypeWasAlign) {
              columnLines += "none ";
            }

            prevTypeWasAlign = true;
          } else if (cols[_i].type === "separator") {
            // MathML accepts only single lines between cells.
            // So we read only the first of consecutive separators.
            if (prevTypeWasAlign) {
              columnLines += cols[_i].separator === "|" ? "solid " : "dashed ";
              prevTypeWasAlign = false;
            }
          }
        }

        table.setAttribute("columnalign", align.trim());

        if (/[sd]/.test(columnLines)) {
          table.setAttribute("columnlines", columnLines.trim());
        }
      } // Set column spacing.


      if (group.colSeparationType === "align") {
        var _cols = group.cols || [];

        var spacing = "";

        for (var _i2 = 1; _i2 < _cols.length; _i2++) {
          spacing += _i2 % 2 ? "0em " : "1em ";
        }

        table.setAttribute("columnspacing", spacing.trim());
      } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
        table.setAttribute("columnspacing", "0em");
      } else if (group.colSeparationType === "small") {
        table.setAttribute("columnspacing", "0.2778em");
      } else if (group.colSeparationType === "CD") {
        table.setAttribute("columnspacing", "0.5em");
      } else {
        table.setAttribute("columnspacing", "1em");
      } // Address \hline and \hdashline


      var rowLines = "";
      var hlines = group.hLinesBeforeRow;
      menclose += hlines[0].length > 0 ? "left " : "";
      menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";

      for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {
        rowLines += hlines[_i3].length === 0 ? "none " // MathML accepts only a single line between rows. Read one element.
        : hlines[_i3][0] ? "dashed " : "solid ";
      }

      if (/[sd]/.test(rowLines)) {
        table.setAttribute("rowlines", rowLines.trim());
      }

      if (menclose !== "") {
        table = new mathMLTree.MathNode("menclose", [table]);
        table.setAttribute("notation", menclose.trim());
      }

      if (group.arraystretch && group.arraystretch < 1) {
        // A small array. Wrap in scriptstyle so row gap is not too large.
        table = new mathMLTree.MathNode("mstyle", [table]);
        table.setAttribute("scriptlevel", "1");
      }

      return table;
    }; // Convenience function for align, align*, aligned, alignat, alignat*, alignedat.


    var alignedHandler = function alignedHandler(context, args) {
      if (context.envName.indexOf("ed") === -1) {
        validateAmsEnvironmentContext(context);
      }

      var cols = [];
      var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
      var isSplit = context.envName === "split";
      var res = parseArray(context.parser, {
        cols,
        addJot: true,
        autoTag: isSplit ? undefined : getAutoTag(context.envName),
        emptySingleRow: true,
        colSeparationType: separationType,
        maxNumCols: isSplit ? 2 : undefined,
        leqno: context.parser.settings.leqno
      }, "display"); // Determining number of columns.
      // 1. If the first argument is given, we use it as a number of columns,
      //    and makes sure that each row doesn't exceed that number.
      // 2. Otherwise, just count number of columns = maximum number
      //    of cells in each row ("aligned" mode -- isAligned will be true).
      //
      // At the same time, prepend empty group {} at beginning of every second
      // cell in each row (starting with second cell) so that operators become
      // binary.  This behavior is implemented in amsmath's \start@aligned.

      var numMaths;
      var numCols = 0;
      var emptyGroup = {
        type: "ordgroup",
        mode: context.mode,
        body: []
      };

      if (args[0] && args[0].type === "ordgroup") {
        var arg0 = "";

        for (var i = 0; i < args[0].body.length; i++) {
          var textord = assertNodeType(args[0].body[i], "textord");
          arg0 += textord.text;
        }

        numMaths = Number(arg0);
        numCols = numMaths * 2;
      }

      var isAligned = !numCols;
      res.body.forEach(function (row) {
        for (var _i4 = 1; _i4 < row.length; _i4 += 2) {
          // Modify ordgroup node within styling node
          var styling = assertNodeType(row[_i4], "styling");
          var ordgroup = assertNodeType(styling.body[0], "ordgroup");
          ordgroup.body.unshift(emptyGroup);
        }

        if (!isAligned) {
          // Case 1
          var curMaths = row.length / 2;

          if (numMaths < curMaths) {
            throw new ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
          }
        } else if (numCols < row.length) {
          // Case 2
          numCols = row.length;
        }
      }); // Adjusting alignment.
      // In aligned mode, we add one \qquad between columns;
      // otherwise we add nothing.

      for (var _i5 = 0; _i5 < numCols; ++_i5) {
        var align = "r";
        var pregap = 0;

        if (_i5 % 2 === 1) {
          align = "l";
        } else if (_i5 > 0 && isAligned) {
          // "aligned" mode.
          pregap = 1; // add one \quad
        }

        cols[_i5] = {
          type: "align",
          align: align,
          pregap: pregap,
          postgap: 0
        };
      }

      res.colSeparationType = isAligned ? "align" : "alignat";
      return res;
    }; // Arrays are part of LaTeX, defined in lttab.dtx so its documentation
    // is part of the source2e.pdf file of LaTeX2e source documentation.
    // {darray} is an {array} environment where cells are set in \displaystyle,
    // as defined in nccmath.sty.


    defineEnvironment({
      type: "array",
      names: ["array", "darray"],
      props: {
        numArgs: 1
      },

      handler(context, args) {
        // Since no types are specified above, the two possibilities are
        // - The argument is wrapped in {} or [], in which case Parser's
        //   parseGroup() returns an "ordgroup" wrapping some symbol node.
        // - The argument is a bare symbol node.
        var symNode = checkSymbolNodeType(args[0]);
        var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
        var cols = colalign.map(function (nde) {
          var node = assertSymbolNodeType(nde);
          var ca = node.text;

          if ("lcr".indexOf(ca) !== -1) {
            return {
              type: "align",
              align: ca
            };
          } else if (ca === "|") {
            return {
              type: "separator",
              separator: "|"
            };
          } else if (ca === ":") {
            return {
              type: "separator",
              separator: ":"
            };
          }

          throw new ParseError("Unknown column alignment: " + ca, nde);
        });
        var res = {
          cols,
          hskipBeforeAndAfter: true,
          // \@preamble in lttab.dtx
          maxNumCols: cols.length
        };
        return parseArray(context.parser, res, dCellStyle(context.envName));
      },

      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    }); // The matrix environments of amsmath builds on the array environment
    // of LaTeX, which is discussed above.
    // The mathtools package adds starred versions of the same environments.
    // These have an optional argument to choose left|center|right justification.

    defineEnvironment({
      type: "array",
      names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
      props: {
        numArgs: 0
      },

      handler(context) {
        var delimiters = {
          "matrix": null,
          "pmatrix": ["(", ")"],
          "bmatrix": ["[", "]"],
          "Bmatrix": ["\\{", "\\}"],
          "vmatrix": ["|", "|"],
          "Vmatrix": ["\\Vert", "\\Vert"]
        }[context.envName.replace("*", "")]; // \hskip -\arraycolsep in amsmath

        var colAlign = "c";
        var payload = {
          hskipBeforeAndAfter: false,
          cols: [{
            type: "align",
            align: colAlign
          }]
        };

        if (context.envName.charAt(context.envName.length - 1) === "*") {
          // It's one of the mathtools starred functions.
          // Parse the optional alignment argument.
          var parser = context.parser;
          parser.consumeSpaces();

          if (parser.fetch().text === "[") {
            parser.consume();
            parser.consumeSpaces();
            colAlign = parser.fetch().text;

            if ("lcr".indexOf(colAlign) === -1) {
              throw new ParseError("Expected l or c or r", parser.nextToken);
            }

            parser.consume();
            parser.consumeSpaces();
            parser.expect("]");
            parser.consume();
            payload.cols = [{
              type: "align",
              align: colAlign
            }];
          }
        }

        var res = parseArray(context.parser, payload, dCellStyle(context.envName)); // Populate cols with the correct number of column alignment specs.

        var numCols = Math.max(0, ...res.body.map(row => row.length));
        res.cols = new Array(numCols).fill({
          type: "align",
          align: colAlign
        });
        return delimiters ? {
          type: "leftright",
          mode: context.mode,
          body: [res],
          left: delimiters[0],
          right: delimiters[1],
          rightColor: undefined // \right uninfluenced by \color in array

        } : res;
      },

      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineEnvironment({
      type: "array",
      names: ["smallmatrix"],
      props: {
        numArgs: 0
      },

      handler(context) {
        var payload = {
          arraystretch: 0.5
        };
        var res = parseArray(context.parser, payload, "script");
        res.colSeparationType = "small";
        return res;
      },

      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineEnvironment({
      type: "array",
      names: ["subarray"],
      props: {
        numArgs: 1
      },

      handler(context, args) {
        // Parsing of {subarray} is similar to {array}
        var symNode = checkSymbolNodeType(args[0]);
        var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
        var cols = colalign.map(function (nde) {
          var node = assertSymbolNodeType(nde);
          var ca = node.text; // {subarray} only recognizes "l" & "c"

          if ("lc".indexOf(ca) !== -1) {
            return {
              type: "align",
              align: ca
            };
          }

          throw new ParseError("Unknown column alignment: " + ca, nde);
        });

        if (cols.length > 1) {
          throw new ParseError("{subarray} can contain only one column");
        }

        var res = {
          cols,
          hskipBeforeAndAfter: false,
          arraystretch: 0.5
        };
        res = parseArray(context.parser, res, "script");

        if (res.body.length > 0 && res.body[0].length > 1) {
          throw new ParseError("{subarray} can contain only one column");
        }

        return res;
      },

      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    }); // A cases environment (in amsmath.sty) is almost equivalent to
    // \def\arraystretch{1.2}%
    // \left\{\begin{array}{@{}l@{\quad}l@{}}  \end{array}\right.
    // {dcases} is a {cases} environment where cells are set in \displaystyle,
    // as defined in mathtools.sty.
    // {rcases} is another mathtools environment. It's brace is on the right side.

    defineEnvironment({
      type: "array",
      names: ["cases", "dcases", "rcases", "drcases"],
      props: {
        numArgs: 0
      },

      handler(context) {
        var payload = {
          arraystretch: 1.2,
          cols: [{
            type: "align",
            align: "l",
            pregap: 0,
            // TODO(kevinb) get the current style.
            // For now we use the metrics for TEXT style which is what we were
            // doing before.  Before attempting to get the current style we
            // should look at TeX's behavior especially for \over and matrices.
            postgap: 1.0
            /* 1em quad */

          }, {
            type: "align",
            align: "l",
            pregap: 0,
            postgap: 0
          }]
        };
        var res = parseArray(context.parser, payload, dCellStyle(context.envName));
        return {
          type: "leftright",
          mode: context.mode,
          body: [res],
          left: context.envName.indexOf("r") > -1 ? "." : "\\{",
          right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
          rightColor: undefined
        };
      },

      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    }); // In the align environment, one uses ampersands, &, to specify number of
    // columns in each row, and to locate spacing between each column.
    // align gets automatic numbering. align* and aligned do not.
    // The alignedat environment can be used in math mode.
    // Note that we assume \nomallineskiplimit to be zero,
    // so that \strut@ is the same as \strut.

    defineEnvironment({
      type: "array",
      names: ["align", "align*", "aligned", "split"],
      props: {
        numArgs: 0
      },
      handler: alignedHandler,
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    }); // A gathered environment is like an array environment with one centered
    // column, but where rows are considered lines so get \jot line spacing
    // and contents are set in \displaystyle.

    defineEnvironment({
      type: "array",
      names: ["gathered", "gather", "gather*"],
      props: {
        numArgs: 0
      },

      handler(context) {
        if (["gather", "gather*"].includes(context.envName)) {
          validateAmsEnvironmentContext(context);
        }

        var res = {
          cols: [{
            type: "align",
            align: "c"
          }],
          addJot: true,
          colSeparationType: "gather",
          autoTag: getAutoTag(context.envName),
          emptySingleRow: true,
          leqno: context.parser.settings.leqno
        };
        return parseArray(context.parser, res, "display");
      },

      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    }); // alignat environment is like an align environment, but one must explicitly
    // specify maximum number of columns in each row, and can adjust spacing between
    // each columns.

    defineEnvironment({
      type: "array",
      names: ["alignat", "alignat*", "alignedat"],
      props: {
        numArgs: 1
      },
      handler: alignedHandler,
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineEnvironment({
      type: "array",
      names: ["equation", "equation*"],
      props: {
        numArgs: 0
      },

      handler(context) {
        validateAmsEnvironmentContext(context);
        var res = {
          autoTag: getAutoTag(context.envName),
          emptySingleRow: true,
          singleRow: true,
          maxNumCols: 1,
          leqno: context.parser.settings.leqno
        };
        return parseArray(context.parser, res, "display");
      },

      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineEnvironment({
      type: "array",
      names: ["CD"],
      props: {
        numArgs: 0
      },

      handler(context) {
        validateAmsEnvironmentContext(context);
        return parseCD(context.parser);
      },

      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$5
    });
    defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
    defineMacro("\\notag", "\\nonumber"); // Catch \hline outside array environment

    defineFunction({
      type: "text",
      // Doesn't matter what this is.
      names: ["\\hline", "\\hdashline"],
      props: {
        numArgs: 0,
        allowedInText: true,
        allowedInMath: true
      },

      handler(context, args) {
        throw new ParseError(context.funcName + " valid only within array environment");
      }

    });

    var environments = _environments;

    // defineEnvironment definitions.

    defineFunction({
      type: "environment",
      names: ["\\begin", "\\end"],
      props: {
        numArgs: 1,
        argTypes: ["text"]
      },

      handler(_ref, args) {
        var {
          parser,
          funcName
        } = _ref;
        var nameGroup = args[0];

        if (nameGroup.type !== "ordgroup") {
          throw new ParseError("Invalid environment name", nameGroup);
        }

        var envName = "";

        for (var i = 0; i < nameGroup.body.length; ++i) {
          envName += assertNodeType(nameGroup.body[i], "textord").text;
        }

        if (funcName === "\\begin") {
          // begin...end is similar to left...right
          if (!environments.hasOwnProperty(envName)) {
            throw new ParseError("No such environment: " + envName, nameGroup);
          } // Build the environment object. Arguments and other information will
          // be made available to the begin and end methods using properties.


          var env = environments[envName];
          var {
            args: _args,
            optArgs
          } = parser.parseArguments("\\begin{" + envName + "}", env);
          var context = {
            mode: parser.mode,
            envName,
            parser
          };
          var result = env.handler(context, _args, optArgs);
          parser.expect("\\end", false);
          var endNameToken = parser.nextToken;
          var end = assertNodeType(parser.parseFunction(), "environment");

          if (end.name !== envName) {
            throw new ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
          } // $FlowFixMe, "environment" handler returns an environment ParseNode


          return result;
        }

        return {
          type: "environment",
          mode: parser.mode,
          name: envName,
          nameGroup
        };
      }

    });

    // TODO(kevinb): implement \\sl and \\sc

    var htmlBuilder$5 = (group, options) => {
      var font = group.font;
      var newOptions = options.withFont(font);
      return buildGroup$1(group.body, newOptions);
    };

    var mathmlBuilder$4 = (group, options) => {
      var font = group.font;
      var newOptions = options.withFont(font);
      return buildGroup(group.body, newOptions);
    };

    var fontAliases = {
      "\\Bbb": "\\mathbb",
      "\\bold": "\\mathbf",
      "\\frak": "\\mathfrak",
      "\\bm": "\\boldsymbol"
    };
    defineFunction({
      type: "font",
      names: [// styles, except \boldsymbol defined below
      "\\mathrm", "\\mathit", "\\mathbf", "\\mathnormal", "\\mathsfit", // families
      "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf", "\\mathtt", // aliases, except \bm defined below
      "\\Bbb", "\\bold", "\\frak"],
      props: {
        numArgs: 1,
        allowedInArgument: true
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName
        } = _ref;
        var body = normalizeArgument(args[0]);
        var func = funcName;

        if (func in fontAliases) {
          func = fontAliases[func];
        }

        return {
          type: "font",
          mode: parser.mode,
          font: func.slice(1),
          body
        };
      },
      htmlBuilder: htmlBuilder$5,
      mathmlBuilder: mathmlBuilder$4
    });
    defineFunction({
      type: "mclass",
      names: ["\\boldsymbol", "\\bm"],
      props: {
        numArgs: 1
      },
      handler: (_ref2, args) => {
        var {
          parser
        } = _ref2;
        var body = args[0];
        var isCharacterBox = utils.isCharacterBox(body); // amsbsy.sty's \boldsymbol uses \binrel spacing to inherit the
        // argument's bin|rel|ord status

        return {
          type: "mclass",
          mode: parser.mode,
          mclass: binrelClass(body),
          body: [{
            type: "font",
            mode: parser.mode,
            font: "boldsymbol",
            body
          }],
          isCharacterBox: isCharacterBox
        };
      }
    }); // Old font changing functions

    defineFunction({
      type: "font",
      names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
      props: {
        numArgs: 0,
        allowedInText: true
      },
      handler: (_ref3, args) => {
        var {
          parser,
          funcName,
          breakOnTokenText
        } = _ref3;
        var {
          mode
        } = parser;
        var body = parser.parseExpression(true, breakOnTokenText);
        var style = "math" + funcName.slice(1);
        return {
          type: "font",
          mode: mode,
          font: style,
          body: {
            type: "ordgroup",
            mode: parser.mode,
            body
          }
        };
      },
      htmlBuilder: htmlBuilder$5,
      mathmlBuilder: mathmlBuilder$4
    });

    var adjustStyle = (size, originalStyle) => {
      // Figure out what style this fraction should be in based on the
      // function used
      var style = originalStyle;

      if (size === "display") {
        // Get display style as a default.
        // If incoming style is sub/sup, use style.text() to get correct size.
        style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;
      } else if (size === "text" && style.size === Style$1.DISPLAY.size) {
        // We're in a \tfrac but incoming style is displaystyle, so:
        style = Style$1.TEXT;
      } else if (size === "script") {
        style = Style$1.SCRIPT;
      } else if (size === "scriptscript") {
        style = Style$1.SCRIPTSCRIPT;
      }

      return style;
    };

    var htmlBuilder$4 = (group, options) => {
      // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
      var style = adjustStyle(group.size, options.style);
      var nstyle = style.fracNum();
      var dstyle = style.fracDen();
      var newOptions;
      newOptions = options.havingStyle(nstyle);
      var numerm = buildGroup$1(group.numer, newOptions, options);

      if (group.continued) {
        // \cfrac inserts a \strut into the numerator.
        // Get \strut dimensions from TeXbook page 353.
        var hStrut = 8.5 / options.fontMetrics().ptPerEm;
        var dStrut = 3.5 / options.fontMetrics().ptPerEm;
        numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
        numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
      }

      newOptions = options.havingStyle(dstyle);
      var denomm = buildGroup$1(group.denom, newOptions, options);
      var rule;
      var ruleWidth;
      var ruleSpacing;

      if (group.hasBarLine) {
        if (group.barSize) {
          ruleWidth = calculateSize(group.barSize, options);
          rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
        } else {
          rule = buildCommon.makeLineSpan("frac-line", options);
        }

        ruleWidth = rule.height;
        ruleSpacing = rule.height;
      } else {
        rule = null;
        ruleWidth = 0;
        ruleSpacing = options.fontMetrics().defaultRuleThickness;
      } // Rule 15b


      var numShift;
      var clearance;
      var denomShift;

      if (style.size === Style$1.DISPLAY.size || group.size === "display") {
        numShift = options.fontMetrics().num1;

        if (ruleWidth > 0) {
          clearance = 3 * ruleSpacing;
        } else {
          clearance = 7 * ruleSpacing;
        }

        denomShift = options.fontMetrics().denom1;
      } else {
        if (ruleWidth > 0) {
          numShift = options.fontMetrics().num2;
          clearance = ruleSpacing;
        } else {
          numShift = options.fontMetrics().num3;
          clearance = 3 * ruleSpacing;
        }

        denomShift = options.fontMetrics().denom2;
      }

      var frac;

      if (!rule) {
        // Rule 15c
        var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);

        if (candidateClearance < clearance) {
          numShift += 0.5 * (clearance - candidateClearance);
          denomShift += 0.5 * (clearance - candidateClearance);
        }

        frac = buildCommon.makeVList({
          positionType: "individualShift",
          children: [{
            type: "elem",
            elem: denomm,
            shift: denomShift
          }, {
            type: "elem",
            elem: numerm,
            shift: -numShift
          }]
        }, options);
      } else {
        // Rule 15d
        var axisHeight = options.fontMetrics().axisHeight;

        if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
          numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
        }

        if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
          denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
        }

        var midShift = -(axisHeight - 0.5 * ruleWidth);
        frac = buildCommon.makeVList({
          positionType: "individualShift",
          children: [{
            type: "elem",
            elem: denomm,
            shift: denomShift
          }, {
            type: "elem",
            elem: rule,
            shift: midShift
          }, {
            type: "elem",
            elem: numerm,
            shift: -numShift
          }]
        }, options);
      } // Since we manually change the style sometimes (with \dfrac or \tfrac),
      // account for the possible size change here.


      newOptions = options.havingStyle(style);
      frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
      frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier; // Rule 15e

      var delimSize;

      if (style.size === Style$1.DISPLAY.size) {
        delimSize = options.fontMetrics().delim1;
      } else if (style.size === Style$1.SCRIPTSCRIPT.size) {
        delimSize = options.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
      } else {
        delimSize = options.fontMetrics().delim2;
      }

      var leftDelim;
      var rightDelim;

      if (group.leftDelim == null) {
        leftDelim = makeNullDelimiter(options, ["mopen"]);
      } else {
        leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
      }

      if (group.continued) {
        rightDelim = buildCommon.makeSpan([]); // zero width for \cfrac
      } else if (group.rightDelim == null) {
        rightDelim = makeNullDelimiter(options, ["mclose"]);
      } else {
        rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
      }

      return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
    };

    var mathmlBuilder$3 = (group, options) => {
      var node = new mathMLTree.MathNode("mfrac", [buildGroup(group.numer, options), buildGroup(group.denom, options)]);

      if (!group.hasBarLine) {
        node.setAttribute("linethickness", "0px");
      } else if (group.barSize) {
        var ruleWidth = calculateSize(group.barSize, options);
        node.setAttribute("linethickness", makeEm(ruleWidth));
      }

      var style = adjustStyle(group.size, options.style);

      if (style.size !== options.style.size) {
        node = new mathMLTree.MathNode("mstyle", [node]);
        var isDisplay = style.size === Style$1.DISPLAY.size ? "true" : "false";
        node.setAttribute("displaystyle", isDisplay);
        node.setAttribute("scriptlevel", "0");
      }

      if (group.leftDelim != null || group.rightDelim != null) {
        var withDelims = [];

        if (group.leftDelim != null) {
          var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
          leftOp.setAttribute("fence", "true");
          withDelims.push(leftOp);
        }

        withDelims.push(node);

        if (group.rightDelim != null) {
          var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
          rightOp.setAttribute("fence", "true");
          withDelims.push(rightOp);
        }

        return makeRow(withDelims);
      }

      return node;
    };

    defineFunction({
      type: "genfrac",
      names: ["\\dfrac", "\\frac", "\\tfrac", "\\dbinom", "\\binom", "\\tbinom", "\\\\atopfrac", // cant be entered directly
      "\\\\bracefrac", "\\\\brackfrac" // ditto
      ],
      props: {
        numArgs: 2,
        allowedInArgument: true
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName
        } = _ref;
        var numer = args[0];
        var denom = args[1];
        var hasBarLine;
        var leftDelim = null;
        var rightDelim = null;
        var size = "auto";

        switch (funcName) {
          case "\\dfrac":
          case "\\frac":
          case "\\tfrac":
            hasBarLine = true;
            break;

          case "\\\\atopfrac":
            hasBarLine = false;
            break;

          case "\\dbinom":
          case "\\binom":
          case "\\tbinom":
            hasBarLine = false;
            leftDelim = "(";
            rightDelim = ")";
            break;

          case "\\\\bracefrac":
            hasBarLine = false;
            leftDelim = "\\{";
            rightDelim = "\\}";
            break;

          case "\\\\brackfrac":
            hasBarLine = false;
            leftDelim = "[";
            rightDelim = "]";
            break;

          default:
            throw new Error("Unrecognized genfrac command");
        }

        switch (funcName) {
          case "\\dfrac":
          case "\\dbinom":
            size = "display";
            break;

          case "\\tfrac":
          case "\\tbinom":
            size = "text";
            break;
        }

        return {
          type: "genfrac",
          mode: parser.mode,
          continued: false,
          numer,
          denom,
          hasBarLine,
          leftDelim,
          rightDelim,
          size,
          barSize: null
        };
      },
      htmlBuilder: htmlBuilder$4,
      mathmlBuilder: mathmlBuilder$3
    });
    defineFunction({
      type: "genfrac",
      names: ["\\cfrac"],
      props: {
        numArgs: 2
      },
      handler: (_ref2, args) => {
        var {
          parser,
          funcName
        } = _ref2;
        var numer = args[0];
        var denom = args[1];
        return {
          type: "genfrac",
          mode: parser.mode,
          continued: true,
          numer,
          denom,
          hasBarLine: true,
          leftDelim: null,
          rightDelim: null,
          size: "display",
          barSize: null
        };
      }
    }); // Infix generalized fractions -- these are not rendered directly, but replaced
    // immediately by one of the variants above.

    defineFunction({
      type: "infix",
      names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
      props: {
        numArgs: 0,
        infix: true
      },

      handler(_ref3) {
        var {
          parser,
          funcName,
          token
        } = _ref3;
        var replaceWith;

        switch (funcName) {
          case "\\over":
            replaceWith = "\\frac";
            break;

          case "\\choose":
            replaceWith = "\\binom";
            break;

          case "\\atop":
            replaceWith = "\\\\atopfrac";
            break;

          case "\\brace":
            replaceWith = "\\\\bracefrac";
            break;

          case "\\brack":
            replaceWith = "\\\\brackfrac";
            break;

          default:
            throw new Error("Unrecognized infix genfrac command");
        }

        return {
          type: "infix",
          mode: parser.mode,
          replaceWith,
          token
        };
      }

    });
    var stylArray = ["display", "text", "script", "scriptscript"];

    var delimFromValue = function delimFromValue(delimString) {
      var delim = null;

      if (delimString.length > 0) {
        delim = delimString;
        delim = delim === "." ? null : delim;
      }

      return delim;
    };

    defineFunction({
      type: "genfrac",
      names: ["\\genfrac"],
      props: {
        numArgs: 6,
        allowedInArgument: true,
        argTypes: ["math", "math", "size", "text", "math", "math"]
      },

      handler(_ref4, args) {
        var {
          parser
        } = _ref4;
        var numer = args[4];
        var denom = args[5]; // Look into the parse nodes to get the desired delimiters.

        var leftNode = normalizeArgument(args[0]);
        var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
        var rightNode = normalizeArgument(args[1]);
        var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
        var barNode = assertNodeType(args[2], "size");
        var hasBarLine;
        var barSize = null;

        if (barNode.isBlank) {
          // \genfrac acts differently than \above.
          // \genfrac treats an empty size group as a signal to use a
          // standard bar size. \above would see size = 0 and omit the bar.
          hasBarLine = true;
        } else {
          barSize = barNode.value;
          hasBarLine = barSize.number > 0;
        } // Find out if we want displaystyle, textstyle, etc.


        var size = "auto";
        var styl = args[3];

        if (styl.type === "ordgroup") {
          if (styl.body.length > 0) {
            var textOrd = assertNodeType(styl.body[0], "textord");
            size = stylArray[Number(textOrd.text)];
          }
        } else {
          styl = assertNodeType(styl, "textord");
          size = stylArray[Number(styl.text)];
        }

        return {
          type: "genfrac",
          mode: parser.mode,
          numer,
          denom,
          continued: false,
          hasBarLine,
          barSize,
          leftDelim,
          rightDelim,
          size
        };
      },

      htmlBuilder: htmlBuilder$4,
      mathmlBuilder: mathmlBuilder$3
    }); // \above is an infix fraction that also defines a fraction bar size.

    defineFunction({
      type: "infix",
      names: ["\\above"],
      props: {
        numArgs: 1,
        argTypes: ["size"],
        infix: true
      },

      handler(_ref5, args) {
        var {
          parser,
          funcName,
          token
        } = _ref5;
        return {
          type: "infix",
          mode: parser.mode,
          replaceWith: "\\\\abovefrac",
          size: assertNodeType(args[0], "size").value,
          token
        };
      }

    });
    defineFunction({
      type: "genfrac",
      names: ["\\\\abovefrac"],
      props: {
        numArgs: 3,
        argTypes: ["math", "size", "math"]
      },
      handler: (_ref6, args) => {
        var {
          parser,
          funcName
        } = _ref6;
        var numer = args[0];
        var barSize = assert(assertNodeType(args[1], "infix").size);
        var denom = args[2];
        var hasBarLine = barSize.number > 0;
        return {
          type: "genfrac",
          mode: parser.mode,
          numer,
          denom,
          continued: false,
          hasBarLine,
          barSize,
          leftDelim: null,
          rightDelim: null,
          size: "auto"
        };
      },
      htmlBuilder: htmlBuilder$4,
      mathmlBuilder: mathmlBuilder$3
    });

    // NOTE: Unlike most `htmlBuilder`s, this one handles not only "horizBrace", but
    // also "supsub" since an over/underbrace can affect super/subscripting.
    var htmlBuilder$3 = (grp, options) => {
      var style = options.style; // Pull out the `ParseNode<"horizBrace">` if `grp` is a "supsub" node.

      var supSubGroup;
      var group;

      if (grp.type === "supsub") {
        // Ref: LaTeX source2e: }}}}\limits}
        // i.e. LaTeX treats the brace similar to an op and passes it
        // with \limits, so we need to assign supsub style.
        supSubGroup = grp.sup ? buildGroup$1(grp.sup, options.havingStyle(style.sup()), options) : buildGroup$1(grp.sub, options.havingStyle(style.sub()), options);
        group = assertNodeType(grp.base, "horizBrace");
      } else {
        group = assertNodeType(grp, "horizBrace");
      } // Build the base group


      var body = buildGroup$1(group.base, options.havingBaseStyle(Style$1.DISPLAY)); // Create the stretchy element

      var braceBody = stretchy.svgSpan(group, options); // Generate the vlist, with the appropriate kerns        
      // This first vlist contains the content and the brace:   equation

      var vlist;

      if (group.isOver) {
        vlist = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: body
          }, {
            type: "kern",
            size: 0.1
          }, {
            type: "elem",
            elem: braceBody
          }]
        }, options); // $FlowFixMe: Replace this with passing "svg-align" into makeVList.

        vlist.children[0].children[0].children[1].classes.push("svg-align");
      } else {
        vlist = buildCommon.makeVList({
          positionType: "bottom",
          positionData: body.depth + 0.1 + braceBody.height,
          children: [{
            type: "elem",
            elem: braceBody
          }, {
            type: "kern",
            size: 0.1
          }, {
            type: "elem",
            elem: body
          }]
        }, options); // $FlowFixMe: Replace this with passing "svg-align" into makeVList.

        vlist.children[0].children[0].children[0].classes.push("svg-align");
      }

      if (supSubGroup) {
        // To write the supsub, wrap the first vlist in another vlist:
        // They can't all go in the same vlist, because the note might be
        // wider than the equation. We want the equation to control the
        // brace width.
        //      note          long note           long note
        //      or         not    
        //    equation           eqn                 eqn
        var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);

        if (group.isOver) {
          vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: vSpan
            }, {
              type: "kern",
              size: 0.2
            }, {
              type: "elem",
              elem: supSubGroup
            }]
          }, options);
        } else {
          vlist = buildCommon.makeVList({
            positionType: "bottom",
            positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
            children: [{
              type: "elem",
              elem: supSubGroup
            }, {
              type: "kern",
              size: 0.2
            }, {
              type: "elem",
              elem: vSpan
            }]
          }, options);
        }
      }

      return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
    };

    var mathmlBuilder$2 = (group, options) => {
      var accentNode = stretchy.mathMLnode(group.label);
      return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup(group.base, options), accentNode]);
    }; // Horizontal stretchy braces


    defineFunction({
      type: "horizBrace",
      names: ["\\overbrace", "\\underbrace"],
      props: {
        numArgs: 1
      },

      handler(_ref, args) {
        var {
          parser,
          funcName
        } = _ref;
        return {
          type: "horizBrace",
          mode: parser.mode,
          label: funcName,
          isOver: /^\\over/.test(funcName),
          base: args[0]
        };
      },

      htmlBuilder: htmlBuilder$3,
      mathmlBuilder: mathmlBuilder$2
    });

    defineFunction({
      type: "href",
      names: ["\\href"],
      props: {
        numArgs: 2,
        argTypes: ["url", "original"],
        allowedInText: true
      },
      handler: (_ref, args) => {
        var {
          parser
        } = _ref;
        var body = args[1];
        var href = assertNodeType(args[0], "url").url;

        if (!parser.settings.isTrusted({
          command: "\\href",
          url: href
        })) {
          return parser.formatUnsupportedCmd("\\href");
        }

        return {
          type: "href",
          mode: parser.mode,
          href,
          body: ordargument(body)
        };
      },
      htmlBuilder: (group, options) => {
        var elements = buildExpression$1(group.body, options, false);
        return buildCommon.makeAnchor(group.href, [], elements, options);
      },
      mathmlBuilder: (group, options) => {
        var math = buildExpressionRow(group.body, options);

        if (!(math instanceof MathNode)) {
          math = new MathNode("mrow", [math]);
        }

        math.setAttribute("href", group.href);
        return math;
      }
    });
    defineFunction({
      type: "href",
      names: ["\\url"],
      props: {
        numArgs: 1,
        argTypes: ["url"],
        allowedInText: true
      },
      handler: (_ref2, args) => {
        var {
          parser
        } = _ref2;
        var href = assertNodeType(args[0], "url").url;

        if (!parser.settings.isTrusted({
          command: "\\url",
          url: href
        })) {
          return parser.formatUnsupportedCmd("\\url");
        }

        var chars = [];

        for (var i = 0; i < href.length; i++) {
          var c = href[i];

          if (c === "~") {
            c = "\\textasciitilde";
          }

          chars.push({
            type: "textord",
            mode: "text",
            text: c
          });
        }

        var body = {
          type: "text",
          mode: parser.mode,
          font: "\\texttt",
          body: chars
        };
        return {
          type: "href",
          mode: parser.mode,
          href,
          body: ordargument(body)
        };
      }
    });

    // In LaTeX, \vcenter can act only on a box, as in
    // \vcenter{\hbox{$\frac{a+b}{\dfrac{c}{d}}$}}
    // This function by itself doesn't do anything but prevent a soft line break.

    defineFunction({
      type: "hbox",
      names: ["\\hbox"],
      props: {
        numArgs: 1,
        argTypes: ["text"],
        allowedInText: true,
        primitive: true
      },

      handler(_ref, args) {
        var {
          parser
        } = _ref;
        return {
          type: "hbox",
          mode: parser.mode,
          body: ordargument(args[0])
        };
      },

      htmlBuilder(group, options) {
        var elements = buildExpression$1(group.body, options, false);
        return buildCommon.makeFragment(elements);
      },

      mathmlBuilder(group, options) {
        return new mathMLTree.MathNode("mrow", buildExpression(group.body, options));
      }

    });

    defineFunction({
      type: "html",
      names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
      props: {
        numArgs: 2,
        argTypes: ["raw", "original"],
        allowedInText: true
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName,
          token
        } = _ref;
        var value = assertNodeType(args[0], "raw").string;
        var body = args[1];

        if (parser.settings.strict) {
          parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
        }

        var trustContext;
        var attributes = {};

        switch (funcName) {
          case "\\htmlClass":
            attributes.class = value;
            trustContext = {
              command: "\\htmlClass",
              class: value
            };
            break;

          case "\\htmlId":
            attributes.id = value;
            trustContext = {
              command: "\\htmlId",
              id: value
            };
            break;

          case "\\htmlStyle":
            attributes.style = value;
            trustContext = {
              command: "\\htmlStyle",
              style: value
            };
            break;

          case "\\htmlData":
            {
              var data = value.split(",");

              for (var i = 0; i < data.length; i++) {
                var keyVal = data[i].split("=");

                if (keyVal.length !== 2) {
                  throw new ParseError("Error parsing key-value for \\htmlData");
                }

                attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
              }

              trustContext = {
                command: "\\htmlData",
                attributes
              };
              break;
            }

          default:
            throw new Error("Unrecognized html command");
        }

        if (!parser.settings.isTrusted(trustContext)) {
          return parser.formatUnsupportedCmd(funcName);
        }

        return {
          type: "html",
          mode: parser.mode,
          attributes,
          body: ordargument(body)
        };
      },
      htmlBuilder: (group, options) => {
        var elements = buildExpression$1(group.body, options, false);
        var classes = ["enclosing"];

        if (group.attributes.class) {
          classes.push(...group.attributes.class.trim().split(/\s+/));
        }

        var span = buildCommon.makeSpan(classes, elements, options);

        for (var attr in group.attributes) {
          if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
            span.setAttribute(attr, group.attributes[attr]);
          }
        }

        return span;
      },
      mathmlBuilder: (group, options) => {
        return buildExpressionRow(group.body, options);
      }
    });

    defineFunction({
      type: "htmlmathml",
      names: ["\\html@mathml"],
      props: {
        numArgs: 2,
        allowedInText: true
      },
      handler: (_ref, args) => {
        var {
          parser
        } = _ref;
        return {
          type: "htmlmathml",
          mode: parser.mode,
          html: ordargument(args[0]),
          mathml: ordargument(args[1])
        };
      },
      htmlBuilder: (group, options) => {
        var elements = buildExpression$1(group.html, options, false);
        return buildCommon.makeFragment(elements);
      },
      mathmlBuilder: (group, options) => {
        return buildExpressionRow(group.mathml, options);
      }
    });

    var sizeData = function sizeData(str) {
      if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
        // str is a number with no unit specified.
        // default unit is bp, per graphix package.
        return {
          number: +str,
          unit: "bp"
        };
      } else {
        var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);

        if (!match) {
          throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
        }

        var data = {
          number: +(match[1] + match[2]),
          // sign + magnitude, cast to number
          unit: match[3]
        };

        if (!validUnit(data)) {
          throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
        }

        return data;
      }
    };

    defineFunction({
      type: "includegraphics",
      names: ["\\includegraphics"],
      props: {
        numArgs: 1,
        numOptionalArgs: 1,
        argTypes: ["raw", "url"],
        allowedInText: false
      },
      handler: (_ref, args, optArgs) => {
        var {
          parser
        } = _ref;
        var width = {
          number: 0,
          unit: "em"
        };
        var height = {
          number: 0.9,
          unit: "em"
        }; // sorta character sized.

        var totalheight = {
          number: 0,
          unit: "em"
        };
        var alt = "";

        if (optArgs[0]) {
          var attributeStr = assertNodeType(optArgs[0], "raw").string; // Parser.js does not parse key/value pairs. We get a string.

          var attributes = attributeStr.split(",");

          for (var i = 0; i < attributes.length; i++) {
            var keyVal = attributes[i].split("=");

            if (keyVal.length === 2) {
              var str = keyVal[1].trim();

              switch (keyVal[0].trim()) {
                case "alt":
                  alt = str;
                  break;

                case "width":
                  width = sizeData(str);
                  break;

                case "height":
                  height = sizeData(str);
                  break;

                case "totalheight":
                  totalheight = sizeData(str);
                  break;

                default:
                  throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
              }
            }
          }
        }

        var src = assertNodeType(args[0], "url").url;

        if (alt === "") {
          // No alt given. Use the file name. Strip away the path.
          alt = src;
          alt = alt.replace(/^.*[\\/]/, '');
          alt = alt.substring(0, alt.lastIndexOf('.'));
        }

        if (!parser.settings.isTrusted({
          command: "\\includegraphics",
          url: src
        })) {
          return parser.formatUnsupportedCmd("\\includegraphics");
        }

        return {
          type: "includegraphics",
          mode: parser.mode,
          alt: alt,
          width: width,
          height: height,
          totalheight: totalheight,
          src: src
        };
      },
      htmlBuilder: (group, options) => {
        var height = calculateSize(group.height, options);
        var depth = 0;

        if (group.totalheight.number > 0) {
          depth = calculateSize(group.totalheight, options) - height;
        }

        var width = 0;

        if (group.width.number > 0) {
          width = calculateSize(group.width, options);
        }

        var style = {
          height: makeEm(height + depth)
        };

        if (width > 0) {
          style.width = makeEm(width);
        }

        if (depth > 0) {
          style.verticalAlign = makeEm(-depth);
        }

        var node = new Img(group.src, group.alt, style);
        node.height = height;
        node.depth = depth;
        return node;
      },
      mathmlBuilder: (group, options) => {
        var node = new mathMLTree.MathNode("mglyph", []);
        node.setAttribute("alt", group.alt);
        var height = calculateSize(group.height, options);
        var depth = 0;

        if (group.totalheight.number > 0) {
          depth = calculateSize(group.totalheight, options) - height;
          node.setAttribute("valign", makeEm(-depth));
        }

        node.setAttribute("height", makeEm(height + depth));

        if (group.width.number > 0) {
          var width = calculateSize(group.width, options);
          node.setAttribute("width", makeEm(width));
        }

        node.setAttribute("src", group.src);
        return node;
      }
    });

    // Horizontal spacing commands

    defineFunction({
      type: "kern",
      names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
      props: {
        numArgs: 1,
        argTypes: ["size"],
        primitive: true,
        allowedInText: true
      },

      handler(_ref, args) {
        var {
          parser,
          funcName
        } = _ref;
        var size = assertNodeType(args[0], "size");

        if (parser.settings.strict) {
          var mathFunction = funcName[1] === 'm'; // \mkern, \mskip

          var muUnit = size.value.unit === 'mu';

          if (mathFunction) {
            if (!muUnit) {
              parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
            }

            if (parser.mode !== "math") {
              parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
            }
          } else {
            // !mathFunction
            if (muUnit) {
              parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
            }
          }
        }

        return {
          type: "kern",
          mode: parser.mode,
          dimension: size.value
        };
      },

      htmlBuilder(group, options) {
        return buildCommon.makeGlue(group.dimension, options);
      },

      mathmlBuilder(group, options) {
        var dimension = calculateSize(group.dimension, options);
        return new mathMLTree.SpaceNode(dimension);
      }

    });

    // Horizontal overlap functions
    defineFunction({
      type: "lap",
      names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName
        } = _ref;
        var body = args[0];
        return {
          type: "lap",
          mode: parser.mode,
          alignment: funcName.slice(5),
          body
        };
      },
      htmlBuilder: (group, options) => {
        // mathllap, mathrlap, mathclap
        var inner;

        if (group.alignment === "clap") {
          // ref: https://www.math.lsu.edu/~aperlis/publications/mathclap/
          inner = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]); // wrap, since CSS will center a .clap > .inner > span

          inner = buildCommon.makeSpan(["inner"], [inner], options);
        } else {
          inner = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options)]);
        }

        var fix = buildCommon.makeSpan(["fix"], []);
        var node = buildCommon.makeSpan([group.alignment], [inner, fix], options); // At this point, we have correctly set horizontal alignment of the
        // two items involved in the lap.
        // Next, use a strut to set the height of the HTML bounding box.
        // Otherwise, a tall argument may be misplaced.
        // This code resolved issue #1153

        var strut = buildCommon.makeSpan(["strut"]);
        strut.style.height = makeEm(node.height + node.depth);

        if (node.depth) {
          strut.style.verticalAlign = makeEm(-node.depth);
        }

        node.children.unshift(strut); // Next, prevent vertical misplacement when next to something tall.
        // This code resolves issue #1234

        node = buildCommon.makeSpan(["thinbox"], [node], options);
        return buildCommon.makeSpan(["mord", "vbox"], [node], options);
      },
      mathmlBuilder: (group, options) => {
        // mathllap, mathrlap, mathclap
        var node = new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options)]);

        if (group.alignment !== "rlap") {
          var offset = group.alignment === "llap" ? "-1" : "-0.5";
          node.setAttribute("lspace", offset + "width");
        }

        node.setAttribute("width", "0px");
        return node;
      }
    });

    defineFunction({
      type: "styling",
      names: ["\\(", "$"],
      props: {
        numArgs: 0,
        allowedInText: true,
        allowedInMath: false
      },

      handler(_ref, args) {
        var {
          funcName,
          parser
        } = _ref;
        var outerMode = parser.mode;
        parser.switchMode("math");
        var close = funcName === "\\(" ? "\\)" : "$";
        var body = parser.parseExpression(false, close);
        parser.expect(close);
        parser.switchMode(outerMode);
        return {
          type: "styling",
          mode: parser.mode,
          style: "text",
          body
        };
      }

    }); // Check for extra closing math delimiters

    defineFunction({
      type: "text",
      // Doesn't matter what this is.
      names: ["\\)", "\\]"],
      props: {
        numArgs: 0,
        allowedInText: true,
        allowedInMath: false
      },

      handler(context, args) {
        throw new ParseError("Mismatched " + context.funcName);
      }

    });

    var chooseMathStyle = (group, options) => {
      switch (options.style.size) {
        case Style$1.DISPLAY.size:
          return group.display;

        case Style$1.TEXT.size:
          return group.text;

        case Style$1.SCRIPT.size:
          return group.script;

        case Style$1.SCRIPTSCRIPT.size:
          return group.scriptscript;

        default:
          return group.text;
      }
    };

    defineFunction({
      type: "mathchoice",
      names: ["\\mathchoice"],
      props: {
        numArgs: 4,
        primitive: true
      },
      handler: (_ref, args) => {
        var {
          parser
        } = _ref;
        return {
          type: "mathchoice",
          mode: parser.mode,
          display: ordargument(args[0]),
          text: ordargument(args[1]),
          script: ordargument(args[2]),
          scriptscript: ordargument(args[3])
        };
      },
      htmlBuilder: (group, options) => {
        var body = chooseMathStyle(group, options);
        var elements = buildExpression$1(body, options, false);
        return buildCommon.makeFragment(elements);
      },
      mathmlBuilder: (group, options) => {
        var body = chooseMathStyle(group, options);
        return buildExpressionRow(body, options);
      }
    });

    var assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {
      base = buildCommon.makeSpan([], [base]);
      var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
      var sub;
      var sup; // We manually have to handle the superscripts and subscripts. This,
      // aside from the kern calculations, is copied from supsub.

      if (supGroup) {
        var elem = buildGroup$1(supGroup, options.havingStyle(style.sup()), options);
        sup = {
          elem,
          kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
        };
      }

      if (subGroup) {
        var _elem = buildGroup$1(subGroup, options.havingStyle(style.sub()), options);

        sub = {
          elem: _elem,
          kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
        };
      } // Build the final group as a vlist of the possible subscript, base,
      // and possible superscript.


      var finalGroup;

      if (sup && sub) {
        var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;
        finalGroup = buildCommon.makeVList({
          positionType: "bottom",
          positionData: bottom,
          children: [{
            type: "kern",
            size: options.fontMetrics().bigOpSpacing5
          }, {
            type: "elem",
            elem: sub.elem,
            marginLeft: makeEm(-slant)
          }, {
            type: "kern",
            size: sub.kern
          }, {
            type: "elem",
            elem: base
          }, {
            type: "kern",
            size: sup.kern
          }, {
            type: "elem",
            elem: sup.elem,
            marginLeft: makeEm(slant)
          }, {
            type: "kern",
            size: options.fontMetrics().bigOpSpacing5
          }]
        }, options);
      } else if (sub) {
        var top = base.height - baseShift; // Shift the limits by the slant of the symbol. Note
        // that we are supposed to shift the limits by 1/2 of the slant,
        // but since we are centering the limits adding a full slant of
        // margin will shift by 1/2 that.

        finalGroup = buildCommon.makeVList({
          positionType: "top",
          positionData: top,
          children: [{
            type: "kern",
            size: options.fontMetrics().bigOpSpacing5
          }, {
            type: "elem",
            elem: sub.elem,
            marginLeft: makeEm(-slant)
          }, {
            type: "kern",
            size: sub.kern
          }, {
            type: "elem",
            elem: base
          }]
        }, options);
      } else if (sup) {
        var _bottom = base.depth + baseShift;

        finalGroup = buildCommon.makeVList({
          positionType: "bottom",
          positionData: _bottom,
          children: [{
            type: "elem",
            elem: base
          }, {
            type: "kern",
            size: sup.kern
          }, {
            type: "elem",
            elem: sup.elem,
            marginLeft: makeEm(slant)
          }, {
            type: "kern",
            size: options.fontMetrics().bigOpSpacing5
          }]
        }, options);
      } else {
        // This case probably shouldn't occur (this would mean the
        // supsub was sending us a group with no superscript or
        // subscript) but be safe.
        return base;
      }

      var parts = [finalGroup];

      if (sub && slant !== 0 && !subIsSingleCharacter) {
        // A negative margin-left was applied to the lower limit.
        // Avoid an overlap by placing a spacer on the left on the group.
        var spacer = buildCommon.makeSpan(["mspace"], [], options);
        spacer.style.marginRight = makeEm(slant);
        parts.unshift(spacer);
      }

      return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
    };

    // Limits, symbols
    // Most operators have a large successor symbol, but these don't.
    var noSuccessor = ["\\smallint"]; // NOTE: Unlike most `htmlBuilder`s, this one handles not only "op", but also
    // "supsub" since some of them (like \int) can affect super/subscripting.

    var htmlBuilder$2 = (grp, options) => {
      // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
      var supGroup;
      var subGroup;
      var hasLimits = false;
      var group;

      if (grp.type === "supsub") {
        // If we have limits, supsub will pass us its group to handle. Pull
        // out the superscript and subscript and set the group to the op in
        // its base.
        supGroup = grp.sup;
        subGroup = grp.sub;
        group = assertNodeType(grp.base, "op");
        hasLimits = true;
      } else {
        group = assertNodeType(grp, "op");
      }

      var style = options.style;
      var large = false;

      if (style.size === Style$1.DISPLAY.size && group.symbol && !noSuccessor.includes(group.name)) {
        // Most symbol operators get larger in displaystyle (rule 13)
        large = true;
      }

      var base;

      if (group.symbol) {
        // If this is a symbol, create the symbol.
        var fontName = large ? "Size2-Regular" : "Size1-Regular";
        var stash = "";

        if (group.name === "\\oiint" || group.name === "\\oiiint") {
          // No font glyphs yet, so use a glyph w/o the oval.
          // TODO: When font glyphs are available, delete this code.
          stash = group.name.slice(1);
          group.name = stash === "oiint" ? "\\iint" : "\\iiint";
        }

        base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);

        if (stash.length > 0) {
          // We're in \oiint or \oiiint. Overlay the oval.
          // TODO: When font glyphs are available, delete this code.
          var italic = base.italic;
          var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
          base = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: base,
              shift: 0
            }, {
              type: "elem",
              elem: oval,
              shift: large ? 0.08 : 0
            }]
          }, options);
          group.name = "\\" + stash;
          base.classes.unshift("mop"); // $FlowFixMe

          base.italic = italic;
        }
      } else if (group.body) {
        // If this is a list, compose that list.
        var inner = buildExpression$1(group.body, options, true);

        if (inner.length === 1 && inner[0] instanceof SymbolNode) {
          base = inner[0];
          base.classes[0] = "mop"; // replace old mclass
        } else {
          base = buildCommon.makeSpan(["mop"], inner, options);
        }
      } else {
        // Otherwise, this is a text operator. Build the text from the
        // operator's name.
        var output = [];

        for (var i = 1; i < group.name.length; i++) {
          output.push(buildCommon.mathsym(group.name[i], group.mode, options));
        }

        base = buildCommon.makeSpan(["mop"], output, options);
      } // If content of op is a single symbol, shift it vertically.


      var baseShift = 0;
      var slant = 0;

      if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
        // We suppress the shift of the base of \overset and \underset. Otherwise,
        // shift the symbol so its center lies on the axis (rule 13). It
        // appears that our fonts have the centers of the symbols already
        // almost on the axis, so these numbers are very small. Note we
        // don't actually apply this here, but instead it is used either in
        // the vlist creation or separately when there are no limits.
        baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight; // The slant of the symbol is just its italic correction.
        // $FlowFixMe

        slant = base.italic;
      }

      if (hasLimits) {
        return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);
      } else {
        if (baseShift) {
          base.style.position = "relative";
          base.style.top = makeEm(baseShift);
        }

        return base;
      }
    };

    var mathmlBuilder$1 = (group, options) => {
      var node;

      if (group.symbol) {
        // This is a symbol. Just add the symbol.
        node = new MathNode("mo", [makeText(group.name, group.mode)]);

        if (noSuccessor.includes(group.name)) {
          node.setAttribute("largeop", "false");
        }
      } else if (group.body) {
        // This is an operator with children. Add them.
        node = new MathNode("mo", buildExpression(group.body, options));
      } else {
        // This is a text operator. Add all of the characters from the
        // operator's name.
        node = new MathNode("mi", [new TextNode(group.name.slice(1))]); // Append an <mo>&ApplyFunction;</mo>.
        // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4

        var operator = new MathNode("mo", [makeText("\u2061", "text")]);

        if (group.parentIsSupSub) {
          node = new MathNode("mrow", [node, operator]);
        } else {
          node = newDocumentFragment([node, operator]);
        }
      }

      return node;
    };

    var singleCharBigOps = {
      "\u220F": "\\prod",
      "\u2210": "\\coprod",
      "\u2211": "\\sum",
      "\u22c0": "\\bigwedge",
      "\u22c1": "\\bigvee",
      "\u22c2": "\\bigcap",
      "\u22c3": "\\bigcup",
      "\u2a00": "\\bigodot",
      "\u2a01": "\\bigoplus",
      "\u2a02": "\\bigotimes",
      "\u2a04": "\\biguplus",
      "\u2a06": "\\bigsqcup"
    };
    defineFunction({
      type: "op",
      names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22c0", "\u22c1", "\u22c2", "\u22c3", "\u2a00", "\u2a01", "\u2a02", "\u2a04", "\u2a06"],
      props: {
        numArgs: 0
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName
        } = _ref;
        var fName = funcName;

        if (fName.length === 1) {
          fName = singleCharBigOps[fName];
        }

        return {
          type: "op",
          mode: parser.mode,
          limits: true,
          parentIsSupSub: false,
          symbol: true,
          name: fName
        };
      },
      htmlBuilder: htmlBuilder$2,
      mathmlBuilder: mathmlBuilder$1
    }); // Note: calling defineFunction with a type that's already been defined only
    // works because the same htmlBuilder and mathmlBuilder are being used.

    defineFunction({
      type: "op",
      names: ["\\mathop"],
      props: {
        numArgs: 1,
        primitive: true
      },
      handler: (_ref2, args) => {
        var {
          parser
        } = _ref2;
        var body = args[0];
        return {
          type: "op",
          mode: parser.mode,
          limits: false,
          parentIsSupSub: false,
          symbol: false,
          body: ordargument(body)
        };
      },
      htmlBuilder: htmlBuilder$2,
      mathmlBuilder: mathmlBuilder$1
    }); // There are 2 flags for operators; whether they produce limits in
    // displaystyle, and whether they are symbols and should grow in
    // displaystyle. These four groups cover the four possible choices.

    var singleCharIntegrals = {
      "\u222b": "\\int",
      "\u222c": "\\iint",
      "\u222d": "\\iiint",
      "\u222e": "\\oint",
      "\u222f": "\\oiint",
      "\u2230": "\\oiiint"
    }; // No limits, not symbols

    defineFunction({
      type: "op",
      names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
      props: {
        numArgs: 0
      },

      handler(_ref3) {
        var {
          parser,
          funcName
        } = _ref3;
        return {
          type: "op",
          mode: parser.mode,
          limits: false,
          parentIsSupSub: false,
          symbol: false,
          name: funcName
        };
      },

      htmlBuilder: htmlBuilder$2,
      mathmlBuilder: mathmlBuilder$1
    }); // Limits, not symbols

    defineFunction({
      type: "op",
      names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
      props: {
        numArgs: 0
      },

      handler(_ref4) {
        var {
          parser,
          funcName
        } = _ref4;
        return {
          type: "op",
          mode: parser.mode,
          limits: true,
          parentIsSupSub: false,
          symbol: false,
          name: funcName
        };
      },

      htmlBuilder: htmlBuilder$2,
      mathmlBuilder: mathmlBuilder$1
    }); // No limits, symbols

    defineFunction({
      type: "op",
      names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222b", "\u222c", "\u222d", "\u222e", "\u222f", "\u2230"],
      props: {
        numArgs: 0
      },

      handler(_ref5) {
        var {
          parser,
          funcName
        } = _ref5;
        var fName = funcName;

        if (fName.length === 1) {
          fName = singleCharIntegrals[fName];
        }

        return {
          type: "op",
          mode: parser.mode,
          limits: false,
          parentIsSupSub: false,
          symbol: true,
          name: fName
        };
      },

      htmlBuilder: htmlBuilder$2,
      mathmlBuilder: mathmlBuilder$1
    });

    // NOTE: Unlike most `htmlBuilder`s, this one handles not only
    // "operatorname", but also  "supsub" since \operatorname* can
    // affect super/subscripting.
    var htmlBuilder$1 = (grp, options) => {
      // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
      var supGroup;
      var subGroup;
      var hasLimits = false;
      var group;

      if (grp.type === "supsub") {
        // If we have limits, supsub will pass us its group to handle. Pull
        // out the superscript and subscript and set the group to the op in
        // its base.
        supGroup = grp.sup;
        subGroup = grp.sub;
        group = assertNodeType(grp.base, "operatorname");
        hasLimits = true;
      } else {
        group = assertNodeType(grp, "operatorname");
      }

      var base;

      if (group.body.length > 0) {
        var body = group.body.map(child => {
          // $FlowFixMe: Check if the node has a string `text` property.
          var childText = child.text;

          if (typeof childText === "string") {
            return {
              type: "textord",
              mode: child.mode,
              text: childText
            };
          } else {
            return child;
          }
        }); // Consolidate function names into symbol characters.

        var expression = buildExpression$1(body, options.withFont("mathrm"), true);

        for (var i = 0; i < expression.length; i++) {
          var child = expression[i];

          if (child instanceof SymbolNode) {
            // Per amsopn package,
            // change minus to hyphen and \ast to asterisk
            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
          }
        }

        base = buildCommon.makeSpan(["mop"], expression, options);
      } else {
        base = buildCommon.makeSpan(["mop"], [], options);
      }

      if (hasLimits) {
        return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
      } else {
        return base;
      }
    };

    var mathmlBuilder = (group, options) => {
      // The steps taken here are similar to the html version.
      var expression = buildExpression(group.body, options.withFont("mathrm")); // Is expression a string or has it something like a fraction?

      var isAllString = true; // default

      for (var i = 0; i < expression.length; i++) {
        var node = expression[i];

        if (node instanceof mathMLTree.SpaceNode) ; else if (node instanceof mathMLTree.MathNode) {
          switch (node.type) {
            case "mi":
            case "mn":
            case "ms":
            case "mspace":
            case "mtext":
              break;
            // Do nothing yet.

            case "mo":
              {
                var child = node.children[0];

                if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                  child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                } else {
                  isAllString = false;
                }

                break;
              }

            default:
              isAllString = false;
          }
        } else {
          isAllString = false;
        }
      }

      if (isAllString) {
        // Write a single TextNode instead of multiple nested tags.
        var word = expression.map(node => node.toText()).join("");
        expression = [new mathMLTree.TextNode(word)];
      }

      var identifier = new mathMLTree.MathNode("mi", expression);
      identifier.setAttribute("mathvariant", "normal"); // \u2061 is the same as &ApplyFunction;
      // ref: https://www.w3schools.com/charsets/ref_html_entities_a.asp

      var operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);

      if (group.parentIsSupSub) {
        return new mathMLTree.MathNode("mrow", [identifier, operator]);
      } else {
        return mathMLTree.newDocumentFragment([identifier, operator]);
      }
    }; // \operatorname
    // amsopn.dtx: \mathop{#1\kern\z@\operator@font#3}\newmcodes@


    defineFunction({
      type: "operatorname",
      names: ["\\operatorname@", "\\operatornamewithlimits"],
      props: {
        numArgs: 1
      },
      handler: (_ref, args) => {
        var {
          parser,
          funcName
        } = _ref;
        var body = args[0];
        return {
          type: "operatorname",
          mode: parser.mode,
          body: ordargument(body),
          alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
          limits: false,
          parentIsSupSub: false
        };
      },
      htmlBuilder: htmlBuilder$1,
      mathmlBuilder
    });
    defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");

    defineFunctionBuilders({
      type: "ordgroup",

      htmlBuilder(group, options) {
        if (group.semisimple) {
          return buildCommon.makeFragment(buildExpression$1(group.body, options, false));
        }

        return buildCommon.makeSpan(["mord"], buildExpression$1(group.body, options, true), options);
      },

      mathmlBuilder(group, options) {
        return buildExpressionRow(group.body, options, true);
      }

    });

    defineFunction({
      type: "overline",
      names: ["\\overline"],
      props: {
        numArgs: 1
      },

      handler(_ref, args) {
        var {
          parser
        } = _ref;
        var body = args[0];
        return {
          type: "overline",
          mode: parser.mode,
          body
        };
      },

      htmlBuilder(group, options) {
        // Overlines are handled in the TeXbook pg 443, Rule 9.
        // Build the inner group in the cramped style.
        var innerGroup = buildGroup$1(group.body, options.havingCrampedStyle()); // Create the line above the body

        var line = buildCommon.makeLineSpan("overline-line", options); // Generate the vlist, with the appropriate kerns

        var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
        var vlist = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: innerGroup
          }, {
            type: "kern",
            size: 3 * defaultRuleThickness
          }, {
            type: "elem",
            elem: line
          }, {
            type: "kern",
            size: defaultRuleThickness
          }]
        }, options);
        return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
      },

      mathmlBuilder(group, options) {
        var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203e")]);
        operator.setAttribute("stretchy", "true");
        var node = new mathMLTree.MathNode("mover", [buildGroup(group.body, options), operator]);
        node.setAttribute("accent", "true");
        return node;
      }

    });

    defineFunction({
      type: "phantom",
      names: ["\\phantom"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler: (_ref, args) => {
        var {
          parser
        } = _ref;
        var body = args[0];
        return {
          type: "phantom",
          mode: parser.mode,
          body: ordargument(body)
        };
      },
      htmlBuilder: (group, options) => {
        var elements = buildExpression$1(group.body, options.withPhantom(), false); // \phantom isn't supposed to affect the elements it contains.
        // See "color" for more details.

        return buildCommon.makeFragment(elements);
      },
      mathmlBuilder: (group, options) => {
        var inner = buildExpression(group.body, options);
        return new mathMLTree.MathNode("mphantom", inner);
      }
    });
    defineFunction({
      type: "hphantom",
      names: ["\\hphantom"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler: (_ref2, args) => {
        var {
          parser
        } = _ref2;
        var body = args[0];
        return {
          type: "hphantom",
          mode: parser.mode,
          body
        };
      },
      htmlBuilder: (group, options) => {
        var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options.withPhantom())]);
        node.height = 0;
        node.depth = 0;

        if (node.children) {
          for (var i = 0; i < node.children.length; i++) {
            node.children[i].height = 0;
            node.children[i].depth = 0;
          }
        } // See smash for comment re: use of makeVList


        node = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: node
          }]
        }, options); // For spacing, TeX treats \smash as a math group (same spacing as ord).

        return buildCommon.makeSpan(["mord"], [node], options);
      },
      mathmlBuilder: (group, options) => {
        var inner = buildExpression(ordargument(group.body), options);
        var phantom = new mathMLTree.MathNode("mphantom", inner);
        var node = new mathMLTree.MathNode("mpadded", [phantom]);
        node.setAttribute("height", "0px");
        node.setAttribute("depth", "0px");
        return node;
      }
    });
    defineFunction({
      type: "vphantom",
      names: ["\\vphantom"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler: (_ref3, args) => {
        var {
          parser
        } = _ref3;
        var body = args[0];
        return {
          type: "vphantom",
          mode: parser.mode,
          body
        };
      },
      htmlBuilder: (group, options) => {
        var inner = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options.withPhantom())]);
        var fix = buildCommon.makeSpan(["fix"], []);
        return buildCommon.makeSpan(["mord", "rlap"], [inner, fix], options);
      },
      mathmlBuilder: (group, options) => {
        var inner = buildExpression(ordargument(group.body), options);
        var phantom = new mathMLTree.MathNode("mphantom", inner);
        var node = new mathMLTree.MathNode("mpadded", [phantom]);
        node.setAttribute("width", "0px");
        return node;
      }
    });

    defineFunction({
      type: "raisebox",
      names: ["\\raisebox"],
      props: {
        numArgs: 2,
        argTypes: ["size", "hbox"],
        allowedInText: true
      },

      handler(_ref, args) {
        var {
          parser
        } = _ref;
        var amount = assertNodeType(args[0], "size").value;
        var body = args[1];
        return {
          type: "raisebox",
          mode: parser.mode,
          dy: amount,
          body
        };
      },

      htmlBuilder(group, options) {
        var body = buildGroup$1(group.body, options);
        var dy = calculateSize(group.dy, options);
        return buildCommon.makeVList({
          positionType: "shift",
          positionData: -dy,
          children: [{
            type: "elem",
            elem: body
          }]
        }, options);
      },

      mathmlBuilder(group, options) {
        var node = new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options)]);
        var dy = group.dy.number + group.dy.unit;
        node.setAttribute("voffset", dy);
        return node;
      }

    });

    defineFunction({
      type: "internal",
      names: ["\\relax"],
      props: {
        numArgs: 0,
        allowedInText: true,
        allowedInArgument: true
      },

      handler(_ref) {
        var {
          parser
        } = _ref;
        return {
          type: "internal",
          mode: parser.mode
        };
      }

    });

    defineFunction({
      type: "rule",
      names: ["\\rule"],
      props: {
        numArgs: 2,
        numOptionalArgs: 1,
        allowedInText: true,
        allowedInMath: true,
        argTypes: ["size", "size", "size"]
      },

      handler(_ref, args, optArgs) {
        var {
          parser
        } = _ref;
        var shift = optArgs[0];
        var width = assertNodeType(args[0], "size");
        var height = assertNodeType(args[1], "size");
        return {
          type: "rule",
          mode: parser.mode,
          shift: shift && assertNodeType(shift, "size").value,
          width: width.value,
          height: height.value
        };
      },

      htmlBuilder(group, options) {
        // Make an empty span for the rule
        var rule = buildCommon.makeSpan(["mord", "rule"], [], options); // Calculate the shift, width, and height of the rule, and account for units

        var width = calculateSize(group.width, options);
        var height = calculateSize(group.height, options);
        var shift = group.shift ? calculateSize(group.shift, options) : 0; // Style the rule to the right size

        rule.style.borderRightWidth = makeEm(width);
        rule.style.borderTopWidth = makeEm(height);
        rule.style.bottom = makeEm(shift); // Record the height and width

        rule.width = width;
        rule.height = height + shift;
        rule.depth = -shift; // Font size is the number large enough that the browser will
        // reserve at least `absHeight` space above the baseline.
        // The 1.125 factor was empirically determined

        rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
        return rule;
      },

      mathmlBuilder(group, options) {
        var width = calculateSize(group.width, options);
        var height = calculateSize(group.height, options);
        var shift = group.shift ? calculateSize(group.shift, options) : 0;
        var color = options.color && options.getColor() || "black";
        var rule = new mathMLTree.MathNode("mspace");
        rule.setAttribute("mathbackground", color);
        rule.setAttribute("width", makeEm(width));
        rule.setAttribute("height", makeEm(height));
        var wrapper = new mathMLTree.MathNode("mpadded", [rule]);

        if (shift >= 0) {
          wrapper.setAttribute("height", makeEm(shift));
        } else {
          wrapper.setAttribute("height", makeEm(shift));
          wrapper.setAttribute("depth", makeEm(-shift));
        }

        wrapper.setAttribute("voffset", makeEm(shift));
        return wrapper;
      }

    });

    function sizingGroup(value, options, baseOptions) {
      var inner = buildExpression$1(value, options, false);
      var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier; // Add size-resetting classes to the inner list and set maxFontSize
      // manually. Handle nested size changes.

      for (var i = 0; i < inner.length; i++) {
        var pos = inner[i].classes.indexOf("sizing");

        if (pos < 0) {
          Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));
        } else if (inner[i].classes[pos + 1] === "reset-size" + options.size) {
          // This is a nested size change: e.g., inner[i] is the "b" in
          // `\Huge a \small b`. Override the old size (the `reset-` class)
          // but not the new size.
          inner[i].classes[pos + 1] = "reset-size" + baseOptions.size;
        }

        inner[i].height *= multiplier;
        inner[i].depth *= multiplier;
      }

      return buildCommon.makeFragment(inner);
    }
    var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
    var htmlBuilder = (group, options) => {
      // Handle sizing operators like \Huge. Real TeX doesn't actually allow
      // these functions inside of math expressions, so we do some special
      // handling.
      var newOptions = options.havingSize(group.size);
      return sizingGroup(group.body, newOptions, options);
    };
    defineFunction({
      type: "sizing",
      names: sizeFuncs,
      props: {
        numArgs: 0,
        allowedInText: true
      },
      handler: (_ref, args) => {
        var {
          breakOnTokenText,
          funcName,
          parser
        } = _ref;
        var body = parser.parseExpression(false, breakOnTokenText);
        return {
          type: "sizing",
          mode: parser.mode,
          // Figure out what size to use based on the list of functions above
          size: sizeFuncs.indexOf(funcName) + 1,
          body
        };
      },
      htmlBuilder,
      mathmlBuilder: (group, options) => {
        var newOptions = options.havingSize(group.size);
        var inner = buildExpression(group.body, newOptions);
        var node = new mathMLTree.MathNode("mstyle", inner); // TODO(emily): This doesn't produce the correct size for nested size
        // changes, because we don't keep state of what style we're currently
        // in, so we can't reset the size to normal before changing it.  Now
        // that we're passing an options parameter we should be able to fix
        // this.

        node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
        return node;
      }
    });

    // smash, with optional [tb], as in AMS
    defineFunction({
      type: "smash",
      names: ["\\smash"],
      props: {
        numArgs: 1,
        numOptionalArgs: 1,
        allowedInText: true
      },
      handler: (_ref, args, optArgs) => {
        var {
          parser
        } = _ref;
        var smashHeight = false;
        var smashDepth = false;
        var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");

        if (tbArg) {
          // Optional [tb] argument is engaged.
          // ref: amsmath: \renewcommand{\smash}[1][tb]{%
          //               def\mb@t{\ht}\def\mb@b{\dp}\def\mb@tb{\ht\z@\z@\dp}%
          var letter = "";

          for (var i = 0; i < tbArg.body.length; ++i) {
            var node = tbArg.body[i]; // $FlowFixMe: Not every node type has a `text` property.

            letter = node.text;

            if (letter === "t") {
              smashHeight = true;
            } else if (letter === "b") {
              smashDepth = true;
            } else {
              smashHeight = false;
              smashDepth = false;
              break;
            }
          }
        } else {
          smashHeight = true;
          smashDepth = true;
        }

        var body = args[0];
        return {
          type: "smash",
          mode: parser.mode,
          body,
          smashHeight,
          smashDepth
        };
      },
      htmlBuilder: (group, options) => {
        var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);

        if (!group.smashHeight && !group.smashDepth) {
          return node;
        }

        if (group.smashHeight) {
          node.height = 0; // In order to influence makeVList, we have to reset the children.

          if (node.children) {
            for (var i = 0; i < node.children.length; i++) {
              node.children[i].height = 0;
            }
          }
        }

        if (group.smashDepth) {
          node.depth = 0;

          if (node.children) {
            for (var _i = 0; _i < node.children.length; _i++) {
              node.children[_i].depth = 0;
            }
          }
        } // At this point, we've reset the TeX-like height and depth values.
        // But the span still has an HTML line height.
        // makeVList applies "display: table-cell", which prevents the browser
        // from acting on that line height. So we'll call makeVList now.


        var smashedNode = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: node
          }]
        }, options); // For spacing, TeX treats \hphantom as a math group (same spacing as ord).

        return buildCommon.makeSpan(["mord"], [smashedNode], options);
      },
      mathmlBuilder: (group, options) => {
        var node = new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options)]);

        if (group.smashHeight) {
          node.setAttribute("height", "0px");
        }

        if (group.smashDepth) {
          node.setAttribute("depth", "0px");
        }

        return node;
      }
    });

    defineFunction({
      type: "sqrt",
      names: ["\\sqrt"],
      props: {
        numArgs: 1,
        numOptionalArgs: 1
      },

      handler(_ref, args, optArgs) {
        var {
          parser
        } = _ref;
        var index = optArgs[0];
        var body = args[0];
        return {
          type: "sqrt",
          mode: parser.mode,
          body,
          index
        };
      },

      htmlBuilder(group, options) {
        // Square roots are handled in the TeXbook pg. 443, Rule 11.
        // First, we do the same steps as in overline to build the inner group
        // and line
        var inner = buildGroup$1(group.body, options.havingCrampedStyle());

        if (inner.height === 0) {
          // Render a small surd.
          inner.height = options.fontMetrics().xHeight;
        } // Some groups can return document fragments.  Handle those by wrapping
        // them in a span.


        inner = buildCommon.wrapFragment(inner, options); // Calculate the minimum size for the \surd delimiter

        var metrics = options.fontMetrics();
        var theta = metrics.defaultRuleThickness;
        var phi = theta;

        if (options.style.id < Style$1.TEXT.id) {
          phi = options.fontMetrics().xHeight;
        } // Calculate the clearance between the body and line


        var lineClearance = theta + phi / 4;
        var minDelimiterHeight = inner.height + inner.depth + lineClearance + theta; // Create a sqrt SVG of the required minimum size

        var {
          span: img,
          ruleWidth,
          advanceWidth
        } = delimiter.sqrtImage(minDelimiterHeight, options);
        var delimDepth = img.height - ruleWidth; // Adjust the clearance based on the delimiter size

        if (delimDepth > inner.height + inner.depth + lineClearance) {
          lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;
        } // Shift the sqrt image


        var imgShift = img.height - inner.height - lineClearance - ruleWidth;
        inner.style.paddingLeft = makeEm(advanceWidth); // Overlay the image and the argument.

        var body = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: inner,
            wrapperClasses: ["svg-align"]
          }, {
            type: "kern",
            size: -(inner.height + imgShift)
          }, {
            type: "elem",
            elem: img
          }, {
            type: "kern",
            size: ruleWidth
          }]
        }, options);

        if (!group.index) {
          return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
        } else {
          // Handle the optional root index
          // The index is always in scriptscript style
          var newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);
          var rootm = buildGroup$1(group.index, newOptions, options); // The amount the index is shifted by. This is taken from the TeX
          // source, in the definition of `\r@@t`.

          var toShift = 0.6 * (body.height - body.depth); // Build a VList with the superscript shifted up correctly

          var rootVList = buildCommon.makeVList({
            positionType: "shift",
            positionData: -toShift,
            children: [{
              type: "elem",
              elem: rootm
            }]
          }, options); // Add a class surrounding it so we can add on the appropriate
          // kerning

          var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
          return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
        }
      },

      mathmlBuilder(group, options) {
        var {
          body,
          index
        } = group;
        return index ? new mathMLTree.MathNode("mroot", [buildGroup(body, options), buildGroup(index, options)]) : new mathMLTree.MathNode("msqrt", [buildGroup(body, options)]);
      }

    });

    var styleMap = {
      "display": Style$1.DISPLAY,
      "text": Style$1.TEXT,
      "script": Style$1.SCRIPT,
      "scriptscript": Style$1.SCRIPTSCRIPT
    };
    defineFunction({
      type: "styling",
      names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
      props: {
        numArgs: 0,
        allowedInText: true,
        primitive: true
      },

      handler(_ref, args) {
        var {
          breakOnTokenText,
          funcName,
          parser
        } = _ref;
        // parse out the implicit body
        var body = parser.parseExpression(true, breakOnTokenText); // TODO: Refactor to avoid duplicating styleMap in multiple places (e.g.
        // here and in buildHTML and de-dupe the enumeration of all the styles).
        // $FlowFixMe: The names above exactly match the styles.

        var style = funcName.slice(1, funcName.length - 5);
        return {
          type: "styling",
          mode: parser.mode,
          // Figure out what style to use by pulling out the style from
          // the function name
          style,
          body
        };
      },

      htmlBuilder(group, options) {
        // Style changes are handled in the TeXbook on pg. 442, Rule 3.
        var newStyle = styleMap[group.style];
        var newOptions = options.havingStyle(newStyle).withFont('');
        return sizingGroup(group.body, newOptions, options);
      },

      mathmlBuilder(group, options) {
        // Figure out what style we're changing to.
        var newStyle = styleMap[group.style];
        var newOptions = options.havingStyle(newStyle);
        var inner = buildExpression(group.body, newOptions);
        var node = new mathMLTree.MathNode("mstyle", inner);
        var styleAttributes = {
          "display": ["0", "true"],
          "text": ["0", "false"],
          "script": ["1", "false"],
          "scriptscript": ["2", "false"]
        };
        var attr = styleAttributes[group.style];
        node.setAttribute("scriptlevel", attr[0]);
        node.setAttribute("displaystyle", attr[1]);
        return node;
      }

    });

    /**
     * Sometimes, groups perform special rules when they have superscripts or
     * subscripts attached to them. This function lets the `supsub` group know that
     * Sometimes, groups perform special rules when they have superscripts or
     * its inner element should handle the superscripts and subscripts instead of
     * handling them itself.
     */
    var htmlBuilderDelegate = function htmlBuilderDelegate(group, options) {
      var base = group.base;

      if (!base) {
        return null;
      } else if (base.type === "op") {
        // Operators handle supsubs differently when they have limits
        // (e.g. `\displaystyle\sum_2^3`)
        var delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
        return delegate ? htmlBuilder$2 : null;
      } else if (base.type === "operatorname") {
        var _delegate = base.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base.limits);

        return _delegate ? htmlBuilder$1 : null;
      } else if (base.type === "accent") {
        return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;
      } else if (base.type === "horizBrace") {
        var isSup = !group.sub;
        return isSup === base.isOver ? htmlBuilder$3 : null;
      } else {
        return null;
      }
    }; // Super scripts and subscripts, whose precise placement can depend on other
    // functions that precede them.


    defineFunctionBuilders({
      type: "supsub",

      htmlBuilder(group, options) {
        // Superscript and subscripts are handled in the TeXbook on page
        // 445-446, rules 18(a-f).
        // Here is where we defer to the inner group if it should handle
        // superscripts and subscripts itself.
        var builderDelegate = htmlBuilderDelegate(group, options);

        if (builderDelegate) {
          return builderDelegate(group, options);
        }

        var {
          base: valueBase,
          sup: valueSup,
          sub: valueSub
        } = group;
        var base = buildGroup$1(valueBase, options);
        var supm;
        var subm;
        var metrics = options.fontMetrics(); // Rule 18a

        var supShift = 0;
        var subShift = 0;
        var isCharacterBox = valueBase && utils.isCharacterBox(valueBase);

        if (valueSup) {
          var newOptions = options.havingStyle(options.style.sup());
          supm = buildGroup$1(valueSup, newOptions, options);

          if (!isCharacterBox) {
            supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
          }
        }

        if (valueSub) {
          var _newOptions = options.havingStyle(options.style.sub());

          subm = buildGroup$1(valueSub, _newOptions, options);

          if (!isCharacterBox) {
            subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
          }
        } // Rule 18c


        var minSupShift;

        if (options.style === Style$1.DISPLAY) {
          minSupShift = metrics.sup1;
        } else if (options.style.cramped) {
          minSupShift = metrics.sup3;
        } else {
          minSupShift = metrics.sup2;
        } // scriptspace is a font-size-independent size, so scale it
        // appropriately for use as the marginRight.


        var multiplier = options.sizeMultiplier;
        var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
        var marginLeft = null;

        if (subm) {
          // Subscripts shouldn't be shifted by the base's italic correction.
          // Account for that by shifting the subscript back the appropriate
          // amount. Note we only do this when the base is a single symbol.
          var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");

          if (base instanceof SymbolNode || isOiint) {
            // $FlowFixMe
            marginLeft = makeEm(-base.italic);
          }
        }

        var supsub;

        if (supm && subm) {
          supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
          subShift = Math.max(subShift, metrics.sub2);
          var ruleWidth = metrics.defaultRuleThickness; // Rule 18e

          var maxWidth = 4 * ruleWidth;

          if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
            subShift = maxWidth - (supShift - supm.depth) + subm.height;
            var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);

            if (psi > 0) {
              supShift += psi;
              subShift -= psi;
            }
          }

          var vlistElem = [{
            type: "elem",
            elem: subm,
            shift: subShift,
            marginRight,
            marginLeft
          }, {
            type: "elem",
            elem: supm,
            shift: -supShift,
            marginRight
          }];
          supsub = buildCommon.makeVList({
            positionType: "individualShift",
            children: vlistElem
          }, options);
        } else if (subm) {
          // Rule 18b
          subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
          var _vlistElem = [{
            type: "elem",
            elem: subm,
            marginLeft,
            marginRight
          }];
          supsub = buildCommon.makeVList({
            positionType: "shift",
            positionData: subShift,
            children: _vlistElem
          }, options);
        } else if (supm) {
          // Rule 18c, d
          supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
          supsub = buildCommon.makeVList({
            positionType: "shift",
            positionData: -supShift,
            children: [{
              type: "elem",
              elem: supm,
              marginRight
            }]
          }, options);
        } else {
          throw new Error("supsub must have either sup or sub.");
        } // Wrap the supsub vlist in a span.msupsub to reset text-align.


        var mclass = getTypeOfDomTree(base, "right") || "mord";
        return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
      },

      mathmlBuilder(group, options) {
        // Is the inner group a relevant horizontal brace?
        var isBrace = false;
        var isOver;
        var isSup;

        if (group.base && group.base.type === "horizBrace") {
          isSup = !!group.sup;

          if (isSup === group.base.isOver) {
            isBrace = true;
            isOver = group.base.isOver;
          }
        }

        if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
          group.base.parentIsSupSub = true;
        }

        var children = [buildGroup(group.base, options)];

        if (group.sub) {
          children.push(buildGroup(group.sub, options));
        }

        if (group.sup) {
          children.push(buildGroup(group.sup, options));
        }

        var nodeType;

        if (isBrace) {
          nodeType = isOver ? "mover" : "munder";
        } else if (!group.sub) {
          var base = group.base;

          if (base && base.type === "op" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
            nodeType = "mover";
          } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {
            nodeType = "mover";
          } else {
            nodeType = "msup";
          }
        } else if (!group.sup) {
          var _base = group.base;

          if (_base && _base.type === "op" && _base.limits && (options.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
            nodeType = "munder";
          } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === Style$1.DISPLAY)) {
            nodeType = "munder";
          } else {
            nodeType = "msub";
          }
        } else {
          var _base2 = group.base;

          if (_base2 && _base2.type === "op" && _base2.limits && options.style === Style$1.DISPLAY) {
            nodeType = "munderover";
          } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || _base2.limits)) {
            nodeType = "munderover";
          } else {
            nodeType = "msubsup";
          }
        }

        return new mathMLTree.MathNode(nodeType, children);
      }

    });

    defineFunctionBuilders({
      type: "atom",

      htmlBuilder(group, options) {
        return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
      },

      mathmlBuilder(group, options) {
        var node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);

        if (group.family === "bin") {
          var variant = getVariant(group, options);

          if (variant === "bold-italic") {
            node.setAttribute("mathvariant", variant);
          }
        } else if (group.family === "punct") {
          node.setAttribute("separator", "true");
        } else if (group.family === "open" || group.family === "close") {
          // Delims built here should not stretch vertically.
          // See delimsizing.js for stretchy delims.
          node.setAttribute("stretchy", "false");
        }

        return node;
      }

    });

    // "mathord" and "textord" ParseNodes created in Parser.js from symbol Groups in
    // src/symbols.js.
    var defaultVariant = {
      "mi": "italic",
      "mn": "normal",
      "mtext": "normal"
    };
    defineFunctionBuilders({
      type: "mathord",

      htmlBuilder(group, options) {
        return buildCommon.makeOrd(group, options, "mathord");
      },

      mathmlBuilder(group, options) {
        var node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
        var variant = getVariant(group, options) || "italic";

        if (variant !== defaultVariant[node.type]) {
          node.setAttribute("mathvariant", variant);
        }

        return node;
      }

    });
    defineFunctionBuilders({
      type: "textord",

      htmlBuilder(group, options) {
        return buildCommon.makeOrd(group, options, "textord");
      },

      mathmlBuilder(group, options) {
        var text = makeText(group.text, group.mode, options);
        var variant = getVariant(group, options) || "normal";
        var node;

        if (group.mode === 'text') {
          node = new mathMLTree.MathNode("mtext", [text]);
        } else if (/[0-9]/.test(group.text)) {
          node = new mathMLTree.MathNode("mn", [text]);
        } else if (group.text === "\\prime") {
          node = new mathMLTree.MathNode("mo", [text]);
        } else {
          node = new mathMLTree.MathNode("mi", [text]);
        }

        if (variant !== defaultVariant[node.type]) {
          node.setAttribute("mathvariant", variant);
        }

        return node;
      }

    });

    var cssSpace = {
      "\\nobreak": "nobreak",
      "\\allowbreak": "allowbreak"
    }; // A lookup table to determine whether a spacing function/symbol should be
    // treated like a regular space character.  If a symbol or command is a key
    // in this table, then it should be a regular space character.  Furthermore,
    // the associated value may have a `className` specifying an extra CSS class
    // to add to the created `span`.

    var regularSpace = {
      " ": {},
      "\\ ": {},
      "~": {
        className: "nobreak"
      },
      "\\space": {},
      "\\nobreakspace": {
        className: "nobreak"
      }
    }; // ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
    // src/symbols.js.

    defineFunctionBuilders({
      type: "spacing",

      htmlBuilder(group, options) {
        if (regularSpace.hasOwnProperty(group.text)) {
          var className = regularSpace[group.text].className || ""; // Spaces are generated by adding an actual space. Each of these
          // things has an entry in the symbols table, so these will be turned
          // into appropriate outputs.

          if (group.mode === "text") {
            var ord = buildCommon.makeOrd(group, options, "textord");
            ord.classes.push(className);
            return ord;
          } else {
            return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
          }
        } else if (cssSpace.hasOwnProperty(group.text)) {
          // Spaces based on just a CSS class.
          return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
        } else {
          throw new ParseError("Unknown type of space \"" + group.text + "\"");
        }
      },

      mathmlBuilder(group, options) {
        var node;

        if (regularSpace.hasOwnProperty(group.text)) {
          node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\u00a0")]);
        } else if (cssSpace.hasOwnProperty(group.text)) {
          // CSS-based MathML spaces (\nobreak, \allowbreak) are ignored
          return new mathMLTree.MathNode("mspace");
        } else {
          throw new ParseError("Unknown type of space \"" + group.text + "\"");
        }

        return node;
      }

    });

    var pad = () => {
      var padNode = new mathMLTree.MathNode("mtd", []);
      padNode.setAttribute("width", "50%");
      return padNode;
    };

    defineFunctionBuilders({
      type: "tag",

      mathmlBuilder(group, options) {
        var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
        table.setAttribute("width", "100%");
        return table; // TODO: Left-aligned tags.
        // Currently, the group and options passed here do not contain
        // enough info to set tag alignment. `leqno` is in Settings but it is
        // not passed to Options. On the HTML side, leqno is
        // set by a CSS class applied in buildTree.js. That would have worked
        // in MathML if browsers supported <mlabeledtr>. Since they don't, we
        // need to rewrite the way this function is called.
      }

    });

    var textFontFamilies = {
      "\\text": undefined,
      "\\textrm": "textrm",
      "\\textsf": "textsf",
      "\\texttt": "texttt",
      "\\textnormal": "textrm"
    };
    var textFontWeights = {
      "\\textbf": "textbf",
      "\\textmd": "textmd"
    };
    var textFontShapes = {
      "\\textit": "textit",
      "\\textup": "textup"
    };

    var optionsWithFont = (group, options) => {
      var font = group.font; // Checks if the argument is a font family or a font style.

      if (!font) {
        return options;
      } else if (textFontFamilies[font]) {
        return options.withTextFontFamily(textFontFamilies[font]);
      } else if (textFontWeights[font]) {
        return options.withTextFontWeight(textFontWeights[font]);
      } else if (font === "\\emph") {
        return options.fontShape === "textit" ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
      }

      return options.withTextFontShape(textFontShapes[font]);
    };

    defineFunction({
      type: "text",
      names: [// Font families
      "\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal", // Font weights
      "\\textbf", "\\textmd", // Font Shapes
      "\\textit", "\\textup", "\\emph"],
      props: {
        numArgs: 1,
        argTypes: ["text"],
        allowedInArgument: true,
        allowedInText: true
      },

      handler(_ref, args) {
        var {
          parser,
          funcName
        } = _ref;
        var body = args[0];
        return {
          type: "text",
          mode: parser.mode,
          body: ordargument(body),
          font: funcName
        };
      },

      htmlBuilder(group, options) {
        var newOptions = optionsWithFont(group, options);
        var inner = buildExpression$1(group.body, newOptions, true);
        return buildCommon.makeSpan(["mord", "text"], inner, newOptions);
      },

      mathmlBuilder(group, options) {
        var newOptions = optionsWithFont(group, options);
        return buildExpressionRow(group.body, newOptions);
      }

    });

    defineFunction({
      type: "underline",
      names: ["\\underline"],
      props: {
        numArgs: 1,
        allowedInText: true
      },

      handler(_ref, args) {
        var {
          parser
        } = _ref;
        return {
          type: "underline",
          mode: parser.mode,
          body: args[0]
        };
      },

      htmlBuilder(group, options) {
        // Underlines are handled in the TeXbook pg 443, Rule 10.
        // Build the inner group.
        var innerGroup = buildGroup$1(group.body, options); // Create the line to go below the body

        var line = buildCommon.makeLineSpan("underline-line", options); // Generate the vlist, with the appropriate kerns

        var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
        var vlist = buildCommon.makeVList({
          positionType: "top",
          positionData: innerGroup.height,
          children: [{
            type: "kern",
            size: defaultRuleThickness
          }, {
            type: "elem",
            elem: line
          }, {
            type: "kern",
            size: 3 * defaultRuleThickness
          }, {
            type: "elem",
            elem: innerGroup
          }]
        }, options);
        return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
      },

      mathmlBuilder(group, options) {
        var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203e")]);
        operator.setAttribute("stretchy", "true");
        var node = new mathMLTree.MathNode("munder", [buildGroup(group.body, options), operator]);
        node.setAttribute("accentunder", "true");
        return node;
      }

    });

    defineFunction({
      type: "vcenter",
      names: ["\\vcenter"],
      props: {
        numArgs: 1,
        argTypes: ["original"],
        // In LaTeX, \vcenter can act only on a box.
        allowedInText: false
      },

      handler(_ref, args) {
        var {
          parser
        } = _ref;
        return {
          type: "vcenter",
          mode: parser.mode,
          body: args[0]
        };
      },

      htmlBuilder(group, options) {
        var body = buildGroup$1(group.body, options);
        var axisHeight = options.fontMetrics().axisHeight;
        var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
        return buildCommon.makeVList({
          positionType: "shift",
          positionData: dy,
          children: [{
            type: "elem",
            elem: body
          }]
        }, options);
      },

      mathmlBuilder(group, options) {
        // There is no way to do this in MathML.
        // Write a class as a breadcrumb in case some post-processor wants
        // to perform a vcenter adjustment.
        return new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options)], ["vcenter"]);
      }

    });

    defineFunction({
      type: "verb",
      names: ["\\verb"],
      props: {
        numArgs: 0,
        allowedInText: true
      },

      handler(context, args, optArgs) {
        // \verb and \verb* are dealt with directly in Parser.js.
        // If we end up here, it's because of a failure to match the two delimiters
        // in the regex in Lexer.js.  LaTeX raises the following error when \verb is
        // terminated by end of line (or file).
        throw new ParseError("\\verb ended by end of line instead of matching delimiter");
      },

      htmlBuilder(group, options) {
        var text = makeVerb(group);
        var body = []; // \verb enters text mode and therefore is sized like \textstyle

        var newOptions = options.havingStyle(options.style.text());

        for (var i = 0; i < text.length; i++) {
          var c = text[i];

          if (c === '~') {
            c = '\\textasciitilde';
          }

          body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
        }

        return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
      },

      mathmlBuilder(group, options) {
        var text = new mathMLTree.TextNode(makeVerb(group));
        var node = new mathMLTree.MathNode("mtext", [text]);
        node.setAttribute("mathvariant", "monospace");
        return node;
      }

    });
    /**
     * Converts verb group into body string.
     *
     * \verb* replaces each space with an open box \u2423
     * \verb replaces each space with a no-break space \xA0
     */

    var makeVerb = group => group.body.replace(/ /g, group.star ? '\u2423' : '\xA0');

    /** Include this to ensure that all functions are defined. */
    var functions = _functions;

    /**
     * The Lexer class handles tokenizing the input in various ways. Since our
     * parser expects us to be able to backtrack, the lexer allows lexing from any
     * given starting point.
     *
     * Its main exposed function is the `lex` function, which takes a position to
     * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
     * function.
     *
     * The various `_innerLex` functions perform the actual lexing of different
     * kinds.
     */

    /* The following tokenRegex
     * - matches typical whitespace (but not NBSP etc.) using its first group
     * - does not match any control character \x00-\x1f except whitespace
     * - does not match a bare backslash
     * - matches any ASCII character except those just mentioned
     * - does not match the BMP private use area \uE000-\uF8FF
     * - does not match bare surrogate code units
     * - matches any BMP character except for those just described
     * - matches any valid Unicode surrogate pair
     * - matches a backslash followed by one or more whitespace characters
     * - matches a backslash followed by one or more letters then whitespace
     * - matches a backslash followed by any BMP character
     * Capturing groups:
     *   [1] regular whitespace
     *   [2] backslash followed by whitespace
     *   [3] anything else, which may include:
     *     [4] left character of \verb*
     *     [5] left character of \verb
     *     [6] backslash followed by word, excluding any trailing whitespace
     * Just because the Lexer matches something doesn't mean it's valid input:
     * If there is no matching function or symbol definition, the Parser will
     * still reject the input.
     */
    var spaceRegexString = "[ \r\n\t]";
    var controlWordRegexString = "\\\\[a-zA-Z@]+";
    var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
    var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
    var controlSpaceRegexString = "\\\\(\n|[ \r\t]+\n?)[ \r\t]*";
    var combiningDiacriticalMarkString = "[\u0300-\u036f]";
    var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
    var tokenRegexString = "(" + spaceRegexString + "+)|" + ( // whitespace
    controlSpaceRegexString + "|") + // \whitespace
    "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + ( // single codepoint
    combiningDiacriticalMarkString + "*") + // ...plus accents
    "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + ( // surrogate pair
    combiningDiacriticalMarkString + "*") + // ...plus accents
    "|\\\\verb\\*([^]).*?\\4" + // \verb*
    "|\\\\verb([^*a-zA-Z]).*?\\5" + ( // \verb unstarred
    "|" + controlWordWhitespaceRegexString) + ( // \macroName + spaces
    "|" + controlSymbolRegexString + ")"); // \\, \', etc.

    /** Main Lexer class */

    class Lexer {
      // Category codes. The lexer only supports comment characters (14) for now.
      // MacroExpander additionally distinguishes active (13).
      constructor(input, settings) {
        this.input = void 0;
        this.settings = void 0;
        this.tokenRegex = void 0;
        this.catcodes = void 0;
        // Separate accents from characters
        this.input = input;
        this.settings = settings;
        this.tokenRegex = new RegExp(tokenRegexString, 'g');
        this.catcodes = {
          "%": 14,
          // comment character
          "~": 13 // active character

        };
      }

      setCatcode(char, code) {
        this.catcodes[char] = code;
      }
      /**
       * This function lexes a single token.
       */


      lex() {
        var input = this.input;
        var pos = this.tokenRegex.lastIndex;

        if (pos === input.length) {
          return new Token("EOF", new SourceLocation(this, pos, pos));
        }

        var match = this.tokenRegex.exec(input);

        if (match === null || match.index !== pos) {
          throw new ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
        }

        var text = match[6] || match[3] || (match[2] ? "\\ " : " ");

        if (this.catcodes[text] === 14) {
          // comment character
          var nlIndex = input.indexOf('\n', this.tokenRegex.lastIndex);

          if (nlIndex === -1) {
            this.tokenRegex.lastIndex = input.length; // EOF

            this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would " + "fail because of commenting the end of math mode (e.g. $)");
          } else {
            this.tokenRegex.lastIndex = nlIndex + 1;
          }

          return this.lex();
        }

        return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
      }

    }

    /**
     * A `Namespace` refers to a space of nameable things like macros or lengths,
     * which can be `set` either globally or local to a nested group, using an
     * undo stack similar to how TeX implements this functionality.
     * Performance-wise, `get` and local `set` take constant time, while global
     * `set` takes time proportional to the depth of group nesting.
     */
    class Namespace {
      /**
       * Both arguments are optional.  The first argument is an object of
       * built-in mappings which never change.  The second argument is an object
       * of initial (global-level) mappings, which will constantly change
       * according to any global/top-level `set`s done.
       */
      constructor(builtins, globalMacros) {
        if (builtins === void 0) {
          builtins = {};
        }

        if (globalMacros === void 0) {
          globalMacros = {};
        }

        this.current = void 0;
        this.builtins = void 0;
        this.undefStack = void 0;
        this.current = globalMacros;
        this.builtins = builtins;
        this.undefStack = [];
      }
      /**
       * Start a new nested group, affecting future local `set`s.
       */


      beginGroup() {
        this.undefStack.push({});
      }
      /**
       * End current nested group, restoring values before the group began.
       */


      endGroup() {
        if (this.undefStack.length === 0) {
          throw new ParseError("Unbalanced namespace destruction: attempt " + "to pop global namespace; please report this as a bug");
        }

        var undefs = this.undefStack.pop();

        for (var undef in undefs) {
          if (undefs.hasOwnProperty(undef)) {
            if (undefs[undef] == null) {
              delete this.current[undef];
            } else {
              this.current[undef] = undefs[undef];
            }
          }
        }
      }
      /**
       * Ends all currently nested groups (if any), restoring values before the
       * groups began.  Useful in case of an error in the middle of parsing.
       */


      endGroups() {
        while (this.undefStack.length > 0) {
          this.endGroup();
        }
      }
      /**
       * Detect whether `name` has a definition.  Equivalent to
       * `get(name) != null`.
       */


      has(name) {
        return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
      }
      /**
       * Get the current value of a name, or `undefined` if there is no value.
       *
       * Note: Do not use `if (namespace.get(...))` to detect whether a macro
       * is defined, as the definition may be the empty string which evaluates
       * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
       * `if (namespace.has(...))`.
       */


      get(name) {
        if (this.current.hasOwnProperty(name)) {
          return this.current[name];
        } else {
          return this.builtins[name];
        }
      }
      /**
       * Set the current value of a name, and optionally set it globally too.
       * Local set() sets the current value and (when appropriate) adds an undo
       * operation to the undo stack.  Global set() may change the undo
       * operation at every level, so takes time linear in their number.
       * A value of undefined means to delete existing definitions.
       */


      set(name, value, global) {
        if (global === void 0) {
          global = false;
        }

        if (global) {
          // Global set is equivalent to setting in all groups.  Simulate this
          // by destroying any undos currently scheduled for this name,
          // and adding an undo with the *new* value (in case it later gets
          // locally reset within this environment).
          for (var i = 0; i < this.undefStack.length; i++) {
            delete this.undefStack[i][name];
          }

          if (this.undefStack.length > 0) {
            this.undefStack[this.undefStack.length - 1][name] = value;
          }
        } else {
          // Undo this set at end of this group (possibly to `undefined`),
          // unless an undo is already in place, in which case that older
          // value is the correct one.
          var top = this.undefStack[this.undefStack.length - 1];

          if (top && !top.hasOwnProperty(name)) {
            top[name] = this.current[name];
          }
        }

        if (value == null) {
          delete this.current[name];
        } else {
          this.current[name] = value;
        }
      }

    }

    /**
     * Predefined macros for KaTeX.
     * This can be used to define some commands in terms of others.
     */
    var macros = _macros;
    // macro tools

    defineMacro("\\noexpand", function (context) {
      // The expansion is the token itself; but that token is interpreted
      // as if its meaning were \relax if it is a control sequence that
      // would ordinarily be expanded by TeXs expansion rules.
      var t = context.popToken();

      if (context.isExpandable(t.text)) {
        t.noexpand = true;
        t.treatAsRelax = true;
      }

      return {
        tokens: [t],
        numArgs: 0
      };
    });
    defineMacro("\\expandafter", function (context) {
      // TeX first reads the token that comes immediately after \expandafter,
      // without expanding it; lets call this token t. Then TeX reads the
      // token that comes after t (and possibly more tokens, if that token
      // has an argument), replacing it by its expansion. Finally TeX puts
      // t back in front of that expansion.
      var t = context.popToken();
      context.expandOnce(true); // expand only an expandable token

      return {
        tokens: [t],
        numArgs: 0
      };
    }); // LaTeX's \@firstoftwo{#1}{#2} expands to #1, skipping #2
    // TeX source: \long\def\@firstoftwo#1#2{#1}

    defineMacro("\\@firstoftwo", function (context) {
      var args = context.consumeArgs(2);
      return {
        tokens: args[0],
        numArgs: 0
      };
    }); // LaTeX's \@secondoftwo{#1}{#2} expands to #2, skipping #1
    // TeX source: \long\def\@secondoftwo#1#2{#2}

    defineMacro("\\@secondoftwo", function (context) {
      var args = context.consumeArgs(2);
      return {
        tokens: args[1],
        numArgs: 0
      };
    }); // LaTeX's \@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)
    // symbol that isn't a space, consuming any spaces but not consuming the
    // first nonspace character.  If that nonspace character matches #1, then
    // the macro expands to #2; otherwise, it expands to #3.

    defineMacro("\\@ifnextchar", function (context) {
      var args = context.consumeArgs(3); // symbol, if, else

      context.consumeSpaces();
      var nextToken = context.future();

      if (args[0].length === 1 && args[0][0].text === nextToken.text) {
        return {
          tokens: args[1],
          numArgs: 0
        };
      } else {
        return {
          tokens: args[2],
          numArgs: 0
        };
      }
    }); // LaTeX's \@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.
    // If it is `*`, then it consumes the symbol, and the macro expands to #1;
    // otherwise, the macro expands to #2 (without consuming the symbol).
    // TeX source: \def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}

    defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"); // LaTeX's \TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode

    defineMacro("\\TextOrMath", function (context) {
      var args = context.consumeArgs(2);

      if (context.mode === 'text') {
        return {
          tokens: args[0],
          numArgs: 0
        };
      } else {
        return {
          tokens: args[1],
          numArgs: 0
        };
      }
    }); // Lookup table for parsing numbers in base 8 through 16

    var digitToNumber = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      "a": 10,
      "A": 10,
      "b": 11,
      "B": 11,
      "c": 12,
      "C": 12,
      "d": 13,
      "D": 13,
      "e": 14,
      "E": 14,
      "f": 15,
      "F": 15
    }; // TeX \char makes a literal character (catcode 12) using the following forms:
    // (see The TeXBook, p. 43)
    //   \char123  -- decimal
    //   \char'123 -- octal
    //   \char"123 -- hex
    //   \char`x   -- character that can be written (i.e. isn't active)
    //   \char`\x  -- character that cannot be written (e.g. %)
    // These all refer to characters from the font, so we turn them into special
    // calls to a function \@char dealt with in the Parser.

    defineMacro("\\char", function (context) {
      var token = context.popToken();
      var base;
      var number = '';

      if (token.text === "'") {
        base = 8;
        token = context.popToken();
      } else if (token.text === '"') {
        base = 16;
        token = context.popToken();
      } else if (token.text === "`") {
        token = context.popToken();

        if (token.text[0] === "\\") {
          number = token.text.charCodeAt(1);
        } else if (token.text === "EOF") {
          throw new ParseError("\\char` missing argument");
        } else {
          number = token.text.charCodeAt(0);
        }
      } else {
        base = 10;
      }

      if (base) {
        // Parse a number in the given base, starting with first `token`.
        number = digitToNumber[token.text];

        if (number == null || number >= base) {
          throw new ParseError("Invalid base-" + base + " digit " + token.text);
        }

        var digit;

        while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
          number *= base;
          number += digit;
          context.popToken();
        }
      }

      return "\\@char{" + number + "}";
    }); // \newcommand{\macro}[args]{definition}
    // \renewcommand{\macro}[args]{definition}
    // TODO: Optional arguments: \newcommand{\macro}[args][default]{definition}

    var newcommand = (context, existsOK, nonexistsOK, skipIfExists) => {
      var arg = context.consumeArg().tokens;

      if (arg.length !== 1) {
        throw new ParseError("\\newcommand's first argument must be a macro name");
      }

      var name = arg[0].text;
      var exists = context.isDefined(name);

      if (exists && !existsOK) {
        throw new ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
      }

      if (!exists && !nonexistsOK) {
        throw new ParseError("\\renewcommand{" + name + "} when command " + name + " " + "does not yet exist; use \\newcommand");
      }

      var numArgs = 0;
      arg = context.consumeArg().tokens;

      if (arg.length === 1 && arg[0].text === "[") {
        var argText = '';
        var token = context.expandNextToken();

        while (token.text !== "]" && token.text !== "EOF") {
          // TODO: Should properly expand arg, e.g., ignore {}s
          argText += token.text;
          token = context.expandNextToken();
        }

        if (!argText.match(/^\s*[0-9]+\s*$/)) {
          throw new ParseError("Invalid number of arguments: " + argText);
        }

        numArgs = parseInt(argText);
        arg = context.consumeArg().tokens;
      }

      if (!(exists && skipIfExists)) {
        // Final arg is the expansion of the macro
        context.macros.set(name, {
          tokens: arg,
          numArgs
        });
      }

      return '';
    };

    defineMacro("\\newcommand", context => newcommand(context, false, true, false));
    defineMacro("\\renewcommand", context => newcommand(context, true, false, false));
    defineMacro("\\providecommand", context => newcommand(context, true, true, true)); // terminal (console) tools

    defineMacro("\\message", context => {
      var arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console

      console.log(arg.reverse().map(token => token.text).join(""));
      return '';
    });
    defineMacro("\\errmessage", context => {
      var arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console

      console.error(arg.reverse().map(token => token.text).join(""));
      return '';
    });
    defineMacro("\\show", context => {
      var tok = context.popToken();
      var name = tok.text; // eslint-disable-next-line no-console

      console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);
      return '';
    }); //////////////////////////////////////////////////////////////////////
    // Grouping
    // \let\bgroup={ \let\egroup=}

    defineMacro("\\bgroup", "{");
    defineMacro("\\egroup", "}"); // Symbols from latex.ltx:
    // \def~{\nobreakspace{}}
    // \def\lq{`}
    // \def\rq{'}
    // \def \aa {\r a}
    // \def \AA {\r A}

    defineMacro("~", "\\nobreakspace");
    defineMacro("\\lq", "`");
    defineMacro("\\rq", "'");
    defineMacro("\\aa", "\\r a");
    defineMacro("\\AA", "\\r A"); // Copyright (C) and registered (R) symbols. Use raw symbol in MathML.
    // \DeclareTextCommandDefault{\textcopyright}{\textcircled{c}}
    // \DeclareTextCommandDefault{\textregistered}{\textcircled{%
    //      \check@mathfonts\fontsize\sf@size\z@\math@fontsfalse\selectfont R}}
    // \DeclareRobustCommand{\copyright}{%
    //    \ifmmode{\nfss@text{\textcopyright}}\else\textcopyright\fi}

    defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`}");
    defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
    defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}"); // Characters omitted from Unicode range 1D4001D7FF

    defineMacro("\u212C", "\\mathscr{B}"); // script

    defineMacro("\u2130", "\\mathscr{E}");
    defineMacro("\u2131", "\\mathscr{F}");
    defineMacro("\u210B", "\\mathscr{H}");
    defineMacro("\u2110", "\\mathscr{I}");
    defineMacro("\u2112", "\\mathscr{L}");
    defineMacro("\u2133", "\\mathscr{M}");
    defineMacro("\u211B", "\\mathscr{R}");
    defineMacro("\u212D", "\\mathfrak{C}"); // Fraktur

    defineMacro("\u210C", "\\mathfrak{H}");
    defineMacro("\u2128", "\\mathfrak{Z}"); // Define \Bbbk with a macro that works in both HTML and MathML.

    defineMacro("\\Bbbk", "\\Bbb{k}"); // Unicode middle dot
    // The KaTeX fonts do not contain U+00B7. Instead, \cdotp displays
    // the dot at U+22C5 and gives it punct spacing.

    defineMacro("\u00b7", "\\cdotp"); // \llap and \rlap render their contents in text mode

    defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
    defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
    defineMacro("\\clap", "\\mathclap{\\textrm{#1}}"); // \mathstrut from the TeXbook, p 360

    defineMacro("\\mathstrut", "\\vphantom{(}"); // \underbar from TeXbook p 353

    defineMacro("\\underbar", "\\underline{\\text{#1}}"); // \not is defined by base/fontmath.ltx via
    // \DeclareMathSymbol{\not}{\mathrel}{symbols}{"36}
    // It's thus treated like a \mathrel, but defined by a symbol that has zero
    // width but extends to the right.  We use \rlap to get that spacing.
    // For MathML we write U+0338 here. buildMathML.js will then do the overlay.

    defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}'); // Negated symbols from base/fontmath.ltx:
    // \def\neq{\not=} \let\ne=\neq
    // \DeclareRobustCommand
    //   \notin{\mathrel{\m@th\mathpalette\c@ncel\in}}
    // \def\c@ncel#1#2{\m@th\ooalign{$\hfil#1\mkern1mu/\hfil$\crcr$#1#2$}}

    defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");
    defineMacro("\\ne", "\\neq");
    defineMacro("\u2260", "\\neq");
    defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}" + "{\\mathrel{\\char`}}");
    defineMacro("\u2209", "\\notin"); // Unicode stacked relations

    defineMacro("\u2258", "\\html@mathml{" + "\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}" + "}{\\mathrel{\\char`\u2258}}");
    defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
    defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
    defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}" + "{\\mathrel{\\char`\u225B}}");
    defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}" + "{\\mathrel{\\char`\u225D}}");
    defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}" + "{\\mathrel{\\char`\u225E}}");
    defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}"); // Misc Unicode

    defineMacro("\u27C2", "\\perp");
    defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
    defineMacro("\u220C", "\\notni");
    defineMacro("\u231C", "\\ulcorner");
    defineMacro("\u231D", "\\urcorner");
    defineMacro("\u231E", "\\llcorner");
    defineMacro("\u231F", "\\lrcorner");
    defineMacro("\u00A9", "\\copyright");
    defineMacro("\u00AE", "\\textregistered");
    defineMacro("\uFE0F", "\\textregistered"); // The KaTeX fonts have corners at codepoints that don't match Unicode.
    // For MathML purposes, use the Unicode code point.

    defineMacro("\\ulcorner", "\\html@mathml{\\@ulcorner}{\\mathop{\\char\"231c}}");
    defineMacro("\\urcorner", "\\html@mathml{\\@urcorner}{\\mathop{\\char\"231d}}");
    defineMacro("\\llcorner", "\\html@mathml{\\@llcorner}{\\mathop{\\char\"231e}}");
    defineMacro("\\lrcorner", "\\html@mathml{\\@lrcorner}{\\mathop{\\char\"231f}}"); //////////////////////////////////////////////////////////////////////
    // LaTeX_2
    // \vdots{\vbox{\baselineskip4\p@  \lineskiplimit\z@
    // \kern6\p@\hbox{.}\hbox{.}\hbox{.}}}
    // We'll call \varvdots, which gets a glyph from symbols.js.
    // The zero-width rule gets us an equivalent to the vertical 6pt kern.

    defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
    defineMacro("\u22ee", "\\vdots"); //////////////////////////////////////////////////////////////////////
    // amsmath.sty
    // http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf
    // Italic Greek capital letters.  AMS defines these with \DeclareMathSymbol,
    // but they are equivalent to \mathit{\Letter}.

    defineMacro("\\varGamma", "\\mathit{\\Gamma}");
    defineMacro("\\varDelta", "\\mathit{\\Delta}");
    defineMacro("\\varTheta", "\\mathit{\\Theta}");
    defineMacro("\\varLambda", "\\mathit{\\Lambda}");
    defineMacro("\\varXi", "\\mathit{\\Xi}");
    defineMacro("\\varPi", "\\mathit{\\Pi}");
    defineMacro("\\varSigma", "\\mathit{\\Sigma}");
    defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
    defineMacro("\\varPhi", "\\mathit{\\Phi}");
    defineMacro("\\varPsi", "\\mathit{\\Psi}");
    defineMacro("\\varOmega", "\\mathit{\\Omega}"); //\newcommand{\substack}[1]{\subarray{c}#1\endsubarray}

    defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}"); // \renewcommand{\colon}{\nobreak\mskip2mu\mathpunct{}\nonscript
    // \mkern-\thinmuskip{:}\mskip6muplus1mu\relax}

    defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}" + "\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax"); // \newcommand{\boxed}[1]{\fbox{\m@th$\displaystyle#1$}}

    defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}"); // \def\iff{\DOTSB\;\Longleftrightarrow\;}
    // \def\implies{\DOTSB\;\Longrightarrow\;}
    // \def\impliedby{\DOTSB\;\Longleftarrow\;}

    defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
    defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
    defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;"); // \def\dddot#1{{\mathop{#1}\limits^{\vbox to-1.4\ex@{\kern-\tw@\ex@
    //  \hbox{\normalfont ...}\vss}}}}
    // We use \overset which avoids the vertical shift of \mathop.

    defineMacro("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
    defineMacro("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}"); // AMSMath's automatic \dots, based on \mdots@@ macro.

    var dotsByToken = {
      ',': '\\dotsc',
      '\\not': '\\dotsb',
      // \keybin@ checks for the following:
      '+': '\\dotsb',
      '=': '\\dotsb',
      '<': '\\dotsb',
      '>': '\\dotsb',
      '-': '\\dotsb',
      '*': '\\dotsb',
      ':': '\\dotsb',
      // Symbols whose definition starts with \DOTSB:
      '\\DOTSB': '\\dotsb',
      '\\coprod': '\\dotsb',
      '\\bigvee': '\\dotsb',
      '\\bigwedge': '\\dotsb',
      '\\biguplus': '\\dotsb',
      '\\bigcap': '\\dotsb',
      '\\bigcup': '\\dotsb',
      '\\prod': '\\dotsb',
      '\\sum': '\\dotsb',
      '\\bigotimes': '\\dotsb',
      '\\bigoplus': '\\dotsb',
      '\\bigodot': '\\dotsb',
      '\\bigsqcup': '\\dotsb',
      '\\And': '\\dotsb',
      '\\longrightarrow': '\\dotsb',
      '\\Longrightarrow': '\\dotsb',
      '\\longleftarrow': '\\dotsb',
      '\\Longleftarrow': '\\dotsb',
      '\\longleftrightarrow': '\\dotsb',
      '\\Longleftrightarrow': '\\dotsb',
      '\\mapsto': '\\dotsb',
      '\\longmapsto': '\\dotsb',
      '\\hookrightarrow': '\\dotsb',
      '\\doteq': '\\dotsb',
      // Symbols whose definition starts with \mathbin:
      '\\mathbin': '\\dotsb',
      // Symbols whose definition starts with \mathrel:
      '\\mathrel': '\\dotsb',
      '\\relbar': '\\dotsb',
      '\\Relbar': '\\dotsb',
      '\\xrightarrow': '\\dotsb',
      '\\xleftarrow': '\\dotsb',
      // Symbols whose definition starts with \DOTSI:
      '\\DOTSI': '\\dotsi',
      '\\int': '\\dotsi',
      '\\oint': '\\dotsi',
      '\\iint': '\\dotsi',
      '\\iiint': '\\dotsi',
      '\\iiiint': '\\dotsi',
      '\\idotsint': '\\dotsi',
      // Symbols whose definition starts with \DOTSX:
      '\\DOTSX': '\\dotsx'
    };
    defineMacro("\\dots", function (context) {
      // TODO: If used in text mode, should expand to \textellipsis.
      // However, in KaTeX, \textellipsis and \ldots behave the same
      // (in text mode), and it's unlikely we'd see any of the math commands
      // that affect the behavior of \dots when in text mode.  So fine for now
      // (until we support \ifmmode ... \else ... \fi).
      var thedots = '\\dotso';
      var next = context.expandAfterFuture().text;

      if (next in dotsByToken) {
        thedots = dotsByToken[next];
      } else if (next.slice(0, 4) === '\\not') {
        thedots = '\\dotsb';
      } else if (next in symbols.math) {
        if (['bin', 'rel'].includes(symbols.math[next].group)) {
          thedots = '\\dotsb';
        }
      }

      return thedots;
    });
    var spaceAfterDots = {
      // \rightdelim@ checks for the following:
      ')': true,
      ']': true,
      '\\rbrack': true,
      '\\}': true,
      '\\rbrace': true,
      '\\rangle': true,
      '\\rceil': true,
      '\\rfloor': true,
      '\\rgroup': true,
      '\\rmoustache': true,
      '\\right': true,
      '\\bigr': true,
      '\\biggr': true,
      '\\Bigr': true,
      '\\Biggr': true,
      // \extra@ also tests for the following:
      '$': true,
      // \extrap@ checks for the following:
      ';': true,
      '.': true,
      ',': true
    };
    defineMacro("\\dotso", function (context) {
      var next = context.future().text;

      if (next in spaceAfterDots) {
        return "\\ldots\\,";
      } else {
        return "\\ldots";
      }
    });
    defineMacro("\\dotsc", function (context) {
      var next = context.future().text; // \dotsc uses \extra@ but not \extrap@, instead specially checking for
      // ';' and '.', but doesn't check for ','.

      if (next in spaceAfterDots && next !== ',') {
        return "\\ldots\\,";
      } else {
        return "\\ldots";
      }
    });
    defineMacro("\\cdots", function (context) {
      var next = context.future().text;

      if (next in spaceAfterDots) {
        return "\\@cdots\\,";
      } else {
        return "\\@cdots";
      }
    });
    defineMacro("\\dotsb", "\\cdots");
    defineMacro("\\dotsm", "\\cdots");
    defineMacro("\\dotsi", "\\!\\cdots"); // amsmath doesn't actually define \dotsx, but \dots followed by a macro
    // starting with \DOTSX implies \dotso, and then \extra@ detects this case
    // and forces the added `\,`.

    defineMacro("\\dotsx", "\\ldots\\,"); // \let\DOTSI\relax
    // \let\DOTSB\relax
    // \let\DOTSX\relax

    defineMacro("\\DOTSI", "\\relax");
    defineMacro("\\DOTSB", "\\relax");
    defineMacro("\\DOTSX", "\\relax"); // Spacing, based on amsmath.sty's override of LaTeX defaults
    // \DeclareRobustCommand{\tmspace}[3]{%
    //   \ifmmode\mskip#1#2\else\kern#1#3\fi\relax}

    defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"); // \renewcommand{\,}{\tmspace+\thinmuskip{.1667em}}
    // TODO: math mode should use \thinmuskip

    defineMacro("\\,", "\\tmspace+{3mu}{.1667em}"); // \let\thinspace\,

    defineMacro("\\thinspace", "\\,"); // \def\>{\mskip\medmuskip}
    // \renewcommand{\:}{\tmspace+\medmuskip{.2222em}}
    // TODO: \> and math mode of \: should use \medmuskip = 4mu plus 2mu minus 4mu

    defineMacro("\\>", "\\mskip{4mu}");
    defineMacro("\\:", "\\tmspace+{4mu}{.2222em}"); // \let\medspace\:

    defineMacro("\\medspace", "\\:"); // \renewcommand{\;}{\tmspace+\thickmuskip{.2777em}}
    // TODO: math mode should use \thickmuskip = 5mu plus 5mu

    defineMacro("\\;", "\\tmspace+{5mu}{.2777em}"); // \let\thickspace\;

    defineMacro("\\thickspace", "\\;"); // \renewcommand{\!}{\tmspace-\thinmuskip{.1667em}}
    // TODO: math mode should use \thinmuskip

    defineMacro("\\!", "\\tmspace-{3mu}{.1667em}"); // \let\negthinspace\!

    defineMacro("\\negthinspace", "\\!"); // \newcommand{\negmedspace}{\tmspace-\medmuskip{.2222em}}
    // TODO: math mode should use \medmuskip

    defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}"); // \newcommand{\negthickspace}{\tmspace-\thickmuskip{.2777em}}
    // TODO: math mode should use \thickmuskip

    defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}"); // \def\enspace{\kern.5em }

    defineMacro("\\enspace", "\\kern.5em "); // \def\enskip{\hskip.5em\relax}

    defineMacro("\\enskip", "\\hskip.5em\\relax"); // \def\quad{\hskip1em\relax}

    defineMacro("\\quad", "\\hskip1em\\relax"); // \def\qquad{\hskip2em\relax}

    defineMacro("\\qquad", "\\hskip2em\\relax"); // \tag@in@display form of \tag

    defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
    defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
    defineMacro("\\tag@literal", context => {
      if (context.macros.get("\\df@tag")) {
        throw new ParseError("Multiple \\tag");
      }

      return "\\gdef\\df@tag{\\text{#1}}";
    }); // \renewcommand{\bmod}{\nonscript\mskip-\medmuskip\mkern5mu\mathbin
    //   {\operator@font mod}\penalty900
    //   \mkern5mu\nonscript\mskip-\medmuskip}
    // \newcommand{\pod}[1]{\allowbreak
    //   \if@display\mkern18mu\else\mkern8mu\fi(#1)}
    // \renewcommand{\pmod}[1]{\pod{{\operator@font mod}\mkern6mu#1}}
    // \newcommand{\mod}[1]{\allowbreak\if@display\mkern18mu
    //   \else\mkern12mu\fi{\operator@font mod}\,\,#1}
    // TODO: math mode should use \medmuskip = 4mu plus 2mu minus 4mu

    defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}" + "\\mathbin{\\rm mod}" + "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
    defineMacro("\\pod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
    defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
    defineMacro("\\mod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}" + "{\\rm mod}\\,\\,#1"); //////////////////////////////////////////////////////////////////////
    // LaTeX source2e
    // \expandafter\let\expandafter\@normalcr
    //     \csname\expandafter\@gobble\string\\ \endcsname
    // \DeclareRobustCommand\newline{\@normalcr\relax}

    defineMacro("\\newline", "\\\\\\relax"); // \def\TeX{T\kern-.1667em\lower.5ex\hbox{E}\kern-.125emX\@}
    // TODO: Doesn't normally work in math mode because \@ fails.  KaTeX doesn't
    // support \@ yet, so that's omitted, and we add \text so that the result
    // doesn't look funny in math mode.

    defineMacro("\\TeX", "\\textrm{\\html@mathml{" + "T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX" + "}{TeX}}"); // \DeclareRobustCommand{\LaTeX}{L\kern-.36em%
    //         {\sbox\z@ T%
    //          \vbox to\ht\z@{\hbox{\check@mathfonts
    //                               \fontsize\sf@size\z@
    //                               \math@fontsfalse\selectfont
    //                               A}%
    //                         \vss}%
    //         }%
    //         \kern-.15em%
    //         \TeX}
    // This code aligns the top of the A with the T (from the perspective of TeX's
    // boxes, though visually the A appears to extend above slightly).
    // We compute the corresponding \raisebox when A is rendered in \normalsize
    // \scriptstyle, which has a scale factor of 0.7 (see Options.js).

    var latexRaiseA = makeEm(fontMetricsData['Main-Regular']["T".charCodeAt(0)][1] - 0.7 * fontMetricsData['Main-Regular']["A".charCodeAt(0)][1]);
    defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}"); // New KaTeX logo based on tweaking LaTeX logo

    defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}"); // \DeclareRobustCommand\hspace{\@ifstar\@hspacer\@hspace}
    // \def\@hspace#1{\hskip  #1\relax}
    // \def\@hspacer#1{\vrule \@width\z@\nobreak
    //                 \hskip #1\hskip \z@skip}

    defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
    defineMacro("\\@hspace", "\\hskip #1\\relax");
    defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"); //////////////////////////////////////////////////////////////////////
    // mathtools.sty
    //\providecommand\ordinarycolon{:}

    defineMacro("\\ordinarycolon", ":"); //\def\vcentcolon{\mathrel{\mathop\ordinarycolon}}
    //TODO(edemaine): Not yet centered. Fix via \raisebox or #726

    defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"); // \providecommand*\dblcolon{\vcentcolon\mathrel{\mkern-.9mu}\vcentcolon}

    defineMacro("\\dblcolon", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}" + "{\\mathop{\\char\"2237}}"); // \providecommand*\coloneqq{\vcentcolon\mathrel{\mkern-1.2mu}=}

    defineMacro("\\coloneqq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}" + "{\\mathop{\\char\"2254}}"); // 
    // \providecommand*\Coloneqq{\dblcolon\mathrel{\mkern-1.2mu}=}

    defineMacro("\\Coloneqq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}" + "{\\mathop{\\char\"2237\\char\"3d}}"); // \providecommand*\coloneq{\vcentcolon\mathrel{\mkern-1.2mu}\mathrel{-}}

    defineMacro("\\coloneq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + "{\\mathop{\\char\"3a\\char\"2212}}"); // \providecommand*\Coloneq{\dblcolon\mathrel{\mkern-1.2mu}\mathrel{-}}

    defineMacro("\\Coloneq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + "{\\mathop{\\char\"2237\\char\"2212}}"); // \providecommand*\eqqcolon{=\mathrel{\mkern-1.2mu}\vcentcolon}

    defineMacro("\\eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + "{\\mathop{\\char\"2255}}"); // 
    // \providecommand*\Eqqcolon{=\mathrel{\mkern-1.2mu}\dblcolon}

    defineMacro("\\Eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + "{\\mathop{\\char\"3d\\char\"2237}}"); // \providecommand*\eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\vcentcolon}

    defineMacro("\\eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + "{\\mathop{\\char\"2239}}"); // \providecommand*\Eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\dblcolon}

    defineMacro("\\Eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + "{\\mathop{\\char\"2212\\char\"2237}}"); // \providecommand*\colonapprox{\vcentcolon\mathrel{\mkern-1.2mu}\approx}

    defineMacro("\\colonapprox", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + "{\\mathop{\\char\"3a\\char\"2248}}"); // \providecommand*\Colonapprox{\dblcolon\mathrel{\mkern-1.2mu}\approx}

    defineMacro("\\Colonapprox", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + "{\\mathop{\\char\"2237\\char\"2248}}"); // \providecommand*\colonsim{\vcentcolon\mathrel{\mkern-1.2mu}\sim}

    defineMacro("\\colonsim", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + "{\\mathop{\\char\"3a\\char\"223c}}"); // \providecommand*\Colonsim{\dblcolon\mathrel{\mkern-1.2mu}\sim}

    defineMacro("\\Colonsim", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + "{\\mathop{\\char\"2237\\char\"223c}}"); // Some Unicode characters are implemented with macros to mathtools functions.

    defineMacro("\u2237", "\\dblcolon"); // ::

    defineMacro("\u2239", "\\eqcolon"); // -:

    defineMacro("\u2254", "\\coloneqq"); // :=

    defineMacro("\u2255", "\\eqqcolon"); // =:

    defineMacro("\u2A74", "\\Coloneqq"); // ::=
    //////////////////////////////////////////////////////////////////////
    // colonequals.sty
    // Alternate names for mathtools's macros:

    defineMacro("\\ratio", "\\vcentcolon");
    defineMacro("\\coloncolon", "\\dblcolon");
    defineMacro("\\colonequals", "\\coloneqq");
    defineMacro("\\coloncolonequals", "\\Coloneqq");
    defineMacro("\\equalscolon", "\\eqqcolon");
    defineMacro("\\equalscoloncolon", "\\Eqqcolon");
    defineMacro("\\colonminus", "\\coloneq");
    defineMacro("\\coloncolonminus", "\\Coloneq");
    defineMacro("\\minuscolon", "\\eqcolon");
    defineMacro("\\minuscoloncolon", "\\Eqcolon"); // \colonapprox name is same in mathtools and colonequals.

    defineMacro("\\coloncolonapprox", "\\Colonapprox"); // \colonsim name is same in mathtools and colonequals.

    defineMacro("\\coloncolonsim", "\\Colonsim"); // Additional macros, implemented by analogy with mathtools definitions:

    defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
    defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
    defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
    defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"); // Present in newtxmath, pxfonts and txfonts

    defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
    defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
    defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}"); //////////////////////////////////////////////////////////////////////
    // From amsopn.sty

    defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
    defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
    defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
    defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
    defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
    defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}"); //////////////////////////////////////////////////////////////////////
    // MathML alternates for KaTeX glyphs in the Unicode private area

    defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
    defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
    defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
    defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
    defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
    defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
    defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{}");
    defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{}");
    defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
    defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
    defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{}");
    defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{}");
    defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{}");
    defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{}");
    defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
    defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}"); //////////////////////////////////////////////////////////////////////
    // stmaryrd and semantic
    // The stmaryrd and semantic packages render the next four items by calling a
    // glyph. Those glyphs do not exist in the KaTeX fonts. Hence the macros.

    defineMacro("\\llbracket", "\\html@mathml{" + "\\mathopen{[\\mkern-3.2mu[}}" + "{\\mathopen{\\char`\u27e6}}");
    defineMacro("\\rrbracket", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu]}}" + "{\\mathclose{\\char`\u27e7}}");
    defineMacro("\u27e6", "\\llbracket"); // blackboard bold [

    defineMacro("\u27e7", "\\rrbracket"); // blackboard bold ]

    defineMacro("\\lBrace", "\\html@mathml{" + "\\mathopen{\\{\\mkern-3.2mu[}}" + "{\\mathopen{\\char`\u2983}}");
    defineMacro("\\rBrace", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu\\}}}" + "{\\mathclose{\\char`\u2984}}");
    defineMacro("\u2983", "\\lBrace"); // blackboard bold {

    defineMacro("\u2984", "\\rBrace"); // blackboard bold }
    // TODO: Create variable sized versions of the last two items. I believe that
    // will require new font glyphs.
    // The stmaryrd function `\minuso` provides a "Plimsoll" symbol that
    // superimposes the characters \circ and \mathminus. Used in chemistry.

    defineMacro("\\minuso", "\\mathbin{\\html@mathml{" + "{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}" + "{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}" + "{\\char`}}");
    defineMacro("", "\\minuso"); //////////////////////////////////////////////////////////////////////
    // texvc.sty
    // The texvc package contains macros available in mediawiki pages.
    // We omit the functions deprecated at
    // https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax
    // We also omit texvc's \O, which conflicts with \text{\O}

    defineMacro("\\darr", "\\downarrow");
    defineMacro("\\dArr", "\\Downarrow");
    defineMacro("\\Darr", "\\Downarrow");
    defineMacro("\\lang", "\\langle");
    defineMacro("\\rang", "\\rangle");
    defineMacro("\\uarr", "\\uparrow");
    defineMacro("\\uArr", "\\Uparrow");
    defineMacro("\\Uarr", "\\Uparrow");
    defineMacro("\\N", "\\mathbb{N}");
    defineMacro("\\R", "\\mathbb{R}");
    defineMacro("\\Z", "\\mathbb{Z}");
    defineMacro("\\alef", "\\aleph");
    defineMacro("\\alefsym", "\\aleph");
    defineMacro("\\Alpha", "\\mathrm{A}");
    defineMacro("\\Beta", "\\mathrm{B}");
    defineMacro("\\bull", "\\bullet");
    defineMacro("\\Chi", "\\mathrm{X}");
    defineMacro("\\clubs", "\\clubsuit");
    defineMacro("\\cnums", "\\mathbb{C}");
    defineMacro("\\Complex", "\\mathbb{C}");
    defineMacro("\\Dagger", "\\ddagger");
    defineMacro("\\diamonds", "\\diamondsuit");
    defineMacro("\\empty", "\\emptyset");
    defineMacro("\\Epsilon", "\\mathrm{E}");
    defineMacro("\\Eta", "\\mathrm{H}");
    defineMacro("\\exist", "\\exists");
    defineMacro("\\harr", "\\leftrightarrow");
    defineMacro("\\hArr", "\\Leftrightarrow");
    defineMacro("\\Harr", "\\Leftrightarrow");
    defineMacro("\\hearts", "\\heartsuit");
    defineMacro("\\image", "\\Im");
    defineMacro("\\infin", "\\infty");
    defineMacro("\\Iota", "\\mathrm{I}");
    defineMacro("\\isin", "\\in");
    defineMacro("\\Kappa", "\\mathrm{K}");
    defineMacro("\\larr", "\\leftarrow");
    defineMacro("\\lArr", "\\Leftarrow");
    defineMacro("\\Larr", "\\Leftarrow");
    defineMacro("\\lrarr", "\\leftrightarrow");
    defineMacro("\\lrArr", "\\Leftrightarrow");
    defineMacro("\\Lrarr", "\\Leftrightarrow");
    defineMacro("\\Mu", "\\mathrm{M}");
    defineMacro("\\natnums", "\\mathbb{N}");
    defineMacro("\\Nu", "\\mathrm{N}");
    defineMacro("\\Omicron", "\\mathrm{O}");
    defineMacro("\\plusmn", "\\pm");
    defineMacro("\\rarr", "\\rightarrow");
    defineMacro("\\rArr", "\\Rightarrow");
    defineMacro("\\Rarr", "\\Rightarrow");
    defineMacro("\\real", "\\Re");
    defineMacro("\\reals", "\\mathbb{R}");
    defineMacro("\\Reals", "\\mathbb{R}");
    defineMacro("\\Rho", "\\mathrm{P}");
    defineMacro("\\sdot", "\\cdot");
    defineMacro("\\sect", "\\S");
    defineMacro("\\spades", "\\spadesuit");
    defineMacro("\\sub", "\\subset");
    defineMacro("\\sube", "\\subseteq");
    defineMacro("\\supe", "\\supseteq");
    defineMacro("\\Tau", "\\mathrm{T}");
    defineMacro("\\thetasym", "\\vartheta"); // TODO: defineMacro("\\varcoppa", "\\\mbox{\\coppa}");

    defineMacro("\\weierp", "\\wp");
    defineMacro("\\Zeta", "\\mathrm{Z}"); //////////////////////////////////////////////////////////////////////
    // statmath.sty
    // https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf

    defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
    defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
    defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits"); //////////////////////////////////////////////////////////////////////
    // braket.sty
    // http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/braket/braket.pdf

    defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
    defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
    defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
    defineMacro("\\Bra", "\\left\\langle#1\\right|");
    defineMacro("\\Ket", "\\left|#1\\right\\rangle");

    var braketHelper = one => context => {
      var left = context.consumeArg().tokens;
      var middle = context.consumeArg().tokens;
      var middleDouble = context.consumeArg().tokens;
      var right = context.consumeArg().tokens;
      var oldMiddle = context.macros.get("|");
      var oldMiddleDouble = context.macros.get("\\|");
      context.macros.beginGroup();

      var midMacro = double => context => {
        if (one) {
          // Only modify the first instance of | or \|
          context.macros.set("|", oldMiddle);

          if (middleDouble.length) {
            context.macros.set("\\|", oldMiddleDouble);
          }
        }

        var doubled = double;

        if (!double && middleDouble.length) {
          // Mimic \@ifnextchar
          var nextToken = context.future();

          if (nextToken.text === "|") {
            context.popToken();
            doubled = true;
          }
        }

        return {
          tokens: doubled ? middleDouble : middle,
          numArgs: 0
        };
      };

      context.macros.set("|", midMacro(false));

      if (middleDouble.length) {
        context.macros.set("\\|", midMacro(true));
      }

      var arg = context.consumeArg().tokens;
      var expanded = context.expandTokens([...right, ...arg, ...left // reversed
      ]);
      context.macros.endGroup();
      return {
        tokens: expanded.reverse(),
        numArgs: 0
      };
    };

    defineMacro("\\bra@ket", braketHelper(false));
    defineMacro("\\bra@set", braketHelper(true));
    defineMacro("\\Braket", "\\bra@ket{\\left\\langle}" + "{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
    defineMacro("\\Set", "\\bra@set{\\left\\{\\:}" + "{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
    defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}"); // has no support for special || or \|
    //////////////////////////////////////////////////////////////////////
    // actuarialangle.dtx

    defineMacro("\\angln", "{\\angl n}"); // Custom Khan Academy colors, should be moved to an optional package

    defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
    defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
    defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
    defineMacro("\\red", "\\textcolor{##df0030}{#1}");
    defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
    defineMacro("\\gray", "\\textcolor{gray}{#1}");
    defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
    defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
    defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
    defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
    defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
    defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
    defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
    defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
    defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
    defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
    defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
    defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
    defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
    defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
    defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
    defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
    defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
    defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
    defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
    defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
    defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
    defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
    defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
    defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
    defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
    defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
    defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
    defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
    defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
    defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
    defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
    defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
    defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
    defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
    defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
    defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
    defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
    defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
    defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
    defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
    defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
    defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
    defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
    defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
    defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
    defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
    defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
    defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
    defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
    defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");

    /**
     * This file contains the gullet where macros are expanded
     * until only non-macro tokens remain.
     */
    // List of commands that act like macros but aren't defined as a macro,
    // function, or symbol.  Used in `isDefined`.
    var implicitCommands = {
      "^": true,
      // Parser.js
      "_": true,
      // Parser.js
      "\\limits": true,
      // Parser.js
      "\\nolimits": true // Parser.js

    };
    class MacroExpander {
      constructor(input, settings, mode) {
        this.settings = void 0;
        this.expansionCount = void 0;
        this.lexer = void 0;
        this.macros = void 0;
        this.stack = void 0;
        this.mode = void 0;
        this.settings = settings;
        this.expansionCount = 0;
        this.feed(input); // Make new global namespace

        this.macros = new Namespace(macros, settings.macros);
        this.mode = mode;
        this.stack = []; // contains tokens in REVERSE order
      }
      /**
       * Feed a new input string to the same MacroExpander
       * (with existing macros etc.).
       */


      feed(input) {
        this.lexer = new Lexer(input, this.settings);
      }
      /**
       * Switches between "text" and "math" modes.
       */


      switchMode(newMode) {
        this.mode = newMode;
      }
      /**
       * Start a new group nesting within all namespaces.
       */


      beginGroup() {
        this.macros.beginGroup();
      }
      /**
       * End current group nesting within all namespaces.
       */


      endGroup() {
        this.macros.endGroup();
      }
      /**
       * Ends all currently nested groups (if any), restoring values before the
       * groups began.  Useful in case of an error in the middle of parsing.
       */


      endGroups() {
        this.macros.endGroups();
      }
      /**
       * Returns the topmost token on the stack, without expanding it.
       * Similar in behavior to TeX's `\futurelet`.
       */


      future() {
        if (this.stack.length === 0) {
          this.pushToken(this.lexer.lex());
        }

        return this.stack[this.stack.length - 1];
      }
      /**
       * Remove and return the next unexpanded token.
       */


      popToken() {
        this.future(); // ensure non-empty stack

        return this.stack.pop();
      }
      /**
       * Add a given token to the token stack.  In particular, this get be used
       * to put back a token returned from one of the other methods.
       */


      pushToken(token) {
        this.stack.push(token);
      }
      /**
       * Append an array of tokens to the token stack.
       */


      pushTokens(tokens) {
        this.stack.push(...tokens);
      }
      /**
       * Find an macro argument without expanding tokens and append the array of
       * tokens to the token stack. Uses Token as a container for the result.
       */


      scanArgument(isOptional) {
        var start;
        var end;
        var tokens;

        if (isOptional) {
          this.consumeSpaces(); // \@ifnextchar gobbles any space following it

          if (this.future().text !== "[") {
            return null;
          }

          start = this.popToken(); // don't include [ in tokens

          ({
            tokens,
            end
          } = this.consumeArg(["]"]));
        } else {
          ({
            tokens,
            start,
            end
          } = this.consumeArg());
        } // indicate the end of an argument


        this.pushToken(new Token("EOF", end.loc));
        this.pushTokens(tokens);
        return new Token("", SourceLocation.range(start, end));
      }
      /**
       * Consume all following space tokens, without expansion.
       */


      consumeSpaces() {
        for (;;) {
          var token = this.future();

          if (token.text === " ") {
            this.stack.pop();
          } else {
            break;
          }
        }
      }
      /**
       * Consume an argument from the token stream, and return the resulting array
       * of tokens and start/end token.
       */


      consumeArg(delims) {
        // The argument for a delimited parameter is the shortest (possibly
        // empty) sequence of tokens with properly nested {...} groups that is
        // followed ... by this particular list of non-parameter tokens.
        // The argument for an undelimited parameter is the next nonblank
        // token, unless that token is {, when the argument will be the
        // entire {...} group that follows.
        var tokens = [];
        var isDelimited = delims && delims.length > 0;

        if (!isDelimited) {
          // Ignore spaces between arguments.  As the TeXbook says:
          // "After you have said \def\row#1#2{...}, you are allowed to
          //  put spaces between the arguments (e.g., \row x n), because
          //  TeX doesnt use single spaces as undelimited arguments."
          this.consumeSpaces();
        }

        var start = this.future();
        var tok;
        var depth = 0;
        var match = 0;

        do {
          tok = this.popToken();
          tokens.push(tok);

          if (tok.text === "{") {
            ++depth;
          } else if (tok.text === "}") {
            --depth;

            if (depth === -1) {
              throw new ParseError("Extra }", tok);
            }
          } else if (tok.text === "EOF") {
            throw new ParseError("Unexpected end of input in a macro argument" + ", expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
          }

          if (delims && isDelimited) {
            if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
              ++match;

              if (match === delims.length) {
                // don't include delims in tokens
                tokens.splice(-match, match);
                break;
              }
            } else {
              match = 0;
            }
          }
        } while (depth !== 0 || isDelimited); // If the argument found ... has the form {<nested tokens>},
        // ... the outermost braces enclosing the argument are removed


        if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
          tokens.pop();
          tokens.shift();
        }

        tokens.reverse(); // to fit in with stack order

        return {
          tokens,
          start,
          end: tok
        };
      }
      /**
       * Consume the specified number of (delimited) arguments from the token
       * stream and return the resulting array of arguments.
       */


      consumeArgs(numArgs, delimiters) {
        if (delimiters) {
          if (delimiters.length !== numArgs + 1) {
            throw new ParseError("The length of delimiters doesn't match the number of args!");
          }

          var delims = delimiters[0];

          for (var i = 0; i < delims.length; i++) {
            var tok = this.popToken();

            if (delims[i] !== tok.text) {
              throw new ParseError("Use of the macro doesn't match its definition", tok);
            }
          }
        }

        var args = [];

        for (var _i = 0; _i < numArgs; _i++) {
          args.push(this.consumeArg(delimiters && delimiters[_i + 1]).tokens);
        }

        return args;
      }
      /**
       * Increment `expansionCount` by the specified amount.
       * Throw an error if it exceeds `maxExpand`.
       */


      countExpansion(amount) {
        this.expansionCount += amount;

        if (this.expansionCount > this.settings.maxExpand) {
          throw new ParseError("Too many expansions: infinite loop or " + "need to increase maxExpand setting");
        }
      }
      /**
       * Expand the next token only once if possible.
       *
       * If the token is expanded, the resulting tokens will be pushed onto
       * the stack in reverse order, and the number of such tokens will be
       * returned.  This number might be zero or positive.
       *
       * If not, the return value is `false`, and the next token remains at the
       * top of the stack.
       *
       * In either case, the next token will be on the top of the stack,
       * or the stack will be empty (in case of empty expansion
       * and no other tokens).
       *
       * Used to implement `expandAfterFuture` and `expandNextToken`.
       *
       * If expandableOnly, only expandable tokens are expanded and
       * an undefined control sequence results in an error.
       */


      expandOnce(expandableOnly) {
        var topToken = this.popToken();
        var name = topToken.text;
        var expansion = !topToken.noexpand ? this._getExpansion(name) : null;

        if (expansion == null || expandableOnly && expansion.unexpandable) {
          if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
            throw new ParseError("Undefined control sequence: " + name);
          }

          this.pushToken(topToken);
          return false;
        }

        this.countExpansion(1);
        var tokens = expansion.tokens;
        var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);

        if (expansion.numArgs) {
          // paste arguments in place of the placeholders
          tokens = tokens.slice(); // make a shallow copy

          for (var i = tokens.length - 1; i >= 0; --i) {
            var tok = tokens[i];

            if (tok.text === "#") {
              if (i === 0) {
                throw new ParseError("Incomplete placeholder at end of macro body", tok);
              }

              tok = tokens[--i]; // next token on stack

              if (tok.text === "#") {
                // ##  #
                tokens.splice(i + 1, 1); // drop first #
              } else if (/^[1-9]$/.test(tok.text)) {
                // replace the placeholder with the indicated argument
                tokens.splice(i, 2, ...args[+tok.text - 1]);
              } else {
                throw new ParseError("Not a valid argument number", tok);
              }
            }
          }
        } // Concatenate expansion onto top of stack.


        this.pushTokens(tokens);
        return tokens.length;
      }
      /**
       * Expand the next token only once (if possible), and return the resulting
       * top token on the stack (without removing anything from the stack).
       * Similar in behavior to TeX's `\expandafter\futurelet`.
       * Equivalent to expandOnce() followed by future().
       */


      expandAfterFuture() {
        this.expandOnce();
        return this.future();
      }
      /**
       * Recursively expand first token, then return first non-expandable token.
       */


      expandNextToken() {
        for (;;) {
          if (this.expandOnce() === false) {
            // fully expanded
            var token = this.stack.pop(); // the token after \noexpand is interpreted as if its meaning
            // were \relax

            if (token.treatAsRelax) {
              token.text = "\\relax";
            }

            return token;
          }
        } // Flow unable to figure out that this pathway is impossible.
        // https://github.com/facebook/flow/issues/4808


        throw new Error(); // eslint-disable-line no-unreachable
      }
      /**
       * Fully expand the given macro name and return the resulting list of
       * tokens, or return `undefined` if no such macro is defined.
       */


      expandMacro(name) {
        return this.macros.has(name) ? this.expandTokens([new Token(name)]) : undefined;
      }
      /**
       * Fully expand the given token stream and return the resulting list of
       * tokens.  Note that the input tokens are in reverse order, but the
       * output tokens are in forward order.
       */


      expandTokens(tokens) {
        var output = [];
        var oldStackLength = this.stack.length;
        this.pushTokens(tokens);

        while (this.stack.length > oldStackLength) {
          // Expand only expandable tokens
          if (this.expandOnce(true) === false) {
            // fully expanded
            var token = this.stack.pop();

            if (token.treatAsRelax) {
              // the expansion of \noexpand is the token itself
              token.noexpand = false;
              token.treatAsRelax = false;
            }

            output.push(token);
          }
        } // Count all of these tokens as additional expansions, to prevent
        // exponential blowup from linearly many \edef's.


        this.countExpansion(output.length);
        return output;
      }
      /**
       * Fully expand the given macro name and return the result as a string,
       * or return `undefined` if no such macro is defined.
       */


      expandMacroAsText(name) {
        var tokens = this.expandMacro(name);

        if (tokens) {
          return tokens.map(token => token.text).join("");
        } else {
          return tokens;
        }
      }
      /**
       * Returns the expanded macro as a reversed array of tokens and a macro
       * argument count.  Or returns `null` if no such macro.
       */


      _getExpansion(name) {
        var definition = this.macros.get(name);

        if (definition == null) {
          // mainly checking for undefined here
          return definition;
        } // If a single character has an associated catcode other than 13
        // (active character), then don't expand it.


        if (name.length === 1) {
          var catcode = this.lexer.catcodes[name];

          if (catcode != null && catcode !== 13) {
            return;
          }
        }

        var expansion = typeof definition === "function" ? definition(this) : definition;

        if (typeof expansion === "string") {
          var numArgs = 0;

          if (expansion.indexOf("#") !== -1) {
            var stripped = expansion.replace(/##/g, "");

            while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
              ++numArgs;
            }
          }

          var bodyLexer = new Lexer(expansion, this.settings);
          var tokens = [];
          var tok = bodyLexer.lex();

          while (tok.text !== "EOF") {
            tokens.push(tok);
            tok = bodyLexer.lex();
          }

          tokens.reverse(); // to fit in with stack using push and pop

          var expanded = {
            tokens,
            numArgs
          };
          return expanded;
        }

        return expansion;
      }
      /**
       * Determine whether a command is currently "defined" (has some
       * functionality), meaning that it's a macro (in the current group),
       * a function, a symbol, or one of the special commands listed in
       * `implicitCommands`.
       */


      isDefined(name) {
        return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
      }
      /**
       * Determine whether a command is expandable.
       */


      isExpandable(name) {
        var macro = this.macros.get(name);
        return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;
      }

    }

    // Helpers for Parser.js handling of Unicode (sub|super)script characters.
    var unicodeSubRegEx = /^[]/;
    var uSubsAndSups = Object.freeze({
      '': '+',
      '': '-',
      '': '=',
      '': '(',
      '': ')',
      '': '0',
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '\u2090': 'a',
      '\u2091': 'e',
      '\u2095': 'h',
      '\u1D62': 'i',
      '\u2C7C': 'j',
      '\u2096': 'k',
      '\u2097': 'l',
      '\u2098': 'm',
      '\u2099': 'n',
      '\u2092': 'o',
      '\u209A': 'p',
      '\u1D63': 'r',
      '\u209B': 's',
      '\u209C': 't',
      '\u1D64': 'u',
      '\u1D65': 'v',
      '\u2093': 'x',
      '\u1D66': '',
      '\u1D67': '',
      '\u1D68': '',
      '\u1D69': '\u03d5',
      '\u1D6A': '',
      '': '+',
      '': '-',
      '': '=',
      '': '(',
      '': ')',
      '': '0',
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '\u1D2C': 'A',
      '\u1D2E': 'B',
      '\u1D30': 'D',
      '\u1D31': 'E',
      '\u1D33': 'G',
      '\u1D34': 'H',
      '\u1D35': 'I',
      '\u1D36': 'J',
      '\u1D37': 'K',
      '\u1D38': 'L',
      '\u1D39': 'M',
      '\u1D3A': 'N',
      '\u1D3C': 'O',
      '\u1D3E': 'P',
      '\u1D3F': 'R',
      '\u1D40': 'T',
      '\u1D41': 'U',
      '\u2C7D': 'V',
      '\u1D42': 'W',
      '\u1D43': 'a',
      '\u1D47': 'b',
      '\u1D9C': 'c',
      '\u1D48': 'd',
      '\u1D49': 'e',
      '\u1DA0': 'f',
      '\u1D4D': 'g',
      '\u02B0': 'h',
      '\u2071': 'i',
      '\u02B2': 'j',
      '\u1D4F': 'k',
      '\u02E1': 'l',
      '\u1D50': 'm',
      '\u207F': 'n',
      '\u1D52': 'o',
      '\u1D56': 'p',
      '\u02B3': 'r',
      '\u02E2': 's',
      '\u1D57': 't',
      '\u1D58': 'u',
      '\u1D5B': 'v',
      '\u02B7': 'w',
      '\u02E3': 'x',
      '\u02B8': 'y',
      '\u1DBB': 'z',
      '\u1D5D': '',
      '\u1D5E': '',
      '\u1D5F': '',
      '\u1D60': '\u03d5',
      '\u1D61': '',
      '\u1DBF': ''
    });

    /* eslint no-constant-condition:0 */

    var unicodeAccents = {
      "": {
        "text": "\\'",
        "math": "\\acute"
      },
      "": {
        "text": "\\`",
        "math": "\\grave"
      },
      "": {
        "text": "\\\"",
        "math": "\\ddot"
      },
      "": {
        "text": "\\~",
        "math": "\\tilde"
      },
      "": {
        "text": "\\=",
        "math": "\\bar"
      },
      "": {
        "text": "\\u",
        "math": "\\breve"
      },
      "": {
        "text": "\\v",
        "math": "\\check"
      },
      "": {
        "text": "\\^",
        "math": "\\hat"
      },
      "": {
        "text": "\\.",
        "math": "\\dot"
      },
      "": {
        "text": "\\r",
        "math": "\\mathring"
      },
      "": {
        "text": "\\H"
      },
      "": {
        "text": "\\c"
      }
    };
    var unicodeSymbols = {
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "b",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "d",
      "": "d",
      "": "d",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "f",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "h",
      "": "h",
      "": "h",
      "": "h",
      "": "h",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "j",
      "": "j",
      "": "k",
      "": "k",
      "": "k",
      "": "l",
      "": "l",
      "": "l",
      "": "m",
      "": "m",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "p",
      "": "p",
      "": "r",
      "": "r",
      "": "r",
      "": "r",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "t",
      "": "t",
      "": "t",
      "": "t",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "v",
      "": "w",
      "": "w",
      "": "w",
      "": "w",
      "": "w",
      "": "w",
      "": "x",
      "": "x",
      "": "y",
      "": "y",
      "": "y",
      "": "y",
      "": "y",
      "": "y",
      "": "y",
      "": "y",
      "": "z",
      "": "z",
      "": "z",
      "": "z",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "B",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "D",
      "": "D",
      "": "D",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "F",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "H",
      "": "H",
      "": "H",
      "": "H",
      "": "H",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "J",
      "": "K",
      "": "K",
      "": "K",
      "": "L",
      "": "L",
      "": "L",
      "": "M",
      "": "M",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "P",
      "": "P",
      "": "R",
      "": "R",
      "": "R",
      "": "R",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "T",
      "": "T",
      "": "T",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "V",
      "": "W",
      "": "W",
      "": "W",
      "": "W",
      "": "W",
      "": "X",
      "": "X",
      "": "Y",
      "": "Y",
      "": "Y",
      "": "Y",
      "": "Y",
      "": "Y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    };

    /**
     * This file contains the parser used to parse out a TeX expression from the
     * input. Since TeX isn't context-free, standard parsers don't work particularly
     * well.
     *
     * The strategy of this parser is as such:
     *
     * The main functions (the `.parse...` ones) take a position in the current
     * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
     * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When
     * individual tokens are needed at a position, the lexer is called to pull out a
     * token, which is then used.
     *
     * The parser has a property called "mode" indicating the mode that
     * the parser is currently in. Currently it has to be one of "math" or
     * "text", which denotes whether the current environment is a math-y
     * one or a text-y one (e.g. inside \text). Currently, this serves to
     * limit the functions which can be used in text mode.
     *
     * The main functions then return an object which contains the useful data that
     * was parsed at its given point, and a new position at the end of the parsed
     * data. The main functions can call each other and continue the parsing by
     * using the returned position as a new starting point.
     *
     * There are also extra `.handle...` functions, which pull out some reused
     * functionality into self-contained functions.
     *
     * The functions return ParseNodes.
     */
    class Parser {
      constructor(input, settings) {
        this.mode = void 0;
        this.gullet = void 0;
        this.settings = void 0;
        this.leftrightDepth = void 0;
        this.nextToken = void 0;
        // Start in math mode
        this.mode = "math"; // Create a new macro expander (gullet) and (indirectly via that) also a
        // new lexer (mouth) for this parser (stomach, in the language of TeX)

        this.gullet = new MacroExpander(input, settings, this.mode); // Store the settings for use in parsing

        this.settings = settings; // Count leftright depth (for \middle errors)

        this.leftrightDepth = 0;
      }
      /**
       * Checks a result to make sure it has the right type, and throws an
       * appropriate error otherwise.
       */


      expect(text, consume) {
        if (consume === void 0) {
          consume = true;
        }

        if (this.fetch().text !== text) {
          throw new ParseError("Expected '" + text + "', got '" + this.fetch().text + "'", this.fetch());
        }

        if (consume) {
          this.consume();
        }
      }
      /**
       * Discards the current lookahead token, considering it consumed.
       */


      consume() {
        this.nextToken = null;
      }
      /**
       * Return the current lookahead token, or if there isn't one (at the
       * beginning, or if the previous lookahead token was consume()d),
       * fetch the next token as the new lookahead token and return it.
       */


      fetch() {
        if (this.nextToken == null) {
          this.nextToken = this.gullet.expandNextToken();
        }

        return this.nextToken;
      }
      /**
       * Switches between "text" and "math" modes.
       */


      switchMode(newMode) {
        this.mode = newMode;
        this.gullet.switchMode(newMode);
      }
      /**
       * Main parsing function, which parses an entire input.
       */


      parse() {
        if (!this.settings.globalGroup) {
          // Create a group namespace for the math expression.
          // (LaTeX creates a new group for every $...$, $$...$$, \[...\].)
          this.gullet.beginGroup();
        } // Use old \color behavior (same as LaTeX's \textcolor) if requested.
        // We do this within the group for the math expression, so it doesn't
        // pollute settings.macros.


        if (this.settings.colorIsTextColor) {
          this.gullet.macros.set("\\color", "\\textcolor");
        }

        try {
          // Try to parse the input
          var parse = this.parseExpression(false); // If we succeeded, make sure there's an EOF at the end

          this.expect("EOF"); // End the group namespace for the expression

          if (!this.settings.globalGroup) {
            this.gullet.endGroup();
          }

          return parse; // Close any leftover groups in case of a parse error.
        } finally {
          this.gullet.endGroups();
        }
      }
      /**
       * Fully parse a separate sequence of tokens as a separate job.
       * Tokens should be specified in reverse order, as in a MacroDefinition.
       */


      subparse(tokens) {
        // Save the next token from the current job.
        var oldToken = this.nextToken;
        this.consume(); // Run the new job, terminating it with an excess '}'

        this.gullet.pushToken(new Token("}"));
        this.gullet.pushTokens(tokens);
        var parse = this.parseExpression(false);
        this.expect("}"); // Restore the next token from the current job.

        this.nextToken = oldToken;
        return parse;
      }

      /**
       * Parses an "expression", which is a list of atoms.
       *
       * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
       *                 happens when functions have higher precedence han infix
       *                 nodes in implicit parses.
       *
       * `breakOnTokenText`: The text of the token that the expression should end
       *                     with, or `null` if something else should end the
       *                     expression.
       */
      parseExpression(breakOnInfix, breakOnTokenText) {
        var body = []; // Keep adding atoms to the body until we can't parse any more atoms (either
        // we reached the end, a }, or a \right)

        while (true) {
          // Ignore spaces in math mode
          if (this.mode === "math") {
            this.consumeSpaces();
          }

          var lex = this.fetch();

          if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
            break;
          }

          if (breakOnTokenText && lex.text === breakOnTokenText) {
            break;
          }

          if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
            break;
          }

          var atom = this.parseAtom(breakOnTokenText);

          if (!atom) {
            break;
          } else if (atom.type === "internal") {
            // Internal nodes do not appear in parse tree
            continue;
          }

          body.push(atom);
        }

        if (this.mode === "text") {
          this.formLigatures(body);
        }

        return this.handleInfixNodes(body);
      }
      /**
       * Rewrites infix operators such as \over with corresponding commands such
       * as \frac.
       *
       * There can only be one infix operator per group.  If there's more than one
       * then the expression is ambiguous.  This can be resolved by adding {}.
       */


      handleInfixNodes(body) {
        var overIndex = -1;
        var funcName;

        for (var i = 0; i < body.length; i++) {
          if (body[i].type === "infix") {
            if (overIndex !== -1) {
              throw new ParseError("only one infix operator per group", body[i].token);
            }

            overIndex = i;
            funcName = body[i].replaceWith;
          }
        }

        if (overIndex !== -1 && funcName) {
          var numerNode;
          var denomNode;
          var numerBody = body.slice(0, overIndex);
          var denomBody = body.slice(overIndex + 1);

          if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
            numerNode = numerBody[0];
          } else {
            numerNode = {
              type: "ordgroup",
              mode: this.mode,
              body: numerBody
            };
          }

          if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
            denomNode = denomBody[0];
          } else {
            denomNode = {
              type: "ordgroup",
              mode: this.mode,
              body: denomBody
            };
          }

          var node;

          if (funcName === "\\\\abovefrac") {
            node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
          } else {
            node = this.callFunction(funcName, [numerNode, denomNode], []);
          }

          return [node];
        } else {
          return body;
        }
      }
      /**
       * Handle a subscript or superscript with nice errors.
       */


      handleSupSubscript(name // For error reporting.
      ) {
        var symbolToken = this.fetch();
        var symbol = symbolToken.text;
        this.consume();
        this.consumeSpaces(); // ignore spaces before sup/subscript argument
        // Skip over allowed internal nodes such as \relax

        var group;

        do {
          var _group;

          group = this.parseGroup(name);
        } while (((_group = group) == null ? void 0 : _group.type) === "internal");

        if (!group) {
          throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
        }

        return group;
      }
      /**
       * Converts the textual input of an unsupported command into a text node
       * contained within a color node whose color is determined by errorColor
       */


      formatUnsupportedCmd(text) {
        var textordArray = [];

        for (var i = 0; i < text.length; i++) {
          textordArray.push({
            type: "textord",
            mode: "text",
            text: text[i]
          });
        }

        var textNode = {
          type: "text",
          mode: this.mode,
          body: textordArray
        };
        var colorNode = {
          type: "color",
          mode: this.mode,
          color: this.settings.errorColor,
          body: [textNode]
        };
        return colorNode;
      }
      /**
       * Parses a group with optional super/subscripts.
       */


      parseAtom(breakOnTokenText) {
        // The body of an atom is an implicit group, so that things like
        // \left(x\right)^2 work correctly.
        var base = this.parseGroup("atom", breakOnTokenText); // Internal nodes (e.g. \relax) cannot support super/subscripts.
        // Instead we will pick up super/subscripts with blank base next round.

        if ((base == null ? void 0 : base.type) === "internal") {
          return base;
        } // In text mode, we don't have superscripts or subscripts


        if (this.mode === "text") {
          return base;
        } // Note that base may be empty (i.e. null) at this point.


        var superscript;
        var subscript;

        while (true) {
          // Guaranteed in math mode, so eat any spaces first.
          this.consumeSpaces(); // Lex the first token

          var lex = this.fetch();

          if (lex.text === "\\limits" || lex.text === "\\nolimits") {
            // We got a limit control
            if (base && base.type === "op") {
              var limits = lex.text === "\\limits";
              base.limits = limits;
              base.alwaysHandleSupSub = true;
            } else if (base && base.type === "operatorname") {
              if (base.alwaysHandleSupSub) {
                base.limits = lex.text === "\\limits";
              }
            } else {
              throw new ParseError("Limit controls must follow a math operator", lex);
            }

            this.consume();
          } else if (lex.text === "^") {
            // We got a superscript start
            if (superscript) {
              throw new ParseError("Double superscript", lex);
            }

            superscript = this.handleSupSubscript("superscript");
          } else if (lex.text === "_") {
            // We got a subscript start
            if (subscript) {
              throw new ParseError("Double subscript", lex);
            }

            subscript = this.handleSupSubscript("subscript");
          } else if (lex.text === "'") {
            // We got a prime
            if (superscript) {
              throw new ParseError("Double superscript", lex);
            }

            var prime = {
              type: "textord",
              mode: this.mode,
              text: "\\prime"
            }; // Many primes can be grouped together, so we handle this here

            var primes = [prime];
            this.consume(); // Keep lexing tokens until we get something that's not a prime

            while (this.fetch().text === "'") {
              // For each one, add another prime to the list
              primes.push(prime);
              this.consume();
            } // If there's a superscript following the primes, combine that
            // superscript in with the primes.


            if (this.fetch().text === "^") {
              primes.push(this.handleSupSubscript("superscript"));
            } // Put everything into an ordgroup as the superscript


            superscript = {
              type: "ordgroup",
              mode: this.mode,
              body: primes
            };
          } else if (uSubsAndSups[lex.text]) {
            // A Unicode subscript or superscript character.
            // We treat these similarly to the unicode-math package.
            // So we render a string of Unicode (sub|super)scripts the
            // same as a (sub|super)script of regular characters.
            var isSub = unicodeSubRegEx.test(lex.text);
            var subsupTokens = [];
            subsupTokens.push(new Token(uSubsAndSups[lex.text]));
            this.consume(); // Continue fetching tokens to fill out the string.

            while (true) {
              var token = this.fetch().text;

              if (!uSubsAndSups[token]) {
                break;
              }

              if (unicodeSubRegEx.test(token) !== isSub) {
                break;
              }

              subsupTokens.unshift(new Token(uSubsAndSups[token]));
              this.consume();
            } // Now create a (sub|super)script.


            var body = this.subparse(subsupTokens);

            if (isSub) {
              subscript = {
                type: "ordgroup",
                mode: "math",
                body
              };
            } else {
              superscript = {
                type: "ordgroup",
                mode: "math",
                body
              };
            }
          } else {
            // If it wasn't ^, _, or ', stop parsing super/subscripts
            break;
          }
        } // Base must be set if superscript or subscript are set per logic above,
        // but need to check here for type check to pass.


        if (superscript || subscript) {
          // If we got either a superscript or subscript, create a supsub
          return {
            type: "supsub",
            mode: this.mode,
            base: base,
            sup: superscript,
            sub: subscript
          };
        } else {
          // Otherwise return the original body
          return base;
        }
      }
      /**
       * Parses an entire function, including its base and all of its arguments.
       */


      parseFunction(breakOnTokenText, name // For determining its context
      ) {
        var token = this.fetch();
        var func = token.text;
        var funcData = functions[func];

        if (!funcData) {
          return null;
        }

        this.consume(); // consume command token

        if (name && name !== "atom" && !funcData.allowedInArgument) {
          throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
        } else if (this.mode === "text" && !funcData.allowedInText) {
          throw new ParseError("Can't use function '" + func + "' in text mode", token);
        } else if (this.mode === "math" && funcData.allowedInMath === false) {
          throw new ParseError("Can't use function '" + func + "' in math mode", token);
        }

        var {
          args,
          optArgs
        } = this.parseArguments(func, funcData);
        return this.callFunction(func, args, optArgs, token, breakOnTokenText);
      }
      /**
       * Call a function handler with a suitable context and arguments.
       */


      callFunction(name, args, optArgs, token, breakOnTokenText) {
        var context = {
          funcName: name,
          parser: this,
          token,
          breakOnTokenText
        };
        var func = functions[name];

        if (func && func.handler) {
          return func.handler(context, args, optArgs);
        } else {
          throw new ParseError("No function handler for " + name);
        }
      }
      /**
       * Parses the arguments of a function or environment
       */


      parseArguments(func, // Should look like "\name" or "\begin{name}".
      funcData) {
        var totalArgs = funcData.numArgs + funcData.numOptionalArgs;

        if (totalArgs === 0) {
          return {
            args: [],
            optArgs: []
          };
        }

        var args = [];
        var optArgs = [];

        for (var i = 0; i < totalArgs; i++) {
          var argType = funcData.argTypes && funcData.argTypes[i];
          var isOptional = i < funcData.numOptionalArgs;

          if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
          funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
            argType = "primitive";
          }

          var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);

          if (isOptional) {
            optArgs.push(arg);
          } else if (arg != null) {
            args.push(arg);
          } else {
            // should be unreachable
            throw new ParseError("Null argument, please report this as a bug");
          }
        }

        return {
          args,
          optArgs
        };
      }
      /**
       * Parses a group when the mode is changing.
       */


      parseGroupOfType(name, type, optional) {
        switch (type) {
          case "color":
            return this.parseColorGroup(optional);

          case "size":
            return this.parseSizeGroup(optional);

          case "url":
            return this.parseUrlGroup(optional);

          case "math":
          case "text":
            return this.parseArgumentGroup(optional, type);

          case "hbox":
            {
              // hbox argument type wraps the argument in the equivalent of
              // \hbox, which is like \text but switching to \textstyle size.
              var group = this.parseArgumentGroup(optional, "text");
              return group != null ? {
                type: "styling",
                mode: group.mode,
                body: [group],
                style: "text" // simulate \textstyle

              } : null;
            }

          case "raw":
            {
              var token = this.parseStringGroup("raw", optional);
              return token != null ? {
                type: "raw",
                mode: "text",
                string: token.text
              } : null;
            }

          case "primitive":
            {
              if (optional) {
                throw new ParseError("A primitive argument cannot be optional");
              }

              var _group2 = this.parseGroup(name);

              if (_group2 == null) {
                throw new ParseError("Expected group as " + name, this.fetch());
              }

              return _group2;
            }

          case "original":
          case null:
          case undefined:
            return this.parseArgumentGroup(optional);

          default:
            throw new ParseError("Unknown group type as " + name, this.fetch());
        }
      }
      /**
       * Discard any space tokens, fetching the next non-space token.
       */


      consumeSpaces() {
        while (this.fetch().text === " ") {
          this.consume();
        }
      }
      /**
       * Parses a group, essentially returning the string formed by the
       * brace-enclosed tokens plus some position information.
       */


      parseStringGroup(modeName, // Used to describe the mode in error messages.
      optional) {
        var argToken = this.gullet.scanArgument(optional);

        if (argToken == null) {
          return null;
        }

        var str = "";
        var nextToken;

        while ((nextToken = this.fetch()).text !== "EOF") {
          str += nextToken.text;
          this.consume();
        }

        this.consume(); // consume the end of the argument

        argToken.text = str;
        return argToken;
      }
      /**
       * Parses a regex-delimited group: the largest sequence of tokens
       * whose concatenated strings match `regex`. Returns the string
       * formed by the tokens plus some position information.
       */


      parseRegexGroup(regex, modeName // Used to describe the mode in error messages.
      ) {
        var firstToken = this.fetch();
        var lastToken = firstToken;
        var str = "";
        var nextToken;

        while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
          lastToken = nextToken;
          str += lastToken.text;
          this.consume();
        }

        if (str === "") {
          throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
        }

        return firstToken.range(lastToken, str);
      }
      /**
       * Parses a color description.
       */


      parseColorGroup(optional) {
        var res = this.parseStringGroup("color", optional);

        if (res == null) {
          return null;
        }

        var match = /^(#[a-f0-9]{3,4}|#[a-f0-9]{6}|#[a-f0-9]{8}|[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);

        if (!match) {
          throw new ParseError("Invalid color: '" + res.text + "'", res);
        }

        var color = match[0];

        if (/^[0-9a-f]{6}$/i.test(color)) {
          // We allow a 6-digit HTML color spec without a leading "#".
          // This follows the xcolor package's HTML color model.
          // Predefined color names are all missed by this RegEx pattern.
          color = "#" + color;
        }

        return {
          type: "color-token",
          mode: this.mode,
          color
        };
      }
      /**
       * Parses a size specification, consisting of magnitude and unit.
       */


      parseSizeGroup(optional) {
        var res;
        var isBlank = false; // don't expand before parseStringGroup

        this.gullet.consumeSpaces();

        if (!optional && this.gullet.future().text !== "{") {
          res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
        } else {
          res = this.parseStringGroup("size", optional);
        }

        if (!res) {
          return null;
        }

        if (!optional && res.text.length === 0) {
          // Because we've tested for what is !optional, this block won't
          // affect \kern, \hspace, etc. It will capture the mandatory arguments
          // to \genfrac and \above.
          res.text = "0pt"; // Enable \above{}

          isBlank = true; // This is here specifically for \genfrac
        }

        var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);

        if (!match) {
          throw new ParseError("Invalid size: '" + res.text + "'", res);
        }

        var data = {
          number: +(match[1] + match[2]),
          // sign + magnitude, cast to number
          unit: match[3]
        };

        if (!validUnit(data)) {
          throw new ParseError("Invalid unit: '" + data.unit + "'", res);
        }

        return {
          type: "size",
          mode: this.mode,
          value: data,
          isBlank
        };
      }
      /**
       * Parses an URL, checking escaped letters and allowed protocols,
       * and setting the catcode of % as an active character (as in \hyperref).
       */


      parseUrlGroup(optional) {
        this.gullet.lexer.setCatcode("%", 13); // active character

        this.gullet.lexer.setCatcode("~", 12); // other character

        var res = this.parseStringGroup("url", optional);
        this.gullet.lexer.setCatcode("%", 14); // comment character

        this.gullet.lexer.setCatcode("~", 13); // active character

        if (res == null) {
          return null;
        } // hyperref package allows backslashes alone in href, but doesn't
        // generate valid links in such cases; we interpret this as
        // "undefined" behaviour, and keep them as-is. Some browser will
        // replace backslashes with forward slashes.


        var url = res.text.replace(/\\([#$%&~_^{}])/g, '$1');
        return {
          type: "url",
          mode: this.mode,
          url
        };
      }
      /**
       * Parses an argument with the mode specified.
       */


      parseArgumentGroup(optional, mode) {
        var argToken = this.gullet.scanArgument(optional);

        if (argToken == null) {
          return null;
        }

        var outerMode = this.mode;

        if (mode) {
          // Switch to specified mode
          this.switchMode(mode);
        }

        this.gullet.beginGroup();
        var expression = this.parseExpression(false, "EOF"); // TODO: find an alternative way to denote the end

        this.expect("EOF"); // expect the end of the argument

        this.gullet.endGroup();
        var result = {
          type: "ordgroup",
          mode: this.mode,
          loc: argToken.loc,
          body: expression
        };

        if (mode) {
          // Switch mode back
          this.switchMode(outerMode);
        }

        return result;
      }
      /**
       * Parses an ordinary group, which is either a single nucleus (like "x")
       * or an expression in braces (like "{x+y}") or an implicit group, a group
       * that starts at the current position, and ends right before a higher explicit
       * group ends, or at EOF.
       */


      parseGroup(name, // For error reporting.
      breakOnTokenText) {
        var firstToken = this.fetch();
        var text = firstToken.text;
        var result; // Try to parse an open brace or \begingroup

        if (text === "{" || text === "\\begingroup") {
          this.consume();
          var groupEnd = text === "{" ? "}" : "\\endgroup";
          this.gullet.beginGroup(); // If we get a brace, parse an expression

          var expression = this.parseExpression(false, groupEnd);
          var lastToken = this.fetch();
          this.expect(groupEnd); // Check that we got a matching closing brace

          this.gullet.endGroup();
          result = {
            type: "ordgroup",
            mode: this.mode,
            loc: SourceLocation.range(firstToken, lastToken),
            body: expression,
            // A group formed by \begingroup...\endgroup is a semi-simple group
            // which doesn't affect spacing in math mode, i.e., is transparent.
            // https://tex.stackexchange.com/questions/1930/when-should-one-
            // use-begingroup-instead-of-bgroup
            semisimple: text === "\\begingroup" || undefined
          };
        } else {
          // If there exists a function with this name, parse the function.
          // Otherwise, just return a nucleus
          result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();

          if (result == null && text[0] === "\\" && !implicitCommands.hasOwnProperty(text)) {
            if (this.settings.throwOnError) {
              throw new ParseError("Undefined control sequence: " + text, firstToken);
            }

            result = this.formatUnsupportedCmd(text);
            this.consume();
          }
        }

        return result;
      }
      /**
       * Form ligature-like combinations of characters for text mode.
       * This includes inputs like "--", "---", "``" and "''".
       * The result will simply replace multiple textord nodes with a single
       * character in each value by a single textord node having multiple
       * characters in its value.  The representation is still ASCII source.
       * The group will be modified in place.
       */


      formLigatures(group) {
        var n = group.length - 1;

        for (var i = 0; i < n; ++i) {
          var a = group[i]; // $FlowFixMe: Not every node type has a `text` property.

          var v = a.text;

          if (v === "-" && group[i + 1].text === "-") {
            if (i + 1 < n && group[i + 2].text === "-") {
              group.splice(i, 3, {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(a, group[i + 2]),
                text: "---"
              });
              n -= 2;
            } else {
              group.splice(i, 2, {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(a, group[i + 1]),
                text: "--"
              });
              n -= 1;
            }
          }

          if ((v === "'" || v === "`") && group[i + 1].text === v) {
            group.splice(i, 2, {
              type: "textord",
              mode: "text",
              loc: SourceLocation.range(a, group[i + 1]),
              text: v + v
            });
            n -= 1;
          }
        }
      }
      /**
       * Parse a single symbol out of the string. Here, we handle single character
       * symbols and special functions like \verb.
       */


      parseSymbol() {
        var nucleus = this.fetch();
        var text = nucleus.text;

        if (/^\\verb[^a-zA-Z]/.test(text)) {
          this.consume();
          var arg = text.slice(5);
          var star = arg.charAt(0) === "*";

          if (star) {
            arg = arg.slice(1);
          } // Lexer's tokenRegex is constructed to always have matching
          // first/last characters.


          if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
            throw new ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
          }

          arg = arg.slice(1, -1); // remove first and last char

          return {
            type: "verb",
            mode: "text",
            body: arg,
            star
          };
        } // At this point, we should have a symbol, possibly with accents.
        // First expand any accented base symbol according to unicodeSymbols.


        if (unicodeSymbols.hasOwnProperty(text[0]) && !symbols[this.mode][text[0]]) {
          // This behavior is not strict (XeTeX-compatible) in math mode.
          if (this.settings.strict && this.mode === "math") {
            this.settings.reportNonstrict("unicodeTextInMathMode", "Accented Unicode text character \"" + text[0] + "\" used in " + "math mode", nucleus);
          }

          text = unicodeSymbols[text[0]] + text.slice(1);
        } // Strip off any combining characters


        var match = combiningDiacriticalMarksEndRegex.exec(text);

        if (match) {
          text = text.substring(0, match.index);

          if (text === 'i') {
            text = '\u0131'; // dotless i, in math and text mode
          } else if (text === 'j') {
            text = '\u0237'; // dotless j, in math and text mode
          }
        } // Recognize base symbol


        var symbol;

        if (symbols[this.mode][text]) {
          if (this.settings.strict && this.mode === 'math' && extraLatin.indexOf(text) >= 0) {
            this.settings.reportNonstrict("unicodeTextInMathMode", "Latin-1/Unicode text character \"" + text[0] + "\" used in " + "math mode", nucleus);
          }

          var group = symbols[this.mode][text].group;
          var loc = SourceLocation.range(nucleus);
          var s;

          if (ATOMS.hasOwnProperty(group)) {
            // $FlowFixMe
            var family = group;
            s = {
              type: "atom",
              mode: this.mode,
              family,
              loc,
              text
            };
          } else {
            // $FlowFixMe
            s = {
              type: group,
              mode: this.mode,
              loc,
              text
            };
          } // $FlowFixMe


          symbol = s;
        } else if (text.charCodeAt(0) >= 0x80) {
          // no symbol for e.g. ^
          if (this.settings.strict) {
            if (!supportedCodepoint(text.charCodeAt(0))) {
              this.settings.reportNonstrict("unknownSymbol", "Unrecognized Unicode character \"" + text[0] + "\"" + (" (" + text.charCodeAt(0) + ")"), nucleus);
            } else if (this.mode === "math") {
              this.settings.reportNonstrict("unicodeTextInMathMode", "Unicode text character \"" + text[0] + "\" used in math mode", nucleus);
            }
          } // All nonmathematical Unicode characters are rendered as if they
          // are in text mode (wrapped in \text) because that's what it
          // takes to render them in LaTeX.  Setting `mode: this.mode` is
          // another natural choice (the user requested math mode), but
          // this makes it more difficult for getCharacterMetrics() to
          // distinguish Unicode characters without metrics and those for
          // which we want to simulate the letter M.


          symbol = {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(nucleus),
            text
          };
        } else {
          return null; // EOF, ^, _, {, }, etc.
        }

        this.consume(); // Transform combining characters into accents

        if (match) {
          for (var i = 0; i < match[0].length; i++) {
            var accent = match[0][i];

            if (!unicodeAccents[accent]) {
              throw new ParseError("Unknown accent ' " + accent + "'", nucleus);
            }

            var command = unicodeAccents[accent][this.mode] || unicodeAccents[accent].text;

            if (!command) {
              throw new ParseError("Accent " + accent + " unsupported in " + this.mode + " mode", nucleus);
            }

            symbol = {
              type: "accent",
              mode: this.mode,
              loc: SourceLocation.range(nucleus),
              label: command,
              isStretchy: false,
              isShifty: true,
              // $FlowFixMe
              base: symbol
            };
          }
        } // $FlowFixMe


        return symbol;
      }

    }
    Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];

    /**
     * Provides a single function for parsing an expression using a Parser
     * TODO(emily): Remove this
     */

    /**
     * Parses an expression using a Parser, then returns the parsed result.
     */
    var parseTree = function parseTree(toParse, settings) {
      if (!(typeof toParse === 'string' || toParse instanceof String)) {
        throw new TypeError('KaTeX can only parse string typed expression');
      }

      var parser = new Parser(toParse, settings); // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors

      delete parser.gullet.macros.current["\\df@tag"];
      var tree = parser.parse(); // Prevent a color definition from persisting between calls to katex.render().

      delete parser.gullet.macros.current["\\current@color"];
      delete parser.gullet.macros.current["\\color"]; // If the input used \tag, it will set the \df@tag macro to the tag.
      // In this case, we separately parse the tag and wrap the tree.

      if (parser.gullet.macros.get("\\df@tag")) {
        if (!settings.displayMode) {
          throw new ParseError("\\tag works only in display equations");
        }

        tree = [{
          type: "tag",
          mode: "text",
          body: tree,
          tag: parser.subparse([new Token("\\df@tag")])
        }];
      }

      return tree;
    };

    /* eslint no-console:0 */

    /**
     * Parse and build an expression, and place that expression in the DOM node
     * given.
     */
    var render = function render(expression, baseNode, options) {
      baseNode.textContent = "";
      var node = renderToDomTree(expression, options).toNode();
      baseNode.appendChild(node);
    }; // KaTeX's styles don't work properly in quirks mode. Print out an error, and
    // disable rendering.


    if (typeof document !== "undefined") {
      if (document.compatMode !== "CSS1Compat") {
        typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your " + "website has a suitable doctype.");

        render = function render() {
          throw new ParseError("KaTeX doesn't work in quirks mode.");
        };
      }
    }
    /**
     * Parse and build an expression, and return the markup for that.
     */


    var renderToString = function renderToString(expression, options) {
      var markup = renderToDomTree(expression, options).toMarkup();
      return markup;
    };
    /**
     * Parse an expression and return the parse tree.
     */


    var generateParseTree = function generateParseTree(expression, options) {
      var settings = new Settings(options);
      return parseTree(expression, settings);
    };
    /**
     * If the given error is a KaTeX ParseError and options.throwOnError is false,
     * renders the invalid LaTeX as a span with hover title giving the KaTeX
     * error message.  Otherwise, simply throws the error.
     */


    var renderError = function renderError(error, expression, options) {
      if (options.throwOnError || !(error instanceof ParseError)) {
        throw error;
      }

      var node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
      node.setAttribute("title", error.toString());
      node.setAttribute("style", "color:" + options.errorColor);
      return node;
    };
    /**
     * Generates and returns the katex build tree. This is used for advanced
     * use cases (like rendering to custom output).
     */


    var renderToDomTree = function renderToDomTree(expression, options) {
      var settings = new Settings(options);

      try {
        var tree = parseTree(expression, settings);
        return buildTree(tree, expression, settings);
      } catch (error) {
        return renderError(error, expression, settings);
      }
    };
    /**
     * Generates and returns the katex build tree, with just HTML (no MathML).
     * This is used for advanced use cases (like rendering to custom output).
     */


    var renderToHTMLTree = function renderToHTMLTree(expression, options) {
      var settings = new Settings(options);

      try {
        var tree = parseTree(expression, settings);
        return buildHTMLTree(tree, expression, settings);
      } catch (error) {
        return renderError(error, expression, settings);
      }
    };

    var version = "0.16.25";
    var __domTree = {
      Span,
      Anchor,
      SymbolNode,
      SvgNode,
      PathNode,
      LineNode
    }; // ESM exports

    var katex = {
      /**
       * Current KaTeX version
       */
      version,

      /**
       * Renders the given LaTeX into an HTML+MathML combination, and adds
       * it as a child to the specified DOM node.
       */
      render,

      /**
       * Renders the given LaTeX into an HTML+MathML combination string,
       * for sending to the client.
       */
      renderToString,

      /**
       * KaTeX error, usually during parsing.
       */
      ParseError,

      /**
       * The schema of Settings
       */
      SETTINGS_SCHEMA,

      /**
       * Parses the given LaTeX into KaTeX's internal parse tree structure,
       * without rendering to HTML or MathML.
       *
       * NOTE: This method is not currently recommended for public use.
       * The internal tree representation is unstable and is very likely
       * to change. Use at your own risk.
       */
      __parse: generateParseTree,

      /**
       * Renders the given LaTeX into an HTML+MathML internal DOM tree
       * representation, without flattening that representation to a string.
       *
       * NOTE: This method is not currently recommended for public use.
       * The internal tree representation is unstable and is very likely
       * to change. Use at your own risk.
       */
      __renderToDomTree: renderToDomTree,

      /**
       * Renders the given LaTeX into an HTML internal DOM tree representation,
       * without MathML and without flattening that representation to a string.
       *
       * NOTE: This method is not currently recommended for public use.
       * The internal tree representation is unstable and is very likely
       * to change. Use at your own risk.
       */
      __renderToHTMLTree: renderToHTMLTree,

      /**
       * extends internal font metrics object with a new object
       * each key in the new object represents a font name
      */
      __setFontMetrics: setFontMetrics,

      /**
       * adds a new symbol to builtin symbols table
       */
      __defineSymbol: defineSymbol,

      /**
       * adds a new function to builtin function list,
       * which directly produce parse tree elements
       * and have their own html/mathml builders
       */
      __defineFunction: defineFunction,

      /**
       * adds a new macro to builtin macro list
       */
      __defineMacro: defineMacro,

      /**
       * Expose the dom tree node types, which can be useful for type checking nodes.
       *
       * NOTE: These methods are not currently recommended for public use.
       * The internal tree representation is unstable and is very likely
       * to change. Use at your own risk.
       */
      __domTree
    };

    // Generated using scripts/write-decode-map.ts
    const htmlDecodeTree = /* #__PURE__ */ new Uint16Array(
    // prettier-ignore
    /* #__PURE__ */ "\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
        .split("")
        .map((c) => c.charCodeAt(0)));

    // Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
    var _a;
    const decodeMap = new Map([
        [0, 65533],
        // C1 Unicode control character reference replacements
        [128, 8364],
        [130, 8218],
        [131, 402],
        [132, 8222],
        [133, 8230],
        [134, 8224],
        [135, 8225],
        [136, 710],
        [137, 8240],
        [138, 352],
        [139, 8249],
        [140, 338],
        [142, 381],
        [145, 8216],
        [146, 8217],
        [147, 8220],
        [148, 8221],
        [149, 8226],
        [150, 8211],
        [151, 8212],
        [152, 732],
        [153, 8482],
        [154, 353],
        [155, 8250],
        [156, 339],
        [158, 382],
        [159, 376],
    ]);
    /**
     * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
     */
    const fromCodePoint = 
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
        let output = "";
        if (codePoint > 65535) {
            codePoint -= 65536;
            output += String.fromCharCode(((codePoint >>> 10) & 1023) | 55296);
            codePoint = 56320 | (codePoint & 1023);
        }
        output += String.fromCharCode(codePoint);
        return output;
    };
    /**
     * Replace the given code point with a replacement character if it is a
     * surrogate or is outside the valid range. Otherwise return the code
     * point unchanged.
     */
    function replaceCodePoint(codePoint) {
        var _a;
        if ((codePoint >= 55296 && codePoint <= 57343) ||
            codePoint > 1114111) {
            return 65533;
        }
        return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
    }

    var CharCodes;
    (function (CharCodes) {
        CharCodes[CharCodes["NUM"] = 35] = "NUM";
        CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
        CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
        CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
        CharCodes[CharCodes["NINE"] = 57] = "NINE";
        CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
        CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
        CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
        CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
        CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
        CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
        CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes || (CharCodes = {}));
    /** Bit that needs to be set to convert an upper case ASCII character to lower case */
    const TO_LOWER_BIT = 32;
    var BinTrieFlags;
    (function (BinTrieFlags) {
        BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
        BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
        BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags || (BinTrieFlags = {}));
    function isNumber(code) {
        return code >= CharCodes.ZERO && code <= CharCodes.NINE;
    }
    function isHexadecimalCharacter(code) {
        return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
            (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));
    }
    function isAsciiAlphaNumeric(code) {
        return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
            (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
            isNumber(code));
    }
    /**
     * Checks if the given character is a valid end character for an entity in an attribute.
     *
     * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
     * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
     */
    function isEntityInAttributeInvalidEnd(code) {
        return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
    }
    var EntityDecoderState;
    (function (EntityDecoderState) {
        EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
        EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
        EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
        EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
        EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function (DecodingMode) {
        /** Entities in text nodes that can end with any character. */
        DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
        /** Only allow entities terminated with a semicolon. */
        DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
        /** Entities in attributes have limitations on ending characters. */
        DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
    })(DecodingMode || (DecodingMode = {}));
    /**
     * Token decoder with support of writing partial entities.
     */
    class EntityDecoder {
        constructor(
        /** The tree used to decode entities. */
        decodeTree, 
        /**
         * The function that is called when a codepoint is decoded.
         *
         * For multi-byte named entities, this will be called multiple times,
         * with the second codepoint, and the same `consumed` value.
         *
         * @param codepoint The decoded codepoint.
         * @param consumed The number of bytes consumed by the decoder.
         */
        emitCodePoint, 
        /** An object that is used to produce errors. */
        errors) {
            this.decodeTree = decodeTree;
            this.emitCodePoint = emitCodePoint;
            this.errors = errors;
            /** The current state of the decoder. */
            this.state = EntityDecoderState.EntityStart;
            /** Characters that were consumed while parsing an entity. */
            this.consumed = 1;
            /**
             * The result of the entity.
             *
             * Either the result index of a numeric entity, or the codepoint of a
             * numeric entity.
             */
            this.result = 0;
            /** The current index in the decode tree. */
            this.treeIndex = 0;
            /** The number of characters that were consumed in excess. */
            this.excess = 1;
            /** The mode in which the decoder is operating. */
            this.decodeMode = DecodingMode.Strict;
        }
        /** Resets the instance to make it reusable. */
        startEntity(decodeMode) {
            this.decodeMode = decodeMode;
            this.state = EntityDecoderState.EntityStart;
            this.result = 0;
            this.treeIndex = 0;
            this.excess = 1;
            this.consumed = 1;
        }
        /**
         * Write an entity to the decoder. This can be called multiple times with partial entities.
         * If the entity is incomplete, the decoder will return -1.
         *
         * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
         * entity is incomplete, and resume when the next string is written.
         *
         * @param input The string containing the entity (or a continuation of the entity).
         * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        write(input, offset) {
            switch (this.state) {
                case EntityDecoderState.EntityStart: {
                    if (input.charCodeAt(offset) === CharCodes.NUM) {
                        this.state = EntityDecoderState.NumericStart;
                        this.consumed += 1;
                        return this.stateNumericStart(input, offset + 1);
                    }
                    this.state = EntityDecoderState.NamedEntity;
                    return this.stateNamedEntity(input, offset);
                }
                case EntityDecoderState.NumericStart: {
                    return this.stateNumericStart(input, offset);
                }
                case EntityDecoderState.NumericDecimal: {
                    return this.stateNumericDecimal(input, offset);
                }
                case EntityDecoderState.NumericHex: {
                    return this.stateNumericHex(input, offset);
                }
                case EntityDecoderState.NamedEntity: {
                    return this.stateNamedEntity(input, offset);
                }
            }
        }
        /**
         * Switches between the numeric decimal and hexadecimal states.
         *
         * Equivalent to the `Numeric character reference state` in the HTML spec.
         *
         * @param input The string containing the entity (or a continuation of the entity).
         * @param offset The current offset.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        stateNumericStart(input, offset) {
            if (offset >= input.length) {
                return -1;
            }
            if ((input.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
                this.state = EntityDecoderState.NumericHex;
                this.consumed += 1;
                return this.stateNumericHex(input, offset + 1);
            }
            this.state = EntityDecoderState.NumericDecimal;
            return this.stateNumericDecimal(input, offset);
        }
        addToNumericResult(input, start, end, base) {
            if (start !== end) {
                const digitCount = end - start;
                this.result =
                    this.result * Math.pow(base, digitCount) +
                        Number.parseInt(input.substr(start, digitCount), base);
                this.consumed += digitCount;
            }
        }
        /**
         * Parses a hexadecimal numeric entity.
         *
         * Equivalent to the `Hexademical character reference state` in the HTML spec.
         *
         * @param input The string containing the entity (or a continuation of the entity).
         * @param offset The current offset.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        stateNumericHex(input, offset) {
            const startIndex = offset;
            while (offset < input.length) {
                const char = input.charCodeAt(offset);
                if (isNumber(char) || isHexadecimalCharacter(char)) {
                    offset += 1;
                }
                else {
                    this.addToNumericResult(input, startIndex, offset, 16);
                    return this.emitNumericEntity(char, 3);
                }
            }
            this.addToNumericResult(input, startIndex, offset, 16);
            return -1;
        }
        /**
         * Parses a decimal numeric entity.
         *
         * Equivalent to the `Decimal character reference state` in the HTML spec.
         *
         * @param input The string containing the entity (or a continuation of the entity).
         * @param offset The current offset.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        stateNumericDecimal(input, offset) {
            const startIndex = offset;
            while (offset < input.length) {
                const char = input.charCodeAt(offset);
                if (isNumber(char)) {
                    offset += 1;
                }
                else {
                    this.addToNumericResult(input, startIndex, offset, 10);
                    return this.emitNumericEntity(char, 2);
                }
            }
            this.addToNumericResult(input, startIndex, offset, 10);
            return -1;
        }
        /**
         * Validate and emit a numeric entity.
         *
         * Implements the logic from the `Hexademical character reference start
         * state` and `Numeric character reference end state` in the HTML spec.
         *
         * @param lastCp The last code point of the entity. Used to see if the
         *               entity was terminated with a semicolon.
         * @param expectedLength The minimum number of characters that should be
         *                       consumed. Used to validate that at least one digit
         *                       was consumed.
         * @returns The number of characters that were consumed.
         */
        emitNumericEntity(lastCp, expectedLength) {
            var _a;
            // Ensure we consumed at least one digit.
            if (this.consumed <= expectedLength) {
                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                return 0;
            }
            // Figure out if this is a legit end of the entity
            if (lastCp === CharCodes.SEMI) {
                this.consumed += 1;
            }
            else if (this.decodeMode === DecodingMode.Strict) {
                return 0;
            }
            this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
            if (this.errors) {
                if (lastCp !== CharCodes.SEMI) {
                    this.errors.missingSemicolonAfterCharacterReference();
                }
                this.errors.validateNumericCharacterReference(this.result);
            }
            return this.consumed;
        }
        /**
         * Parses a named entity.
         *
         * Equivalent to the `Named character reference state` in the HTML spec.
         *
         * @param input The string containing the entity (or a continuation of the entity).
         * @param offset The current offset.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        stateNamedEntity(input, offset) {
            const { decodeTree } = this;
            let current = decodeTree[this.treeIndex];
            // The mask is the number of bytes of the value, including the current byte.
            let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            for (; offset < input.length; offset++, this.excess++) {
                const char = input.charCodeAt(offset);
                this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
                if (this.treeIndex < 0) {
                    return this.result === 0 ||
                        // If we are parsing an attribute
                        (this.decodeMode === DecodingMode.Attribute &&
                            // We shouldn't have consumed any characters after the entity,
                            (valueLength === 0 ||
                                // And there should be no invalid characters.
                                isEntityInAttributeInvalidEnd(char)))
                        ? 0
                        : this.emitNotTerminatedNamedEntity();
                }
                current = decodeTree[this.treeIndex];
                valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
                // If the branch is a value, store it and continue
                if (valueLength !== 0) {
                    // If the entity is terminated by a semicolon, we are done.
                    if (char === CharCodes.SEMI) {
                        return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
                    }
                    // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
                    if (this.decodeMode !== DecodingMode.Strict) {
                        this.result = this.treeIndex;
                        this.consumed += this.excess;
                        this.excess = 0;
                    }
                }
            }
            return -1;
        }
        /**
         * Emit a named entity that was not terminated with a semicolon.
         *
         * @returns The number of characters consumed.
         */
        emitNotTerminatedNamedEntity() {
            var _a;
            const { result, decodeTree } = this;
            const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
            this.emitNamedEntityData(result, valueLength, this.consumed);
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
            return this.consumed;
        }
        /**
         * Emit a named entity.
         *
         * @param result The index of the entity in the decode tree.
         * @param valueLength The number of bytes in the entity.
         * @param consumed The number of characters consumed.
         *
         * @returns The number of characters consumed.
         */
        emitNamedEntityData(result, valueLength, consumed) {
            const { decodeTree } = this;
            this.emitCodePoint(valueLength === 1
                ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
                : decodeTree[result + 1], consumed);
            if (valueLength === 3) {
                // For multi-byte values, we need to emit the second byte.
                this.emitCodePoint(decodeTree[result + 2], consumed);
            }
            return consumed;
        }
        /**
         * Signal to the parser that the end of the input was reached.
         *
         * Remaining data will be emitted and relevant errors will be produced.
         *
         * @returns The number of characters consumed.
         */
        end() {
            var _a;
            switch (this.state) {
                case EntityDecoderState.NamedEntity: {
                    // Emit a named entity if we have one.
                    return this.result !== 0 &&
                        (this.decodeMode !== DecodingMode.Attribute ||
                            this.result === this.treeIndex)
                        ? this.emitNotTerminatedNamedEntity()
                        : 0;
                }
                // Otherwise, emit a numeric entity if we have one.
                case EntityDecoderState.NumericDecimal: {
                    return this.emitNumericEntity(0, 2);
                }
                case EntityDecoderState.NumericHex: {
                    return this.emitNumericEntity(0, 3);
                }
                case EntityDecoderState.NumericStart: {
                    (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                    return 0;
                }
                case EntityDecoderState.EntityStart: {
                    // Return 0 if we have no entity.
                    return 0;
                }
            }
        }
    }
    /**
     * Creates a function that decodes entities in a string.
     *
     * @param decodeTree The decode tree.
     * @returns A function that decodes entities in a string.
     */
    function getDecoder(decodeTree) {
        let returnValue = "";
        const decoder = new EntityDecoder(decodeTree, (data) => (returnValue += fromCodePoint(data)));
        return function decodeWithTrie(input, decodeMode) {
            let lastIndex = 0;
            let offset = 0;
            while ((offset = input.indexOf("&", offset)) >= 0) {
                returnValue += input.slice(lastIndex, offset);
                decoder.startEntity(decodeMode);
                const length = decoder.write(input, 
                // Skip the "&"
                offset + 1);
                if (length < 0) {
                    lastIndex = offset + decoder.end();
                    break;
                }
                lastIndex = offset + length;
                // If `length` is 0, skip the current `&` and continue.
                offset = length === 0 ? lastIndex + 1 : lastIndex;
            }
            const result = returnValue + input.slice(lastIndex);
            // Make sure we don't keep a reference to the final string.
            returnValue = "";
            return result;
        };
    }
    /**
     * Determines the branch of the current node that is taken given the current
     * character. This function is used to traverse the trie.
     *
     * @param decodeTree The trie.
     * @param current The current node.
     * @param nodeIdx The index right after the current node and its value.
     * @param char The current character.
     * @returns The index of the next node, or -1 if no branch is taken.
     */
    function determineBranch(decodeTree, current, nodeIndex, char) {
        const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
        const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
        // Case 1: Single branch encoded in jump offset
        if (branchCount === 0) {
            return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;
        }
        // Case 2: Multiple branches encoded in jump table
        if (jumpOffset) {
            const value = char - jumpOffset;
            return value < 0 || value >= branchCount
                ? -1
                : decodeTree[nodeIndex + value] - 1;
        }
        // Case 3: Multiple branches encoded in dictionary
        // Binary search for the character.
        let lo = nodeIndex;
        let hi = lo + branchCount - 1;
        while (lo <= hi) {
            const mid = (lo + hi) >>> 1;
            const midValue = decodeTree[mid];
            if (midValue < char) {
                lo = mid + 1;
            }
            else if (midValue > char) {
                hi = mid - 1;
            }
            else {
                return decodeTree[mid + branchCount];
            }
        }
        return -1;
    }
    const htmlDecoder = /* #__PURE__ */ getDecoder(htmlDecodeTree);
    /**
     * Decodes an HTML string.
     *
     * @param htmlString The string to decode.
     * @param mode The decoding mode.
     * @returns The decoded string.
     */
    function decodeHTML(htmlString, mode = DecodingMode.Legacy) {
        return htmlDecoder(htmlString, mode);
    }

    const delimiters = [
        { left: "$$", right: "$$", display: false },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: false },
    ];
    function renderWithDelimiters(latexString, delimiters) {
        let htmlString = "";
        let position = 0;
        while (position < latexString.length) {
            let match = null;
            let matchStart = -1;
            let matchEnd = -1;
            let isDisplay = false;
            for (let delimiter of delimiters) {
                let start = latexString.indexOf(delimiter.left, position);
                if (start !== -1 && (matchStart === -1 || start < matchStart)) {
                    let end = latexString.indexOf(delimiter.right, start + delimiter.left.length);
                    if (end !== -1) {
                        match = delimiter;
                        matchStart = start;
                        matchEnd = end;
                        isDisplay = delimiter.display;
                    }
                }
            }
            if (match === null) {
                htmlString += latexString.slice(position);
                break;
            }
            htmlString += latexString.slice(position, matchStart);
            let latex = latexString.slice(matchStart + match.left.length, matchEnd);
            let renderedHTML = katex.renderToString(latex, {
                throwOnError: false,
                displayMode: isDisplay,
                output: "html",
            });
            htmlString += renderedHTML;
            position = matchEnd + match.right.length;
        }
        return htmlString;
    }
    function latexParser(text) {
        const regex = /<span class=\\*"math-tex\\*">([.\s\S]*?)<\/span>/g;
        let match;
        let dataModified = text;
        while ((match = regex.exec(text)) !== null) {
            let renderFormula;
            try {
                renderFormula = renderWithDelimiters(decodeHTML(match[1]).replace(/\u00A0/g, " "), delimiters);
                dataModified = dataModified.replace(match[0], `<span class="math-tex">${renderFormula}</span>`);
            }
            catch (e) {
                console.log(e);
            }
        }
        return dataModified;
    }

    const createLayout = () => new LayoutAvaliacaoBuilder();

    exports.LayoutAvaliacao = LayoutAvaliacao;
    exports.LayoutRenderer = PagedJsRenderer;
    exports.createLayout = createLayout;
    exports.latexParser = latexParser;
    exports.replacePlaceholders = replacePlaceholders;
    exports.shuffleAndMultiply = shuffleAndMultiply;

}));
//# sourceMappingURL=avaliacao-layout.umd.js.map
